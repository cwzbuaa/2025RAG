{"doc_id": "5389c068", "content": "Python 语言服务\nPython 提供了许多模块来帮助使用 Python 语言。 这些模块支持标记化、解析、语法分析、字节码\n反汇编以及各种其他工具。\n这些模块包括：\nast --- 抽象语法树\n抽象语法\n节点类\n根节点\n字面值\n变量\n表达式\n抽取\n推导式\n语句\n导入\n控制流\n模式匹配\n类型标注\n类型形参\n函数与类定义\nasync 与 await\nast 辅助函数\n编译器标志\n命令行用法\nsymtable --- 访问编译器的符号表\n符号表的生成\n符号表的查看\n命令行用法\ntoken --- 用于 Python 解析树的常量\nkeyword --- 检验 Python 关键字\ntokenize --- Python 源代码的分词器\n对输入进行解析标记\n命令行用法\n例子\ntabnanny --- 检测有歧义的缩进\npyclbr --- Python 模块浏览器支持\nFunction 对象\nClass 对象\n\npy_compile --- 编译 Python 源文件\n命令行接口\ncompileall --- 字节编译 Python 库\n使用命令行\n公有函数\ndis --- Python 字节码反汇编器\n命令行接口\n字节码分析\n分析函数\nPython字节码说明\n操作码集合\npickletools --- pickle 开发者工具\n命令行用法\n命令行选项\n编程接口", "metadata": {"title": "00_Python_语言服务", "source": "md_docs\\python_library_md\\00_Python_语言服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "5389c068"}}
{"doc_id": "57801e8e", "content": "Python 运行时服务\n本章描述的模块广泛服务于 Python 解释器及其与其环境的交互：\nsys --- 系统相关的形参和函数\nsys.monitoring --- 执行事件监测\n工具标识符\n注册和使用工具\n事件\n本地事件\n已弃用的事件\n辅助事件\n其他事件\nSTOP_ITERATION 事件\n开启和关闭事件\n全局设置事件\n针对特定代码对象的事件\n禁用事件\n注册回调函数\n回调函数参数\nsysconfig --- 提供对 Python 配置信息的访问\n配置变量\n安装路径\n用户方案\nposix_user\nnt_user\nosx_framework_user\n主方案\nposix_home\n前缀方案\nposix_prefix\nnt\n安装路径函数\n其他功能\n命令行用法\nbuiltins --- 内置对象\n__main__ --- 最高层级代码环境\n__name__ == '__main__'\n什么是“顶层代码环境”？\n惯用法\n打包考量\n\nPython 包中的 __main__.py\n惯用法\nimport __main__\nwarnings --- 警告信息控制\n警告类别\n警告过滤器\n重复警告的屏蔽准则\n警告过滤器的介绍\n默认警告过滤器\n重写默认的过滤器\n暂时禁止警告\n测试警告\n为新版本的依赖关系更新代码\n可用的函数\n可用的上下文管理器\n上下文管理器的并发安全性\ndataclasses --- 数据类\n模块内容\n初始化后处理\n类变量\n仅初始化变量\n冻结的实例\n继承\n__init__() 中仅限关键字形参的重新排序\n默认工厂函数\n可变的默认值\n描述器类型的字段\ncontextlib --- 为 with语句上下文提供的工具\n工具\n例子和配方\n支持可变数量的上下文管理器\n捕获 __enter__ 方法产生的异常\n在一个 __enter__ 方法的实现中进行清理\n替换任何对 try-finally 和旗标变量的使用\n将上下文管理器作为函数装饰器使用\n单独使用，可重用并可重进入的上下文管理器\n重进入上下文管理器\n可重用的上下文管理器\nabc --- 抽象基类\natexit --- 退出处理器\natexit 示例\ntraceback --- 打印或读取栈回溯信息\n模块级函数\n\n|  | Python 包中的 __main__.py\n惯用法\nimport __main__\nwarnings --- 警告信息控制\n警告类别\n警告过滤器\n重复警告的屏蔽准则\n警告过滤器的介绍\n默认警告过滤器\n重写默认的过滤器\n暂时禁止警告\n测试警告\n为新版本的依赖关系更新代码\n可用的函数\n可用的上下文管理器\n上下文管理器的并发安全性\ndataclasses --- 数据类\n模块内容\n初始化后处理\n类变量\n仅初始化变量\n冻结的实例\n继承\n__init__() 中仅限关键字形参的重新排序\n默认工厂函数\n可变的默认值\n描述器类型的字段\ncontextlib --- 为 with语句上下文提供的工具\n工具\n例子和配方\n支持可变数量的上下文管理器\n捕获 __enter__ 方法产生的异常\n在一个 __enter__ 方法的实现中进行清理\n替换任何对 try-finally 和旗标变量的使用\n将上下文管理器作为函数装饰器使用\n单独使用，可重用并可重进入的上下文管理器\n重进入上下文管理器\n可重用的上下文管理器\nabc --- 抽象基类\natexit --- 退出处理器\natexit 示例\ntraceback --- 打印或读取栈回溯信息\n模块级函数 |  |\n| --- | --- | --- |\n\nTracebackException 对象\nStackSummary 对象\nFrameSummary 对象\n使用模块级函数的例子\n使用 TracebackException 的示例\n__future__ --- Future 语句定义\n模块内容\ngc --- 垃圾回收器接口\ninspect --- 检查当前对象\n类型和成员\n获取源代码\n使用 Signature 对象对可调用对象进行内省\n类与函数\n解释器栈\n静态地获取属性\n生成器、协程和异步生成器的当前状态\n代码对象位标志\n缓冲区旗标\n命令行界面\nannotationlib --- 用于内省标记的功能\n注解语义（Annotation semantics）\n类\n函数\n例程\n在元类中使用注解\nSTRING 格式的局限性\nFORWARDREF 格式的局限性\n内省标注的安全意义\nsite --- 站点专属的配置钩子\nsitecustomize\nusercustomize\nReadline 配置\n模块内容\n命令行界面\n参见:\n参见 concurrent.interpreters 模块，它以类似方式对外公开了核心运行时功能。\n\n| TracebackException 对象\nStackSummary 对象\nFrameSummary 对象\n使用模块级函数的例子\n使用 TracebackException 的示例\n__future__ --- Future 语句定义\n模块内容\ngc --- 垃圾回收器接口\ninspect --- 检查当前对象\n类型和成员\n获取源代码\n使用 Signature 对象对可调用对象进行内省\n类与函数\n解释器栈\n静态地获取属性\n生成器、协程和异步生成器的当前状态\n代码对象位标志\n缓冲区旗标\n命令行界面\nannotationlib --- 用于内省标记的功能\n注解语义（Annotation semantics）\n类\n函数\n例程\n在元类中使用注解\nSTRING 格式的局限性\nFORWARDREF 格式的局限性\n内省标注的安全意义\nsite --- 站点专属的配置钩子\nsitecustomize\nusercustomize\nReadline 配置\n模块内容\n命令行界面 |\n| --- |\n| 参见:\n参见 concurrent.interpreters 模块，它以类似方式对外公开了核心运行时功能。 |", "metadata": {"title": "00_Python_运行时服务", "source": "md_docs\\python_library_md\\00_Python_运行时服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "57801e8e"}}
{"doc_id": "a2665356", "content": "Unix 专属服务\n本章描述的模块提供了 Unix 操作系统独有特性的接口，在某些情况下也适用于它的某些或许多衍生\n版。 以下为模块概览：\nshlex --- 简单词法分析\nshlex 对象\n解析规则\n改进的 shell 兼容性\nposix --- 最常见的 POSIX 系统调用\n大文件支持\n重要的模块内容\npwd --- 密码数据库\ngrp --- 组数据库\ntermios --- POSIX 风格的 tty 控制\n示例\ntty --- 终端控制函数\npty --- 伪终端工具\n示例\nfcntl --- fcntl 和 ioctl 系统调用\nresource --- 资源使用信息\n资源限制\n资源用量\nsyslog --- Unix syslog 库例程\n例子\n简单示例", "metadata": {"title": "00_Unix_专属服务", "source": "md_docs\\python_library_md\\00_Unix_专属服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "a2665356"}}
{"doc_id": "2e5909b6", "content": "Windows系统相关模块\n本章节叙述的模块只在 Windows 平台上可用。\nmsvcrt --- 来自 MS VC++ 运行时的有用例程\n文件操作\n控制台 I/O\n其他函数\nwinreg --- Windows 注册表访问\n函数\n常量\nHKEY_* 常量\n访问权限\n64 位系统特有\n注册表值的类型\n注册表句柄对象\nwinsound --- 针对 Windows 的声音播放接口", "metadata": {"title": "00_Windows系统相关模块", "source": "md_docs\\python_library_md\\00_Windows系统相关模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "2e5909b6"}}
{"doc_id": "b62c4a6a", "content": "二进制数据服务\n本章介绍的模块提供了一些操作二进制数据的基本服务操作。 有关二进制数据的其他操作，特别是\n与文件格式和网络协议有关的操作，将在相关章节中介绍。\n下面描述的一些库 文本处理服务 也可以使用 ASCII 兼容的二进制格式（例如 re ）或所有二进制数\n据（例如 difflib ）。\n另外，请参阅 Python 的内置二进制数据类型的文档 二进制序列类型 --- bytes, bytearray,\nmemoryview 。\nstruct --- 将字节串解读为打包的二进制数据\n函数和异常\n格式字符串\n字节顺序，大小和对齐方式\n格式字符\n例子\n应用\n原生格式\n标准格式\n类\ncodecs --- 编解码器注册和相关基类\n编解码器基类\n错误处理方案\n无状态的编码和解码\n增量式的编码和解码\nIncrementalEncoder 对象\nIncrementalDecoder 对象\n流式的编码和解码\nStreamWriter 对象\nStreamReader 对象\nStreamReaderWriter 对象\nStreamRecoder 对象\n编码格式与 Unicode\n标准编码\nPython 专属的编码格式\n文字编码\n二进制转换\n独立编解码器函数\n文字转换\nencodings --- 编码格式包\n\nencodings.idna --- 应用程序中的国际化域名\nencodings.mbcs --- Windows ANSI代码页\nencodings.utf_8_sig --- 带BOM签名的UTF-8编解码器", "metadata": {"title": "00_二进制数据服务", "source": "md_docs\\python_library_md\\00_二进制数据服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "b62c4a6a"}}
{"doc_id": "6caf07aa", "content": "互联网协议和支持\n本章介绍的模块实现了互联网协议以及相关技术支持。 它们都是用 Python 实现的。 这些模块大多\n需要依赖于系统的模块 socket 作为前提，该模块在大多数流行系统平台上都受到支持。 下面是一\n份概览:\nwebbrowser --- 方便的 Web 浏览器控制工具\n浏览器控制器对象\nwsgiref --- WSGI 工具和参考实现\nwsgiref.util -- WSGI 环境工具\nwsgiref.headers -- WSGI 响应标头工具\nwsgiref.simple_server -- 一个简单的 WSGI HTTP 服务器\nwsgiref.validate --- WSGI 一致性检查器\nwsgiref.handlers -- 服务器/网关基类\nwsgiref.types -- 用于静态类型检查的 WSGI 类型\n例子\nurllib --- URL 处理模块\nurllib.request --- 用于打开 URL 的可扩展库\nRequest 对象\nOpenerDirector 对象\nBaseHandler 对象\nHTTPRedirectHandler 对象\nHTTPCookieProcessor 对象\nProxyHandler 对象\nHTTPPasswordMgr 对象\nHTTPPasswordMgrWithPriorAuth 对象\nAbstractBasicAuthHandler 对象\nHTTPBasicAuthHandler 对象\nProxyBasicAuthHandler 对象\nAbstractDigestAuthHandler 对象\nHTTPDigestAuthHandler 对象\nProxyDigestAuthHandler 对象\nHTTPHandler 对象\nHTTPSHandler 对象\nFileHandler 对象\nDataHandler 对象\nFTPHandler 对象\nCacheFTPHandler 对象\nUnknownHandler 对象\nHTTPErrorProcessor 对象\n例子\n\n已停用的接口\nurllib.request 的限制\nurllib.response --- urllib 使用的 Response 类\nurllib.parse --- 将 URL 解析为组件\nURL 解析\nURL 解析安全\n解析ASCII编码字节\n结构化解析结果\nURL 转码\nurllib.error --- 由 urllib.request 引发的异常类\nurllib.robotparser --- 用于 robots.txt 的解析器\nhttp --- HTTP 模块\nHTTP 状态码\nHTTP 状态类别\nHTTP 方法\nhttp.client --- HTTP 协议客户端\nHTTPConnection 对象\nHTTPResponse 对象\n例子\nHTTPMessage 对象\nftplib --- FTP 协议客户端\n参考\nFTP 对象\nFTP_TLS 对象\n模块变量\npoplib --- POP3 协议客户端\nPOP3 对象\nPOP3 示例\nimaplib --- IMAP4 协议客户端\nIMAP4 对象\nIMAP4 示例\nsmtplib --- SMTP 协议客户端\nSMTP 对象\nSMTP 示例\nuuid --- 根据 RFC 9562 定义的 UUID 对象\n命令行用法\n示例\n命令行示例\nsocketserver --- 用于网络服务器的框架\n服务器创建的说明\nServer 对象\n请求处理器对象\n例子\n\n|  | 已停用的接口\nurllib.request 的限制\nurllib.response --- urllib 使用的 Response 类\nurllib.parse --- 将 URL 解析为组件\nURL 解析\nURL 解析安全\n解析ASCII编码字节\n结构化解析结果\nURL 转码\nurllib.error --- 由 urllib.request 引发的异常类\nurllib.robotparser --- 用于 robots.txt 的解析器\nhttp --- HTTP 模块\nHTTP 状态码\nHTTP 状态类别\nHTTP 方法\nhttp.client --- HTTP 协议客户端\nHTTPConnection 对象\nHTTPResponse 对象\n例子\nHTTPMessage 对象\nftplib --- FTP 协议客户端\n参考\nFTP 对象\nFTP_TLS 对象\n模块变量\npoplib --- POP3 协议客户端\nPOP3 对象\nPOP3 示例\nimaplib --- IMAP4 协议客户端\nIMAP4 对象\nIMAP4 示例\nsmtplib --- SMTP 协议客户端\nSMTP 对象\nSMTP 示例\nuuid --- 根据 RFC 9562 定义的 UUID 对象\n命令行用法\n示例\n命令行示例\nsocketserver --- 用于网络服务器的框架\n服务器创建的说明\nServer 对象\n请求处理器对象\n例子 |  |\n| --- | --- | --- |\n\nsocketserver.TCPServer 示例\nsocketserver.UDPServer 示例\n异步混合类\nhttp.server --- HTTP 服务器\n命令行接口\n安全考量\nhttp.cookies --- HTTP 状态管理\nCookie 对象\nMorsel 对象\n示例\nhttp.cookiejar --- HTTP 客户端的 Cookie 处理\nCookieJar 和 FileCookieJar 对象\nFileCookieJar 的子类及其与 Web 浏览器的协同\nCookiePolicy 对象\nDefaultCookiePolicy 对象\nCookie 对象\n例子\nxmlrpc --- XMLRPC 服务端与客户端模块\nxmlrpc.client --- XML-RPC 客户端访问\nServerProxy 对象\nDateTime 对象\nBinary 对象\nFault 对象\nProtocolError 对象\nMultiCall 对象\n便捷函数\n客户端用法的示例\n客户端与服务器用法的示例\nxmlrpc.server --- 基本 XML-RPC 服务器\nSimpleXMLRPCServer 对象\nSimpleXMLRPCServer 示例\nCGIXMLRPCRequestHandler\n文档 XMLRPC 服务器\nDocXMLRPCServer 对象\nDocCGIXMLRPCRequestHandler\nipaddress --- IPv4/IPv6 操作库\n方便的工厂函数\nIP 地址\n地址对象\n转换字符串和整数\n运算符\n比较运算符\n算术运算符\n\n|  | socketserver.TCPServer 示例\nsocketserver.UDPServer 示例\n异步混合类\nhttp.server --- HTTP 服务器\n命令行接口\n安全考量\nhttp.cookies --- HTTP 状态管理\nCookie 对象\nMorsel 对象\n示例\nhttp.cookiejar --- HTTP 客户端的 Cookie 处理\nCookieJar 和 FileCookieJar 对象\nFileCookieJar 的子类及其与 Web 浏览器的协同\nCookiePolicy 对象\nDefaultCookiePolicy 对象\nCookie 对象\n例子\nxmlrpc --- XMLRPC 服务端与客户端模块\nxmlrpc.client --- XML-RPC 客户端访问\nServerProxy 对象\nDateTime 对象\nBinary 对象\nFault 对象\nProtocolError 对象\nMultiCall 对象\n便捷函数\n客户端用法的示例\n客户端与服务器用法的示例\nxmlrpc.server --- 基本 XML-RPC 服务器\nSimpleXMLRPCServer 对象\nSimpleXMLRPCServer 示例\nCGIXMLRPCRequestHandler\n文档 XMLRPC 服务器\nDocXMLRPCServer 对象\nDocCGIXMLRPCRequestHandler\nipaddress --- IPv4/IPv6 操作库\n方便的工厂函数\nIP 地址\n地址对象\n转换字符串和整数\n运算符\n比较运算符\n算术运算符 |  |\n| --- | --- | --- |\n\nIP网络的定义\n前缀、网络掩码和主机掩码\n网络对象\n运算符\n逻辑运算符\n迭代\n作为地址容器的网络\n接口对象\n运算符\n逻辑运算符\n其他模块级别函数\n自定义异常", "metadata": {"title": "00_互联网协议和支持", "source": "md_docs\\python_library_md\\00_互联网协议和支持.md", "doc_type": "标准库", "language": "中文", "doc_id": "6caf07aa"}}
{"doc_id": "7bd5ed56", "content": "互联网数据处理\n本章介绍了一些支持处理因特网上常用数据格式的模块。\nemail --- 电子邮件与 MIME 处理包\nemail.message: 表示电子邮件消息\nemail.parser: 解析电子邮件消息\nFeedParser API\nParser API\n附加说明\nemail.generator: 生成 MIME 文档\nemail.policy: 策略对象\nemail.errors: 异常和缺陷类\nemail.headerregistry: 自定义标头对象\nemail.contentmanager: 管理 MIME 内容\n内容管理器实例\nemail: 示例\nemail.message.Message: 使用 compat32 API 来表示电子邮件消息\nemail.mime: 从头创建电子邮件和 MIME 对象\nemail.header: 国际化标头\nemail.charset: 表示字符集\nemail.encoders: 编码器\nemail.utils: 杂项工具\nemail.iterators: 迭代器\njson --- JSON 编码器和解码器\n基本使用\n编码器和解码器\n异常\n标准符合性和互操作性\n字符编码\nInfinite 和 NaN 数值\n对象中的重复名称\n顶级非对象，非数组值\n实现限制\n命令行接口\n命令行选项\nmailbox --- 操纵多种格式的邮箱\nMailbox 对象\nMaildir 对象\nmbox 对象\nMH 对象\n\nBabyl 对象\nMMDF 对象\nMessage 对象\nMaildirMessage 对象\nmboxMessage 对象\nMHMessage 对象\nBabylMessage 对象\nMMDFMessage 对象\n异常\n例子\nmimetypes --- 将文件名映射到 MIME 类型\nMimeTypes 对象\n命令行用法\n命令行示例\nbase64 --- Base16, Base32, Base64, Base85 数据编码\nRFC 4648 编码格式\nBase85 编码格式\n旧式接口\n安全考量\nbinascii --- 在二进制数据和 ASCII 之间进行转换\nquopri --- 编码与解码 MIME 转码的可打印数据", "metadata": {"title": "00_互联网数据处理", "source": "md_docs\\python_library_md\\00_互联网数据处理.md", "doc_type": "标准库", "language": "中文", "doc_id": "7bd5ed56"}}
{"doc_id": "ccfcfa99", "content": "使用 Tk 创建图形用户界面\nTk/Tcl 早已成为 Python 的一部分。 它提供了一套健壮且独立于平台的窗口工具集，Python 程序员\n可通过 tkinter 包及其扩展 tkinter.ttk 模块来使用它。\ntkinter 包是使用面向对象方式对 Tcl/Tk 进行的一层薄包装。 使用 tkinter，你不需要写 Tcl 代\n码，但你将需要参阅 Tk 文档，有时还需要参阅 Tcl 文档。 tkinter 是一组包装器，它将 Tk 的可视\n化部件实现为相应的 Python 类。\ntkinter 的主要特点是速度很快，并且通常直接附带在 Python 中。 虽然它的官方文档做得不好，\n但还是有许多可用的资源，包括：在线参考、教程、入门书等等。 tkinter 还有众所周知的较过时\n的外观界面，这在 Tk 8.5 中已得到很大改进。 无论如何，你还可以考虑许多其他的 GUI 库。\nPython wiki 例出了一些替代性的 GUI 框架和工具。\ntkinter --- Tcl/Tk 的 Python 接口\n架构\nTkinter 模块\nTkinter 拾遗\nHello World 程序\n重要的 Tk 概念\n了解 Tkinter 如何封装 Tcl/Tk\n我该如何...？这个选项会做...？\n浏览 Tcl/Tk 参考手册\n线程模型\n快速参考\n可选配置项\n包装器\n包装器的参数\n部件与变量的关联\n窗口管理器\nTk 参数的数据类型\n绑定和事件\nindex 参数\n图片\n文件处理程序\ntkinter.colorchooser --- 颜色选择对话框\ntkinter.font --- Tkinter 字体包装器\nTkinter 对话框\ntkinter.simpledialog --- 标准 Tkinter 输入对话框\ntkinter.filedialog --- 文件选择对话框.\n原生的载入/保存对话框.\n\ntkinter.commondialog --- 对话窗口模板\ntkinter.messagebox --- Tkinter 消息提示\ntkinter.scrolledtext --- 流动文本控件\ntkinter.dnd --- 拖放操作支持\ntkinter.ttk --- Tk 带主题的控件\nttk 的用法\nttk 控件\n控件\n标准属性\n可滚动控件的属性\n标签控件的属性\n兼容性属性\n控件状态\nttk.Widget\nCombobox\n属性\n虚拟事件\nttk.Combobox\nSpinbox\n属性\n虚拟事件\nttk.Spinbox\nNotebook\n属性\nTab 属性\nTab ID\n虚拟事件\nttk.Notebook\nProgressbar\n属性\nttk.Progressbar\nSeparator\n属性\nSizegrip\n与平台相关的注意事项\nBug\nTreeview\n属性\n数据项的属性\ntag 属性\n列标识\n虚拟事件\nttk.Treeview\n\n|  | tkinter.commondialog --- 对话窗口模板\ntkinter.messagebox --- Tkinter 消息提示\ntkinter.scrolledtext --- 流动文本控件\ntkinter.dnd --- 拖放操作支持\ntkinter.ttk --- Tk 带主题的控件\nttk 的用法\nttk 控件\n控件\n标准属性\n可滚动控件的属性\n标签控件的属性\n兼容性属性\n控件状态\nttk.Widget\nCombobox\n属性\n虚拟事件\nttk.Combobox\nSpinbox\n属性\n虚拟事件\nttk.Spinbox\nNotebook\n属性\nTab 属性\nTab ID\n虚拟事件\nttk.Notebook\nProgressbar\n属性\nttk.Progressbar\nSeparator\n属性\nSizegrip\n与平台相关的注意事项\nBug\nTreeview\n属性\n数据项的属性\ntag 属性\n列标识\n虚拟事件\nttk.Treeview |  |\n| --- | --- | --- |\n\nTtk 样式\n布局\nIDLE --- Python 编辑器和 shell\n目录\n文件菜单 （命令行和编辑器）\n编辑菜单（命令行和编辑器）\n格式菜单（仅 window 编辑器）\n运行菜单（仅 window 编辑器）\nShell 菜单（仅限 Shell 窗口）\n调试菜单（仅限 Shell 窗口）\n选项菜单（命令行和编辑器）\nWindow 菜单（命令行和编辑器）\n帮助菜单（命令行和编辑器）\n上下文菜单\n编辑和导航\n编辑窗口\n按键绑定\n自动缩进\n搜索和替换\n补全\n提示\n代码上下文\nShell 窗口\n文本颜色\n启动和代码执行\n命令行用法\n启动失败\n运行用户代码\nShell中的用户输出\n开发 tkinter 应用程序\n在没有子进程的情况下运行\n帮助和首选项Help and Preferences\n帮助源\n首选项设置\nmacOS 上的IDLE\n扩展\nidlelib --- IDLE 应用程序的实现\nturtle --- 海龟绘图\n概述\n入门\n教程\n启动海龟环境\n基本绘图\n\n|  | Ttk 样式\n布局\nIDLE --- Python 编辑器和 shell\n目录\n文件菜单 （命令行和编辑器）\n编辑菜单（命令行和编辑器）\n格式菜单（仅 window 编辑器）\n运行菜单（仅 window 编辑器）\nShell 菜单（仅限 Shell 窗口）\n调试菜单（仅限 Shell 窗口）\n选项菜单（命令行和编辑器）\nWindow 菜单（命令行和编辑器）\n帮助菜单（命令行和编辑器）\n上下文菜单\n编辑和导航\n编辑窗口\n按键绑定\n自动缩进\n搜索和替换\n补全\n提示\n代码上下文\nShell 窗口\n文本颜色\n启动和代码执行\n命令行用法\n启动失败\n运行用户代码\nShell中的用户输出\n开发 tkinter 应用程序\n在没有子进程的情况下运行\n帮助和首选项Help and Preferences\n帮助源\n首选项设置\nmacOS 上的IDLE\n扩展\nidlelib --- IDLE 应用程序的实现\nturtle --- 海龟绘图\n概述\n入门\n教程\n启动海龟环境\n基本绘图 |  |\n| --- | --- | --- |\n\n画笔控制\n海龟的位置\n使用算法绘制图案\n如何...\n尽快地开始\n自动开始和结束填充\n使用 turtle 模块命名空间\n在脚本中使用海龟绘图\n使用面向对象的海龟绘图\n海龟绘图参考\nTurtle 方法\nTurtleScreen/Screen 方法\nRawTurtle/Turtle 方法和对应函数\n海龟动作\n获取海龟的状态\n度量单位设置\n画笔控制\n绘图状态\n颜色控制\n填充\n更多绘图控制\n海龟状态\n可见性\n外观\n使用事件\n特殊海龟方法\n复合形状\nTurtleScreen/Screen 方法及对应函数\n窗口控制\n动画控制\n使用屏幕事件\n输入方法\n设置与特殊方法\nScreen 专有方法, 而非继承自 TurtleScreen\n公共类\n说明\n帮助与配置\n如何使用帮助\n文档字符串翻译为不同的语言\n如何配置 Screen 和 Turtle\nturtledemo --- 演示脚本集\nPython 2.6 之后的变化\nPython 3.0 之后的变化", "metadata": {"title": "00_使用_Tk_创建图形用户界面", "source": "md_docs\\python_library_md\\00_使用_Tk_创建图形用户界面.md", "doc_type": "标准库", "language": "中文", "doc_id": "ccfcfa99"}}
{"doc_id": "55d36831", "content": "内置函数\nPython 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。\n内置函数\nA E L R\nabs() enumerate() len() range()\naiter() eval() list() repr()\nall() exec() locals() reversed()\nanext() round()\nany() F M\nascii() filter() map() S\nfloat() max() set()\nB format() memoryview() setattr()\nbin() frozenset() min() slice()\nbool() sorted()\nbreakpoint() G N staticmethod()\nbytearray() getattr() next() str()\nbytes() globals() sum()\nO super()\nC H object()\ncallable() hasattr() oct() T\nchr() hash() open() tuple()\nclassmethod() help() ord() type()\ncompile() hex()\ncomplex() P V\nI pow() vars()\nD id() print()\ndelattr() input() property() Z\ndict() int() zip()\ndir() isinstance()\ndivmod() issubclass() _\niter() __import__()\nabs(number, /)\n返回一个数字的绝对值。 参数可以是整数、浮点数或任何实现了 __abs__() 的对象。 如果参\n数是一个复数，则返回它的模。\naiter(async_iterable, /)\n返回 asynchronous iterable 的 asynchronous iterator 。相当于调用 x.__aiter__()。\n注意：与 iter() 不同，aiter() 没有两个参数的版本。\nAdded in version 3.10.\n\n| 内置函数 |  |  |  |\n| --- | --- | --- | --- |\n| A\nabs()\naiter()\nall()\nanext()\nany()\nascii()\nB\nbin()\nbool()\nbreakpoint()\nbytearray()\nbytes()\nC\ncallable()\nchr()\nclassmethod()\ncompile()\ncomplex()\nD\ndelattr()\ndict()\ndir()\ndivmod() | E\nenumerate()\neval()\nexec()\nF\nfilter()\nfloat()\nformat()\nfrozenset()\nG\ngetattr()\nglobals()\nH\nhasattr()\nhash()\nhelp()\nhex()\nI\nid()\ninput()\nint()\nisinstance()\nissubclass()\niter() | L\nlen()\nlist()\nlocals()\nM\nmap()\nmax()\nmemoryview()\nmin()\nN\nnext()\nO\nobject()\noct()\nopen()\nord()\nP\npow()\nprint()\nproperty() | R\nrange()\nrepr()\nreversed()\nround()\nS\nset()\nsetattr()\nslice()\nsorted()\nstaticmethod()\nstr()\nsum()\nsuper()\nT\ntuple()\ntype()\nV\nvars()\nZ\nzip()\n_\n__import__() |\n\nall(iterable, /)\n如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。 等价于：\ndef all(iterable):\nfor element in iterable:\nif not element:\nreturn False\nreturn True\nawaitable anext(async_iterator, /)\nawaitable anext(async_iterator, default, /)\n当进入 await 状态时，从给定 asynchronous iterator 返回下一数据项，迭代完毕则返回\ndefault。\n这是内置函数 next() 的异步版本，类似于：\n调用 async_iterator 的 __anext__() 方法，返回一个 awaitable。等待返回迭代器的下一个值。\n若有给出 default，则在迭代完毕后会返回给出的值，否则会触发 StopAsyncIteration。\nAdded in version 3.10.\nany(iterable, /)\n如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。 等价于:\ndef any(iterable):\nfor element in iterable:\nif element:\nreturn True\nreturn False\nascii(object, /)\n与 repr() 类似，返回一个包含对象的可打印表示形式的字符串，但是使用 \\x、\\u 和 \\U 对\nrepr() 返回的字符串中非 ASCII 编码的字符进行转义。生成的字符串和 Python 2 的 repr()\n返回的结果相似。\nbin(integer, /)\n将一个整数转换为带前缀 \"0b\" 的二进制数字符串。 结果是一个合法的 Python 表达式。 如果\ninteger 不是一个 Python int 对象，则它必须定义返回一个整数的 __index__() 方法。 下面\n是一些例子:\n>>> bin(3)\n'0b11'\n>>> bin(-10)\n'-0b1010'\n若要控制是否显示前缀“0b”，可以采用以下两种方案：\n>>> format(14, '#b'), format(14, 'b')\n('0b1110', '1110')\n\n|  | all(iterable, /)\n如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。 等价于：\ndef all(iterable):\nfor element in iterable:\nif not element:\nreturn False\nreturn True\nawaitable anext(async_iterator, /)\nawaitable anext(async_iterator, default, /)\n当进入 await 状态时，从给定 asynchronous iterator 返回下一数据项，迭代完毕则返回\ndefault。\n这是内置函数 next() 的异步版本，类似于：\n调用 async_iterator 的 __anext__() 方法，返回一个 awaitable。等待返回迭代器的下一个值。\n若有给出 default，则在迭代完毕后会返回给出的值，否则会触发 StopAsyncIteration。\nAdded in version 3.10.\nany(iterable, /)\n如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。 等价于:\ndef any(iterable):\nfor element in iterable:\nif element:\nreturn True\nreturn False\nascii(object, /)\n与 repr() 类似，返回一个包含对象的可打印表示形式的字符串，但是使用 \\x、\\u 和 \\U 对\nrepr() 返回的字符串中非 ASCII 编码的字符进行转义。生成的字符串和 Python 2 的 repr()\n返回的结果相似。\nbin(integer, /)\n将一个整数转换为带前缀 \"0b\" 的二进制数字符串。 结果是一个合法的 Python 表达式。 如果\ninteger 不是一个 Python int 对象，则它必须定义返回一个整数的 __index__() 方法。 下面\n是一些例子:\n>>> bin(3)\n'0b11'\n>>> bin(-10)\n'-0b1010'\n若要控制是否显示前缀“0b”，可以采用以下两种方案：\n>>> format(14, '#b'), format(14, 'b')\n('0b1110', '1110') |  |  |\n| --- | --- | --- | --- |\n|  |  | >>> format(14, '#b'), format(14, 'b')\n('0b1110', '1110') |  |\n\n>>> f'{14:#b}', f'{14:b}'\n('0b1110', '1110')\n另见 format() 获取更多信息。\nclass bool(object=False, /)\n返回布尔值，即 True 或 False 中的一个。 其参数将使用标准的 真值测试过程 来转换。 如果\n该参数为假值或被省略，则返回 False；在其他情况下，将返回 True。 bool 类是 int 的子类\n(参见 数字类型 --- int, float, complex)。 它不能被继续子类化。 它只有 False 和 True 这两个\n实例 (参见 布尔类型 - bool)。\n在 3.7 版本发生变更: 该形参现在为仅限位置形参。\nbreakpoint(*args, **kws)\n此函数会在调用位置进入调试器。 具体来说，它将调用 sys.breakpointhook()，直接传递\nargs 和 kws。 在默认情况下，sys.breakpointhook() 将不带参数地调用\npdb.set_trace()。 在此情况下，它纯粹是一个便捷函数让你不必显式地导入 pdb 或键入过多\n代码即可进入调试器。 不过，sys.breakpointhook() 也可被设置为某些其他函数并被\nbreakpoint() 自动调用，允许你进入选定的调试器。 如果 sys.breakpointhook() 不可用，\n此函数将引发 RuntimeError。\n在默认情况下，breakpoint() 的行为可使用 PYTHONBREAKPOINT 环境变量来改变。 请参阅\nsys.breakpointhook() 了解详细用法。\n请注意这并不保证 sys.breakpointhook() 会被替换。\n引发一个 审计事件 builtins.breakpoint 并附带参数 breakpointhook。\nAdded in version 3.7.\nclass bytearray(source=b'')\nclass bytearray(source, encoding, errors='strict')\n返回一个新的 bytes 数组。 bytearray 类是一个可变序列，包含范围为 0 <= x < 256 的整数。\n它有可变序列大部分常见的方法，见 可变序列类型 的描述；同时有 bytes 类型的大部分方\n法，参见 bytes 和 bytearray 操作。\n可选形参 source 可以用不同的方式来初始化数组：\n如果是一个 string，您必须提供 encoding 参数（errors 参数仍是可选的）；bytearray() 会\n使用 str.encode() 方法来将 string 转变成 bytes。\n如果是一个 integer，会初始化大小为该数字的数组，并使用 null 字节填充。\n如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始化字节数组。\n如果是一个 iterable 可迭代对象，它的元素的范围必须是 0 <= x < 256 的整数，它会被用\n作数组的初始内容。\n如果没有实参，则创建大小为 0 的数组。\n另见 二进制序列类型 --- bytes, bytearray, memoryview 和 bytearray 对象。\n\n|  | >>> f'{14:#b}', f'{14:b}'\n('0b1110', '1110')\n另见 format() 获取更多信息。\nclass bool(object=False, /)\n返回布尔值，即 True 或 False 中的一个。 其参数将使用标准的 真值测试过程 来转换。 如果\n该参数为假值或被省略，则返回 False；在其他情况下，将返回 True。 bool 类是 int 的子类\n(参见 数字类型 --- int, float, complex)。 它不能被继续子类化。 它只有 False 和 True 这两个\n实例 (参见 布尔类型 - bool)。\n在 3.7 版本发生变更: 该形参现在为仅限位置形参。\nbreakpoint(*args, **kws)\n此函数会在调用位置进入调试器。 具体来说，它将调用 sys.breakpointhook()，直接传递\nargs 和 kws。 在默认情况下，sys.breakpointhook() 将不带参数地调用\npdb.set_trace()。 在此情况下，它纯粹是一个便捷函数让你不必显式地导入 pdb 或键入过多\n代码即可进入调试器。 不过，sys.breakpointhook() 也可被设置为某些其他函数并被\nbreakpoint() 自动调用，允许你进入选定的调试器。 如果 sys.breakpointhook() 不可用，\n此函数将引发 RuntimeError。\n在默认情况下，breakpoint() 的行为可使用 PYTHONBREAKPOINT 环境变量来改变。 请参阅\nsys.breakpointhook() 了解详细用法。\n请注意这并不保证 sys.breakpointhook() 会被替换。\n引发一个 审计事件 builtins.breakpoint 并附带参数 breakpointhook。\nAdded in version 3.7.\nclass bytearray(source=b'')\nclass bytearray(source, encoding, errors='strict')\n返回一个新的 bytes 数组。 bytearray 类是一个可变序列，包含范围为 0 <= x < 256 的整数。\n它有可变序列大部分常见的方法，见 可变序列类型 的描述；同时有 bytes 类型的大部分方\n法，参见 bytes 和 bytearray 操作。\n可选形参 source 可以用不同的方式来初始化数组：\n如果是一个 string，您必须提供 encoding 参数（errors 参数仍是可选的）；bytearray() 会\n使用 str.encode() 方法来将 string 转变成 bytes。\n如果是一个 integer，会初始化大小为该数字的数组，并使用 null 字节填充。\n如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始化字节数组。\n如果是一个 iterable 可迭代对象，它的元素的范围必须是 0 <= x < 256 的整数，它会被用\n作数组的初始内容。\n如果没有实参，则创建大小为 0 的数组。\n另见 二进制序列类型 --- bytes, bytearray, memoryview 和 bytearray 对象。 | >>> f'{14:#b}', f'{14:b}'\n('0b1110', '1110') |  |\n| --- | --- | --- | --- |\n\nclass bytes(source=b'')\nclass bytes(source, encoding, errors='strict')\n返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 0 <= x < 256 的整数。bytes\n是 bytearray 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。\n因此，构造函数的实参和 bytearray() 相同。\n字节对象还可以用字面值创建，参见 字符串与字节串字面量。\n另见 二进制序列类型 --- bytes, bytearray, memoryview，bytes 对象 和 bytes 和 bytearray 操\n作。\ncallable(object, /)\n如果 object 参数是可调用的则返回 True，否则返回 False。 如果返回 True，调用仍可能失\n败，但如果返回 False，则调用 object 肯定不会成功。 请注意类是可调用的（调用类将返回一\n个新的实例）；如果实例所属的类有 __call__() 方法则它就是可调用的。\nAdded in version 3.2: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加\n入。\nchr(codepoint, /)\n返回表示指定 Unicode 码位对应字符的字符串。例如，chr(97) 返回字符串 'a'，而\nchr(8364) 返回字符串 '€'。此函数是 ord() 的逆操作。\n该参数的有效范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果超过这个范围，会引发\nValueError 异常。\n@classmethod\n把一个方法封装成类方法。\n类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，\n按惯例请使用以下方案：\nclass C:\n@classmethod\ndef f(cls, arg1, arg2): ...\n@classmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。\n类方法的调用可以在类上进行 (例如 C.f()) 也可以在实例上进行 (例如 C().f())。 其所属类以\n外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含\n的第一个参数被传入。\n类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的\nstaticmethod()。 有关类方法的更多信息，请参阅 标准类型层级结构。\n在 3.9 版本发生变更: 类方法现在可以包装其他 描述器 例如 property()。\n\n|  | class bytes(source=b'')\nclass bytes(source, encoding, errors='strict')\n返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 0 <= x < 256 的整数。bytes\n是 bytearray 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。\n因此，构造函数的实参和 bytearray() 相同。\n字节对象还可以用字面值创建，参见 字符串与字节串字面量。\n另见 二进制序列类型 --- bytes, bytearray, memoryview，bytes 对象 和 bytes 和 bytearray 操\n作。\ncallable(object, /)\n如果 object 参数是可调用的则返回 True，否则返回 False。 如果返回 True，调用仍可能失\n败，但如果返回 False，则调用 object 肯定不会成功。 请注意类是可调用的（调用类将返回一\n个新的实例）；如果实例所属的类有 __call__() 方法则它就是可调用的。\nAdded in version 3.2: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加\n入。\nchr(codepoint, /)\n返回表示指定 Unicode 码位对应字符的字符串。例如，chr(97) 返回字符串 'a'，而\nchr(8364) 返回字符串 '€'。此函数是 ord() 的逆操作。\n该参数的有效范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果超过这个范围，会引发\nValueError 异常。\n@classmethod\n把一个方法封装成类方法。\n类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，\n按惯例请使用以下方案：\nclass C:\n@classmethod\ndef f(cls, arg1, arg2): ...\n@classmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。\n类方法的调用可以在类上进行 (例如 C.f()) 也可以在实例上进行 (例如 C().f())。 其所属类以\n外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含\n的第一个参数被传入。\n类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的\nstaticmethod()。 有关类方法的更多信息，请参阅 标准类型层级结构。\n在 3.9 版本发生变更: 类方法现在可以包装其他 描述器 例如 property()。 |  |\n| --- | --- | --- |\n\n在 3.10 版本发生变更: 类方法现在继承了方法的属性 (__module__, __name__,\n__qualname__, __doc__ 和 __annotations__) 并具有新的 __wrapped__ 属性。\nDeprecated since version 3.11, removed in version 3.13: 类方法不再可以包装其他\ndescriptors 例如 property()。\ncompile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)\n将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。source 可以是常\n规的字符串、字节字符串，或者 AST 对象。参见 ast 模块的文档了解如何使用 AST 对象。\nfilename 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识\n的值（经常会使用 '<string>'）。\nmode 实参指定了编译代码必须用的模式。如果 source 是语句序列，可以是 'exec'；如果是单\n一表达式，可以是 'eval'；如果是单个交互式语句，可以是 'single'。（在最后一种情况\n下，如果表达式执行结果不是 None 将会被打印出来。）\n可选参数 flags 和 dont_inherit 控制应当激活哪个 编译器选项 以及应当允许哪个 future 特性。\n如果两者都未提供 (或都为零) 则代码会应用与调用 compile() 的代码相同的旗标来编译。 如\n果给出了 flags 参数而未给出 dont_inherit (或者为零) 则会在无论如何都将被使用的旗标之外还\n会额外使用 flags 参数所指定的编译器选项和 future 语句。 如果 dont_inherit 为非零整数，则\n只使用 flags 参数 -- 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。\n编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选\n项。 指明特定 future 特性所需的比特位可以在 __future__ 模块的 _Feature 实例的\ncompiler_flag 属性中找到。 编译器旗标 可以在 ast 模块中查找带有 PyCF_ 前缀的名称。\noptimize 实参指定编译器的优化级别；默认值 -1 选择与解释器的 -O 选项相同的优化级别。显\n式级别为 0 （没有优化；__debug__ 为真）、1 （断言被删除， __debug__ 为假）或 2 （文\n档字符串也被删除）。\n如果编译的源码不合法，此函数会触发 SyntaxError 异常；如果源码包含 null 字节，则会触发\nValueError 异常。\n如果您想分析 Python 代码的 AST 表示，请参阅 ast.parse()。\n引发一个 审计事件 compile 附带参数 source 和 filename。 此事件也可通过隐式编译来引\n发。\n备注: 在 'single' 或 'eval' 模式编译多行代码字符串时，输入必须以至少一个换行符结\n尾。 这使 code 模块更容易检测语句的完整性。\n警告: 在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为\nPython AST 编译器的栈深度限制而崩溃。\n\n|  | 在 3.10 版本发生变更: 类方法现在继承了方法的属性 (__module__, __name__,\n__qualname__, __doc__ 和 __annotations__) 并具有新的 __wrapped__ 属性。\nDeprecated since version 3.11, removed in version 3.13: 类方法不再可以包装其他\ndescriptors 例如 property()。\ncompile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)\n将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。source 可以是常\n规的字符串、字节字符串，或者 AST 对象。参见 ast 模块的文档了解如何使用 AST 对象。\nfilename 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识\n的值（经常会使用 '<string>'）。\nmode 实参指定了编译代码必须用的模式。如果 source 是语句序列，可以是 'exec'；如果是单\n一表达式，可以是 'eval'；如果是单个交互式语句，可以是 'single'。（在最后一种情况\n下，如果表达式执行结果不是 None 将会被打印出来。）\n可选参数 flags 和 dont_inherit 控制应当激活哪个 编译器选项 以及应当允许哪个 future 特性。\n如果两者都未提供 (或都为零) 则代码会应用与调用 compile() 的代码相同的旗标来编译。 如\n果给出了 flags 参数而未给出 dont_inherit (或者为零) 则会在无论如何都将被使用的旗标之外还\n会额外使用 flags 参数所指定的编译器选项和 future 语句。 如果 dont_inherit 为非零整数，则\n只使用 flags 参数 -- 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。\n编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选\n项。 指明特定 future 特性所需的比特位可以在 __future__ 模块的 _Feature 实例的\ncompiler_flag 属性中找到。 编译器旗标 可以在 ast 模块中查找带有 PyCF_ 前缀的名称。\noptimize 实参指定编译器的优化级别；默认值 -1 选择与解释器的 -O 选项相同的优化级别。显\n式级别为 0 （没有优化；__debug__ 为真）、1 （断言被删除， __debug__ 为假）或 2 （文\n档字符串也被删除）。\n如果编译的源码不合法，此函数会触发 SyntaxError 异常；如果源码包含 null 字节，则会触发\nValueError 异常。\n如果您想分析 Python 代码的 AST 表示，请参阅 ast.parse()。\n引发一个 审计事件 compile 附带参数 source 和 filename。 此事件也可通过隐式编译来引\n发。\n备注: 在 'single' 或 'eval' 模式编译多行代码字符串时，输入必须以至少一个换行符结\n尾。 这使 code 模块更容易检测语句的完整性。\n警告: 在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为\nPython AST 编译器的栈深度限制而崩溃。 |  |\n| --- | --- | --- |\n\n在 3.2 版本发生变更: Windows 和 Mac 的换行符均可使用。而且在 'exec' 模式下的输入\n不必再以换行符结尾了。另增加了 optimize 参数。\n在 3.5 版本发生变更: 之前 source 中包含 null 字节的话会触发 TypeError 异常。\nAdded in version 3.8: ast.PyCF_ALLOW_TOP_LEVEL_AWAIT 现在可在旗标中传入以启用对\n最高层级 await, async for 和 async with 的支持。\nclass complex(number=0, /)\nclass complex(string, /)\nclass complex(real=0, imag=0)\n将特定的字符串或数字转换为一个复数，或基于特定的实部和虚部创建一个复数。\n示例：\n>>> complex('+1.23')\n(1.23+0j)\n>>> complex('-4.5j')\n-4.5j\n>>> complex('-1.23+4.5j')\n(-1.23+4.5j)\n>>> complex('\\t( -1.23+4.5J )\\n')\n(-1.23+4.5j)\n>>> complex('-Infinity+NaNj')\n(-inf+nanj)\n>>> complex(1.23)\n(1.23+0j)\n>>> complex(imag=-4.5)\n-4.5j\n>>> complex(-1.23, 4.5)\n(-1.23+4.5j)\n如果该参数为字符串，则它必须包含一个实部（格式与 float() 接受格式相同）或一个虚部\n（与实部格式相同但带有 'j' 或 'J' 后缀），或者同时包含实部和虚部（在此情况下虚部必须\n加上正负号）。 该字符串首尾可以被空白字符和圆括号 '(' and ')' 包裹，但它们会被忽略。\n该字符串中的 '+', '-', 'j' 或 'J' 后缀以及十进制数字之间不可存在空格。 例如，\ncomplex('1+2j') 是可以的，但 complex('1 + 2j') 则会引发 ValueError。 更准确地说，\n输入在移除圆括号以及开头和末尾的空白字符之后，必须符合以下 complexvalue 产生式规\n则：\ncomplexvalue: floatvalue |\nfloatvalue (\"j\" | \"J\") |\nfloatvalue sign absfloatvalue (\"j\" | \"J\")\n如果该参数为数字，则此构造器将进行与 int 和 float 类似的数值转换。 对于一个普通的\nPython 对象 x，complex(x) 会委托给 x.__complex__()。 如果未定义 __complex__() 则它\n将回退至 __float__()。 如果未定义 __float__() 则它将回退至 __index__()。\n如果提供了两个参数或是使用了关键字参数，则每个参数可以为任意数字类型（包括复数）。\n如果两个参数均为实数值，则会返回一个实部为 real 而虚部为 imag 的复数。 如果两个参数均\n\n|  | 在 3.2 版本发生变更: Windows 和 Mac 的换行符均可使用。而且在 'exec' 模式下的输入\n不必再以换行符结尾了。另增加了 optimize 参数。\n在 3.5 版本发生变更: 之前 source 中包含 null 字节的话会触发 TypeError 异常。\nAdded in version 3.8: ast.PyCF_ALLOW_TOP_LEVEL_AWAIT 现在可在旗标中传入以启用对\n最高层级 await, async for 和 async with 的支持。\nclass complex(number=0, /)\nclass complex(string, /)\nclass complex(real=0, imag=0)\n将特定的字符串或数字转换为一个复数，或基于特定的实部和虚部创建一个复数。\n示例：\n>>> complex('+1.23')\n(1.23+0j)\n>>> complex('-4.5j')\n-4.5j\n>>> complex('-1.23+4.5j')\n(-1.23+4.5j)\n>>> complex('\\t( -1.23+4.5J )\\n')\n(-1.23+4.5j)\n>>> complex('-Infinity+NaNj')\n(-inf+nanj)\n>>> complex(1.23)\n(1.23+0j)\n>>> complex(imag=-4.5)\n-4.5j\n>>> complex(-1.23, 4.5)\n(-1.23+4.5j)\n如果该参数为字符串，则它必须包含一个实部（格式与 float() 接受格式相同）或一个虚部\n（与实部格式相同但带有 'j' 或 'J' 后缀），或者同时包含实部和虚部（在此情况下虚部必须\n加上正负号）。 该字符串首尾可以被空白字符和圆括号 '(' and ')' 包裹，但它们会被忽略。\n该字符串中的 '+', '-', 'j' 或 'J' 后缀以及十进制数字之间不可存在空格。 例如，\ncomplex('1+2j') 是可以的，但 complex('1 + 2j') 则会引发 ValueError。 更准确地说，\n输入在移除圆括号以及开头和末尾的空白字符之后，必须符合以下 complexvalue 产生式规\n则：\ncomplexvalue: floatvalue |\nfloatvalue (\"j\" | \"J\") |\nfloatvalue sign absfloatvalue (\"j\" | \"J\")\n如果该参数为数字，则此构造器将进行与 int 和 float 类似的数值转换。 对于一个普通的\nPython 对象 x，complex(x) 会委托给 x.__complex__()。 如果未定义 __complex__() 则它\n将回退至 __float__()。 如果未定义 __float__() 则它将回退至 __index__()。\n如果提供了两个参数或是使用了关键字参数，则每个参数可以为任意数字类型（包括复数）。\n如果两个参数均为实数值，则会返回一个实部为 real 而虚部为 imag 的复数。 如果两个参数均 |  |\n| --- | --- | --- |\n\n为复数值，则会返回一个实部为 real.real-imag.imag 而虚部为 real.imag+imag.real 的复\n数。 如果有一个参数为实数值，则上面的表达式中将只用到实部。\n另请参阅仅接受单个数字参数的 complex.from_number()。\n如果省略所有参数，则返回 0j。\n数字类型 --- int, float, complex 描述了复数类型。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.8 版本发生变更: 如果 __complex__() 和 __float__() 均未定义则回退至\n__index__()。\n自 3.14 版本弃用: 参数 以 real 或 imag 的形式传递复数现在已弃用；只能以单个位置参数\n传递。\ndelattr(object, name, /)\n这是 setattr() 的相关函数。 其参数是一个对象和一个字符串。 其中字符串必须是对象的某\n个属性的名称。 该函数会删除指定的属性，如果对象允许这样做的话。 例如，delattr(x,\n'foobar') 等价于 del x.foobar。 name 不要求必须是 Python 标识符 (参见 setattr())。\nclass dict(**kwargs)\nclass dict(mapping, /, **kwargs)\nclass dict(iterable, /, **kwargs)\n创建一个新的字典。dict 对象是一个字典类。参见 dict 和 映射类型 --- dict 了解这个类。\n其他容器类型，请参见内置的 list、set 和 tuple 类，以及 collections 模块。\ndir()\ndir(object, /)\n如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有\n效属性列表。\n如果对象有一个名为 __dir__() 的方法，则该方法将被调用并且必须返回由属列组成的列表。\n这允许实现自定义This allows objects that implement a custom __getattr__() 或\n__getattribute__() 函数的对象能够定制 dir() 报告其属性的方式。\n如果对象未提供 __dir__()，该函数会尽量从对象所定义的 __dict__ 属性和其类型对象中收\n集信息。 结果列表不一定是完整的，并且当对象具有自定义的 __getattr__() 时还可能是不\n准确的。\n默认的 dir() 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：\n如果对象是模块对象，则列表包含模块的属性名称。\n如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。\n否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属\n性。\n\n|  |  | 为复数值，则会返回一个实部为 real.real-imag.imag 而虚部为 real.imag+imag.real 的复\n数。 如果有一个参数为实数值，则上面的表达式中将只用到实部。\n另请参阅仅接受单个数字参数的 complex.from_number()。\n如果省略所有参数，则返回 0j。\n数字类型 --- int, float, complex 描述了复数类型。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.8 版本发生变更: 如果 __complex__() 和 __float__() 均未定义则回退至\n__index__()。\n自 3.14 版本弃用: 参数 以 real 或 imag 的形式传递复数现在已弃用；只能以单个位置参数\n传递。\ndelattr(object, name, /)\n这是 setattr() 的相关函数。 其参数是一个对象和一个字符串。 其中字符串必须是对象的某\n个属性的名称。 该函数会删除指定的属性，如果对象允许这样做的话。 例如，delattr(x,\n'foobar') 等价于 del x.foobar。 name 不要求必须是 Python 标识符 (参见 setattr())。\nclass dict(**kwargs)\nclass dict(mapping, /, **kwargs)\nclass dict(iterable, /, **kwargs)\n创建一个新的字典。dict 对象是一个字典类。参见 dict 和 映射类型 --- dict 了解这个类。\n其他容器类型，请参见内置的 list、set 和 tuple 类，以及 collections 模块。\ndir()\ndir(object, /)\n如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有\n效属性列表。\n如果对象有一个名为 __dir__() 的方法，则该方法将被调用并且必须返回由属列组成的列表。\n这允许实现自定义This allows objects that implement a custom __getattr__() 或\n__getattribute__() 函数的对象能够定制 dir() 报告其属性的方式。\n如果对象未提供 __dir__()，该函数会尽量从对象所定义的 __dict__ 属性和其类型对象中收\n集信息。 结果列表不一定是完整的，并且当对象具有自定义的 __getattr__() 时还可能是不\n准确的。\n默认的 dir() 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：\n如果对象是模块对象，则列表包含模块的属性名称。\n如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。\n否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属\n性。 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | delattr(x, |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n\n返回的列表按字母表排序。例如：\n>>> import struct\n>>> dir() # show the names in the module namespace\n['__builtins__', '__name__', 'struct']\n>>> dir(struct) # show the names in the struct module\n['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',\n'__initializing__', '__loader__', '__name__', '__package__',\n'_clearcache', 'calcsize', 'error', 'pack', 'pack_into',\n'unpack', 'unpack_from']\n>>> class Shape:\n... def __dir__(self):\n... return ['area', 'perimeter', 'location']\n...\n>>> s = Shape()\n>>> dir(s)\n['area', 'location', 'perimeter']\n备注: 因为 dir() 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字\n集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。\n例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。\ndivmod(a, b, /)\n接受两个（非复数）数字作为参数并返回由当对其使用整数除法时的商和余数组成的数字对。\n在混用不同的操作数类型时，则会应用二元算术运算符的规则。 对于整数来说，结果与 (a //\nb, a % b) 相同。 对于浮点数来说则结果为 (q, a % b)，其中 q 通常为 math.floor(a / b)\n但可能会比它小 1。 在任何情况下 q * b + a % b 都非常接近 a，如果 a % b 为非零值则它\n将具有与 b 相同的正负号，并且 0 <= abs(a % b) < abs(b)。\nenumerate(iterable, start=0)\n返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。\nenumerate() 返回的迭代器的 __next__() 方法返回一个元组，里面包含一个计数值（从 start\n开始，默认为 0）和通过迭代 iterable 获得的值。\n>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']\n>>> list(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n>>> list(enumerate(seasons, start=1))\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\n等价于:\ndef enumerate(iterable, start=0):\nn = start\nfor elem in iterable:\nyield n, elem\nn += 1\neval(source, /, globals=None, locals=None)\n参数: source (str | code object) -- 一个 Python 表达式。\n\n|  | 返回的列表按字母表排序。例如：\n>>> import struct\n>>> dir() # show the names in the module namespace\n['__builtins__', '__name__', 'struct']\n>>> dir(struct) # show the names in the struct module\n['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',\n'__initializing__', '__loader__', '__name__', '__package__',\n'_clearcache', 'calcsize', 'error', 'pack', 'pack_into',\n'unpack', 'unpack_from']\n>>> class Shape:\n... def __dir__(self):\n... return ['area', 'perimeter', 'location']\n...\n>>> s = Shape()\n>>> dir(s)\n['area', 'location', 'perimeter']\n备注: 因为 dir() 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字\n集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。\n例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。\ndivmod(a, b, /)\n接受两个（非复数）数字作为参数并返回由当对其使用整数除法时的商和余数组成的数字对。\n在混用不同的操作数类型时，则会应用二元算术运算符的规则。 对于整数来说，结果与 (a //\nb, a % b) 相同。 对于浮点数来说则结果为 (q, a % b)，其中 q 通常为 math.floor(a / b)\n但可能会比它小 1。 在任何情况下 q * b + a % b 都非常接近 a，如果 a % b 为非零值则它\n将具有与 b 相同的正负号，并且 0 <= abs(a % b) < abs(b)。\nenumerate(iterable, start=0)\n返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。\nenumerate() 返回的迭代器的 __next__() 方法返回一个元组，里面包含一个计数值（从 start\n开始，默认为 0）和通过迭代 iterable 获得的值。\n>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']\n>>> list(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n>>> list(enumerate(seasons, start=1))\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\n等价于:\ndef enumerate(iterable, start=0):\nn = start\nfor elem in iterable:\nyield n, elem\nn += 1\neval(source, /, globals=None, locals=None)\n参数: source (str | code object) -- 一个 Python 表达式。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | (a // |  |  |\n|  |  |  |  |  |\n\n|  | b, a % b) |\n| --- | --- |\n\nglobals (dict | None) -- 全局命名空间 (默认值: None)。\nlocals (mapping | None) -- 局部命名空间 (默认值: None)。\n返回: 被求值表达式的求值结果。\n引发: 语法错误将作为异常被报告。\n警告: 此函数可执行任意代码。 调用它时附带用户提供的输入可能导致安全弱点。\nexpression 参数将作为一个 Python 表达式 (从技术上说，是一个条件列表) 使用 globals 和\nlocals 映射作为全局和局部命名空间被解析并求值。 如果 globals 字典存在并且不包含\n__builtins__ 键对应的值，则在 expression 被解析之前会插入该键对应的指向内置模块\nbuiltins 的字典的引用。 这样你就可以在将 globals 传给 eval() 之前通过向其传入你自己的\n__builtins__ 字典来控制被执行代码可以使用哪些内置对象。 如果 locals 映射被省略则它将\n默认为 globals 字典。 如果两个映射都被省略，则将使用调用 eval() 所在环境中的 globals 和\nlocals 来执行该表达式。 请注意，eval() 将只能访问所在环境中的 嵌套作用域 (非局部作用\n域)，如果它们已经在调用 eval() 的作用域中被引用的话 (例如通过 nonlocal 语句)。\n示例:\n>>> x = 1\n>>> eval('x+1')\n2\n该函数还可用于执行任意代码对象（比如由 compile() 创建的对象）。 这时传入的是代码对\n象，而非一个字符串了。如果代码对象已用参数为 mode 的 'exec' 进行了编译，那么 eval()\n的返回值将为 None。\n提示： exec() 函数支持语句的动态执行。 globals() 和 locals() 函数分别返回当前的全局\n和本地字典，可供传给 eval() 或 exec() 使用。\n如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。\n另外可以参阅 ast.literal_eval()，该函数可以安全执行仅包含文字的表达式字符串。\n引发一个 审计事件 exec 附带代码对象作为参数。 代码编译事件也可能被引发。\n在 3.13 版本发生变更: 现在可以将 globals 和 locals 作为关键字参数传入。\n在 3.13 版本发生变更: 默认 locals 命名空间的语义已被调整为与 locals() 内置函数的描\n述一致。\nexec(source, /, globals=None, locals=None, *, closure=None)\n警告: 此函数可执行任意代码。 调用它时附带用户提供的输入可能导致安全弱点。\n这个函数支持动态执行 Python 代码。 source 必须是字符串或代码对象。 如果是字符串，那么\n该字符串将被解析为一组 Python 语句并随即被执行（除非发生语法错误）。 [1] 如果是代码对\n象，那么它将被直接执行。 在所有情况下，被执行的代码都应当是有效的文件输入（见参考手\n\n|  | globals (dict | None) -- 全局命名空间 (默认值: None)。\nlocals (mapping | None) -- 局部命名空间 (默认值: None)。\n返回: 被求值表达式的求值结果。\n引发: 语法错误将作为异常被报告。\n警告: 此函数可执行任意代码。 调用它时附带用户提供的输入可能导致安全弱点。\nexpression 参数将作为一个 Python 表达式 (从技术上说，是一个条件列表) 使用 globals 和\nlocals 映射作为全局和局部命名空间被解析并求值。 如果 globals 字典存在并且不包含\n__builtins__ 键对应的值，则在 expression 被解析之前会插入该键对应的指向内置模块\nbuiltins 的字典的引用。 这样你就可以在将 globals 传给 eval() 之前通过向其传入你自己的\n__builtins__ 字典来控制被执行代码可以使用哪些内置对象。 如果 locals 映射被省略则它将\n默认为 globals 字典。 如果两个映射都被省略，则将使用调用 eval() 所在环境中的 globals 和\nlocals 来执行该表达式。 请注意，eval() 将只能访问所在环境中的 嵌套作用域 (非局部作用\n域)，如果它们已经在调用 eval() 的作用域中被引用的话 (例如通过 nonlocal 语句)。\n示例:\n>>> x = 1\n>>> eval('x+1')\n2\n该函数还可用于执行任意代码对象（比如由 compile() 创建的对象）。 这时传入的是代码对\n象，而非一个字符串了。如果代码对象已用参数为 mode 的 'exec' 进行了编译，那么 eval()\n的返回值将为 None。\n提示： exec() 函数支持语句的动态执行。 globals() 和 locals() 函数分别返回当前的全局\n和本地字典，可供传给 eval() 或 exec() 使用。\n如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。\n另外可以参阅 ast.literal_eval()，该函数可以安全执行仅包含文字的表达式字符串。\n引发一个 审计事件 exec 附带代码对象作为参数。 代码编译事件也可能被引发。\n在 3.13 版本发生变更: 现在可以将 globals 和 locals 作为关键字参数传入。\n在 3.13 版本发生变更: 默认 locals 命名空间的语义已被调整为与 locals() 内置函数的描\n述一致。\nexec(source, /, globals=None, locals=None, *, closure=None)\n警告: 此函数可执行任意代码。 调用它时附带用户提供的输入可能导致安全弱点。\n这个函数支持动态执行 Python 代码。 source 必须是字符串或代码对象。 如果是字符串，那么\n该字符串将被解析为一组 Python 语句并随即被执行（除非发生语法错误）。 [1] 如果是代码对\n象，那么它将被直接执行。 在所有情况下，被执行的代码都应当是有效的文件输入（见参考手 |  |\n| --- | --- | --- |\n\n|  |\n| --- |\n| 返回: |\n| 引发: |\n\n册中的 文件输入 一节）。 请注意即使是在传递给 exec() 函数的代码的上下文中 nonlocal,\nyield 和 return 语句也不可在函数定义以外使用。 函数的返回值为 None。\n在所有情况下，如果省略了可选部分，代码将在当前作用域中执行。 如果只提供了 globals，则\n它必须是一个字典（并且不能是字典的子类），它将被同时用于全局和局部变量。 如果给出了\nglobals 和 locals，它们将被分别用于全局和局部变量。 如果提供了 locals，它可以是任何映射\n对象。 请记住在模块层级上，globals 和 locals 是同一个字典。\n备注: 当 exec 获得两个不同的对象作为 globals 和 locals 时，代码被执行时就会像是嵌套\n在一个类定义中那样。 这意味着在被执行代码中定义的函数和类将无法访问在最高层级上赋\n值的变量（因为“最高层级”变量会被当作是类定义中的类变量来对待）。\n如果 globals 字典不包含 __builtins__ 键值，则将为该键插入对内建 builtins 模块字典的引\n用。因此，在将执行的代码传递给 exec() 之前，可以通过将自己的 __builtins__ 字典插入\n到 globals 中来控制可以使用哪些内置代码。\nclosure 参数指定了一个闭包 —— 一个单元变量的元组。 它只有有 object 是一个包含 自由（闭\n包）变量 的代码对象时才有效。 元组的长度必须与代码对象的 co_freevars 属性的长度完全\n匹配。\n引发一个 审计事件 exec 附带代码对象作为参数。 代码编译事件也可能被引发。\n备注: 内置函数 globals() 和 locals() 分别返回当前的全局和局部字典，这在用作\nexec() 的第二个和第三个参数进行传递时会很有用处。\n备注: 默认的 locals 行为与下面 locals() 函数所描述的一样。 如果你需要在 exec() 返回\n之后查看代码对 locals 的影响可以显式地传入一个 locals 字典。\n在 3.11 版本发生变更: 添加了 closure 参数。\n在 3.13 版本发生变更: 现在可以将 globals 和 locals 作为关键字参数传入。\n在 3.13 版本发生变更: 默认 locals 命名空间的语义已被调整为与 locals() 内置函数的描\n述一致。\nfilter(function, iterable, /)\n使用 iterable 中 function 返回真值的元素构造一个迭代器。 iterable 可以是一个序列，一个支持\n迭代的容器或者一个迭代器。 如果 function 为 None，则会使用标识号函数，也就是说，\niterable 中所有具有假值的元素都将被移除。\n请注意， filter(function, iterable) 相当于一个生成器表达式，当 function 不是 None 的\n时候为 (item for item in iterable if function(item))；function 是 None 的时候为\n(item for item in iterable if item) 。\n请参阅 itertools.filterfalse() 来了解返回 iterable 中 function 返回假值的元素的补充函\n数。\n\n|  | 册中的 文件输入 一节）。 请注意即使是在传递给 exec() 函数的代码的上下文中 nonlocal,\nyield 和 return 语句也不可在函数定义以外使用。 函数的返回值为 None。\n在所有情况下，如果省略了可选部分，代码将在当前作用域中执行。 如果只提供了 globals，则\n它必须是一个字典（并且不能是字典的子类），它将被同时用于全局和局部变量。 如果给出了\nglobals 和 locals，它们将被分别用于全局和局部变量。 如果提供了 locals，它可以是任何映射\n对象。 请记住在模块层级上，globals 和 locals 是同一个字典。\n备注: 当 exec 获得两个不同的对象作为 globals 和 locals 时，代码被执行时就会像是嵌套\n在一个类定义中那样。 这意味着在被执行代码中定义的函数和类将无法访问在最高层级上赋\n值的变量（因为“最高层级”变量会被当作是类定义中的类变量来对待）。\n如果 globals 字典不包含 __builtins__ 键值，则将为该键插入对内建 builtins 模块字典的引\n用。因此，在将执行的代码传递给 exec() 之前，可以通过将自己的 __builtins__ 字典插入\n到 globals 中来控制可以使用哪些内置代码。\nclosure 参数指定了一个闭包 —— 一个单元变量的元组。 它只有有 object 是一个包含 自由（闭\n包）变量 的代码对象时才有效。 元组的长度必须与代码对象的 co_freevars 属性的长度完全\n匹配。\n引发一个 审计事件 exec 附带代码对象作为参数。 代码编译事件也可能被引发。\n备注: 内置函数 globals() 和 locals() 分别返回当前的全局和局部字典，这在用作\nexec() 的第二个和第三个参数进行传递时会很有用处。\n备注: 默认的 locals 行为与下面 locals() 函数所描述的一样。 如果你需要在 exec() 返回\n之后查看代码对 locals 的影响可以显式地传入一个 locals 字典。\n在 3.11 版本发生变更: 添加了 closure 参数。\n在 3.13 版本发生变更: 现在可以将 globals 和 locals 作为关键字参数传入。\n在 3.13 版本发生变更: 默认 locals 命名空间的语义已被调整为与 locals() 内置函数的描\n述一致。\nfilter(function, iterable, /)\n使用 iterable 中 function 返回真值的元素构造一个迭代器。 iterable 可以是一个序列，一个支持\n迭代的容器或者一个迭代器。 如果 function 为 None，则会使用标识号函数，也就是说，\niterable 中所有具有假值的元素都将被移除。\n请注意， filter(function, iterable) 相当于一个生成器表达式，当 function 不是 None 的\n时候为 (item for item in iterable if function(item))；function 是 None 的时候为\n(item for item in iterable if item) 。\n请参阅 itertools.filterfalse() 来了解返回 iterable 中 function 返回假值的元素的补充函\n数。 |  |\n| --- | --- | --- |\n\nclass float(number=0.0, /)\nclass float(string, /)\n返回基于一个数字或字符串构建的浮点数。\n示例：\n>>> float('+1.23')\n1.23\n>>> float(' -12345\\n')\n-12345.0\n>>> float('1e-003')\n0.001\n>>> float('+1E6')\n1000000.0\n>>> float('-Infinity')\n-inf\n如果该参数是一个字符串，则它应当包含一个十进制数字，前面可以选择带一个符号，也可以\n选择嵌入空格。 可选的符号有 '+' 或 '-'；'+' 符号对所产生的值没有影响。 该参数还可以\n是一个代表 NaN (not-a-number) 或者正负无穷大的字符串。 更确切地说，在移除前导和尾随\n的空格之后，输入必须为符合以下语法的 floatvalue 产生规则：\nsign: \"+\" | \"-\"\ninfinity: \"Infinity\" | \"inf\"\nnan: \"nan\"\ndigit: <a Unicode decimal digit, i.e. characters in Unicode general ca\ndigitpart: digit ([\"_\"] digit)*\nnumber: [digitpart] \".\" digitpart | digitpart [\".\"]\nexponent: (\"e\" | \"E\") [sign] digitpart\nfloatnumber: number [exponent]\nabsfloatvalue: floatnumber | infinity | nan\nfloatvalue: [sign] absfloatvalue\n大小写是无影响的，因此举例来说，\"inf\", \"Inf\", \"INFINITY\" 和 \"iNfINity\" 都是正无穷可接受的拼\n写形式。\n另一方面，如果参数是整数或浮点数，则返回一个具有相同值（在 Python 浮点精度范围内）的\n浮点数。 如果参数超出了 Python 浮点数的取值范围，则会引发 OverflowError。\n对于一个普通 Python 对象 x，float(x) 会委托给 x.__float__()。 如果 __float__() 未定\n义则将回退至 __index__()。\n另请参见 float.from_number()，它只接受数字参数。\n如果没有实参，则返回 0.0 。\n数字类型 --- int, float, complex 描述了浮点类型。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.7 版本发生变更: 该形参现在为仅限位置形参。\n\n|  | class float(number=0.0, /)\nclass float(string, /)\n返回基于一个数字或字符串构建的浮点数。\n示例：\n>>> float('+1.23')\n1.23\n>>> float(' -12345\\n')\n-12345.0\n>>> float('1e-003')\n0.001\n>>> float('+1E6')\n1000000.0\n>>> float('-Infinity')\n-inf\n如果该参数是一个字符串，则它应当包含一个十进制数字，前面可以选择带一个符号，也可以\n选择嵌入空格。 可选的符号有 '+' 或 '-'；'+' 符号对所产生的值没有影响。 该参数还可以\n是一个代表 NaN (not-a-number) 或者正负无穷大的字符串。 更确切地说，在移除前导和尾随\n的空格之后，输入必须为符合以下语法的 floatvalue 产生规则：\nsign: \"+\" | \"-\"\ninfinity: \"Infinity\" | \"inf\"\nnan: \"nan\"\ndigit: <a Unicode decimal digit, i.e. characters in Unicode general ca\ndigitpart: digit ([\"_\"] digit)*\nnumber: [digitpart] \".\" digitpart | digitpart [\".\"]\nexponent: (\"e\" | \"E\") [sign] digitpart\nfloatnumber: number [exponent]\nabsfloatvalue: floatnumber | infinity | nan\nfloatvalue: [sign] absfloatvalue\n大小写是无影响的，因此举例来说，\"inf\", \"Inf\", \"INFINITY\" 和 \"iNfINity\" 都是正无穷可接受的拼\n写形式。\n另一方面，如果参数是整数或浮点数，则返回一个具有相同值（在 Python 浮点精度范围内）的\n浮点数。 如果参数超出了 Python 浮点数的取值范围，则会引发 OverflowError。\n对于一个普通 Python 对象 x，float(x) 会委托给 x.__float__()。 如果 __float__() 未定\n义则将回退至 __index__()。\n另请参见 float.from_number()，它只接受数字参数。\n如果没有实参，则返回 0.0 。\n数字类型 --- int, float, complex 描述了浮点类型。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.7 版本发生变更: 该形参现在为仅限位置形参。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | sign: \"+\" | \"-\"\ninfinity: \"Infinity\" | \"inf\"\nnan: \"nan\"\ndigit: <a Unicode decimal digit, i.e. characters in Unicode general ca\ndigitpart: digit ([\"_\"] digit)*\nnumber: [digitpart] \".\" digitpart | digitpart [\".\"]\nexponent: (\"e\" | \"E\") [sign] digitpart\nfloatnumber: number [exponent]\nabsfloatvalue: floatnumber | infinity | nan\nfloatvalue: [sign] absfloatvalue |  |  |\n|  |  |  |  |  |\n\n在 3.8 版本发生变更: 如果 __float__() 未定义则回退至 __index__()。\nformat(value, format_spec='', /)\n将 value 转换为“格式化后”的形式，格式由 format_spec 进行控制。format_spec 的解释方式取\n决于 value 参数的类型；但大多数内置类型使用一种标准的格式化语法： 格式规格迷你语言。\n默认的 format_spec 是一个空字符串，它通常给出与调用 str(value) 相同的结果。\n对 format(value, format_spec) 的调用会转写为 type(value).__format__(value,\nformat_spec)，这样在搜索值的 __format__() 方法时将绕过实例字典。 如果方法搜索到达\nobject 并且 format_spec 不为空，或者如果 format_spec 或返回值不为字符串则会引发\nTypeError 异常。\n在 3.4 版本发生变更: 当 format_spec 不是空字符串时，\nobject().__format__(format_spec) 会触发 TypeError。\nclass frozenset(iterable=(), /)\n返回一个新的 frozenset 对象，它包含可选参数 iterable 中的元素。 frozenset 是一个内置\n的类。有关此类的文档，请参阅 frozenset 和 集合类型 --- set, frozenset。\n请参阅内建的 set、list、tuple 和 dict 类，以及 collections 模块来了解其它的容器。\ngetattr(object, name, /)\ngetattr(object, name, default, /)\nobject 中指定名称的属性的值。 name 必须是字符串。 如果该字符串是对象的某一属性的名\n称，则结果将为该属性的值。 例如，getattr(x, 'foobar') 等同于 x.foobar。 如果指定名\n称的属性不存在，则如果提供了 default 则返回该值，否则将引发 AttributeError。 name 不\n必是一个 Python 标识符 (参见 setattr())。\n备注: 由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头\n的属性）名称以使用 getattr() 来提取它。\nglobals()\n返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数\n在哪里被调用都保持不变。\nhasattr(object, name, /)\n该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 True，否则返\n回 False。（此功能是通过调用 getattr(object, name) 看是否有 AttributeError 异常来\n实现的。）\nhash(object, /)\n返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较\n字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。\n\n|  |  | 在 3.8 版本发生变更: 如果 __float__() 未定义则回退至 __index__()。\nformat(value, format_spec='', /)\n将 value 转换为“格式化后”的形式，格式由 format_spec 进行控制。format_spec 的解释方式取\n决于 value 参数的类型；但大多数内置类型使用一种标准的格式化语法： 格式规格迷你语言。\n默认的 format_spec 是一个空字符串，它通常给出与调用 str(value) 相同的结果。\n对 format(value, format_spec) 的调用会转写为 type(value).__format__(value,\nformat_spec)，这样在搜索值的 __format__() 方法时将绕过实例字典。 如果方法搜索到达\nobject 并且 format_spec 不为空，或者如果 format_spec 或返回值不为字符串则会引发\nTypeError 异常。\n在 3.4 版本发生变更: 当 format_spec 不是空字符串时，\nobject().__format__(format_spec) 会触发 TypeError。\nclass frozenset(iterable=(), /)\n返回一个新的 frozenset 对象，它包含可选参数 iterable 中的元素。 frozenset 是一个内置\n的类。有关此类的文档，请参阅 frozenset 和 集合类型 --- set, frozenset。\n请参阅内建的 set、list、tuple 和 dict 类，以及 collections 模块来了解其它的容器。\ngetattr(object, name, /)\ngetattr(object, name, default, /)\nobject 中指定名称的属性的值。 name 必须是字符串。 如果该字符串是对象的某一属性的名\n称，则结果将为该属性的值。 例如，getattr(x, 'foobar') 等同于 x.foobar。 如果指定名\n称的属性不存在，则如果提供了 default 则返回该值，否则将引发 AttributeError。 name 不\n必是一个 Python 标识符 (参见 setattr())。\n备注: 由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头\n的属性）名称以使用 getattr() 来提取它。\nglobals()\n返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数\n在哪里被调用都保持不变。\nhasattr(object, name, /)\n该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 True，否则返\n回 False。（此功能是通过调用 getattr(object, name) 看是否有 AttributeError 异常来\n实现的。）\nhash(object, /)\n返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较\n字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | type(value).__format__(value, |  |  |\n|  |  |  |  |  |  |\n|  |  | format_spec) |  |  |  |\n|  |  |  |  |  |  |\n\n备注: 对于具有自定义 __hash__() 方法的对象，请注意 hash() 会根据宿主机的字长来截\n断返回值。\nhelp()\nhelp(request)\n启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动\n交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中\n搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮\n助页。\n请注意，如果在调用 help() 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的\n参数只能是位置参数。详情请参阅 有关仅限位置形参的 FAQ 条目。\n该函数通过 site 模块加入到内置命名空间。\n在 3.4 版本发生变更: pydoc 和 inspect 的变更使得可调用对象的签名信息更加全面和一\n致。\nhex(integer, /)\n将整数转换为带前缀 \"0x\" 前缀的小写十六进制数字符串。 如果 integer 不是一个 Python int\n对象，则它必须定义返回一个整数的 __index__() 方法。 下面是一些例子:\n>>> hex(255)\n'0xff'\n>>> hex(-42)\n'-0x2a'\n如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下\n方法：\n>>> '%#x' % 255, '%x' % 255, '%X' % 255\n('0xff', 'ff', 'FF')\n>>> format(255, '#x'), format(255, 'x'), format(255, 'X')\n('0xff', 'ff', 'FF')\n>>> f'{255:#x}', f'{255:x}', f'{255:X}'\n('0xff', 'ff', 'FF')\n另见 format() 获取更多信息。\n另请参阅 int() 将十六进制字符串转换为以 16 为基数的整数。\n备注: 如果要获取浮点数的十六进制字符串形式，请使用 float.hex() 方法。\nid(object, /)\n返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生\n命期不重叠的对象可能具有相同的 id() 值。\n这是对象在内存中的地址。\n\n|  | 备注: 对于具有自定义 __hash__() 方法的对象，请注意 hash() 会根据宿主机的字长来截\n断返回值。\nhelp()\nhelp(request)\n启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动\n交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中\n搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮\n助页。\n请注意，如果在调用 help() 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的\n参数只能是位置参数。详情请参阅 有关仅限位置形参的 FAQ 条目。\n该函数通过 site 模块加入到内置命名空间。\n在 3.4 版本发生变更: pydoc 和 inspect 的变更使得可调用对象的签名信息更加全面和一\n致。\nhex(integer, /)\n将整数转换为带前缀 \"0x\" 前缀的小写十六进制数字符串。 如果 integer 不是一个 Python int\n对象，则它必须定义返回一个整数的 __index__() 方法。 下面是一些例子:\n>>> hex(255)\n'0xff'\n>>> hex(-42)\n'-0x2a'\n如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下\n方法：\n>>> '%#x' % 255, '%x' % 255, '%X' % 255\n('0xff', 'ff', 'FF')\n>>> format(255, '#x'), format(255, 'x'), format(255, 'X')\n('0xff', 'ff', 'FF')\n>>> f'{255:#x}', f'{255:x}', f'{255:X}'\n('0xff', 'ff', 'FF')\n另见 format() 获取更多信息。\n另请参阅 int() 将十六进制字符串转换为以 16 为基数的整数。\n备注: 如果要获取浮点数的十六进制字符串形式，请使用 float.hex() 方法。\nid(object, /)\n返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生\n命期不重叠的对象可能具有相同的 id() 值。\n这是对象在内存中的地址。 | 备注: 对于具有自定义 __hash__() 方法的对象，请注意 hash() 会根据宿主机的字长来截\n断返回值。 |  |\n| --- | --- | --- | --- |\n\n引发一个 审计事件 builtins.id 并附带参数 id。\ninput()\ninput(prompt, /)\n如果存在 prompt 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取\n一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发\nEOFError。例如:\n>>> s = input('--> ')\n--> Monty Python's Flying Circus\n>>> s\n\"Monty Python's Flying Circus\"\n如果加载了 readline 模块，input() 将使用它来提供复杂的行编辑和历史记录功能。\n在读取输入前引发一个 审计事件 builtins.input 附带参数 prompt\n在成功读取输入之后引发一个 审计事件 builtins.input/result 附带结果。\nclass int(number=0, /)\nclass int(string, /, base=10)\n返回从一个数字或字符串构建的整数对象，或者如果未给出参数则返回 0。\n示例：\n>>> int(123.45)\n123\n>>> int('123')\n123\n>>> int(' -12_345\\n')\n-12345\n>>> int('FACE', 16)\n64206\n>>> int('0xface', 0)\n64206\n>>> int('01110011', base=2)\n115\n如果参数定义了 __int__() , int(x) 返回 x.__int__() 。 如果参数定义了 __index__() ，\n则返回 x.__index__()。 对于浮点数，则向零截断。\n如果参数不是数字或者如果给定了 base，则它必须是表示一个以 base 为基数的整数的字符\n串、bytes 或 bytearray 实例。 字符串前面还可选择加上 + 或 - (中间没有空格)，带有前导\n的零，带有两侧的空格，以及带有数位之间的单个下划线。\n一个以 n 为基数的整数字符串包含多个数位，每个数位代表从 0 到 n-1 范围内的值。 0--9 的值\n可以用任何 Unicode 十进制数码来表示。 10--35 的值可以用 a 到 z (或 A 到 Z) 来表示。 默认\n的 base 为 10。 允许的基数为 0 和 2--36。 对于基数 2, -8 和 -16 来说字符串前面还能加上可\n选的 0b/0B, 0o/0O 或 0x/0X 前缀，就像代码中的整数字面值那样。 对于基数 0 来说，字符串\n会以与 代码中的整数字面值 类似的方式来解读，即实际的基数将由前缀确定为 2, 8, 10 或 16。\n\n|  | 引发一个 审计事件 builtins.id 并附带参数 id。\ninput()\ninput(prompt, /)\n如果存在 prompt 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取\n一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发\nEOFError。例如:\n>>> s = input('--> ')\n--> Monty Python's Flying Circus\n>>> s\n\"Monty Python's Flying Circus\"\n如果加载了 readline 模块，input() 将使用它来提供复杂的行编辑和历史记录功能。\n在读取输入前引发一个 审计事件 builtins.input 附带参数 prompt\n在成功读取输入之后引发一个 审计事件 builtins.input/result 附带结果。\nclass int(number=0, /)\nclass int(string, /, base=10)\n返回从一个数字或字符串构建的整数对象，或者如果未给出参数则返回 0。\n示例：\n>>> int(123.45)\n123\n>>> int('123')\n123\n>>> int(' -12_345\\n')\n-12345\n>>> int('FACE', 16)\n64206\n>>> int('0xface', 0)\n64206\n>>> int('01110011', base=2)\n115\n如果参数定义了 __int__() , int(x) 返回 x.__int__() 。 如果参数定义了 __index__() ，\n则返回 x.__index__()。 对于浮点数，则向零截断。\n如果参数不是数字或者如果给定了 base，则它必须是表示一个以 base 为基数的整数的字符\n串、bytes 或 bytearray 实例。 字符串前面还可选择加上 + 或 - (中间没有空格)，带有前导\n的零，带有两侧的空格，以及带有数位之间的单个下划线。\n一个以 n 为基数的整数字符串包含多个数位，每个数位代表从 0 到 n-1 范围内的值。 0--9 的值\n可以用任何 Unicode 十进制数码来表示。 10--35 的值可以用 a 到 z (或 A 到 Z) 来表示。 默认\n的 base 为 10。 允许的基数为 0 和 2--36。 对于基数 2, -8 和 -16 来说字符串前面还能加上可\n选的 0b/0B, 0o/0O 或 0x/0X 前缀，就像代码中的整数字面值那样。 对于基数 0 来说，字符串\n会以与 代码中的整数字面值 类似的方式来解读，即实际的基数将由前缀确定为 2, 8, 10 或 16。 |  |\n| --- | --- | --- |\n\n基数为 0 还会禁用前导的零: int('010', 0) 将是无效的，而 int('010') 和 int('010', 8)\n则是有效的。\n整数类型定义请参阅 数字类型 --- int, float, complex 。\n在 3.4 版本发生变更: 如果 base 不是 int 的实例，但 base 对象有 base.__index__ 方\n法，则会调用该方法来获取进制数。以前的版本使用 base.__int__ 而不是\nbase.__index__。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.7 版本发生变更: 第一个形参现在是仅限位置形参。\n在 3.8 版本发生变更: 如果 __int__() 未定义则回退至 __index__()。\n在 3.11 版本发生变更: int 字符串输入和字符串表示形式可受到限制以帮助避免拒绝服务\n攻击。当将一个字符串转换为 int 或者将一个 int 转换为字符串的操作走出限制时会引\n发 ValueError。 请参阅 整数字符串转换长度限制 文档。\n在 3.14 版本发生变更: int() 不再委托 __trunc__() 方法\nisinstance(object, classinfo, /)\n如果 object 参数是 classinfo 参数的实例，或者是其 (直接、间接或 虚拟) 子类的实例则返回\nTrue。 如果 object 不是给定类型的对象，则该函数总是返回 False。 如果 classinfo 是由类型\n对象结成的元组 (或是由其他此类元组递归生成) 或者是多个类型的 union 类型，则如果 object\n是其中任一类型的实例时将会返回 True。 如果 classinfo 不是一个类型或类型元组及此类元\n组，则会引发 TypeError 异常。 如果之前的检查成功执行则可以不会为无效的类型引发\nTypeError。\n在 3.10 版本发生变更: classinfo 可以是一个 union 类型。\nissubclass(class, classinfo, /)\n如果 class 是 classinfo 的子类（直接、间接或 虚的 ），则返回 True。类将视为自己的子类。\nclassinfo 可为类对象的元组（或递归地，其他这样的元组）或 union 类型，这时如果 class 是\nclassinfo 中任何条目的子类，则返回 True 。任何其他情况都会触发 TypeError 异常。\n在 3.10 版本发生变更: classinfo 可以是一个 union 类型。\niter(iterable, /)\niter(callable, sentinel, /)\n返回一个 iterator 对象。第一个参数的解释方式会根据第二个参数是否存在而完全不同：若没\n有提供第二个参数，则该单一参数必须是一个支持 iterable 协议（即实现了 __iter__() 方\n法）的多项集对象，或者必须支持序列协议（即实现了以从 0 开始的整数参数调用的\n__getitem__() 方法）。 如果该参数既不支持可迭代协议也不支持序列协议，将会引发\nTypeError 异常。如果提供了第二个参数 sentinel，则第一个参数必须是一个可调用对象。 在\n这种情况下创建的迭代器会在每次调用其 __next__() 方法时，无参数地调用该 可调用对象；\n如果返回的值等于 sentinel，则会引发 StopIteration 异常，否则将返回该值。\n\n|  | 基数为 0 还会禁用前导的零: int('010', 0) 将是无效的，而 int('010') 和 int('010', 8)\n则是有效的。\n整数类型定义请参阅 数字类型 --- int, float, complex 。\n在 3.4 版本发生变更: 如果 base 不是 int 的实例，但 base 对象有 base.__index__ 方\n法，则会调用该方法来获取进制数。以前的版本使用 base.__int__ 而不是\nbase.__index__。\n在 3.6 版本发生变更: 您可以使用下划线将代码文字中的数字进行分组。\n在 3.7 版本发生变更: 第一个形参现在是仅限位置形参。\n在 3.8 版本发生变更: 如果 __int__() 未定义则回退至 __index__()。\n在 3.11 版本发生变更: int 字符串输入和字符串表示形式可受到限制以帮助避免拒绝服务\n攻击。当将一个字符串转换为 int 或者将一个 int 转换为字符串的操作走出限制时会引\n发 ValueError。 请参阅 整数字符串转换长度限制 文档。\n在 3.14 版本发生变更: int() 不再委托 __trunc__() 方法\nisinstance(object, classinfo, /)\n如果 object 参数是 classinfo 参数的实例，或者是其 (直接、间接或 虚拟) 子类的实例则返回\nTrue。 如果 object 不是给定类型的对象，则该函数总是返回 False。 如果 classinfo 是由类型\n对象结成的元组 (或是由其他此类元组递归生成) 或者是多个类型的 union 类型，则如果 object\n是其中任一类型的实例时将会返回 True。 如果 classinfo 不是一个类型或类型元组及此类元\n组，则会引发 TypeError 异常。 如果之前的检查成功执行则可以不会为无效的类型引发\nTypeError。\n在 3.10 版本发生变更: classinfo 可以是一个 union 类型。\nissubclass(class, classinfo, /)\n如果 class 是 classinfo 的子类（直接、间接或 虚的 ），则返回 True。类将视为自己的子类。\nclassinfo 可为类对象的元组（或递归地，其他这样的元组）或 union 类型，这时如果 class 是\nclassinfo 中任何条目的子类，则返回 True 。任何其他情况都会触发 TypeError 异常。\n在 3.10 版本发生变更: classinfo 可以是一个 union 类型。\niter(iterable, /)\niter(callable, sentinel, /)\n返回一个 iterator 对象。第一个参数的解释方式会根据第二个参数是否存在而完全不同：若没\n有提供第二个参数，则该单一参数必须是一个支持 iterable 协议（即实现了 __iter__() 方\n法）的多项集对象，或者必须支持序列协议（即实现了以从 0 开始的整数参数调用的\n__getitem__() 方法）。 如果该参数既不支持可迭代协议也不支持序列协议，将会引发\nTypeError 异常。如果提供了第二个参数 sentinel，则第一个参数必须是一个可调用对象。 在\n这种情况下创建的迭代器会在每次调用其 __next__() 方法时，无参数地调用该 可调用对象；\n如果返回的值等于 sentinel，则会引发 StopIteration 异常，否则将返回该值。 |  |\n| --- | --- | --- |\n\n另请参阅 迭代器类型。\n适合 iter() 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固\n定宽度的块，直至到达文件的末尾:\nfrom functools import partial\nwith open('mydata.db', 'rb') as f:\nfor block in iter(partial(f.read, 64), b''):\nprocess_block(block)\nlen(object, /)\n返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）\n或集合（如 dictionary、set 或 frozen set 等）。\nlen 对于大于 sys.maxsize 的长度如 range(2 ** 100) 会引发 OverflowError。\nclass list(iterable=(), /)\n虽然被称为函数，list 实际上是一种可变序列类型，详情请参阅 列表 和 序列类型 --- list,\ntuple, range。\nlocals()\n返回一个代表当前局部符号表的映射对象，以变量名称作为键，而以其当前绑定的引用作为\n值。\n在模块作用域上，以及当附带单个命名空间使用 exec() 或 eval() 时，此函数将返回与\nglobals() 相同的命名空间。\n在类作用域上，它会返回将被传给元类构造器的命名空间。\n当附带不同的 local 和 global 参数使用 exec() 或 eval() 时，它将返回传入函数调用的 local\n命名空间。\n在上述所有情况下，在一个给定的执行帧中对 locals() 的每次调用都将返回 同一个 映射对\n象。 通过从 locals() 返回的映射对象所做的修改都将如局部变量的赋值、重新赋值或删除一\n样可见，而局部变量的赋值、重新赋值或删除都将立即影响所返回映射对象的内容。\n在一个 optimized scope 中（包括函数、生成器和协程），每个对 locals() 的调用将改为返\n回一个新字典，其中包含函数的局部变量及任何非局部单元引用的当前绑定。 在此情况下，通\n过所返回字典对名称绑定的改变将 不会 写回到对应的局部变量或非局部单元引用，并且赋值、\n重新赋值或删除局部变量和非局部单元引用也 不会 影响之前返回的字典的内容。affect the\ncontents of previously returned dictionaries.\n将 locals() 作为函数、生成器或协程中的一个推导式的组成部分来调用相当于在外层作用域\n中调用它，不同之处在于推导式所初始化的迭代变量将被包括在内。 在其他作用域下，其行为\n与将推导式作为嵌套函数来运行类似。\n将 locals() 作为生成器表达式的组成部分来调用相当于在嵌套的生成器函数中调用它。\n\n|  | 另请参阅 迭代器类型。\n适合 iter() 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固\n定宽度的块，直至到达文件的末尾:\nfrom functools import partial\nwith open('mydata.db', 'rb') as f:\nfor block in iter(partial(f.read, 64), b''):\nprocess_block(block)\nlen(object, /)\n返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）\n或集合（如 dictionary、set 或 frozen set 等）。\nlen 对于大于 sys.maxsize 的长度如 range(2 ** 100) 会引发 OverflowError。\nclass list(iterable=(), /)\n虽然被称为函数，list 实际上是一种可变序列类型，详情请参阅 列表 和 序列类型 --- list,\ntuple, range。\nlocals()\n返回一个代表当前局部符号表的映射对象，以变量名称作为键，而以其当前绑定的引用作为\n值。\n在模块作用域上，以及当附带单个命名空间使用 exec() 或 eval() 时，此函数将返回与\nglobals() 相同的命名空间。\n在类作用域上，它会返回将被传给元类构造器的命名空间。\n当附带不同的 local 和 global 参数使用 exec() 或 eval() 时，它将返回传入函数调用的 local\n命名空间。\n在上述所有情况下，在一个给定的执行帧中对 locals() 的每次调用都将返回 同一个 映射对\n象。 通过从 locals() 返回的映射对象所做的修改都将如局部变量的赋值、重新赋值或删除一\n样可见，而局部变量的赋值、重新赋值或删除都将立即影响所返回映射对象的内容。\n在一个 optimized scope 中（包括函数、生成器和协程），每个对 locals() 的调用将改为返\n回一个新字典，其中包含函数的局部变量及任何非局部单元引用的当前绑定。 在此情况下，通\n过所返回字典对名称绑定的改变将 不会 写回到对应的局部变量或非局部单元引用，并且赋值、\n重新赋值或删除局部变量和非局部单元引用也 不会 影响之前返回的字典的内容。affect the\ncontents of previously returned dictionaries.\n将 locals() 作为函数、生成器或协程中的一个推导式的组成部分来调用相当于在外层作用域\n中调用它，不同之处在于推导式所初始化的迭代变量将被包括在内。 在其他作用域下，其行为\n与将推导式作为嵌套函数来运行类似。\n将 locals() 作为生成器表达式的组成部分来调用相当于在嵌套的生成器函数中调用它。 |  |\n| --- | --- | --- |\n\n在 3.12 版本发生变更: 在推导式中的 locals() 的行为已被更新为符合 PEP 709 中的描\n述。\n在 3.13 版本发生变更: 作为 PEP 667 的组成部分，改变从此函数返回的映射对象的语义现\n在已获得定义。 在 已优化作用域 中的行为现在如上所述。 除了已获得定义，在其他作用\n域中的行为相比之前的版本仍然保持不变。\nmap(function, iterable, /, *iterables, strict=False)\n返回一个将 function 应用于的每个 iterable 项目的迭代器，返回每个结果。 如果传递了额外的\niterables 参数，则 function 必须使用相同数量的参数，并将并行应用于所有 iterables 中的项\n目。 在多个 iterables 的情况下， 迭代器会在最短的 iterable 用尽后停止。 如果 strict 是\nTrue，且其中一个 iterables 在其他之前耗尽，则引发 ValueError 。对于 function 输入已排\n列成参数元组的情况，请参阅 itertools.starmap()。\n在 3.14 版本发生变更: 增加了 strict 形参。\nmax(iterable, /, *, key=None)\nmax(iterable, /, *, default, key=None)\nmax(arg1, arg2, /, *args, key=None)\n返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。\n如果只提供了一个位置参数，它必须是非空 iterable，返回可迭代对象中最大的元素；如果提供\n了两个及以上的位置参数，则返回最大的位置参数。\n有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。\ndefault 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则\n会触发 ValueError。\n如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如\nsorted(iterable, key=keyfunc, reverse=True)[0] 和 heapq.nlargest(1, iterable,\nkey=keyfunc) 保持一致。\n在 3.4 版本发生变更: 增加了 default 仅限关键字形参。\n在 3.8 版本发生变更: key 可以为 None。\nclass memoryview(object)\n返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 内存视图。\nmin(iterable, /, *, key=None)\nmin(iterable, /, *, default, key=None)\nmin(arg1, arg2, /, *args, key=None)\n返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。\n如果只提供了一个位置参数，它必须是 iterable，返回可迭代对象中最小的元素；如果提供了两\n个及以上的位置参数，则返回最小的位置参数。\n\n|  |  | 在 3.12 版本发生变更: 在推导式中的 locals() 的行为已被更新为符合 PEP 709 中的描\n述。\n在 3.13 版本发生变更: 作为 PEP 667 的组成部分，改变从此函数返回的映射对象的语义现\n在已获得定义。 在 已优化作用域 中的行为现在如上所述。 除了已获得定义，在其他作用\n域中的行为相比之前的版本仍然保持不变。\nmap(function, iterable, /, *iterables, strict=False)\n返回一个将 function 应用于的每个 iterable 项目的迭代器，返回每个结果。 如果传递了额外的\niterables 参数，则 function 必须使用相同数量的参数，并将并行应用于所有 iterables 中的项\n目。 在多个 iterables 的情况下， 迭代器会在最短的 iterable 用尽后停止。 如果 strict 是\nTrue，且其中一个 iterables 在其他之前耗尽，则引发 ValueError 。对于 function 输入已排\n列成参数元组的情况，请参阅 itertools.starmap()。\n在 3.14 版本发生变更: 增加了 strict 形参。\nmax(iterable, /, *, key=None)\nmax(iterable, /, *, default, key=None)\nmax(arg1, arg2, /, *args, key=None)\n返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。\n如果只提供了一个位置参数，它必须是非空 iterable，返回可迭代对象中最大的元素；如果提供\n了两个及以上的位置参数，则返回最大的位置参数。\n有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。\ndefault 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则\n会触发 ValueError。\n如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如\nsorted(iterable, key=keyfunc, reverse=True)[0] 和 heapq.nlargest(1, iterable,\nkey=keyfunc) 保持一致。\n在 3.4 版本发生变更: 增加了 default 仅限关键字形参。\n在 3.8 版本发生变更: key 可以为 None。\nclass memoryview(object)\n返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 内存视图。\nmin(iterable, /, *, key=None)\nmin(iterable, /, *, default, key=None)\nmin(arg1, arg2, /, *args, key=None)\n返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。\n如果只提供了一个位置参数，它必须是 iterable，返回可迭代对象中最小的元素；如果提供了两\n个及以上的位置参数，则返回最小的位置参数。 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | heapq.nlargest(1, iterable, |  |  |\n|  |  |  |  |  |  |\n|  |  | key=keyfunc |  |  |  |\n|  |  |  |  |  |  |\n\n有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。\ndefault 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则\n会触发 ValueError。\n如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如\nsorted(iterable, key=keyfunc)[0] 和 heapq.nsmallest(1, iterable, key=keyfunc)\n保持一致。\n在 3.4 版本发生变更: 增加了 default 仅限关键字形参。\n在 3.8 版本发生变更: key 可以为 None。\nnext(iterator, /)\nnext(iterator, default, /)\n通过调用 iterator 的 __next__() 方法获取下一个元素。如果迭代器耗尽，则返回给定的\ndefault，如果没有默认值则触发 StopIteration。\nclass object\n这是所有其他类的终极基类。 它提供了所有 Python 类实例均具有的方法。 当其构造器被调用\n时，它将返回一个新的基本对象。 该构造器不接受任何参数。\n备注: object 实例 没有 __dict__ 属性，因此你无法将任意属性赋给 object 的实例。\noct(integer, /)\n将整数转换为带前缀 \"0o\" 的八进制数字符串。 结果是一个合法的 Python 表达式。 如果\ninteger 不是一个 Python int 对象，则它必须定义返回一个整数的 __index__() 方法。 例如:\n>>> oct(8)\n'0o10'\n>>> oct(-56)\n'-0o70'\n若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：\n>>> '%#o' % 10, '%o' % 10\n('0o12', '12')\n>>> format(10, '#o'), format(10, 'o')\n('0o12', '12')\n>>> f'{10:#o}', f'{10:o}'\n('0o12', '12')\n另见 format() 获取更多信息。\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None,\nclosefd=True, opener=None)\n打开 file 并返回对应的 file object。 如果该文件不能被打开，则引发 OSError。 请参阅 读写文\n件 获取此函数的更多用法示例。\n\n|  | 有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。\ndefault 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则\n会触发 ValueError。\n如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如\nsorted(iterable, key=keyfunc)[0] 和 heapq.nsmallest(1, iterable, key=keyfunc)\n保持一致。\n在 3.4 版本发生变更: 增加了 default 仅限关键字形参。\n在 3.8 版本发生变更: key 可以为 None。\nnext(iterator, /)\nnext(iterator, default, /)\n通过调用 iterator 的 __next__() 方法获取下一个元素。如果迭代器耗尽，则返回给定的\ndefault，如果没有默认值则触发 StopIteration。\nclass object\n这是所有其他类的终极基类。 它提供了所有 Python 类实例均具有的方法。 当其构造器被调用\n时，它将返回一个新的基本对象。 该构造器不接受任何参数。\n备注: object 实例 没有 __dict__ 属性，因此你无法将任意属性赋给 object 的实例。\noct(integer, /)\n将整数转换为带前缀 \"0o\" 的八进制数字符串。 结果是一个合法的 Python 表达式。 如果\ninteger 不是一个 Python int 对象，则它必须定义返回一个整数的 __index__() 方法。 例如:\n>>> oct(8)\n'0o10'\n>>> oct(-56)\n'-0o70'\n若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：\n>>> '%#o' % 10, '%o' % 10\n('0o12', '12')\n>>> format(10, '#o'), format(10, 'o')\n('0o12', '12')\n>>> f'{10:#o}', f'{10:o}'\n('0o12', '12')\n另见 format() 获取更多信息。\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None,\nclosefd=True, opener=None)\n打开 file 并返回对应的 file object。 如果该文件不能被打开，则引发 OSError。 请参阅 读写文\n件 获取此函数的更多用法示例。 |  |\n| --- | --- | --- |\n\nfile 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的\n路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当\n返回的 I/O 对象关闭时它也会关闭，除非将 closefd 设为 False 。）\nmode 是一个指明文件打开模式的可选字符串。 它默认为 'r' 表示以文本模式读取。 其他常见\n模式有表示写入的 'w' (若文件已存在则将其清空)，表示独占创建的 'x'，以及表示追加写入\n的 'a' (在 某些 Unix 系统上，这意味着无论当前查找位置在哪里 所有 写入操作都将追加到文\n件末尾)。 在文本模式下，如果未指定 encoding 则所使用的编码格式将依赖于具体平台:\nlocale.getencoding() 会被调用以获取当前语言区域的编码格式。 (对于读取和写入原始字节\n数据请使用二进制模式并且不要指定 encoding。) 可用的模式有:\n字符 含意\n'r' 读取（默认）\n'w' 写入，并先截断文件\n'x' 排它性创建，如果文件已存在则失败\n'a' 打开文件用于写入，如果文件存在则在末尾追加\n'b' 二进制模式\n't' 文本模式（默认）\n'+' 打开用于更新（读取与写入）\n默认模式为 'r' （打开文件用于读取文本，与 'rt' 同义）。'w+' 和 'w+b' 模式将打开文件\n并清空内容。而 'r+' 和 'r+b' 模式将打开文件但不清空内容。\n正如在 概述 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 mode\n参数中的 'b' ）返回的内容为 bytes 对象，不进行任何解码。在文本模式下（默认情况下，或\n者在 mode 参数中包含 't' ）时，文件内容返回为 str ，首先使用指定的 encoding （如果给\n定）或者使用平台默认的的字节编码解码。\n备注: Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此\n与平台无关。\nbuffering 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（仅在二进制模式下允\n许），传入 1 来选择行缓冲（仅在文本模式下写入时可用），传一个整数 > 1 来表示固定大小\n的块缓冲区的字节大小。 注意这样指定缓冲区的大小适用于二进制缓冲的 I/O,但\nTextIOWrapper (即用 mode='r+' 打开的文件) 会有另一种缓冲。 要禁用 TextIOWrapper 中的\n缓冲，请考虑为 io.TextIOWrapper.reconfigure() 使用 write_through 旗标。 当没有给出\nbuffering 参数时，默认的缓冲策略规则如下:\n二进制文件以固定大小的块缓冲；当设备块大小可用时，缓冲区的大小就是\nmax(min(blocksize, 8 MiB), DEFAULT_BUFFER_SIZE) 。 在大多数系统中，缓冲区的长\n\n|  | file 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的\n路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当\n返回的 I/O 对象关闭时它也会关闭，除非将 closefd 设为 False 。）\nmode 是一个指明文件打开模式的可选字符串。 它默认为 'r' 表示以文本模式读取。 其他常见\n模式有表示写入的 'w' (若文件已存在则将其清空)，表示独占创建的 'x'，以及表示追加写入\n的 'a' (在 某些 Unix 系统上，这意味着无论当前查找位置在哪里 所有 写入操作都将追加到文\n件末尾)。 在文本模式下，如果未指定 encoding 则所使用的编码格式将依赖于具体平台:\nlocale.getencoding() 会被调用以获取当前语言区域的编码格式。 (对于读取和写入原始字节\n数据请使用二进制模式并且不要指定 encoding。) 可用的模式有:\n字符 含意\n'r' 读取（默认）\n'w' 写入，并先截断文件\n'x' 排它性创建，如果文件已存在则失败\n'a' 打开文件用于写入，如果文件存在则在末尾追加\n'b' 二进制模式\n't' 文本模式（默认）\n'+' 打开用于更新（读取与写入）\n默认模式为 'r' （打开文件用于读取文本，与 'rt' 同义）。'w+' 和 'w+b' 模式将打开文件\n并清空内容。而 'r+' 和 'r+b' 模式将打开文件但不清空内容。\n正如在 概述 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 mode\n参数中的 'b' ）返回的内容为 bytes 对象，不进行任何解码。在文本模式下（默认情况下，或\n者在 mode 参数中包含 't' ）时，文件内容返回为 str ，首先使用指定的 encoding （如果给\n定）或者使用平台默认的的字节编码解码。\n备注: Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此\n与平台无关。\nbuffering 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（仅在二进制模式下允\n许），传入 1 来选择行缓冲（仅在文本模式下写入时可用），传一个整数 > 1 来表示固定大小\n的块缓冲区的字节大小。 注意这样指定缓冲区的大小适用于二进制缓冲的 I/O,但\nTextIOWrapper (即用 mode='r+' 打开的文件) 会有另一种缓冲。 要禁用 TextIOWrapper 中的\n缓冲，请考虑为 io.TextIOWrapper.reconfigure() 使用 write_through 旗标。 当没有给出\nbuffering 参数时，默认的缓冲策略规则如下:\n二进制文件以固定大小的块缓冲；当设备块大小可用时，缓冲区的大小就是\nmax(min(blocksize, 8 MiB), DEFAULT_BUFFER_SIZE) 。 在大多数系统中，缓冲区的长 |  |\n| --- | --- | --- |\n\n| 字符 | 含意 |\n| --- | --- |\n| 'r' | 读取（默认） |\n| 'w' | 写入，并先截断文件 |\n| 'x' | 排它性创建，如果文件已存在则失败 |\n| 'a' | 打开文件用于写入，如果文件存在则在末尾追加 |\n| 'b' | 二进制模式 |\n| 't' | 文本模式（默认） |\n| '+' | 打开用于更新（读取与写入） |\n\n度通常为 128KB 。\n“交互式”文本文件（ isatty() 返回 True 的文件）使用行缓冲。其他文本文件使用上述策略\n用于二进制文件。\nencoding 是用于编码或解码文件的编码格式名称。 这应当只有文本模式下使用。 默认的编码\n格式依赖于具体平台 (即 locale.getencoding() 所返回的值)，但是任何 Python 支持的 text\nencoding 都可以被使用。 请参阅 codecs 模块获取受支持的编码格式列表。\nerrors 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使\n用。可以使用各种标准错误处理程序（列在 错误处理方案 ），但是使用\ncodecs.register_error() 注册的任何错误处理名称也是有效的。标准名称包括:\n如果存在编码错误，'strict' 会引发 ValueError 异常。 默认值 None 具有相同的效果。\n'ignore' 忽略错误。请注意，忽略编码错误可能会导致数据丢失。\n'replace' 会将替换标记（例如 '?' ）插入有错误数据的地方。\n'surrogateescape' 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代\n码位。 当在写入数据时使用 surrogateescape 错误处理器时这些替代码位会被转回到相同\n的字节。 这适用于处理具有未知编码格式的文件。\n'xmlcharrefreplace' 仅在写入文件时才受到支持。 编码格式不支持的字符将被替换为相\n应的 XML 字符引用 &#nnn;。\n'backslashreplace' 用Python的反向转义序列替换格式错误的数据。\n'namereplace' （也只在编写时支持）用 \\N{...} 转义序列替换不支持的字符。\nnewline 决定如何解析来自流的换行符。 它可以为 None, '', '\\n', '\\r' 和 '\\r\\n'。 它的工\n作原理如下:\n从流中读取输入时，如果 newline 为 None，则启用通用换行模式。输入中的行可以以\n'\\n'，'\\r' 或 '\\r\\n' 结尾，这些行被翻译成 '\\n' 在返回呼叫者之前。如果它是 ''，则\n启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入\n行仅由给定字符串终止，并且返回给调用者时行结尾不会被转换。\n将输出写入流时，如果 newline 为 None，则写入的任何 '\\n' 字符都将转换为系统默认行分\n隔符 os.linesep。如果 newline 是 '' 或 '\\n'，则不进行翻译。如果 newline 是任何其他\n合法值，则写入的任何 '\\n' 字符将被转换为给定的字符串。\n如果 closefd 为 False 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描\n述符将保持打开状态。如果给出的是文件名，则 closefd 必须为 True （默认值），否则将触发\n错误。\n可以通过传递可调用的 opener 来使用自定义开启器。然后通过使用参数（ file，flags ）调用\nopener 获得文件对象的基础文件描述符。 opener 必须返回一个打开的文件描述符（使用\nos.open as opener 时与传递 None 的效果相同）。\n新创建的文件是 不可继承的。\n下面的示例使用 os.open() 函数的 dir_fd 的形参，从给定的目录中用相对路径打开文件:\n\n|  | 度通常为 128KB 。\n“交互式”文本文件（ isatty() 返回 True 的文件）使用行缓冲。其他文本文件使用上述策略\n用于二进制文件。\nencoding 是用于编码或解码文件的编码格式名称。 这应当只有文本模式下使用。 默认的编码\n格式依赖于具体平台 (即 locale.getencoding() 所返回的值)，但是任何 Python 支持的 text\nencoding 都可以被使用。 请参阅 codecs 模块获取受支持的编码格式列表。\nerrors 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使\n用。可以使用各种标准错误处理程序（列在 错误处理方案 ），但是使用\ncodecs.register_error() 注册的任何错误处理名称也是有效的。标准名称包括:\n如果存在编码错误，'strict' 会引发 ValueError 异常。 默认值 None 具有相同的效果。\n'ignore' 忽略错误。请注意，忽略编码错误可能会导致数据丢失。\n'replace' 会将替换标记（例如 '?' ）插入有错误数据的地方。\n'surrogateescape' 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代\n码位。 当在写入数据时使用 surrogateescape 错误处理器时这些替代码位会被转回到相同\n的字节。 这适用于处理具有未知编码格式的文件。\n'xmlcharrefreplace' 仅在写入文件时才受到支持。 编码格式不支持的字符将被替换为相\n应的 XML 字符引用 &#nnn;。\n'backslashreplace' 用Python的反向转义序列替换格式错误的数据。\n'namereplace' （也只在编写时支持）用 \\N{...} 转义序列替换不支持的字符。\nnewline 决定如何解析来自流的换行符。 它可以为 None, '', '\\n', '\\r' 和 '\\r\\n'。 它的工\n作原理如下:\n从流中读取输入时，如果 newline 为 None，则启用通用换行模式。输入中的行可以以\n'\\n'，'\\r' 或 '\\r\\n' 结尾，这些行被翻译成 '\\n' 在返回呼叫者之前。如果它是 ''，则\n启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入\n行仅由给定字符串终止，并且返回给调用者时行结尾不会被转换。\n将输出写入流时，如果 newline 为 None，则写入的任何 '\\n' 字符都将转换为系统默认行分\n隔符 os.linesep。如果 newline 是 '' 或 '\\n'，则不进行翻译。如果 newline 是任何其他\n合法值，则写入的任何 '\\n' 字符将被转换为给定的字符串。\n如果 closefd 为 False 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描\n述符将保持打开状态。如果给出的是文件名，则 closefd 必须为 True （默认值），否则将触发\n错误。\n可以通过传递可调用的 opener 来使用自定义开启器。然后通过使用参数（ file，flags ）调用\nopener 获得文件对象的基础文件描述符。 opener 必须返回一个打开的文件描述符（使用\nos.open as opener 时与传递 None 的效果相同）。\n新创建的文件是 不可继承的。\n下面的示例使用 os.open() 函数的 dir_fd 的形参，从给定的目录中用相对路径打开文件: |  |\n| --- | --- | --- |\n\n>>> import os\n>>> dir_fd = os.open('somedir', os.O_RDONLY)\n>>> def opener(path, flags):\n... return os.open(path, flags, dir_fd=dir_fd)\n...\n>>> with open('spamspam.txt', 'w', opener=opener) as f:\n... print('This will be written to somedir/spamspam.txt', file=f)\n...\n>>> os.close(dir_fd) # 不要泄漏文件描述符\nopen() 函数所返回的 file object 类型取决于所用模式。 当使用 open() 以文本模式 ('w', 'r',\n'wt', 'rt' 等) 打开文件时，它将返回 io.TextIOBase (具体为 io.TextIOWrapper) 的一个子\n类。 当使用缓冲以二进制模式打开文件时，返回的类是 io.BufferedIOBase 的一个子类。 具\n体的类会有多种：在只读的二进制模式下，它将返回 io.BufferedReader；在写入二进制和追\n加二进制模式下，它将返回 io.BufferedWriter，而在读/写模式下，它将返回\nio.BufferedRandom。 当禁用缓冲时，则会返回原始流，即 io.RawIOBase 的一个子类\nio.FileIO。\n另请参阅文件操作模块，如 fileinput、io （声明了 open()）、os、os.path、tempfile\n和 shutil。\n引发一个 审计事件 open 并附带参数 path, mode, flags。\nmode 与 flags 参数可以在原始调用的基础上被修改或传递。\n在 3.3 版本发生变更:\n增加了 opener 形参。\n增加了 'x' 模式。\n过去触发的 IOError，现在是 OSError 的别名。\n如果文件已存在但使用了排它性创建模式（ 'x' ），现在会触发 FileExistsError。\n在 3.4 版本发生变更:\n文件现在禁止继承。\n在 3.5 版本发生变更:\n如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而\n不是触发 InterruptedError 异常 (原因详见 PEP 475)。\n增加了 'namereplace' 错误处理接口。\n在 3.6 版本发生变更:\n增加对实现了 os.PathLike 对象的支持。\n在 Windows 上，打开一个控制台缓冲区将返回 io.RawIOBase 的子类，而不是\nio.FileIO。\n在 3.11 版本发生变更: 'U' 模式已被移除。\n\n|  | >>> import os\n>>> dir_fd = os.open('somedir', os.O_RDONLY)\n>>> def opener(path, flags):\n... return os.open(path, flags, dir_fd=dir_fd)\n...\n>>> with open('spamspam.txt', 'w', opener=opener) as f:\n... print('This will be written to somedir/spamspam.txt', file=f)\n...\n>>> os.close(dir_fd) # 不要泄漏文件描述符\nopen() 函数所返回的 file object 类型取决于所用模式。 当使用 open() 以文本模式 ('w', 'r',\n'wt', 'rt' 等) 打开文件时，它将返回 io.TextIOBase (具体为 io.TextIOWrapper) 的一个子\n类。 当使用缓冲以二进制模式打开文件时，返回的类是 io.BufferedIOBase 的一个子类。 具\n体的类会有多种：在只读的二进制模式下，它将返回 io.BufferedReader；在写入二进制和追\n加二进制模式下，它将返回 io.BufferedWriter，而在读/写模式下，它将返回\nio.BufferedRandom。 当禁用缓冲时，则会返回原始流，即 io.RawIOBase 的一个子类\nio.FileIO。\n另请参阅文件操作模块，如 fileinput、io （声明了 open()）、os、os.path、tempfile\n和 shutil。\n引发一个 审计事件 open 并附带参数 path, mode, flags。\nmode 与 flags 参数可以在原始调用的基础上被修改或传递。\n在 3.3 版本发生变更:\n增加了 opener 形参。\n增加了 'x' 模式。\n过去触发的 IOError，现在是 OSError 的别名。\n如果文件已存在但使用了排它性创建模式（ 'x' ），现在会触发 FileExistsError。\n在 3.4 版本发生变更:\n文件现在禁止继承。\n在 3.5 版本发生变更:\n如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而\n不是触发 InterruptedError 异常 (原因详见 PEP 475)。\n增加了 'namereplace' 错误处理接口。\n在 3.6 版本发生变更:\n增加对实现了 os.PathLike 对象的支持。\n在 Windows 上，打开一个控制台缓冲区将返回 io.RawIOBase 的子类，而不是\nio.FileIO。\n在 3.11 版本发生变更: 'U' 模式已被移除。 | >>> import os\n>>> dir_fd = os.open('somedir', os.O_RDONLY)\n>>> def opener(path, flags):\n... return os.open(path, flags, dir_fd=dir_fd)\n...\n>>> with open('spamspam.txt', 'w', opener=opener) as f:\n... print('This will be written to somedir/spamspam.txt', file=f)\n...\n>>> os.close(dir_fd) # 不要泄漏文件描述符 |  |\n| --- | --- | --- | --- |\n\nord(character, /)\n返回字符的码序值。\n如果参数是单字符字符串，则返回该字符的 Unicode 码位。例如，ord('a') 返回整数 97，\nord('€')``（欧元符号）返回 ``8364。此函数是 chr() 的逆操作。\n如果参数是长度为 1 的 bytes 或 bytearray 对象，则返回其单个字节值。例如，ord(b'a')\n返回整数 97。\npow(base, exp, mod=None)\n返回 base 的 exp 次幂；如果 mod 存在，则返回 base 的 exp 次幂对 mod 取余（比 pow(base,\nexp) % mod 更高效）。 两参数形式 pow(base, exp) 等价于乘方运算符: base**exp。\n当参数为具有混用操作数类型的内置数字类型时，将应用针对二元算术运算符的强制转换规\n则。 对于 int 操作数，结果具有与操作数相同的类型（转换之后）除非第二个参数为负值；在\n那种情况下，所有参数将被转换为浮点数并输出浮点数形式的结果。 例如，pow(10, 2) 返回\n100，而 pow(10, -2) 返回 0.01。 对于 int 或 float 的基数为负值而幂为非整数的情况，将\n产生一个复数形式的结果。 例如，pow(-9, 0.5) 将返回一个接近 3j 的值。 最后，对于 int\n或 float 的基数为负值而幂为整数的情况，将产生一个浮点数形式的结果。 例如，pow(-9,\n2.0) 将返回 81.0。\n对于 int 操作数 base 和 exp，如果给出 mod，则 mod 必须为整数类型并且 mod 必须不为\n零。 如果给出 mod 并且 exp 为负值，则 base 必须相对于 mod 不可整除。 在这种情况下，将\n会返回 pow(inv_base, -exp, mod)，其中 inv_base 为 base 的倒数对 mod 取余。\n下面的例子是 38 的倒数对 97 取余:\n>>> pow(38, -1, mod=97)\n23\n>>> 23 * 38 % 97 == 1\nTrue\n在 3.8 版本发生变更: 对于 int 操作数，三参数形式的 pow 现在允许第二个参数为负值，\n即可以计算倒数的余数。\n在 3.8 版本发生变更: 允许关键字参数。 之前只支持位置参数。\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n将 objects 打印输出至 file 指定的文本流，以 sep 分隔并在末尾加上 end。 sep 、 end 、 file 和\nflush 必须以关键字参数的形式给出。\n所有非关键字参数都会被转换为字符串，就像是执行了 str() 一样，并会被写入到流，以 sep\n分隔并在末尾加上 end。 sep 和 end 都必须为字符串；它们也可以为 None，这意味着使用默认\n值。 如果没有给出 objects，则 print() 将只写入 end。\nfile 参数必须是一个具有 write(string) 方法的对象；如果参数不存在或为 None，则将使用\nsys.stdout。 由于要打印的参数会被转换为文本字符串，因此 print() 不能用于二进制模式\n的文件对象。 对于这些对象，应改用 file.write(...)。\n\n|  |  |  | ord(character, /)\n返回字符的码序值。\n如果参数是单字符字符串，则返回该字符的 Unicode 码位。例如，ord('a') 返回整数 97，\nord('€')``（欧元符号）返回 ``8364。此函数是 chr() 的逆操作。\n如果参数是长度为 1 的 bytes 或 bytearray 对象，则返回其单个字节值。例如，ord(b'a')\n返回整数 97。\npow(base, exp, mod=None)\n返回 base 的 exp 次幂；如果 mod 存在，则返回 base 的 exp 次幂对 mod 取余（比 pow(base,\nexp) % mod 更高效）。 两参数形式 pow(base, exp) 等价于乘方运算符: base**exp。\n当参数为具有混用操作数类型的内置数字类型时，将应用针对二元算术运算符的强制转换规\n则。 对于 int 操作数，结果具有与操作数相同的类型（转换之后）除非第二个参数为负值；在\n那种情况下，所有参数将被转换为浮点数并输出浮点数形式的结果。 例如，pow(10, 2) 返回\n100，而 pow(10, -2) 返回 0.01。 对于 int 或 float 的基数为负值而幂为非整数的情况，将\n产生一个复数形式的结果。 例如，pow(-9, 0.5) 将返回一个接近 3j 的值。 最后，对于 int\n或 float 的基数为负值而幂为整数的情况，将产生一个浮点数形式的结果。 例如，pow(-9,\n2.0) 将返回 81.0。\n对于 int 操作数 base 和 exp，如果给出 mod，则 mod 必须为整数类型并且 mod 必须不为\n零。 如果给出 mod 并且 exp 为负值，则 base 必须相对于 mod 不可整除。 在这种情况下，将\n会返回 pow(inv_base, -exp, mod)，其中 inv_base 为 base 的倒数对 mod 取余。\n下面的例子是 38 的倒数对 97 取余:\n>>> pow(38, -1, mod=97)\n23\n>>> 23 * 38 % 97 == 1\nTrue\n在 3.8 版本发生变更: 对于 int 操作数，三参数形式的 pow 现在允许第二个参数为负值，\n即可以计算倒数的余数。\n在 3.8 版本发生变更: 允许关键字参数。 之前只支持位置参数。\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n将 objects 打印输出至 file 指定的文本流，以 sep 分隔并在末尾加上 end。 sep 、 end 、 file 和\nflush 必须以关键字参数的形式给出。\n所有非关键字参数都会被转换为字符串，就像是执行了 str() 一样，并会被写入到流，以 sep\n分隔并在末尾加上 end。 sep 和 end 都必须为字符串；它们也可以为 None，这意味着使用默认\n值。 如果没有给出 objects，则 print() 将只写入 end。\nfile 参数必须是一个具有 write(string) 方法的对象；如果参数不存在或为 None，则将使用\nsys.stdout。 由于要打印的参数会被转换为文本字符串，因此 print() 不能用于二进制模式\n的文件对象。 对于这些对象，应改用 file.write(...)。 |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | pow(base, |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  | pow(-9, |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | 2.0) |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n\n输出缓冲通常由 file 确定。 但是，如果 flush 为真值，流将被强制刷新。\n在 3.3 版本发生变更: 增加了 flush 关键字参数。\nclass property(fget=None, fset=None, fdel=None, doc=None)\n返回 property 属性。\nfget 是获取属性值的函数。 fset 是用于设置属性值的函数。 fdel 是用于删除属性值的函数。并\n且 doc 为属性对象创建文档字符串。\n一个典型的用法是定义一个托管属性 x:\nclass C:\ndef __init__(self):\nself._x = None\ndef getx(self):\nreturn self._x\ndef setx(self, value):\nself._x = value\ndef delx(self):\ndel self._x\nx = property(getx, setx, delx, \"I'm the 'x' property.\")\n如果 c 为 C 的实例，c.x 将调用 getter，c.x = value 将调用 setter， del c.x 将调用\ndeleter。\n如果给出，doc 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 fget 的文档字\n符串（如果存在）。 这令使用 property() 作为 decorator 来创建只读的特征属性可以很容易\n地实现:\nclass Parrot:\ndef __init__(self):\nself._voltage = 100000\n@property\ndef voltage(self):\n\"\"\"Get the current voltage.\"\"\"\nreturn self._voltage\n@property 装饰器会将 voltage() 方法转化为一个具有相同名称的只读属性 \"getter\"，并将\nvoltage 的文档字符串设为 \"Get the current voltage.\"\n@getter\n@setter\n@deleter\n\n|  | 输出缓冲通常由 file 确定。 但是，如果 flush 为真值，流将被强制刷新。\n在 3.3 版本发生变更: 增加了 flush 关键字参数。\nclass property(fget=None, fset=None, fdel=None, doc=None)\n返回 property 属性。\nfget 是获取属性值的函数。 fset 是用于设置属性值的函数。 fdel 是用于删除属性值的函数。并\n且 doc 为属性对象创建文档字符串。\n一个典型的用法是定义一个托管属性 x:\nclass C:\ndef __init__(self):\nself._x = None\ndef getx(self):\nreturn self._x\ndef setx(self, value):\nself._x = value\ndef delx(self):\ndel self._x\nx = property(getx, setx, delx, \"I'm the 'x' property.\")\n如果 c 为 C 的实例，c.x 将调用 getter，c.x = value 将调用 setter， del c.x 将调用\ndeleter。\n如果给出，doc 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 fget 的文档字\n符串（如果存在）。 这令使用 property() 作为 decorator 来创建只读的特征属性可以很容易\n地实现:\nclass Parrot:\ndef __init__(self):\nself._voltage = 100000\n@property\ndef voltage(self):\n\"\"\"Get the current voltage.\"\"\"\nreturn self._voltage\n@property 装饰器会将 voltage() 方法转化为一个具有相同名称的只读属性 \"getter\"，并将\nvoltage 的文档字符串设为 \"Get the current voltage.\"\n@getter\n@setter\n@deleter |  |\n| --- | --- | --- |\n\n特征属性对象具有 getter, setter 和 deleter 方法，它们可用作装饰器来创建该特征属\n性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来说明：\nclass C:\ndef __init__(self):\nself._x = None\n@property\ndef x(self):\n\"\"\"I'm the 'x' property.\"\"\"\nreturn self._x\n@x.setter\ndef x(self, value):\nself._x = value\n@x.deleter\ndef x(self):\ndel self._x\n上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称\n(在本例中为 x。)\n返回的特征属性对象同样具有与构造器参数相对应的属性 fget, fset 和 fdel。\n在 3.5 版本发生变更: 特征属性对象的文档字符串现在是可写的。\n__name__\n保存特征属性名称的属性。 特性属性名称可在运行时被修改。\nAdded in version 3.13.\nclass range(stop, /)\nclass range(start, stop, step=1, /)\n虽然被称为函数，但 range 实际上是一个不可变的序列类型，参见在 range 对象 与 序列类型 -\n-- list, tuple, range 中的文档说明。\nrepr(object, /)\n返回包含一个对象的可打印表示形式的字符串。 对于许多类型而言，此函数会尝试返回一个具\n有与传给 eval() 时相同的值的字符串；在其他情况下，其表示形式将为一个包含对象类型名\n称和通常包括对象名称和地址的额外信息的用尖括号括起来的字符串。 一个类可以通过定义\n__repr__() 方法来控制此函数为其实例所返回的内容。 如果 sys.displayhook() 不可访问，\n则此函数将会引发 RuntimeError。\n该类具有自定义的表示形式，它可被求值为:\nclass Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age\n\n|  | 特征属性对象具有 getter, setter 和 deleter 方法，它们可用作装饰器来创建该特征属\n性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来说明：\nclass C:\ndef __init__(self):\nself._x = None\n@property\ndef x(self):\n\"\"\"I'm the 'x' property.\"\"\"\nreturn self._x\n@x.setter\ndef x(self, value):\nself._x = value\n@x.deleter\ndef x(self):\ndel self._x\n上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称\n(在本例中为 x。)\n返回的特征属性对象同样具有与构造器参数相对应的属性 fget, fset 和 fdel。\n在 3.5 版本发生变更: 特征属性对象的文档字符串现在是可写的。\n__name__\n保存特征属性名称的属性。 特性属性名称可在运行时被修改。\nAdded in version 3.13.\nclass range(stop, /)\nclass range(start, stop, step=1, /)\n虽然被称为函数，但 range 实际上是一个不可变的序列类型，参见在 range 对象 与 序列类型 -\n-- list, tuple, range 中的文档说明。\nrepr(object, /)\n返回包含一个对象的可打印表示形式的字符串。 对于许多类型而言，此函数会尝试返回一个具\n有与传给 eval() 时相同的值的字符串；在其他情况下，其表示形式将为一个包含对象类型名\n称和通常包括对象名称和地址的额外信息的用尖括号括起来的字符串。 一个类可以通过定义\n__repr__() 方法来控制此函数为其实例所返回的内容。 如果 sys.displayhook() 不可访问，\n则此函数将会引发 RuntimeError。\n该类具有自定义的表示形式，它可被求值为:\nclass Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age |  |  |\n| --- | --- | --- | --- |\n|  |  | class Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age |  |\n\ndef __repr__(self):\nreturn f\"Person('{self.name}', {self.age})\"\nreversed(object, /)\n返回一个反向的 iterator。 该参数必须是一个具有 __reversed__() 方法或是支持序列协议\n（具有 __len__() 方法和从 0 开始的整数参数的 __getitem__() 方法）的对象。\nround(number, ndigits=None)\n返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回最接\n近输入值的整数。\n对于支持 round() 方法的内置类型，结果值会舍入至最接近的 10 的负 ndigits 次幂的倍数；如\n果与两个倍数同样接近，则选用偶数。因此，round(0.5) 和 round(-0.5) 均得出 0 而\nround(1.5) 则为 2。ndigits 可为任意整数值（正数、零或负数）。如果省略了 ndigits 或为\nNone ，则返回值将为整数。否则返回值与 number 的类型相同。\n对于一般的 Python 对象 number, round 将委托给 number.__round__。\n备注: 对浮点数执行 round() 的行为可能会令人惊讶：例如，round(2.675, 2) 将给出\n2.67 而不是期望的 2.68。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都\n不能以浮点数精确地表示。 请参阅 浮点算术：争议和限制 了解更多信息。\nclass set(iterable=(), /)\n返回一个新的 set 对象，可以选择带有从 iterable 获取的元素。 set 是一个内置类型。 请查看\nset 和 集合类型 --- set, frozenset 获取关于这个类的文档。\n有关其他容器请参看内置的 frozenset, list, tuple 和 dict 类，以及 collections 模块。\nsetattr(object, name, value, /)\n本函数与 getattr() 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某\n现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 setattr(x,\n'foobar', 123) 等价于 x.foobar = 123。\nname 无需为在 名称（标识符和关键字） 中定义的 Python 标识符除非对象选择强制这样做，\n例如在一个自定义的 __getattribute__() 中或是通过 __slots__。 一个名称不为标识符的属\n性将不可使用点号标记来访问，但是可以通过 getattr() 等来访问。\n备注: 由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头\n的属性）名称以便使用 setattr() 来设置它。\nclass slice(stop, /)\nclass slice(start, stop, step=None, /)\n返回一个表示由 range(start, stop, step) 指定的索引集的 slice 对象。 start 和 step 参数默\n认为 None。\n\n|  |  | def __repr__(self):\nreturn f\"Person('{self.name}', {self.age})\"\nreversed(object, /)\n返回一个反向的 iterator。 该参数必须是一个具有 __reversed__() 方法或是支持序列协议\n（具有 __len__() 方法和从 0 开始的整数参数的 __getitem__() 方法）的对象。\nround(number, ndigits=None)\n返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回最接\n近输入值的整数。\n对于支持 round() 方法的内置类型，结果值会舍入至最接近的 10 的负 ndigits 次幂的倍数；如\n果与两个倍数同样接近，则选用偶数。因此，round(0.5) 和 round(-0.5) 均得出 0 而\nround(1.5) 则为 2。ndigits 可为任意整数值（正数、零或负数）。如果省略了 ndigits 或为\nNone ，则返回值将为整数。否则返回值与 number 的类型相同。\n对于一般的 Python 对象 number, round 将委托给 number.__round__。\n备注: 对浮点数执行 round() 的行为可能会令人惊讶：例如，round(2.675, 2) 将给出\n2.67 而不是期望的 2.68。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都\n不能以浮点数精确地表示。 请参阅 浮点算术：争议和限制 了解更多信息。\nclass set(iterable=(), /)\n返回一个新的 set 对象，可以选择带有从 iterable 获取的元素。 set 是一个内置类型。 请查看\nset 和 集合类型 --- set, frozenset 获取关于这个类的文档。\n有关其他容器请参看内置的 frozenset, list, tuple 和 dict 类，以及 collections 模块。\nsetattr(object, name, value, /)\n本函数与 getattr() 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某\n现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 setattr(x,\n'foobar', 123) 等价于 x.foobar = 123。\nname 无需为在 名称（标识符和关键字） 中定义的 Python 标识符除非对象选择强制这样做，\n例如在一个自定义的 __getattribute__() 中或是通过 __slots__。 一个名称不为标识符的属\n性将不可使用点号标记来访问，但是可以通过 getattr() 等来访问。\n备注: 由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头\n的属性）名称以便使用 setattr() 来设置它。\nclass slice(stop, /)\nclass slice(start, stop, step=None, /)\n返回一个表示由 range(start, stop, step) 指定的索引集的 slice 对象。 start 和 step 参数默\n认为 None。 | def __repr__(self):\nreturn f\"Person('{self.name}', {self.age})\" |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | setattr(x, |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n\n切片对象具有只读的数据属性 start, stop 和 step，它们将简单地返回相应的参数值（或其默\n认值）。 它们没有其他显式的功能；但是，它们会被 NumPy 和其他第三方包所使用。\nstart\nstop\nstep\n当使用扩展索引语法时也会生成切片对象。 例如: a[start:stop:step] 或 a[start:stop,\ni]。 请参阅 itertools.islice() 了解返回 iterator 的替代版本。\n在 3.12 版本发生变更: Slice 对象现在将为 hashable (如果 start, stop 和 step 均为可哈\n希对象)。\nsorted(iterable, /, *, key=None, reverse=False)\n根据 iterable 中的项返回一个新的已排序列表。\n具有两个可选参数，它们都必须指定为关键字参数。\nkey 指定带有单个参数的函数，用于从 iterable 的每个元素中提取用于比较的键 (例如\nkey=str.lower)。 默认值为 None (直接比较元素)。\nreverse 为一个布尔值。 如果设为 True，则每个列表元素将按反向顺序比较进行排序。\n使用 functools.cmp_to_key() 可将老式的 cmp 函数转换为 key 函数。\n内置的 sorted() 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序\n就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再按薪级排序）。\n排序算法只使用 < 在项目之间比较。 虽然定义一个 __lt__() 方法就足以进行排序，但 PEP 8\n建议实现所有六个 富比较 。 这将有助于避免在与其他排序工具（如 max() ）使用相同的数据\n时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较\n的混乱，因为混合类型比较可以调用反射到 __gt__() 的方法。\n有关排序示例和简要排序教程，请参阅 排序的技术 。\n@staticmethod\n将方法转换为静态方法。\n静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法\nclass C:\n@staticmethod\ndef f(arg1, arg2, argN): ...\n@staticmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。\n\n|  |  | 切片对象具有只读的数据属性 start, stop 和 step，它们将简单地返回相应的参数值（或其默\n认值）。 它们没有其他显式的功能；但是，它们会被 NumPy 和其他第三方包所使用。\nstart\nstop\nstep\n当使用扩展索引语法时也会生成切片对象。 例如: a[start:stop:step] 或 a[start:stop,\ni]。 请参阅 itertools.islice() 了解返回 iterator 的替代版本。\n在 3.12 版本发生变更: Slice 对象现在将为 hashable (如果 start, stop 和 step 均为可哈\n希对象)。\nsorted(iterable, /, *, key=None, reverse=False)\n根据 iterable 中的项返回一个新的已排序列表。\n具有两个可选参数，它们都必须指定为关键字参数。\nkey 指定带有单个参数的函数，用于从 iterable 的每个元素中提取用于比较的键 (例如\nkey=str.lower)。 默认值为 None (直接比较元素)。\nreverse 为一个布尔值。 如果设为 True，则每个列表元素将按反向顺序比较进行排序。\n使用 functools.cmp_to_key() 可将老式的 cmp 函数转换为 key 函数。\n内置的 sorted() 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序\n就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再按薪级排序）。\n排序算法只使用 < 在项目之间比较。 虽然定义一个 __lt__() 方法就足以进行排序，但 PEP 8\n建议实现所有六个 富比较 。 这将有助于避免在与其他排序工具（如 max() ）使用相同的数据\n时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较\n的混乱，因为混合类型比较可以调用反射到 __gt__() 的方法。\n有关排序示例和简要排序教程，请参阅 排序的技术 。\n@staticmethod\n将方法转换为静态方法。\n静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法\nclass C:\n@staticmethod\ndef f(arg1, arg2, argN): ...\n@staticmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。 |  |\n| --- | --- | --- | --- |\n|  |  | i] |  |\n|  |  |  |  |\n\n静态方式既可以在类上调用 (如 C.f())，也可以在实例上调用 (如 C().f())。 此外，静态方法\ndescriptor 也属于可调用对象，因而它们可以在类定义中使用 (如 f())。\nPython 的静态方法与 Java 或 C++ 类似。另请参阅 classmethod() ，可用于创建另一种类构\n造函数。\n像所有装饰器一样，也可以像常规函数一样调用 staticmethod ，并对其结果执行某些操作。\n比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，\n请使用此语法:\ndef regular_function():\n...\nclass C:\nmethod = staticmethod(regular_function)\n想了解更多有关静态方法的信息，请参阅 标准类型层级结构 。\n在 3.10 版本发生变更: 静态方法现在继承了方法的属性 (__module__, __name__,\n__qualname__, __doc__ 和 __annotations__)，并具有新的 __wrapped__ 属性，现在\n是属于与常规函数类似的可调用对象。\nclass str(*, encoding='utf-8', errors='strict')\nclass str(object)\nclass str(object, encoding, errors='strict')\nclass str(object, *, errors)\n返回一个 str 版本的 object 。有关详细信息，请参阅 str() 。\nstr 是内置字符串 class 。更多关于字符串的信息查看 文本序列类型 --- str。\nsum(iterable, /, start=0)\n从 start 开始自左向右对 iterable 的项求和并返回总计值。 iterable 的项通常为数字，而 start 值\n则不允许为字符串。\n对于某些用例，存在 sum() 的更好替代。 拼接字符串序列的更好、更快的方式是调用\n''.join(sequence)。 要以扩展的精度执行浮点数值的求和，请参阅 math.fsum()。 要拼接\n一系列可迭代对象，请考虑使用 itertools.chain()。\n在 3.8 版本发生变更: start 形参可用关键字参数形式来指定。\n在 3.12 版本发生变更: 浮点数的求和已切换为一种可在大多数构建版本中给出更高精确度\n和更好适应性的算法。\n在 3.14 版本发生变更: 添加了复数求和的特殊化，使用与浮点数求和相同的算法。\nclass super\nclass super(type, object_or_type=None, /)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重写\n的继承方法很有用。\n\n|  | 静态方式既可以在类上调用 (如 C.f())，也可以在实例上调用 (如 C().f())。 此外，静态方法\ndescriptor 也属于可调用对象，因而它们可以在类定义中使用 (如 f())。\nPython 的静态方法与 Java 或 C++ 类似。另请参阅 classmethod() ，可用于创建另一种类构\n造函数。\n像所有装饰器一样，也可以像常规函数一样调用 staticmethod ，并对其结果执行某些操作。\n比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，\n请使用此语法:\ndef regular_function():\n...\nclass C:\nmethod = staticmethod(regular_function)\n想了解更多有关静态方法的信息，请参阅 标准类型层级结构 。\n在 3.10 版本发生变更: 静态方法现在继承了方法的属性 (__module__, __name__,\n__qualname__, __doc__ 和 __annotations__)，并具有新的 __wrapped__ 属性，现在\n是属于与常规函数类似的可调用对象。\nclass str(*, encoding='utf-8', errors='strict')\nclass str(object)\nclass str(object, encoding, errors='strict')\nclass str(object, *, errors)\n返回一个 str 版本的 object 。有关详细信息，请参阅 str() 。\nstr 是内置字符串 class 。更多关于字符串的信息查看 文本序列类型 --- str。\nsum(iterable, /, start=0)\n从 start 开始自左向右对 iterable 的项求和并返回总计值。 iterable 的项通常为数字，而 start 值\n则不允许为字符串。\n对于某些用例，存在 sum() 的更好替代。 拼接字符串序列的更好、更快的方式是调用\n''.join(sequence)。 要以扩展的精度执行浮点数值的求和，请参阅 math.fsum()。 要拼接\n一系列可迭代对象，请考虑使用 itertools.chain()。\n在 3.8 版本发生变更: start 形参可用关键字参数形式来指定。\n在 3.12 版本发生变更: 浮点数的求和已切换为一种可在大多数构建版本中给出更高精确度\n和更好适应性的算法。\n在 3.14 版本发生变更: 添加了复数求和的特殊化，使用与浮点数求和相同的算法。\nclass super\nclass super(type, object_or_type=None, /)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重写\n的继承方法很有用。 |  |\n| --- | --- | --- |\n\nobject_or_type 确定要用于搜索的 method resolution order。 搜索会从 type 之后的类开始。\n举例来说，如果 object_or_type 的 __mro__ 为 D -> B -> C -> A -> object 并且 type 的值\n为 B，则 super() 将会搜索 C -> A -> object。\n对应于 object_or_type 的类的 __mro__ 属性列出了 getattr() 和 super() 所共同使用的方法\n解析搜索顺序。 该属性是动态的并可在任何继承层级结构更新时被改变。\n如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则\nisinstance(obj, type) 必须为真值。 如果第二个参数为一个类型，则 issubclass(type2,\ntype) 必须为真值（这适用于类方法）。\n当在普通方法或类中直接调用时，这两个参数均可被省略 (即 \"零参数 super()\")。 在此情况\n下，type 将为其外层的类，而 obj 将为其所在函数的第一个参数 (通常为 self)。 (这意味着零\n参数 super() 在嵌套的函数内的行为将不会如预期那样，这也包括生成器表达式，因为它会隐\n式地创建嵌套的函数。)\nsuper 有两个典型用例。 在具有单继承的类层级结构中，super 可用来引用父类而不必显式地指\n定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 super 的用法非常相似。\n第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态\n编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同\n的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是\n在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行\n时之前未知的兄弟类）。\n对于以上两个用例，典型的超类调用看起来是这样的:\nclass C(B):\ndef method(self, arg):\nsuper().method(arg) # 它的作用像：\n# super(C, self).method(arg)\n除了方法查找之外，super() 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调\n用 描述器。\n请注意 super() 被实现为为显式的带点号属性查找的绑定过程的组成部分，例如\nsuper().__getitem__(name)。 它做到这一点是通过实现自己的 __getattribute__() 方法\n以便能够按支持协作多重继承的可预测的顺序来搜索类。 相应地，super() 在像 super()\n[name] 这样使用语句或运算符进行隐式查找时则是未定义的。\n还要注意的是，除了零个参数的形式以外，super() 并不限于在方法内部使用。 两个参数的形\n式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填\n入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。\n对于有关如何使用 super() 来如何设计协作类的实用建议，请参阅 使用 super() 的指南。\n在 3.14 版本发生变更: super 对象现在是 pickleable 和 copyable 。\n\n|  |  |  | object_or_type 确定要用于搜索的 method resolution order。 搜索会从 type 之后的类开始。\n举例来说，如果 object_or_type 的 __mro__ 为 D -> B -> C -> A -> object 并且 type 的值\n为 B，则 super() 将会搜索 C -> A -> object。\n对应于 object_or_type 的类的 __mro__ 属性列出了 getattr() 和 super() 所共同使用的方法\n解析搜索顺序。 该属性是动态的并可在任何继承层级结构更新时被改变。\n如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则\nisinstance(obj, type) 必须为真值。 如果第二个参数为一个类型，则 issubclass(type2,\ntype) 必须为真值（这适用于类方法）。\n当在普通方法或类中直接调用时，这两个参数均可被省略 (即 \"零参数 super()\")。 在此情况\n下，type 将为其外层的类，而 obj 将为其所在函数的第一个参数 (通常为 self)。 (这意味着零\n参数 super() 在嵌套的函数内的行为将不会如预期那样，这也包括生成器表达式，因为它会隐\n式地创建嵌套的函数。)\nsuper 有两个典型用例。 在具有单继承的类层级结构中，super 可用来引用父类而不必显式地指\n定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 super 的用法非常相似。\n第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态\n编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同\n的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是\n在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行\n时之前未知的兄弟类）。\n对于以上两个用例，典型的超类调用看起来是这样的:\nclass C(B):\ndef method(self, arg):\nsuper().method(arg) # 它的作用像：\n# super(C, self).method(arg)\n除了方法查找之外，super() 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调\n用 描述器。\n请注意 super() 被实现为为显式的带点号属性查找的绑定过程的组成部分，例如\nsuper().__getitem__(name)。 它做到这一点是通过实现自己的 __getattribute__() 方法\n以便能够按支持协作多重继承的可预测的顺序来搜索类。 相应地，super() 在像 super()\n[name] 这样使用语句或运算符进行隐式查找时则是未定义的。\n还要注意的是，除了零个参数的形式以外，super() 并不限于在方法内部使用。 两个参数的形\n式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填\n入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。\n对于有关如何使用 super() 来如何设计协作类的实用建议，请参阅 使用 super() 的指南。\n在 3.14 版本发生变更: super 对象现在是 pickleable 和 copyable 。 |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | type) |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  | super() |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | [name] |  |  |  |\n|  |  |  |  |  |  |  |\n\nclass tuple(iterable=(), /)\n虽然被称为函数，但 tuple 实际上是一个不可变的序列类型，参见在 元组 与 序列类型 --- list,\ntuple, range 中的文档说明。\nclass type(object, /)\nclass type(name, bases, dict, /, **kwargs)\n传入一个参数时，返回 object 的类型。 返回值是一个 type 对象并且通常与\nobject.__class__ 所返回的对象相同。\n推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。\n传入三个参数时，返回一个新的 type 对象。 这在本质上是 class 语句的一种动态形式。\nname 字符串即类名并会成为 __name__ 属性；bases 元组包含基类并会成为 __bases__ 属\n性；如果为空，则会添加所有类的终极基类，即 object。 dict 字典包含类体的属性和方法定\n义；它在成为 __dict__ 属性之前可能会被拷贝或包装。 下面两条语句会创建同样的 type 对\n象：\n>>> class X:\n... a = 1\n...\n>>> X = type('X', (), dict(a=1))\n另请参阅：\n有关类的属性和方法的文档。\n类型对象\n提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 __init_subclass__())，\n相当于类定义中关键字 (除了 metaclass) 的行为方式。\n另请参阅 自定义类创建。\n在 3.6 版本发生变更: type 的子类如果未重写 type.__new__ 将不再能使用一个参数的形\n式来获取对象的类型。\nvars()\nvars(object, /)\n返回模块、类、实例或任何其他具有 __dict__ 属性的对象的 __dict__ 属性。\n模块和实例这样的对象具有可更新的 __dict__ 属性；但是，其他对象的 __dict__ 属性可能\n会设置写入限制（例如，类会使用 types.MappingProxyType 来防止直接更新字典）。\n不带参数时，vars() 的行为将类似于 locals()。\n如果指定了一个对象但它没有 __dict__ 属性（例如，当它所属的类定义了 __slots__ 属性\n时）则会引发 TypeError 异常。\n在 3.13 版本发生变更: 不带参数调用此函数的结果已被更新为与 locals() 内置函数的描\n述类似。\n\n|  | class tuple(iterable=(), /)\n虽然被称为函数，但 tuple 实际上是一个不可变的序列类型，参见在 元组 与 序列类型 --- list,\ntuple, range 中的文档说明。\nclass type(object, /)\nclass type(name, bases, dict, /, **kwargs)\n传入一个参数时，返回 object 的类型。 返回值是一个 type 对象并且通常与\nobject.__class__ 所返回的对象相同。\n推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。\n传入三个参数时，返回一个新的 type 对象。 这在本质上是 class 语句的一种动态形式。\nname 字符串即类名并会成为 __name__ 属性；bases 元组包含基类并会成为 __bases__ 属\n性；如果为空，则会添加所有类的终极基类，即 object。 dict 字典包含类体的属性和方法定\n义；它在成为 __dict__ 属性之前可能会被拷贝或包装。 下面两条语句会创建同样的 type 对\n象：\n>>> class X:\n... a = 1\n...\n>>> X = type('X', (), dict(a=1))\n另请参阅：\n有关类的属性和方法的文档。\n类型对象\n提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 __init_subclass__())，\n相当于类定义中关键字 (除了 metaclass) 的行为方式。\n另请参阅 自定义类创建。\n在 3.6 版本发生变更: type 的子类如果未重写 type.__new__ 将不再能使用一个参数的形\n式来获取对象的类型。\nvars()\nvars(object, /)\n返回模块、类、实例或任何其他具有 __dict__ 属性的对象的 __dict__ 属性。\n模块和实例这样的对象具有可更新的 __dict__ 属性；但是，其他对象的 __dict__ 属性可能\n会设置写入限制（例如，类会使用 types.MappingProxyType 来防止直接更新字典）。\n不带参数时，vars() 的行为将类似于 locals()。\n如果指定了一个对象但它没有 __dict__ 属性（例如，当它所属的类定义了 __slots__ 属性\n时）则会引发 TypeError 异常。\n在 3.13 版本发生变更: 不带参数调用此函数的结果已被更新为与 locals() 内置函数的描\n述类似。 |  |\n| --- | --- | --- |\n\nzip(*iterables, strict=False)\n在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。\n示例:\n>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n... print(item)\n...\n(1, 'sugar')\n(2, 'spice')\n(3, 'everything nice')\n更正式的说法： zip() 返回元组的迭代器，其中第 i 个元组包含的是每个参数迭代器的第 i 个\n元素。\n不妨换一种方式认识 zip() ：它会把行变成列，把列变成行。这类似于 矩阵转置 。\nzip() 是延迟执行的：直至迭代时才会对元素进行处理，比如 for 循环或放入 list 中。\n值得考虑的是，传给 zip() 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这\n些对象的代码存在错误。Python 提供了三种不同的处理方案：\n默认情况下，zip() 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果\n会裁切至最短可迭代对象的长度：\n>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n[(0, 'fee'), (1, 'fi'), (2, 'fo')]\n通常 zip() 用于可迭代对象等长的情况下。这时建议用 strict=True 的选项。输出与普通\n的 zip() 相同：。\n>>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n[('a', 1), ('b', 2), ('c', 3)]\n与默认行为不同，如果一个可迭代对象在其他几个之前被耗尽则会引发 ValueError:\n>>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):\n... print(item)\n...\n(0, 'fee')\n(1, 'fi')\n(2, 'fo')\nTraceback (most recent call last):\n...\nValueError: zip() argument 2 is longer than argument 1\n如果未指定 strict=True 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会\n在程序的其他地方表现为难以发现的错误。\n为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由\nitertools.zip_longest() 来完成。\n\n|  | zip(*iterables, strict=False)\n在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。\n示例:\n>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n... print(item)\n...\n(1, 'sugar')\n(2, 'spice')\n(3, 'everything nice')\n更正式的说法： zip() 返回元组的迭代器，其中第 i 个元组包含的是每个参数迭代器的第 i 个\n元素。\n不妨换一种方式认识 zip() ：它会把行变成列，把列变成行。这类似于 矩阵转置 。\nzip() 是延迟执行的：直至迭代时才会对元素进行处理，比如 for 循环或放入 list 中。\n值得考虑的是，传给 zip() 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这\n些对象的代码存在错误。Python 提供了三种不同的处理方案：\n默认情况下，zip() 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果\n会裁切至最短可迭代对象的长度：\n>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n[(0, 'fee'), (1, 'fi'), (2, 'fo')]\n通常 zip() 用于可迭代对象等长的情况下。这时建议用 strict=True 的选项。输出与普通\n的 zip() 相同：。\n>>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n[('a', 1), ('b', 2), ('c', 3)]\n与默认行为不同，如果一个可迭代对象在其他几个之前被耗尽则会引发 ValueError:\n>>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):\n... print(item)\n...\n(0, 'fee')\n(1, 'fi')\n(2, 'fo')\nTraceback (most recent call last):\n...\nValueError: zip() argument 2 is longer than argument 1\n如果未指定 strict=True 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会\n在程序的其他地方表现为难以发现的错误。\n为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由\nitertools.zip_longest() 来完成。 |  |\n| --- | --- | --- |\n\n极端例子是只有一个可迭代对象参数，zip() 会返回一个一元组的迭代器。如果未给出参数，\n则返回一个空的迭代器。\n小技巧：\n可确保迭代器的求值顺序是从左到右的。这样就能用 zip(*[iter(s)]*n, strict=True)\n将数据列表按长度 n 进行分组。这将重复 相同 的迭代器 n 次，输出的每个元组都包含 n 次\n调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。\nzip() 与 * 运算符相结合可以用来拆解一个列表:\n>>> x = [1, 2, 3]\n>>> y = [4, 5, 6]\n>>> list(zip(x, y))\n[(1, 4), (2, 5), (3, 6)]\n>>> x2, y2 = zip(*zip(x, y))\n>>> x == list(x2) and y == list(y2)\nTrue\n在 3.10 版本发生变更: 增加了 strict 参数。\n__import__(name, globals=None, locals=None, fromlist=(), level=0)\n备注: 与 importlib.import_module() 不同，这是一个日常 Python 编程中不需要用到的\n高级函数。\n此函数会由 import 语句唤起。 它可以被替换 (通过导入 builtins 模块并赋值给\nbuiltins.__import__) 以便修改 import 语句的语义，但是 强烈 不建议这样做，因为使用导\n入钩子 (参见 PEP 302) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都\n会假定所用的是默认实现。 同样也不建议直接使用 __import__() 而应该用\nimportlib.import_module()。\n本函数会导入模块 name，利用 globals 和 locals 来决定如何在包的上下文中解释该名称。\nfromlist 给出了应从 name 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到\nlocals 参数，只用到了 globals 用于确定 import 语句所在的包上下文。\nlevel 指定是使用绝对还是相对导入。 0 (默认值) 意味着仅执行绝对导入。 level 为正数值表示\n相对于模块调用 __import__() 的目录，将要搜索的父目录层数 (详情参见 PEP 328)。\n当 name 变量的形式为 package.module 时，通常将会返回最高层级的包（第一个点号之前的\n名称），而 不是 以 name 命名的模块。 但是，当给出了非空的 fromlist 参数时，则将返回以\nname 命名的模块。\n例如，语句 import spam 的结果将为与以下代码作用相同的字节码:\nspam = __import__('spam', globals(), locals(), [], 0)\n语句 import spam.ham 的结果将为以下调用:\n\n|  | 极端例子是只有一个可迭代对象参数，zip() 会返回一个一元组的迭代器。如果未给出参数，\n则返回一个空的迭代器。\n小技巧：\n可确保迭代器的求值顺序是从左到右的。这样就能用 zip(*[iter(s)]*n, strict=True)\n将数据列表按长度 n 进行分组。这将重复 相同 的迭代器 n 次，输出的每个元组都包含 n 次\n调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。\nzip() 与 * 运算符相结合可以用来拆解一个列表:\n>>> x = [1, 2, 3]\n>>> y = [4, 5, 6]\n>>> list(zip(x, y))\n[(1, 4), (2, 5), (3, 6)]\n>>> x2, y2 = zip(*zip(x, y))\n>>> x == list(x2) and y == list(y2)\nTrue\n在 3.10 版本发生变更: 增加了 strict 参数。\n__import__(name, globals=None, locals=None, fromlist=(), level=0)\n备注: 与 importlib.import_module() 不同，这是一个日常 Python 编程中不需要用到的\n高级函数。\n此函数会由 import 语句唤起。 它可以被替换 (通过导入 builtins 模块并赋值给\nbuiltins.__import__) 以便修改 import 语句的语义，但是 强烈 不建议这样做，因为使用导\n入钩子 (参见 PEP 302) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都\n会假定所用的是默认实现。 同样也不建议直接使用 __import__() 而应该用\nimportlib.import_module()。\n本函数会导入模块 name，利用 globals 和 locals 来决定如何在包的上下文中解释该名称。\nfromlist 给出了应从 name 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到\nlocals 参数，只用到了 globals 用于确定 import 语句所在的包上下文。\nlevel 指定是使用绝对还是相对导入。 0 (默认值) 意味着仅执行绝对导入。 level 为正数值表示\n相对于模块调用 __import__() 的目录，将要搜索的父目录层数 (详情参见 PEP 328)。\n当 name 变量的形式为 package.module 时，通常将会返回最高层级的包（第一个点号之前的\n名称），而 不是 以 name 命名的模块。 但是，当给出了非空的 fromlist 参数时，则将返回以\nname 命名的模块。\n例如，语句 import spam 的结果将为与以下代码作用相同的字节码:\nspam = __import__('spam', globals(), locals(), [], 0)\n语句 import spam.ham 的结果将为以下调用: |  |\n| --- | --- | --- |\n\nspam = __import__('spam.ham', globals(), locals(), [], 0)\n请注意在这里 __import__() 是如何返回顶层模块的，因为这是通过 import 语句被绑定到特\n定名称的对象。\n另一方面，语句 from spam.ham import eggs, sausage as saus 的结果将为\n_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\neggs = _temp.eggs\nsaus = _temp.sausage\n在这里， spam.ham 模块会由 __import__() 返回。 要导入的对象将从此对象中提取并赋值给\n它们对应的名称。\n如果您只想按名称导入模块（可能在包中），请使用 importlib.import_module()\n在 3.3 版本发生变更: level 的值不再支持负数（默认值也修改为0）。\n在 3.9 版本发生变更: 当使用了命令行参数 -E 或 -I 时，环境变量 PYTHONCASEOK 现在将\n被忽略。\n备注\n[1] 解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换\nWindows 或 Mac 风格的换行符。\n\n| spam = __import__('spam.ham', globals(), locals(), [], 0)\n请注意在这里 __import__() 是如何返回顶层模块的，因为这是通过 import 语句被绑定到特\n定名称的对象。\n另一方面，语句 from spam.ham import eggs, sausage as saus 的结果将为\n_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\neggs = _temp.eggs\nsaus = _temp.sausage\n在这里， spam.ham 模块会由 __import__() 返回。 要导入的对象将从此对象中提取并赋值给\n它们对应的名称。\n如果您只想按名称导入模块（可能在包中），请使用 importlib.import_module()\n在 3.3 版本发生变更: level 的值不再支持负数（默认值也修改为0）。\n在 3.9 版本发生变更: 当使用了命令行参数 -E 或 -I 时，环境变量 PYTHONCASEOK 现在将\n被忽略。\n备注\n[1] 解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换\nWindows 或 Mac 风格的换行符。 | spam = __import__('spam.ham', globals(), locals(), [], 0) |\n| --- | --- |", "metadata": {"title": "00_内置函数", "source": "md_docs\\python_library_md\\00_内置函数.md", "doc_type": "标准库", "language": "中文", "doc_id": "55d36831"}}
{"doc_id": "5d78b690", "content": "内置常量\n有少数的常量存在于内置命名空间中。 它们是：\nFalse\nbool 类型的假值。 给 False 赋值是非法的并会引发 SyntaxError。\nTrue\nbool 类型的真值。 给 True 赋值是非法的并会引发 SyntaxError。\nNone\n通常被用来代表空值的对象，例如未向某个函数传入默认参数时。 向 None 赋值是非法的并会\n引发 SyntaxError。 None 是 NoneType 类型的唯一实例。\nNotImplemented\n一个应当由双目运算特殊方法（如 __eq__(), __lt__(), __add__(), __rsub__() 等）返回的\n特殊值，用来表明该运算没有针对其他类型的实现；也可由原地双目运算特殊方法（如\n__imul__(), __iand__() 等）出于同样的目的而返回。 它不应在布尔上下文中被求值。\nNotImplemented 是 types.NotImplementedType 类型的唯一实例。\n备注: 当一个双目（或原地）方法返回 NotImplemented 时解释器将尝试对另一种类型（或\n其他回退操作，具体取决于所用的运算符）的反射操作。 如果所有尝试都返回\nNotImplemented，解释器将引发适当的异常。 错误地返回 NotImplemented 将导致误导性\n的错误消息或 NotImplemented 值被返回给 Python 代码。\n参见 实现算术运算 为例。\n小心: NotImplemented 和 NotImplementedError 不能互相替代。 此常量应当仅以上文所\n描述的方式使用；请参阅 NotImplementedError 了解正确使用该异常的相关细节。\n在 3.9 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值的做法已被弃用。\n在 3.14 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值现在会引发\nTypeError。 在之前版本中它会被求值为 True 并将自 Python 3.9 起发出\nDeprecationWarning。\nEllipsis\n与省略号字面值 \"...\" 相同，这是一个常用于表示省略内容的对象。可以对 Ellipsis 进行赋\n值，但对 ... 进行赋值会引发 SyntaxError。Ellipsis 是 types.EllipsisType 类型的唯一\n实例。\n__debug__\n如果 Python 没有以 -O 选项启动，则此常量为真值。 另请参见 assert 语句。\n\n备注: 变量名 None，False，True 和 __ debug__ 无法重新赋值（赋值给它们，即使是属性\n名，将引发 SyntaxError ），所以它们可以被认为是“真正的”常数。\n由 site 模块添加的常量\nsite 模块（在启动期间自动导入，除非给出 -S 命令行选项）将几个常量添加到内置命名空间。 它\n们对交互式解释器 shell 很有用，并且不应在程序中使用。\nquit(code=None)\nexit(code=None)\n当对象被打印时，会打印一条消息如 \"Use quit() or Ctrl-D (i.e. EOF) to exit\"，当在交互解释器中\n直接访问或作为函数调用时，将引发 SystemExit 并附带指定的退出码。\nhelp\n该对象在打印时会输出提示信息：\"输入 help() 可获取交互式帮助，或输入 help(object) 查看特\n定对象的帮助信息\"；当在交互式解释器中直接访问该对象时，则会调用内置的帮助系统（参见\nhelp() 函数）。\ncopyright\ncredits\n打印或调用的对象分别打印版权或作者的文本。\nlicense\n当打印此对象时，会打印出一条消息“Type license() to see the full license text”，当调用此对象\n时，将以分页形式显示完整的许可证文本（每次显示一屏）。\n\n| 备注: 变量名 None，False，True 和 __ debug__ 无法重新赋值（赋值给它们，即使是属性\n名，将引发 SyntaxError ），所以它们可以被认为是“真正的”常数。 |\n| --- |\n| 由 site 模块添加的常量\nsite 模块（在启动期间自动导入，除非给出 -S 命令行选项）将几个常量添加到内置命名空间。 它\n们对交互式解释器 shell 很有用，并且不应在程序中使用。\nquit(code=None)\nexit(code=None)\n当对象被打印时，会打印一条消息如 \"Use quit() or Ctrl-D (i.e. EOF) to exit\"，当在交互解释器中\n直接访问或作为函数调用时，将引发 SystemExit 并附带指定的退出码。\nhelp\n该对象在打印时会输出提示信息：\"输入 help() 可获取交互式帮助，或输入 help(object) 查看特\n定对象的帮助信息\"；当在交互式解释器中直接访问该对象时，则会调用内置的帮助系统（参见\nhelp() 函数）。\ncopyright\ncredits\n打印或调用的对象分别打印版权或作者的文本。\nlicense\n当打印此对象时，会打印出一条消息“Type license() to see the full license text”，当调用此对象\n时，将以分页形式显示完整的许可证文本（每次显示一屏）。 |", "metadata": {"title": "00_内置常量", "source": "md_docs\\python_library_md\\00_内置常量.md", "doc_type": "标准库", "language": "中文", "doc_id": "5d78b690"}}
{"doc_id": "780a77e0", "content": "内置异常\n在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。 在带有提及一个特定类的\nexcept 子句的 try 语句中，该子句也会处理任何派生自该类的异常类（但不处理 它 所派生出的异\n常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。\n本章中列出的内置异常可由解释器或内置函数来生成。 除非另有说明，它们都会具有一个提示导致\n错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释该错\n误码的字符串）。 关联值通常会作为参数被传给异常类的构造器。\n用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发\n了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。\n内置异常类可以被子类化以定义新的异常；鼓励程序员从 Exception 类或它的某个子类而不是从\nBaseException 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 用户自定义异常\n部分查看。\n异常上下文\n异常对象上的三个属性提供了有关引发异常所在上下文的信息：\nBaseException.__context__\nBaseException.__cause__\nBaseException.__suppress_context__\n当有其他异常已经被处理的情况下又引发一个新异常的时候，新异常的 __context__ 属性会被\n自动设为已经被处理的异常。 异常可以在使用了 except 或 finally 子句，或者 with 语句的\n时候被处理。\n这个隐式异常上下文可以通过使用 from 配合 raise 来补充一个显式的原因:\nraise new_exc from original_exc\n跟在 from 之后的表达式必须为一个异常或 None。 它将在所引发的异常上被设为\n__cause__。 设置 __cause__ 还会隐式地将 __suppress_context__ 属性设为 True，这样使\n用 raise new_exc from None 可以有效地将旧异常替换为新异常来显示其目的 (例如将\nKeyError 转换为 AttributeError)，同时让旧异常在 __context__ 中保持可用以便在调试时\n执行内省。\n除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 __cause__ 中的显式串连异\n常如果存在将总是显示。 __context__ 中的隐式串连异常仅在 __cause__ 为 None 且\n__suppress_context__ 为假值时显示。\n不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所\n引发的最后一个异常。\n\n从内置异常继承\n用户代码可以创建继承自某个异常类型的子类。 建议每次仅子类化一个异常类型以避免多个基类处\n理 args 属性的不同方式，以及内存布局不兼容可能导致的冲突。\n大多数内置异常都用 C 实现以保证运行效率，参见: Objects/exceptions.c。 其中一些具有自定义内\n存布局，这使得创建继承自多个异常类型的子类成为不可能。 一个类型的内存布局属于实现细节并\n可能随着 Python 版本升级而改变，导致在未来可能产生新的冲突。 因此，建议完全避免子类化多\n个异常类型。\n基类\n下列异常主要被用作其他异常的基类。\nexception BaseException\n所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 Exception)。 如果\n在此类的实例上调用 str()，则会返回实例的参数表示，或者当没有参数时返回空字符串。\nargs\n传给异常构造器的参数元组。 某些内置异常 (例如 OSError) 接受特定数量的参数并赋予此\n元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。\nwith_traceback(tb)\n此方法会将 tb 设为新的异常回溯信息并返回异常对象。 它在 PEP 3134 的异常链特性可\n用之前更为常用。 下面的例子演示了我们如何将一个 SomeException 实例转换为\nOtherException 实例而保留回溯信息。 异常一旦被引发，当前帧会被推至\nOtherException 的回溯栈顶端，就像当我们允许原始 SomeException 被传播给调用方时\n它的回溯栈将会发生的情形一样。:\ntry:\n...\nexcept SomeException:\ntb = sys.exception().__traceback__\nraise OtherException(...).with_traceback(tb)\n__traceback__\n保存关联到该异常的 回溯对象 的可写字段。 另请参阅: raise 语句。\nadd_note(note)\n将字符串 note 添加到在异常字符串之后的标准回溯中显示的注释中。 如果 note 不是一\n个字符串则会引发 TypeError。\nAdded in version 3.11.\n__notes__\n\n|  | 从内置异常继承\n用户代码可以创建继承自某个异常类型的子类。 建议每次仅子类化一个异常类型以避免多个基类处\n理 args 属性的不同方式，以及内存布局不兼容可能导致的冲突。\n大多数内置异常都用 C 实现以保证运行效率，参见: Objects/exceptions.c。 其中一些具有自定义内\n存布局，这使得创建继承自多个异常类型的子类成为不可能。 一个类型的内存布局属于实现细节并\n可能随着 Python 版本升级而改变，导致在未来可能产生新的冲突。 因此，建议完全避免子类化多\n个异常类型。\n基类\n下列异常主要被用作其他异常的基类。\nexception BaseException\n所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 Exception)。 如果\n在此类的实例上调用 str()，则会返回实例的参数表示，或者当没有参数时返回空字符串。\nargs\n传给异常构造器的参数元组。 某些内置异常 (例如 OSError) 接受特定数量的参数并赋予此\n元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。\nwith_traceback(tb)\n此方法会将 tb 设为新的异常回溯信息并返回异常对象。 它在 PEP 3134 的异常链特性可\n用之前更为常用。 下面的例子演示了我们如何将一个 SomeException 实例转换为\nOtherException 实例而保留回溯信息。 异常一旦被引发，当前帧会被推至\nOtherException 的回溯栈顶端，就像当我们允许原始 SomeException 被传播给调用方时\n它的回溯栈将会发生的情形一样。:\ntry:\n...\nexcept SomeException:\ntb = sys.exception().__traceback__\nraise OtherException(...).with_traceback(tb)\n__traceback__\n保存关联到该异常的 回溯对象 的可写字段。 另请参阅: raise 语句。\nadd_note(note)\n将字符串 note 添加到在异常字符串之后的标准回溯中显示的注释中。 如果 note 不是一\n个字符串则会引发 TypeError。\nAdded in version 3.11.\n__notes__ |  |\n| --- | --- | --- |\n\n由此异常的注释组成的列表，它是通过 add_note() 添加的。 该属性是在调用\nadd_note() 时创建的。\nAdded in version 3.11.\nexception Exception\n所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。\nexception ArithmeticError\n此基类用于派生针对各种算术类错误而引发的内置异常: OverflowError, ZeroDivisionError,\nFloatingPointError。\nexception BufferError\n当与 缓冲区 相关的操作无法执行时将被引发。\nexception LookupError\n此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: IndexError, KeyError。\n这可以通过 codecs.lookup() 来直接引发。\n具体异常\n以下异常属于经常被引发的异常。\nexception AssertionError\n当 assert 语句失败时将被引发。\nexception AttributeError\n当属性引用 (参见 属性引用) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性\n赋值时则将引发 TypeError。）\n可选的 name 和 obj 仅限关键字参数设置相应的属性：\nname\n尝试访问的属性的名称。\nobj\n针对指定属性被访问的对象。\n在 3.10 版本发生变更: 增加了 name 和 obj 属性。\nexception EOFError\n当 input() 函数未读取任何数据即达到文件结束条件（EOF）时被引发。 （注意:\nio.IOBase.read() 和 io.IOBase.readline() 方法在遇到 EOF 时将返回一个空字符串。）\nexception FloatingPointError\n目前未被使用。\nexception GeneratorExit\n\n|  | 由此异常的注释组成的列表，它是通过 add_note() 添加的。 该属性是在调用\nadd_note() 时创建的。\nAdded in version 3.11.\nexception Exception\n所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。\nexception ArithmeticError\n此基类用于派生针对各种算术类错误而引发的内置异常: OverflowError, ZeroDivisionError,\nFloatingPointError。\nexception BufferError\n当与 缓冲区 相关的操作无法执行时将被引发。\nexception LookupError\n此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: IndexError, KeyError。\n这可以通过 codecs.lookup() 来直接引发。\n具体异常\n以下异常属于经常被引发的异常。\nexception AssertionError\n当 assert 语句失败时将被引发。\nexception AttributeError\n当属性引用 (参见 属性引用) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性\n赋值时则将引发 TypeError。）\n可选的 name 和 obj 仅限关键字参数设置相应的属性：\nname\n尝试访问的属性的名称。\nobj\n针对指定属性被访问的对象。\n在 3.10 版本发生变更: 增加了 name 和 obj 属性。\nexception EOFError\n当 input() 函数未读取任何数据即达到文件结束条件（EOF）时被引发。 （注意:\nio.IOBase.read() 和 io.IOBase.readline() 方法在遇到 EOF 时将返回一个空字符串。）\nexception FloatingPointError\n目前未被使用。\nexception GeneratorExit |  |\n| --- | --- | --- |\n\n当一个 generator 或 coroutine 被关闭时将被引发；参见 generator.close() 和\ncoroutine.close()。 它直接继承自 BaseException 而不是 Exception，因为从技术上来说\n它并不是一个错误。\nexception ImportError\n当 import 语句尝试加载模块遇到麻烦时将被引发。 并且当 from ... import 中的 \"from list\"\n存在无法找到的名称时也会被引发。\n可选的 name 和 path 仅限关键字参数设置相应的属性：\nname\n尝试导入的模块的名称。\npath\n指向任何触发异常的文件的路径。\n在 3.3 版本发生变更: 添加了 name 与 path 属性。\nexception ModuleNotFoundError\nImportError 的子类，当一个模块无法被定位时将由 import 引发。 当在 sys.modules 中找\n到 None 时也会被引发。\nAdded in version 3.6.\nexception IndexError\n当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是\n整数则 TypeError 会被引发。）\nexception KeyError\n当在现有键集合中找不到指定的映射（字典）键时将被引发。\nexception KeyboardInterrupt\n当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信\n号。 该异常继承自 BaseException 以确保不会被处理 Exception 的代码意外捕获，这样可以\n避免退出解释器。\n备注: 捕获 KeyboardInterrupt 需要特别考虑。 因为它可能会在不可预知的点位被引发，\n在某些情况下，它可能使运行中的程序陷入不一致的状态。 通常最好是让\nKeyboardInterrupt 尽快结束程序或者完全避免引发它。 (参见 有关信号处理器和异常的注\n释。)\nexception MemoryError\n当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个\n字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的\nmalloc() 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异\n常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。\n\n|  | 当一个 generator 或 coroutine 被关闭时将被引发；参见 generator.close() 和\ncoroutine.close()。 它直接继承自 BaseException 而不是 Exception，因为从技术上来说\n它并不是一个错误。\nexception ImportError\n当 import 语句尝试加载模块遇到麻烦时将被引发。 并且当 from ... import 中的 \"from list\"\n存在无法找到的名称时也会被引发。\n可选的 name 和 path 仅限关键字参数设置相应的属性：\nname\n尝试导入的模块的名称。\npath\n指向任何触发异常的文件的路径。\n在 3.3 版本发生变更: 添加了 name 与 path 属性。\nexception ModuleNotFoundError\nImportError 的子类，当一个模块无法被定位时将由 import 引发。 当在 sys.modules 中找\n到 None 时也会被引发。\nAdded in version 3.6.\nexception IndexError\n当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是\n整数则 TypeError 会被引发。）\nexception KeyError\n当在现有键集合中找不到指定的映射（字典）键时将被引发。\nexception KeyboardInterrupt\n当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信\n号。 该异常继承自 BaseException 以确保不会被处理 Exception 的代码意外捕获，这样可以\n避免退出解释器。\n备注: 捕获 KeyboardInterrupt 需要特别考虑。 因为它可能会在不可预知的点位被引发，\n在某些情况下，它可能使运行中的程序陷入不一致的状态。 通常最好是让\nKeyboardInterrupt 尽快结束程序或者完全避免引发它。 (参见 有关信号处理器和异常的注\n释。)\nexception MemoryError\n当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个\n字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的\nmalloc() 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异\n常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。 |  |\n| --- | --- | --- |\n\nexception NameError\n当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信\n息，其中包含未找到的名称。\n可选的 name 仅限关键字参数设置该属性：\nname\n尝试访问的变量的名称。\n在 3.10 版本发生变更: 增加了 name 属性。\nexception NotImplementedError\n此异常派生自 RuntimeError。 在用户自定义的基类中，抽象方法应当在其要求所派生类重写\n该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。\n备注: 它不应当用来表示一个运算符或方法根本不能被支持 -- 在此情况下应当让特定运算\n符 / 方法保持未定义，或者在子类中将其设为 None。\n小心: NotImplementedError 和 NotImplemented 不能互相替代。 此异常应当仅以上文所\n描述的方式使用；请参阅 NotImplemented 了解正确使用该内置常量的相关细节。\nexception OSError([arg])\nexception OSError(errno, strerror[, filename[, winerror[, filename2]]])\n此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 \"文件\n未找到\" 或 \"磁盘已满\" 等（不包括非法参数类型或其他偶然性错误）。\n构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 None。 为了\n能向下兼容，如果传入了三个参数，则 args 属性将仅包含由前两个构造器参数组成的 2 元\n组。\n构造器实际返回的往往是 OSError 的某个子类，如下文 OS exceptions 中所描述的。 具体的子\n类取决于最终的 errno 值。 此行为仅在直接或通过别名来构造 OSError 时发生，并且在子类\n化时不会被继承。\nerrno\n来自于 C 变量 errno 的数字错误码。\nwinerror\n在 Windows 下，此参数将给出原生的 Windows 错误码。 而 errno 属性将是该原生错误\n码在 POSIX 平台下的近似转换形式。\n在 Windows 下，如果 winerror 构造器参数是一个整数，则 errno 属性会根据 Windows\n错误码来确定，而 errno 参数会被忽略。 在其他平台上，winerror 参数会被忽略，并且\nwinerror 属性将不存在。\nstrerror\n\n|  | exception NameError\n当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信\n息，其中包含未找到的名称。\n可选的 name 仅限关键字参数设置该属性：\nname\n尝试访问的变量的名称。\n在 3.10 版本发生变更: 增加了 name 属性。\nexception NotImplementedError\n此异常派生自 RuntimeError。 在用户自定义的基类中，抽象方法应当在其要求所派生类重写\n该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。\n备注: 它不应当用来表示一个运算符或方法根本不能被支持 -- 在此情况下应当让特定运算\n符 / 方法保持未定义，或者在子类中将其设为 None。\n小心: NotImplementedError 和 NotImplemented 不能互相替代。 此异常应当仅以上文所\n描述的方式使用；请参阅 NotImplemented 了解正确使用该内置常量的相关细节。\nexception OSError([arg])\nexception OSError(errno, strerror[, filename[, winerror[, filename2]]])\n此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 \"文件\n未找到\" 或 \"磁盘已满\" 等（不包括非法参数类型或其他偶然性错误）。\n构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 None。 为了\n能向下兼容，如果传入了三个参数，则 args 属性将仅包含由前两个构造器参数组成的 2 元\n组。\n构造器实际返回的往往是 OSError 的某个子类，如下文 OS exceptions 中所描述的。 具体的子\n类取决于最终的 errno 值。 此行为仅在直接或通过别名来构造 OSError 时发生，并且在子类\n化时不会被继承。\nerrno\n来自于 C 变量 errno 的数字错误码。\nwinerror\n在 Windows 下，此参数将给出原生的 Windows 错误码。 而 errno 属性将是该原生错误\n码在 POSIX 平台下的近似转换形式。\n在 Windows 下，如果 winerror 构造器参数是一个整数，则 errno 属性会根据 Windows\n错误码来确定，而 errno 参数会被忽略。 在其他平台上，winerror 参数会被忽略，并且\nwinerror 属性将不存在。\nstrerror |  |\n| --- | --- | --- |\n\n由操作系统提供的相应错误消息。 它在 POSIX 平台上由 C 函数 perror() 进行格式化，\n而在 Windows 下则是由 FormatMessage() 进行。\nfilename\nfilename2\n对于与文件系统路径有关 (例如 open() 或 os.unlink()) 的异常，filename 是传给函数\n的文件名。 对于涉及两个文件系统路径的函数 (例如 os.rename())，filename2 将是传\n给函数的第二个文件名。\n在 3.3 版本发生变更: EnvironmentError, IOError, WindowsError, socket.error,\nselect.error 和 mmap.error 已并合并到 OSError，而构造器可能返回一个子类。\n在 3.4 版本发生变更: filename 属性现在是传给函数的原始文件名，而不是基于\nfilesystem encoding and error handler 进行编码或解码之后的名称。 此外，还添加了\nfilename2 构造器参数和属性。\nexception OverflowError\n当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发\nMemoryError 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下\n引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检\n查。\nexception PythonFinalizationError\n该异常派生自 RuntimeError。 它会在解释器关闭或称 Python 终结化 期间当有操作被阻止时\n被引发。\n在 Python 终结化期间操作被阻止并引发 PythonFinalizationError 的例子：\n新建一个 Python 线程。\n并入 一个正在运行的守护线程。\nos.fork()。\n另请参阅 sys.is_finalizing() 函数。\nAdded in version 3.13: 在此之前将只引发 RuntimeError。\n在 3.14 版本发生变更: 现在 threading.Thread.join() 可以引发该异常。\nexception RecursionError\n此异常派生自 RuntimeError。 它会在解释器检测发现超过最大递归深度 (参见\nsys.getrecursionlimit()) 时被引发。\nAdded in version 3.5: 在此之前将只引发 RuntimeError。\nexception ReferenceError\n此异常将在使用 weakref.proxy() 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收\n的属性时被引发。 有关弱引用的更多信息请参阅 weakref 模块。\n\n|  | 由操作系统提供的相应错误消息。 它在 POSIX 平台上由 C 函数 perror() 进行格式化，\n而在 Windows 下则是由 FormatMessage() 进行。\nfilename\nfilename2\n对于与文件系统路径有关 (例如 open() 或 os.unlink()) 的异常，filename 是传给函数\n的文件名。 对于涉及两个文件系统路径的函数 (例如 os.rename())，filename2 将是传\n给函数的第二个文件名。\n在 3.3 版本发生变更: EnvironmentError, IOError, WindowsError, socket.error,\nselect.error 和 mmap.error 已并合并到 OSError，而构造器可能返回一个子类。\n在 3.4 版本发生变更: filename 属性现在是传给函数的原始文件名，而不是基于\nfilesystem encoding and error handler 进行编码或解码之后的名称。 此外，还添加了\nfilename2 构造器参数和属性。\nexception OverflowError\n当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发\nMemoryError 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下\n引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检\n查。\nexception PythonFinalizationError\n该异常派生自 RuntimeError。 它会在解释器关闭或称 Python 终结化 期间当有操作被阻止时\n被引发。\n在 Python 终结化期间操作被阻止并引发 PythonFinalizationError 的例子：\n新建一个 Python 线程。\n并入 一个正在运行的守护线程。\nos.fork()。\n另请参阅 sys.is_finalizing() 函数。\nAdded in version 3.13: 在此之前将只引发 RuntimeError。\n在 3.14 版本发生变更: 现在 threading.Thread.join() 可以引发该异常。\nexception RecursionError\n此异常派生自 RuntimeError。 它会在解释器检测发现超过最大递归深度 (参见\nsys.getrecursionlimit()) 时被引发。\nAdded in version 3.5: 在此之前将只引发 RuntimeError。\nexception ReferenceError\n此异常将在使用 weakref.proxy() 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收\n的属性时被引发。 有关弱引用的更多信息请参阅 weakref 模块。 |  |\n| --- | --- | --- |\n\nexception RuntimeError\n当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么\n问题的字符串。\nexception StopIteration\n由内置函数 next() 和 iterator 的 __next__() 方法所引发，用来表示该迭代器不能产生下一\n项。\nvalue\n该异常对象只有一个属性 value，它在构造该异常时作为参数给出，默认值为 None。\n当一个 generator 或 coroutine 函数返回时，将引发一个新的 StopIteration 实例，函数返回\n的值将被用作异常构造器的 value 形参。\n如果某个生成器代码直接或间接地引发了 StopIteration，它会被转换为 RuntimeError (并将\nStopIteration 保留为导致新异常的原因)。\n在 3.3 版本发生变更: 添加了 value 属性及其被生成器函数用作返回值的功能。\n在 3.5 版本发生变更: 引入了通过 from __future__ import generator_stop 来实现\nRuntimeError 转换，参见 PEP 479。\n在 3.7 版本发生变更: 默认对所有代码启用 PEP 479: 在生成器中引发的 StopIteration\n错误将被转换为 RuntimeError。\nexception StopAsyncIteration\n必须由一个 asynchronous iterator 对象的 __anext__() 方法来引发以停止迭代操作。\nAdded in version 3.5.\nexception SyntaxError(message, details)\n当解析器遇到语法错误时引发。 这可以发生在 import 语句，对内置函数 compile(), exec()\n或 eval() 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。\n异常实例的 str() 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获\n取。\nfilename\n发生语法错误所在文件的名称。\nlineno\n发生错误所在文件中的行号。 行号索引从 1 开始：文件中首行的 lineno 为 1。\noffset\n发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 offset 为 1。\ntext\n\n|  | exception RuntimeError\n当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么\n问题的字符串。\nexception StopIteration\n由内置函数 next() 和 iterator 的 __next__() 方法所引发，用来表示该迭代器不能产生下一\n项。\nvalue\n该异常对象只有一个属性 value，它在构造该异常时作为参数给出，默认值为 None。\n当一个 generator 或 coroutine 函数返回时，将引发一个新的 StopIteration 实例，函数返回\n的值将被用作异常构造器的 value 形参。\n如果某个生成器代码直接或间接地引发了 StopIteration，它会被转换为 RuntimeError (并将\nStopIteration 保留为导致新异常的原因)。\n在 3.3 版本发生变更: 添加了 value 属性及其被生成器函数用作返回值的功能。\n在 3.5 版本发生变更: 引入了通过 from __future__ import generator_stop 来实现\nRuntimeError 转换，参见 PEP 479。\n在 3.7 版本发生变更: 默认对所有代码启用 PEP 479: 在生成器中引发的 StopIteration\n错误将被转换为 RuntimeError。\nexception StopAsyncIteration\n必须由一个 asynchronous iterator 对象的 __anext__() 方法来引发以停止迭代操作。\nAdded in version 3.5.\nexception SyntaxError(message, details)\n当解析器遇到语法错误时引发。 这可以发生在 import 语句，对内置函数 compile(), exec()\n或 eval() 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。\n异常实例的 str() 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获\n取。\nfilename\n发生语法错误所在文件的名称。\nlineno\n发生错误所在文件中的行号。 行号索引从 1 开始：文件中首行的 lineno 为 1。\noffset\n发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 offset 为 1。\ntext |  |\n| --- | --- | --- |\n\n错误所涉及的源代码文本。\nend_lineno\n发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 lineno 为 1。\nend_offset\n发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 offset 为 1。\n对于 f-字符串字段中的错误，消息会带有 \"f-string: \" 前缀并且其位置是基于替换表达式构建的\n文本中的位置。 例如，编译 f'Bad {a b} field' 将产生这样的 args 属性: ('f-string: ...', ('', 1, 2, '(a\nb)n', 1, 5))。\n在 3.10 版本发生变更: 增加了 end_lineno 和 end_offset 属性。\nexception IndentationError\n与不正确的缩进相关的语法错误的基类。 这是 SyntaxError 的一个子类。\nexception TabError\n当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 IndentationError 的一个子\n类。\nexception SystemError\n当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一\n个指明发生了什么问题的字符串（使用低层级的表示形式）。 在 CPython 中，这可能会因不正\n确地使用 Python 的 C API 而引发，例如返回 NULL 值而不设置一个异常。\n如果你确信此异常不是你的问题，或你所使用的软件包的问题，你应当将此问题报告给你所用\nPython 解释器的作者或维护者。 请确保报告 Python 解释器的版本 (sys.version；它也会在\n交互式 Python 会话开始时被打印出来)，具体的错误消息 (异常所关联的值) 以及可能触发该错\n误的程序的源代码。\nexception SystemExit\n此异常由 sys.exit() 函数引发。 它继承自 BaseException 而不是 Exception 这样它就不会\n被捕获 Exception 的代码所意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 当\n它未被处理时，Python 解释器将会退出；不会有栈回溯信息被打印。 构造器接受与传给\nsys.exit() 的相同的参数。 如果参数值是一个整数，它表示系统退出状态（将被传给 C 的\nexit() 函数）；如果是 None，则退出状态值为零；如果它具有其他类型（如字符串），对象\n的值将被打印而退出状态值为一。\n对 sys.exit() 的调用会被转换为一个异常以便能执行清理处理程序 (try 语句的 finally 子\n句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退\n出（例如在调用 os.fork() 之后的子进程中）则可使用 os._exit().\ncode\n传给构造器的退出状态码或错误信息（默认为 None。）\nexception TypeError\n\n|  | 错误所涉及的源代码文本。\nend_lineno\n发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 lineno 为 1。\nend_offset\n发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 offset 为 1。\n对于 f-字符串字段中的错误，消息会带有 \"f-string: \" 前缀并且其位置是基于替换表达式构建的\n文本中的位置。 例如，编译 f'Bad {a b} field' 将产生这样的 args 属性: ('f-string: ...', ('', 1, 2, '(a\nb)n', 1, 5))。\n在 3.10 版本发生变更: 增加了 end_lineno 和 end_offset 属性。\nexception IndentationError\n与不正确的缩进相关的语法错误的基类。 这是 SyntaxError 的一个子类。\nexception TabError\n当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 IndentationError 的一个子\n类。\nexception SystemError\n当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一\n个指明发生了什么问题的字符串（使用低层级的表示形式）。 在 CPython 中，这可能会因不正\n确地使用 Python 的 C API 而引发，例如返回 NULL 值而不设置一个异常。\n如果你确信此异常不是你的问题，或你所使用的软件包的问题，你应当将此问题报告给你所用\nPython 解释器的作者或维护者。 请确保报告 Python 解释器的版本 (sys.version；它也会在\n交互式 Python 会话开始时被打印出来)，具体的错误消息 (异常所关联的值) 以及可能触发该错\n误的程序的源代码。\nexception SystemExit\n此异常由 sys.exit() 函数引发。 它继承自 BaseException 而不是 Exception 这样它就不会\n被捕获 Exception 的代码所意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 当\n它未被处理时，Python 解释器将会退出；不会有栈回溯信息被打印。 构造器接受与传给\nsys.exit() 的相同的参数。 如果参数值是一个整数，它表示系统退出状态（将被传给 C 的\nexit() 函数）；如果是 None，则退出状态值为零；如果它具有其他类型（如字符串），对象\n的值将被打印而退出状态值为一。\n对 sys.exit() 的调用会被转换为一个异常以便能执行清理处理程序 (try 语句的 finally 子\n句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退\n出（例如在调用 os.fork() 之后的子进程中）则可使用 os._exit().\ncode\n传给构造器的退出状态码或错误信息（默认为 None。）\nexception TypeError |  |\n| --- | --- | --- |\n\n当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关\n类型不匹配的详情。\n此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如\n果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为\nNotImplementedError。\n传入参数的类型错误 (例如在要求 int 时却传入了 list) 应当导致 TypeError，但传入参数的\n值错误 (例如传入要求范围之外的数值) 则应当导致 ValueError。\nexception UnboundLocalError\n当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是\nNameError 的一个子类。\nexception UnicodeError\n当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 ValueError 的一个子类。\nUnicodeError 具有一些描述编码或解码错误的属性。 例如\nerr.object[err.start:err.end] 会给出导致编解码器失败的特定无效输入。\nencoding\n引发错误的编码名称。\nreason\n描述特定编解码器错误的字符串。\nobject\n编解码器试图要编码或解码的对象。\nstart\nobject 中无效数据的开始位置索引。\n该值将被解读为绝对偏移量所以它不应为负数但是该项约束不会在运行时强制执行。\nend\nobject 中无效数据的末尾位置索引（不含）。\n该值将被解读为绝对偏移量所以它不应为负数但是该项约束不会在运行时强制执行。\nexception UnicodeEncodeError\n当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子\n类。\nexception UnicodeDecodeError\n当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子\n类。\n\n|  | 当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关\n类型不匹配的详情。\n此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如\n果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为\nNotImplementedError。\n传入参数的类型错误 (例如在要求 int 时却传入了 list) 应当导致 TypeError，但传入参数的\n值错误 (例如传入要求范围之外的数值) 则应当导致 ValueError。\nexception UnboundLocalError\n当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是\nNameError 的一个子类。\nexception UnicodeError\n当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 ValueError 的一个子类。\nUnicodeError 具有一些描述编码或解码错误的属性。 例如\nerr.object[err.start:err.end] 会给出导致编解码器失败的特定无效输入。\nencoding\n引发错误的编码名称。\nreason\n描述特定编解码器错误的字符串。\nobject\n编解码器试图要编码或解码的对象。\nstart\nobject 中无效数据的开始位置索引。\n该值将被解读为绝对偏移量所以它不应为负数但是该项约束不会在运行时强制执行。\nend\nobject 中无效数据的末尾位置索引（不含）。\n该值将被解读为绝对偏移量所以它不应为负数但是该项约束不会在运行时强制执行。\nexception UnicodeEncodeError\n当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子\n类。\nexception UnicodeDecodeError\n当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子\n类。 |  |\n| --- | --- | --- |\n\nexception UnicodeTranslateError\n在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子类。\nexception ValueError\n当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如\nIndexError 来描述时将被引发。\nexception ZeroDivisionError\n当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算\n的类型。\n下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 OSError 的别名。\nexception EnvironmentError\nexception IOError\nexception WindowsError\n限在 Windows 中可用。\nOS 异常\n下列异常均为 OSError 的子类，它们将根据系统错误代码被引发。\nexception BlockingIOError\n当一个操作将在设置为非阻塞操作的对象（例如套接字）上发生阻塞时将被引发。 对应于\nerrno EAGAIN, EALREADY, EWOULDBLOCK 和 EINPROGRESS。\n除了 OSError 已有的属性，BlockingIOError 还有一个额外属性：\ncharacters_written\n一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 io 模块的带缓冲 I/O 类时\n此属性可用。\nexception ChildProcessError\n当一个子进程上的操作失败时将被引发。 对应于 errno ECHILD。\nexception ConnectionError\n与连接相关问题的基类。\n其子类有 BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError 和\nConnectionResetError。\nexception BrokenPipeError\nConnectionError 的子类，当试图写入一个管道而其另一端已关闭，或者试图写入一个套接字\n而其已关闭写入时将被引发。 对应于 errno EPIPE 和 ESHUTDOWN。\nexception ConnectionAbortedError\n\n|  | exception UnicodeTranslateError\n在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子类。\nexception ValueError\n当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如\nIndexError 来描述时将被引发。\nexception ZeroDivisionError\n当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算\n的类型。\n下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 OSError 的别名。\nexception EnvironmentError\nexception IOError\nexception WindowsError\n限在 Windows 中可用。\nOS 异常\n下列异常均为 OSError 的子类，它们将根据系统错误代码被引发。\nexception BlockingIOError\n当一个操作将在设置为非阻塞操作的对象（例如套接字）上发生阻塞时将被引发。 对应于\nerrno EAGAIN, EALREADY, EWOULDBLOCK 和 EINPROGRESS。\n除了 OSError 已有的属性，BlockingIOError 还有一个额外属性：\ncharacters_written\n一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 io 模块的带缓冲 I/O 类时\n此属性可用。\nexception ChildProcessError\n当一个子进程上的操作失败时将被引发。 对应于 errno ECHILD。\nexception ConnectionError\n与连接相关问题的基类。\n其子类有 BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError 和\nConnectionResetError。\nexception BrokenPipeError\nConnectionError 的子类，当试图写入一个管道而其另一端已关闭，或者试图写入一个套接字\n而其已关闭写入时将被引发。 对应于 errno EPIPE 和 ESHUTDOWN。\nexception ConnectionAbortedError |  |\n| --- | --- | --- |\n\nConnectionError 的子类，当一个连接尝试被对端中止时将被引发。 对应于 errno\nECONNABORTED。\nexception ConnectionRefusedError\nConnectionError 的子类，当一个连接尝试被对端拒绝时将被引发。 对应于 errno\nECONNREFUSED。\nexception ConnectionResetError\nConnectionError 的子类，当一个连接尝试被对端重置时将被引发。 对应于 errno\nECONNRESET。\nexception FileExistsError\n当试图创建一个已存在的文件或目录时将被引发。 对应于 errno EEXIST。\nexception FileNotFoundError\n当所请求的文件或目录不存在时将被引发。 对应于 errno ENOENT。\nexception InterruptedError\n当一个系统调用被传入的信号中断时将被引发。 对应于 errno EINTR。\n在 3.5 版本发生变更: 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非\n该信号的处理程序引发了其它异常 (原理参见 PEP 475) 而不是引发 InterruptedError。\nexception IsADirectoryError\n当请求对一个目录执行文件操作 (如 os.remove()) 时将被引发。 对应于 errno EISDIR。\nexception NotADirectoryError\n当请求对一个非目录执行目录操作 (如 os.listdir()) 时将被引发。 在大多数 POSIX 平台上，\n它还可能在某个操作试图将一个非目录作为目录打开或遍历时被引发。 对应于 errno\nENOTDIR。\nexception PermissionError\n当在没有足够访问权限的情况下试图运行某个操作时将被引发 —— 例如文件系统权限。 对应\n于 errno EACCES, EPERM 和 ENOTCAPABLE。\n在 3.11.1 版本发生变更: WASI 的 ENOTCAPABLE 现在被映射至 PermissionError。\nexception ProcessLookupError\n当给定的进程不存在时将被引发。 对应于 errno ESRCH。\nexception TimeoutError\n当一个系统函数在系统层级发生超时的情况下将被引发。 对应于 errno ETIMEDOUT。\nAdded in version 3.3: 添加了以上所有 OSError 的子类。\n参见: PEP 3151 - 重写 OS 和 IO 异常的层次结构\n警告\n\n|  | ConnectionError 的子类，当一个连接尝试被对端中止时将被引发。 对应于 errno\nECONNABORTED。\nexception ConnectionRefusedError\nConnectionError 的子类，当一个连接尝试被对端拒绝时将被引发。 对应于 errno\nECONNREFUSED。\nexception ConnectionResetError\nConnectionError 的子类，当一个连接尝试被对端重置时将被引发。 对应于 errno\nECONNRESET。\nexception FileExistsError\n当试图创建一个已存在的文件或目录时将被引发。 对应于 errno EEXIST。\nexception FileNotFoundError\n当所请求的文件或目录不存在时将被引发。 对应于 errno ENOENT。\nexception InterruptedError\n当一个系统调用被传入的信号中断时将被引发。 对应于 errno EINTR。\n在 3.5 版本发生变更: 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非\n该信号的处理程序引发了其它异常 (原理参见 PEP 475) 而不是引发 InterruptedError。\nexception IsADirectoryError\n当请求对一个目录执行文件操作 (如 os.remove()) 时将被引发。 对应于 errno EISDIR。\nexception NotADirectoryError\n当请求对一个非目录执行目录操作 (如 os.listdir()) 时将被引发。 在大多数 POSIX 平台上，\n它还可能在某个操作试图将一个非目录作为目录打开或遍历时被引发。 对应于 errno\nENOTDIR。\nexception PermissionError\n当在没有足够访问权限的情况下试图运行某个操作时将被引发 —— 例如文件系统权限。 对应\n于 errno EACCES, EPERM 和 ENOTCAPABLE。\n在 3.11.1 版本发生变更: WASI 的 ENOTCAPABLE 现在被映射至 PermissionError。\nexception ProcessLookupError\n当给定的进程不存在时将被引发。 对应于 errno ESRCH。\nexception TimeoutError\n当一个系统函数在系统层级发生超时的情况下将被引发。 对应于 errno ETIMEDOUT。\nAdded in version 3.3: 添加了以上所有 OSError 的子类。 |  |\n| --- | --- | --- |\n|  | 参见: PEP 3151 - 重写 OS 和 IO 异常的层次结构 |  |\n|  | 警告 |  |\n\n下列异常被用作警告类别；请参阅 警告类别 文档了解详情。\nexception Warning\n警告类别的基类。\nexception UserWarning\n用户代码所产生警告的基类。\nexception DeprecationWarning\n如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。\n会被默认警告过滤器忽略，在 __main__ 模块中的情况除外 (PEP 565)。 启用 Python 开发模式\n时会显示此警告。\n这个弃用政策是在 PEP 387 中描述的。\nexception PendingDeprecationWarning\n对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。\n这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃\n用则推荐使用 DeprecationWarning。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\n这个弃用政策是在 PEP 387 中描述的。\nexception SyntaxWarning\n与模糊的语法相关的警告的基类。\n该警告通常会在编译 Python 源代码时发出，而在运行已编译的代码时通常不会报告。\nexception RuntimeWarning\n与模糊的运行时行为相关的警告的基类。\nexception FutureWarning\n如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警\n告的基类。\nexception ImportWarning\n与在模块导入中可能的错误相关的警告的基类。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\nexception UnicodeWarning\n与 Unicode 相关的警告的基类。\nexception EncodingWarning\n与编码格式相关的警告的基类。\n请参阅 选择性的 EncodingWarning 来了解详情。\n\n|  | 下列异常被用作警告类别；请参阅 警告类别 文档了解详情。\nexception Warning\n警告类别的基类。\nexception UserWarning\n用户代码所产生警告的基类。\nexception DeprecationWarning\n如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。\n会被默认警告过滤器忽略，在 __main__ 模块中的情况除外 (PEP 565)。 启用 Python 开发模式\n时会显示此警告。\n这个弃用政策是在 PEP 387 中描述的。\nexception PendingDeprecationWarning\n对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。\n这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃\n用则推荐使用 DeprecationWarning。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\n这个弃用政策是在 PEP 387 中描述的。\nexception SyntaxWarning\n与模糊的语法相关的警告的基类。\n该警告通常会在编译 Python 源代码时发出，而在运行已编译的代码时通常不会报告。\nexception RuntimeWarning\n与模糊的运行时行为相关的警告的基类。\nexception FutureWarning\n如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警\n告的基类。\nexception ImportWarning\n与在模块导入中可能的错误相关的警告的基类。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\nexception UnicodeWarning\n与 Unicode 相关的警告的基类。\nexception EncodingWarning\n与编码格式相关的警告的基类。\n请参阅 选择性的 EncodingWarning 来了解详情。 |  |\n| --- | --- | --- |\n\nAdded in version 3.10.\nexception BytesWarning\n与 bytes 和 bytearray 相关的警告的基类。\nexception ResourceWarning\n资源使用相关警告的基类。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\nAdded in version 3.2.\n异常组\n下列异常是在有必要引发多个不相关联的异常时使用的。 它们是异常层级结构的一部分因此它们可\n以像所有其他异常一样通过 except 来处理。 此外，它们还可被 except* 所识别，此语法将基于所\n包含异常的类型来匹配其子分组。\nexception ExceptionGroup(msg, excs)\nexception BaseExceptionGroup(msg, excs)\n这两个异常类型都将多个异常包装在序列 excs 中。 msg 形参必须为一个字符串。 这两个类之\n间的区别在于 BaseExceptionGroup 扩展了 BaseException 并且它可以包装任何异常，而\nExceptionGroup 则扩展了 Exception 并且它只能包装 Exception 的子类。 这样的设计是为\n了使得 except Exception 只捕获 ExceptionGroup 而不捕获 BaseExceptionGroup。\nBaseExceptionGroup 构造器返回一个 ExceptionGroup 而不是 BaseExceptionGroup，如果\n所包含的全部异常都是 Exception 的实例的话，因此它可以被用来制造自动化的选择。 在另\n一方面，ExceptionGroup 构造器则会引发 TypeError，如果所包含的任何异常不是\nException 的子类的话。\nmessage\n传给构造器的 msg 参数。 这是一个只读属性。\nexceptions\n传给构造器的 excs 序列中的由异常组成的元组。 这是一个只读属性。\nsubgroup(condition)\n返回一个只包含来自当前组的匹配 condition 的异常的异常组，或者如果结果为空则返回\nNone。\n该条件可以是一个异常类型或由异常类型组成的元组，在后一种情况中将对每个异常使用\n在 except 子句中所使用的相同检测方式来检测是否匹配。 该条件也可以是一个可调用对\n象（而非类型对象），它接受一个异常作为其唯一参数并会针对应当属于特定子分组的异\n常返回真值。\n\n|  | Added in version 3.10.\nexception BytesWarning\n与 bytes 和 bytearray 相关的警告的基类。\nexception ResourceWarning\n资源使用相关警告的基类。\n会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。\nAdded in version 3.2.\n异常组\n下列异常是在有必要引发多个不相关联的异常时使用的。 它们是异常层级结构的一部分因此它们可\n以像所有其他异常一样通过 except 来处理。 此外，它们还可被 except* 所识别，此语法将基于所\n包含异常的类型来匹配其子分组。\nexception ExceptionGroup(msg, excs)\nexception BaseExceptionGroup(msg, excs)\n这两个异常类型都将多个异常包装在序列 excs 中。 msg 形参必须为一个字符串。 这两个类之\n间的区别在于 BaseExceptionGroup 扩展了 BaseException 并且它可以包装任何异常，而\nExceptionGroup 则扩展了 Exception 并且它只能包装 Exception 的子类。 这样的设计是为\n了使得 except Exception 只捕获 ExceptionGroup 而不捕获 BaseExceptionGroup。\nBaseExceptionGroup 构造器返回一个 ExceptionGroup 而不是 BaseExceptionGroup，如果\n所包含的全部异常都是 Exception 的实例的话，因此它可以被用来制造自动化的选择。 在另\n一方面，ExceptionGroup 构造器则会引发 TypeError，如果所包含的任何异常不是\nException 的子类的话。\nmessage\n传给构造器的 msg 参数。 这是一个只读属性。\nexceptions\n传给构造器的 excs 序列中的由异常组成的元组。 这是一个只读属性。\nsubgroup(condition)\n返回一个只包含来自当前组的匹配 condition 的异常的异常组，或者如果结果为空则返回\nNone。\n该条件可以是一个异常类型或由异常类型组成的元组，在后一种情况中将对每个异常使用\n在 except 子句中所使用的相同检测方式来检测是否匹配。 该条件也可以是一个可调用对\n象（而非类型对象），它接受一个异常作为其唯一参数并会针对应当属于特定子分组的异\n常返回真值。 |  |\n| --- | --- | --- |\n\n当前异常的嵌套结构会在结果中保留，就如其 message, __traceback__, __cause__,\n__context__ 和 __notes__ 字段的值一样。 空的嵌套组会在结果中被略去。\n条件检测会针对嵌套异常组中的所有异常执行，包括最高层级的和任何嵌套的异常组。 如\n果针对此类异常组的条件为真值，它将被完整包括在结果中。\nAdded in version 3.13: condition 可以是任意不为类型对象的可调用对象。\nsplit(condition)\n类似于 subgroup()，但将返回 (match, rest) 对，其中 match 为\nsubgroup(condition) 而 rest 为剩余的非匹配部分。\nderive(excs)\n返回一个具有相同 message 的异常组，但会将异常包装在 excs 中。\n此方法是由 subgroup() 和 split() 使用的，它们被用于在各种上下文中拆分异常组。\n子类需要重写它以便让 subgroup() 和 split() 返回子类的实例而不是\nExceptionGroup。\nsubgroup() 和 split() 会从原始异常组拷贝 __traceback__, __cause__, __context__\n和 __notes__ 字段到 derive() 所返回的异常组，这样这些字段就不需要被 derive() 更\n新。\n>>> class MyGroup(ExceptionGroup):\n... def derive(self, excs):\n... return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n... raise e\n... except Exception as e:\n... exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Excep\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'),\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'),\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue\n请注意 BaseExceptionGroup 定义了 __new__()，因此需要不同构造器签名的子类必须重写该\n方法而不是 __init__()。 例如，下面定义了一个接受 exit_code 并根据它来构造分组消息的异\n常组子类。\n\n|  | 当前异常的嵌套结构会在结果中保留，就如其 message, __traceback__, __cause__,\n__context__ 和 __notes__ 字段的值一样。 空的嵌套组会在结果中被略去。\n条件检测会针对嵌套异常组中的所有异常执行，包括最高层级的和任何嵌套的异常组。 如\n果针对此类异常组的条件为真值，它将被完整包括在结果中。\nAdded in version 3.13: condition 可以是任意不为类型对象的可调用对象。\nsplit(condition)\n类似于 subgroup()，但将返回 (match, rest) 对，其中 match 为\nsubgroup(condition) 而 rest 为剩余的非匹配部分。\nderive(excs)\n返回一个具有相同 message 的异常组，但会将异常包装在 excs 中。\n此方法是由 subgroup() 和 split() 使用的，它们被用于在各种上下文中拆分异常组。\n子类需要重写它以便让 subgroup() 和 split() 返回子类的实例而不是\nExceptionGroup。\nsubgroup() 和 split() 会从原始异常组拷贝 __traceback__, __cause__, __context__\n和 __notes__ 字段到 derive() 所返回的异常组，这样这些字段就不需要被 derive() 更\n新。\n>>> class MyGroup(ExceptionGroup):\n... def derive(self, excs):\n... return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n... raise e\n... except Exception as e:\n... exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Excep\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'),\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'),\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue\n请注意 BaseExceptionGroup 定义了 __new__()，因此需要不同构造器签名的子类必须重写该\n方法而不是 __init__()。 例如，下面定义了一个接受 exit_code 并根据它来构造分组消息的异\n常组子类。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | >>> class MyGroup(ExceptionGroup):\n... def derive(self, excs):\n... return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n... raise e\n... except Exception as e:\n... exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Excep\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'),\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'),\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue |  |  |\n|  |  |  |  |  |\n\nclass Errors(ExceptionGroup):\ndef __new__(cls, errors, exit_code):\nself = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\nself.exit_code = exit_code\nreturn self\ndef derive(self, excs):\nreturn Errors(excs, self.exit_code)\n类似于 ExceptionGroup，任何 BaseExceptionGroup 的子类也是 Exception 的子类，只能包\n装 Exception 的实例。\nAdded in version 3.11.\n异常层次结构\n内置异常的类层级结构如下：\nBaseException\n├── BaseExceptionGroup\n├── GeneratorExit\n├── KeyboardInterrupt\n├── SystemExit\n└── Exception\n├── ArithmeticError\n│ ├── FloatingPointError\n│ ├── OverflowError\n│ └── ZeroDivisionError\n├── AssertionError\n├── AttributeError\n├── BufferError\n├── EOFError\n├── ExceptionGroup [BaseExceptionGroup]\n├── ImportError\n│ └── ModuleNotFoundError\n├── LookupError\n│ ├── IndexError\n│ └── KeyError\n├── MemoryError\n├── NameError\n│ └── UnboundLocalError\n├── OSError\n│ ├── BlockingIOError\n│ ├── ChildProcessError\n│ ├── ConnectionError\n│ │ ├── BrokenPipeError\n│ │ ├── ConnectionAbortedError\n│ │ ├── ConnectionRefusedError\n│ │ └── ConnectionResetError\n│ ├── FileExistsError\n│ ├── FileNotFoundError\n│ ├── InterruptedError\n│ ├── IsADirectoryError\n│ ├── NotADirectoryError\n│ ├── PermissionError\n│ ├── ProcessLookupError\n│ └── TimeoutError\n\n|  | class Errors(ExceptionGroup):\ndef __new__(cls, errors, exit_code):\nself = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\nself.exit_code = exit_code\nreturn self\ndef derive(self, excs):\nreturn Errors(excs, self.exit_code)\n类似于 ExceptionGroup，任何 BaseExceptionGroup 的子类也是 Exception 的子类，只能包\n装 Exception 的实例。\nAdded in version 3.11.\n异常层次结构\n内置异常的类层级结构如下： | class Errors(ExceptionGroup):\ndef __new__(cls, errors, exit_code):\nself = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\nself.exit_code = exit_code\nreturn self\ndef derive(self, excs):\nreturn Errors(excs, self.exit_code) |  |\n| --- | --- | --- | --- |\n|  | BaseException\n├── BaseExceptionGroup\n├── GeneratorExit\n├── KeyboardInterrupt\n├── SystemExit\n└── Exception\n├── ArithmeticError\n│ ├── FloatingPointError\n│ ├── OverflowError\n│ └── ZeroDivisionError\n├── AssertionError\n├── AttributeError\n├── BufferError\n├── EOFError\n├── ExceptionGroup [BaseExceptionGroup]\n├── ImportError\n│ └── ModuleNotFoundError\n├── LookupError\n│ ├── IndexError\n│ └── KeyError\n├── MemoryError\n├── NameError\n│ └── UnboundLocalError\n├── OSError\n│ ├── BlockingIOError\n│ ├── ChildProcessError\n│ ├── ConnectionError\n│ │ ├── BrokenPipeError\n│ │ ├── ConnectionAbortedError\n│ │ ├── ConnectionRefusedError\n│ │ └── ConnectionResetError\n│ ├── FileExistsError\n│ ├── FileNotFoundError\n│ ├── InterruptedError\n│ ├── IsADirectoryError\n│ ├── NotADirectoryError\n│ ├── PermissionError\n│ ├── ProcessLookupError\n│ └── TimeoutError |  |  |\n\n├── ReferenceError\n├── RuntimeError\n│ ├── NotImplementedError\n│ ├── PythonFinalizationError\n│ └── RecursionError\n├── StopAsyncIteration\n├── StopIteration\n├── SyntaxError\n│ └── IndentationError\n│ └── TabError\n├── SystemError\n├── TypeError\n├── ValueError\n│ └── UnicodeError\n│ ├── UnicodeDecodeError\n│ ├── UnicodeEncodeError\n│ └── UnicodeTranslateError\n└── Warning\n├── BytesWarning\n├── DeprecationWarning\n├── EncodingWarning\n├── FutureWarning\n├── ImportWarning\n├── PendingDeprecationWarning\n├── ResourceWarning\n├── RuntimeWarning\n├── SyntaxWarning\n├── UnicodeWarning\n└── UserWarning", "metadata": {"title": "00_内置异常", "source": "md_docs\\python_library_md\\00_内置异常.md", "doc_type": "标准库", "language": "中文", "doc_id": "780a77e0"}}
{"doc_id": "be308111", "content": "内置类型\n以下部分描述了解释器中内置的标准类型。\n主要内置类型有数字、序列、映射、类、实例和异常。\n有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的\n项，绝对不会返回多项集实例自身而是返回 None。\n有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以\n及转换为字符串（使用 repr() 函数或略有差异的 str() 函数）。 后一个函数是在对象由 print()\n函数输出时被隐式地调用的。\n逻辑值检测\n任何对象都可以进行逻辑值的检测，以便在 if 或 while 作为条件或是作为下文所述布尔运算的操\n作数来使用。\n在默认情况下，一个对象会被视为具有真值，除非其所属的类定义了在对象上调用时返回 False 的\n__bool__() 方法或者返回零的 __len__() 方法。 [1] 以下基本完整地列出了具有假值的内置对\n象：\n被定义为假值的常量: None 和 False\n任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\n空的序列和多项集: '', (), [], {}, set(), range(0)\n产生布尔值结果的运算和内置函数总是返回 0 或 False 作为假值，1 或 True 作为真值，除非另行\n说明。 （重要例外：布尔运算 or 和 and 总是返回其中一个操作数。）\n布尔运算 --- and, or, not\n这些属于布尔运算，按优先级升序排列:\n运算 结果： 备注\nx or y 如果 x 为真值，则 x，否则 y (1)\nx and y 如果 x 为假值，则返回 x，否则返回 y (2)\nnot x if x is false, then True, else False (3)\n注释：\n1. 这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。\n\n| 运算 | 结果： | 备注 |\n| --- | --- | --- |\n| x or y | 如果 x 为真值，则 x，否则 y | (1) |\n| x and y | 如果 x 为假值，则返回 x，否则返回 y | (2) |\n| not x | if x is false, then True, else False | (3) |\n\n2. 这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。\n3. not 的优先级比非布尔运算符低，因此 not a == b 会被解读为 not (a == b) 而 a == not\nb 会引发语法错误。\n比较运算\n在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任\n意串连；例如，x < y <= z 等价于 x < y and y <= z，前者的不同之处在于 y 只被求值一次（但\n在两种情况下当 x < y 结果为假值时 z 都不会被求值）。\n此表格汇总了比较运算:\n运算 含意\n< 严格小于\n<= 小于或等于\n> 严格大于\n>= 大于或等于\n== 等于\n!= 不等于\nis 对象标识\nis not 否定的对象标识\n除不同的数字类型外，不同类型的对象不能进行相等比较。== 运算符总有定义，但对于某些对象类\n型（例如，类对象），它等于 is 。其他 <、<=、> 和 >= 运算符仅在有意义的地方定义。例如，当\n参与比较的参数之一为复数时，它们会抛出 TypeError 异常。\n具有不同标识的类的实例比较结果通常为不相等，除非类定义了 __eq__() 方法。\n一个类的实例不能与相同类的其他实例或其他类型的对象进行排序，除非定义该类定义了足够多的\n方法，包括 __lt__(), __le__(), __gt__() 以及 __ge__() (而如果你想实现常规意义上的比较操\n作，通常只要有 __lt__() 和 __eq__() 就可以了)。\nis 和 is not 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。\n还有两种具有相同语法优先级的运算 in 和 not in，它们被 iterable 或实现了 __contains__() 方\n法的类型所支持。\n数字类型 --- int, float, complex\n存在三种不同的数字类型: 整数, 浮点数 和 复数。 此外，布尔值属于整数的子类型。 整数具有无限\n的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内\n\n|  | 2. 这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。\n3. not 的优先级比非布尔运算符低，因此 not a == b 会被解读为 not (a == b) 而 a == not\nb 会引发语法错误。\n比较运算\n在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任\n意串连；例如，x < y <= z 等价于 x < y and y <= z，前者的不同之处在于 y 只被求值一次（但\n在两种情况下当 x < y 结果为假值时 z 都不会被求值）。\n此表格汇总了比较运算:\n运算 含意\n< 严格小于\n<= 小于或等于\n> 严格大于\n>= 大于或等于\n== 等于\n!= 不等于\nis 对象标识\nis not 否定的对象标识\n除不同的数字类型外，不同类型的对象不能进行相等比较。== 运算符总有定义，但对于某些对象类\n型（例如，类对象），它等于 is 。其他 <、<=、> 和 >= 运算符仅在有意义的地方定义。例如，当\n参与比较的参数之一为复数时，它们会抛出 TypeError 异常。\n具有不同标识的类的实例比较结果通常为不相等，除非类定义了 __eq__() 方法。\n一个类的实例不能与相同类的其他实例或其他类型的对象进行排序，除非定义该类定义了足够多的\n方法，包括 __lt__(), __le__(), __gt__() 以及 __ge__() (而如果你想实现常规意义上的比较操\n作，通常只要有 __lt__() 和 __eq__() 就可以了)。\nis 和 is not 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。\n还有两种具有相同语法优先级的运算 in 和 not in，它们被 iterable 或实现了 __contains__() 方\n法的类型所支持。\n数字类型 --- int, float, complex\n存在三种不同的数字类型: 整数, 浮点数 和 复数。 此外，布尔值属于整数的子类型。 整数具有无限\n的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内 |  |\n| --- | --- | --- |\n|  | b |  |\n|  |  |  |\n\n| 运算 | 含意 |\n| --- | --- |\n| < | 严格小于 |\n| <= | 小于或等于 |\n| > | 严格大于 |\n| >= | 大于或等于 |\n| == | 等于 |\n| != | 不等于 |\n| is | 对象标识 |\n| is not | 否定的对象标识 |\n\n部表示法可在 sys.float_info 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个\n复数 z 中提取这两个部分，可使用 z.real 和 z.imag。 （标准库包含附加的数字类型，如表示有理\n数的 fractions.Fraction 以及以用户定制精度表示浮点数的 decimal.Decimal。）\n数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进\n制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字\n字面值末尾加上 'j' 或 'J' 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得\n到具有实部和虚部的复数。\n构造函数 int()、 float() 和 complex() 可以用来构造特定类型的数字。\nPython 完全支持混合算术运算：当一个二元算术运算符的操作数具有不同的数值类型时，“较窄”类\n型的操作数会加宽为另一个操作数的类型，如整数的宽度比浮点数窄。 复数和实数操作数的算术运\n算是根据通常的数学准则来定义的，例如:\nx + complex(u, v) = complex(x + u, v)\nx * complex(u, v) = complex(x * u, x * v)\n不同类型数值之间的比较行为就如同对这些数字的实际值进行比较。 [2]\n所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：运算符优先级）:\n运算 结果： 备注 完整文档\nx + y x 和 y 的和\nx - y x 和 y 的差\nx * y x 和 y 的乘积\nx / y x 和 y 的商\nx // y x 和 y 的商数 (1)(2)\nx % y x / y 的余数 (2)\n-x x 取反\n+x x 不变\nabs(x) x 的绝对值或大小 abs()\nint(x) 将 x 转换为整数 (3)(6) int()\nfloat(x) 将 x 转换为浮点数 (4)(6) float()\ncomplex(re, im) 一个带有实部 re 和虚部 im 的复数。im 默认为0。 (6) complex()\nc.conjugate() 复数 c 的共轭\ndivmod(x, y) (x // y, x % y) (2) divmod()\npow(x, y) x 的 y 次幂 (5) pow()\n\n|  | 部表示法可在 sys.float_info 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个\n复数 z 中提取这两个部分，可使用 z.real 和 z.imag。 （标准库包含附加的数字类型，如表示有理\n数的 fractions.Fraction 以及以用户定制精度表示浮点数的 decimal.Decimal。）\n数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进\n制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字\n字面值末尾加上 'j' 或 'J' 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得\n到具有实部和虚部的复数。\n构造函数 int()、 float() 和 complex() 可以用来构造特定类型的数字。\nPython 完全支持混合算术运算：当一个二元算术运算符的操作数具有不同的数值类型时，“较窄”类\n型的操作数会加宽为另一个操作数的类型，如整数的宽度比浮点数窄。 复数和实数操作数的算术运\n算是根据通常的数学准则来定义的，例如: |  |\n| --- | --- | --- |\n|  | x + complex(u, v) = complex(x + u, v)\nx * complex(u, v) = complex(x * u, x * v) |  |\n|  | 不同类型数值之间的比较行为就如同对这些数字的实际值进行比较。 [2]\n所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：运算符优先级）:\n运算 结果： 备注 完整文档\nx + y x 和 y 的和\nx - y x 和 y 的差\nx * y x 和 y 的乘积\nx / y x 和 y 的商\nx // y x 和 y 的商数 (1)(2)\nx % y x / y 的余数 (2)\n-x x 取反\n+x x 不变\nabs(x) x 的绝对值或大小 abs()\nint(x) 将 x 转换为整数 (3)(6) int()\nfloat(x) 将 x 转换为浮点数 (4)(6) float()\ncomplex(re, im) 一个带有实部 re 和虚部 im 的复数。im 默认为0。 (6) complex()\nc.conjugate() 复数 c 的共轭\ndivmod(x, y) (x // y, x % y) (2) divmod()\npow(x, y) x 的 y 次幂 (5) pow() |  |\n\n| 运算 | 结果： | 备注 | 完整文档 |\n| --- | --- | --- | --- |\n| x + y | x 和 y 的和 |  |  |\n| x - y | x 和 y 的差 |  |  |\n| x * y | x 和 y 的乘积 |  |  |\n| x / y | x 和 y 的商 |  |  |\n| x // y | x 和 y 的商数 | (1)(2) |  |\n| x % y | x / y 的余数 | (2) |  |\n| -x | x 取反 |  |  |\n| +x | x 不变 |  |  |\n| abs(x) | x 的绝对值或大小 |  | abs() |\n| int(x) | 将 x 转换为整数 | (3)(6) | int() |\n| float(x) | 将 x 转换为浮点数 | (4)(6) | float() |\n| complex(re, im) | 一个带有实部 re 和虚部 im 的复数。im 默认为0。 | (6) | complex() |\n| c.conjugate() | 复数 c 的共轭 |  |  |\n| divmod(x, y) | (x // y, x % y) | (2) | divmod() |\n| pow(x, y) | x 的 y 次幂 | (5) | pow() |\n\n运算 结果： 备注 完整文档\nx ** y x 的 y 次幂 (5)\n注释：\n1. 也称为整数除法。 对于 int 类型的操作数，结果的类型为 int。 对于 float 类型的操作\n数，结果的类型为 float。 总的说来，结果是一个整数，但结果的类型不一定为 int。 结果\n总是向负无穷的方向舍入: 1//2 为 0，(-1)//2 为 -1，1//(-2) 为 -1，(-1)//(-2) 为 0。\n2. 不可用于复数。 而应在适当条件下使用 abs() 转换为浮点数。\n3. 从 float 转换为 int 将会执行截断，丢弃掉小数部分。 请参阅 math.floor() 和\nmath.ceil() 函数了解替代的转换方式。\n4. float 也接受字符串 \"nan\" 和附带可选前缀 \"+\" 或 \"-\" 的 \"inf\" 分别表示非数字 (NaN) 以及正或\n负无穷。\n5. Python 将 pow(0, 0) 和 0 ** 0 定义为 1，这是编程语言的普遍做法。\n6. 接受的数字字面值包括数码 0 到 9 或任何等效的 Unicode 字符（具有 Nd 特征属性的代码\n点）。\n请参阅 Unicode 标准 了解具有 Nd 特征属性的码位完整列表。\n所有 numbers.Real 类型 (int 和 float) 还包括下列运算:\n运算 结果：\nmath.trunc(x) x 截断为 Integral\nround(x[, n]) x 舍入到 n 位小数，半数值会舍入到偶数。 如果省略 n，则默认为 0。\nmath.floor(x) <= x 的最大 Integral\nmath.ceil(x) >= x 的最小 Integral\n有关更多的数字运算请参阅 math 和 cmath 模块。\n整数类型的按位运算\n按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码\n执行操作。\n二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 ~ 具有与其他一元算术\n运算 (+ and -) 相同的优先级。\n此表格是以优先级升序排序的按位运算列表:\n\n|  | 运算 结果： 备注 完整文档\nx ** y x 的 y 次幂 (5)\n注释：\n1. 也称为整数除法。 对于 int 类型的操作数，结果的类型为 int。 对于 float 类型的操作\n数，结果的类型为 float。 总的说来，结果是一个整数，但结果的类型不一定为 int。 结果\n总是向负无穷的方向舍入: 1//2 为 0，(-1)//2 为 -1，1//(-2) 为 -1，(-1)//(-2) 为 0。\n2. 不可用于复数。 而应在适当条件下使用 abs() 转换为浮点数。\n3. 从 float 转换为 int 将会执行截断，丢弃掉小数部分。 请参阅 math.floor() 和\nmath.ceil() 函数了解替代的转换方式。\n4. float 也接受字符串 \"nan\" 和附带可选前缀 \"+\" 或 \"-\" 的 \"inf\" 分别表示非数字 (NaN) 以及正或\n负无穷。\n5. Python 将 pow(0, 0) 和 0 ** 0 定义为 1，这是编程语言的普遍做法。\n6. 接受的数字字面值包括数码 0 到 9 或任何等效的 Unicode 字符（具有 Nd 特征属性的代码\n点）。\n请参阅 Unicode 标准 了解具有 Nd 特征属性的码位完整列表。\n所有 numbers.Real 类型 (int 和 float) 还包括下列运算:\n运算 结果：\nmath.trunc(x) x 截断为 Integral\nround(x[, n]) x 舍入到 n 位小数，半数值会舍入到偶数。 如果省略 n，则默认为 0。\nmath.floor(x) <= x 的最大 Integral\nmath.ceil(x) >= x 的最小 Integral\n有关更多的数字运算请参阅 math 和 cmath 模块。\n整数类型的按位运算\n按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码\n执行操作。\n二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 ~ 具有与其他一元算术\n运算 (+ and -) 相同的优先级。\n此表格是以优先级升序排序的按位运算列表: |  |\n| --- | --- | --- |\n\n| 运算 | 结果： | 备注 | 完整文档 |\n| --- | --- | --- | --- |\n| x ** y | x 的 y 次幂 | (5) |  |\n\n| 运算 | 结果： |\n| --- | --- |\n| math.trunc(x) | x 截断为 Integral |\n| round(x[, n]) | x 舍入到 n 位小数，半数值会舍入到偶数。 如果省略 n，则默认为 0。 |\n| math.floor(x) | <= x 的最大 Integral |\n| math.ceil(x) | >= x 的最小 Integral |\n\n运算 结果： 备注\nx | y x 和 y 按位 或 (4)\nx ^ y x 和 y 按位 异或 (4)\nx & y x 和 y 按位 与 (4)\nx << n x 左移 n 位 (1)(2)\nx >> n x 右移 n 位 (1)(3)\n~x x 逐位取反\n注释：\n1. 负的移位数是非法的，会导致引发 ValueError。\n2. 左移 n 位等价于乘以 pow(2, n) 。\n3. 右移 n 位等价于除以 pow(2, n) ，作向下取整除法。\n4. 使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 1 +\nmax(x.bit_length(), y.bit_length()) 或以上）执行这些计算就足以获得相当于有无数个\n符号位时的同样结果。\n整数类型的附加方法\nint 类型实现了 numbers.Integral abstract base class。 此外，它还提供了其他几个方法:\nint.bit_length()\n返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:\n>>> n = -37\n>>> bin(n)\n'-0b100101'\n>>> n.bit_length()\n6\n更准确地说，如果 x 非零，则 x.bit_length() 是使得 2**(k-1) <= abs(x) < 2**k 的唯一\n正整数 k。 同样地，当 abs(x) 小到足以具有正确的舍入对数时，则 k = 1 +\nint(log(abs(x), 2))。 如果 x 为零，则 x.bit_length() 返回 0。\n等价于:\ndef bit_length(self):\ns = bin(self) # 二进制表示形式: bin(-37) --> '-0b100101'\ns = s.lstrip('-0b') # 移除开头的零和负号\nreturn len(s) # len('100101') --> 6\nAdded in version 3.1.\nint.bit_count()\n返回整数的绝对值的二进制表示中 1 的个数。也被称为 population count。示例:\n\n|  |  | 运算 结果： 备注\nx | y x 和 y 按位 或 (4)\nx ^ y x 和 y 按位 异或 (4)\nx & y x 和 y 按位 与 (4)\nx << n x 左移 n 位 (1)(2)\nx >> n x 右移 n 位 (1)(3)\n~x x 逐位取反\n注释：\n1. 负的移位数是非法的，会导致引发 ValueError。\n2. 左移 n 位等价于乘以 pow(2, n) 。\n3. 右移 n 位等价于除以 pow(2, n) ，作向下取整除法。\n4. 使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 1 +\nmax(x.bit_length(), y.bit_length()) 或以上）执行这些计算就足以获得相当于有无数个\n符号位时的同样结果。\n整数类型的附加方法\nint 类型实现了 numbers.Integral abstract base class。 此外，它还提供了其他几个方法:\nint.bit_length()\n返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:\n>>> n = -37\n>>> bin(n)\n'-0b100101'\n>>> n.bit_length()\n6\n更准确地说，如果 x 非零，则 x.bit_length() 是使得 2**(k-1) <= abs(x) < 2**k 的唯一\n正整数 k。 同样地，当 abs(x) 小到足以具有正确的舍入对数时，则 k = 1 +\nint(log(abs(x), 2))。 如果 x 为零，则 x.bit_length() 返回 0。\n等价于:\ndef bit_length(self):\ns = bin(self) # 二进制表示形式: bin(-37) --> '-0b100101'\ns = s.lstrip('-0b') # 移除开头的零和负号\nreturn len(s) # len('100101') --> 6\nAdded in version 3.1.\nint.bit_count()\n返回整数的绝对值的二进制表示中 1 的个数。也被称为 population count。示例: |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | 1 + |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | k = 1 + |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  | int(log(abs(x), 2)) |  |  |  |  |\n|  |  |  |  |  |  |  |\n\n| 运算 | 结果： | 备注 |\n| --- | --- | --- |\n| x | y | x 和 y 按位 或 | (4) |\n| x ^ y | x 和 y 按位 异或 | (4) |\n| x & y | x 和 y 按位 与 | (4) |\n| x << n | x 左移 n 位 | (1)(2) |\n| x >> n | x 右移 n 位 | (1)(3) |\n| ~x | x 逐位取反 |  |\n\n>>> n = 19\n>>> bin(n)\n'0b10011'\n>>> n.bit_count()\n3\n>>> (-n).bit_count()\n3\n等价于:\ndef bit_count(self):\nreturn bin(self).count(\"1\")\nAdded in version 3.10.\nint.to_bytes(length=1, byteorder='big', *, signed=False)\n返回表示一个整数的字节数组。\n>>> (1024).to_bytes(2, byteorder='big')\nb'\\x04\\x00'\n>>> (1024).to_bytes(10, byteorder='big')\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00'\n>>> (-1024).to_bytes(10, byteorder='big', signed=True)\nb'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00'\n>>> x = 1000\n>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')\nb'\\xe8\\x03'\n整数会使用 length 个字节来表示，默认为 1。 如果整数不能用给定的字节数来表示则会引发\nOverflowError。\nbyteorder 参数确定用于表示整数的字节顺序，默认为 \"big\"。 如果 byteorder 为 \"big\"，则最\n高位字节放在字节数组的开头。 如果 byteorder 为 \"little\"，则最高位字节放在字节数组的末\n尾。\nsigned 参数确定是否使用二的补码来表示整数。 如果 signed 为 False 并且给出的是负整数，\n则会引发 OverflowError。 signed 的默认值为 False。\n默认值可用于方便地将整数转为一个单字节对象:\n>>> (65).to_bytes()\nb'A'\n但是，当使用默认参数时，请不要试图转换大于 255 的值否则会引发 OverflowError。\n等价于:\ndef to_bytes(n, length=1, byteorder='big', signed=False):\nif byteorder == 'little':\norder = range(length)\nelif byteorder == 'big':\norder = reversed(range(length))\nelse:\n\n|  | >>> n = 19\n>>> bin(n)\n'0b10011'\n>>> n.bit_count()\n3\n>>> (-n).bit_count()\n3\n等价于:\ndef bit_count(self):\nreturn bin(self).count(\"1\")\nAdded in version 3.10.\nint.to_bytes(length=1, byteorder='big', *, signed=False)\n返回表示一个整数的字节数组。\n>>> (1024).to_bytes(2, byteorder='big')\nb'\\x04\\x00'\n>>> (1024).to_bytes(10, byteorder='big')\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00'\n>>> (-1024).to_bytes(10, byteorder='big', signed=True)\nb'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00'\n>>> x = 1000\n>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')\nb'\\xe8\\x03'\n整数会使用 length 个字节来表示，默认为 1。 如果整数不能用给定的字节数来表示则会引发\nOverflowError。\nbyteorder 参数确定用于表示整数的字节顺序，默认为 \"big\"。 如果 byteorder 为 \"big\"，则最\n高位字节放在字节数组的开头。 如果 byteorder 为 \"little\"，则最高位字节放在字节数组的末\n尾。\nsigned 参数确定是否使用二的补码来表示整数。 如果 signed 为 False 并且给出的是负整数，\n则会引发 OverflowError。 signed 的默认值为 False。\n默认值可用于方便地将整数转为一个单字节对象:\n>>> (65).to_bytes()\nb'A'\n但是，当使用默认参数时，请不要试图转换大于 255 的值否则会引发 OverflowError。\n等价于:\ndef to_bytes(n, length=1, byteorder='big', signed=False):\nif byteorder == 'little':\norder = range(length)\nelif byteorder == 'big':\norder = reversed(range(length))\nelse: | >>> n = 19\n>>> bin(n)\n'0b10011'\n>>> n.bit_count()\n3\n>>> (-n).bit_count()\n3 |  |\n| --- | --- | --- | --- |\n|  |  | def to_bytes(n, length=1, byteorder='big', signed=False):\nif byteorder == 'little':\norder = range(length)\nelif byteorder == 'big':\norder = reversed(range(length))\nelse: |  |\n\nraise ValueError(\"byteorder must be either 'little' or 'big'\")\nreturn bytes((n >> i*8) & 0xff for i in order)\nAdded in version 3.2.\n在 3.11 版本发生变更: 添加了 length 和 byteorder 的默认参数值。\nclassmethod int.from_bytes(bytes, byteorder='big', *, signed=False)\n返回由给定字节数组所表示的整数。\n>>> int.from_bytes(b'\\x00\\x10', byteorder='big')\n16\n>>> int.from_bytes(b'\\x00\\x10', byteorder='little')\n4096\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True)\n-1024\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False)\n64512\n>>> int.from_bytes([255, 0, 0], byteorder='big')\n16711680\nbytes 参数必须为一个 bytes-like object 或是生成字节的可迭代对象。\nbyteorder 参数确定用于表示整数的字节顺序，默认为 \"big\"。 如果 byteorder 为 \"big\"，则最\n高位字节放在字节数组的开头。 如果 byteorder 为 \"little\"，则最高位字节放在字节数组的末\n尾。 要请求主机系统上的原生字节顺序，请使用 sys.byteorder 作为字节顺序值。\nsigned 参数指明是否使用二的补码来表示整数。\n等价于:\ndef from_bytes(bytes, byteorder='big', signed=False):\nif byteorder == 'little':\nlittle_ordered = list(bytes)\nelif byteorder == 'big':\nlittle_ordered = list(reversed(bytes))\nelse:\nraise ValueError(\"byteorder must be either 'little' or 'big'\")\nn = sum(b << i*8 for i, b in enumerate(little_ordered))\nif signed and little_ordered and (little_ordered[-1] & 0x80):\nn -= 1 << 8*len(little_ordered)\nreturn n\nAdded in version 3.2.\n在 3.11 版本发生变更: 添加了 byteorder 的默认参数值。\nint.as_integer_ratio()\n返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为\n分子并以 1 作为分母。\n\n|  | raise ValueError(\"byteorder must be either 'little' or 'big'\")\nreturn bytes((n >> i*8) & 0xff for i in order)\nAdded in version 3.2.\n在 3.11 版本发生变更: 添加了 length 和 byteorder 的默认参数值。\nclassmethod int.from_bytes(bytes, byteorder='big', *, signed=False)\n返回由给定字节数组所表示的整数。\n>>> int.from_bytes(b'\\x00\\x10', byteorder='big')\n16\n>>> int.from_bytes(b'\\x00\\x10', byteorder='little')\n4096\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True)\n-1024\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False)\n64512\n>>> int.from_bytes([255, 0, 0], byteorder='big')\n16711680\nbytes 参数必须为一个 bytes-like object 或是生成字节的可迭代对象。\nbyteorder 参数确定用于表示整数的字节顺序，默认为 \"big\"。 如果 byteorder 为 \"big\"，则最\n高位字节放在字节数组的开头。 如果 byteorder 为 \"little\"，则最高位字节放在字节数组的末\n尾。 要请求主机系统上的原生字节顺序，请使用 sys.byteorder 作为字节顺序值。\nsigned 参数指明是否使用二的补码来表示整数。\n等价于:\ndef from_bytes(bytes, byteorder='big', signed=False):\nif byteorder == 'little':\nlittle_ordered = list(bytes)\nelif byteorder == 'big':\nlittle_ordered = list(reversed(bytes))\nelse:\nraise ValueError(\"byteorder must be either 'little' or 'big'\")\nn = sum(b << i*8 for i, b in enumerate(little_ordered))\nif signed and little_ordered and (little_ordered[-1] & 0x80):\nn -= 1 << 8*len(little_ordered)\nreturn n\nAdded in version 3.2.\n在 3.11 版本发生变更: 添加了 byteorder 的默认参数值。\nint.as_integer_ratio()\n返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为\n分子并以 1 作为分母。 | raise ValueError(\"byteorder must be either 'little' or 'big'\")\nreturn bytes((n >> i*8) & 0xff for i in order) |  |\n| --- | --- | --- | --- |\n\nAdded in version 3.8.\nint.is_integer()\n返回 True。 存在于兼容 float.is_integer() 的鸭子类型。\nAdded in version 3.12.\n浮点类型的附加方法\nfloat 类型实现了 numbers.Real abstract base class。 float 还具有以下附加方法。\nclassmethod float.from_number(x)\n返回基于一个数字 x 所构造的浮点数的类方法。\n如果参数是整数或浮点数，则返回一个具有相同值（在 Python 浮点精度范围内）的浮点数。\n如果参数超出了 Python 浮点数的取值范围，则会引发 OverflowError。\n对于一个普通 Python 对象 x，float.from_number(x) 会委托给 x.__float__()。 如果\n__float__() 未定义则将回退至 __index__()。\nAdded in version 3.14.\nfloat.as_integer_ratio()\n返回一对整数，其比率正好等于原浮点数。 该比率为最简形式且分母为正值。 无穷大会引发\nOverflowError 而 NaN 则会引发 ValueError。\nfloat.is_integer()\n如果 float 实例可用有限位整数表示则返回 True，否则返回 False:\n>>> (-2.0).is_integer()\nTrue\n>>> (3.2).is_integer()\nFalse\n两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因\n此浮点数与 十进制数 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精\n确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。\nfloat.hex()\n以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导\n的 0x 和尾随的 p 加指数。\nclassmethod float.fromhex(s)\n返回以十六进制字符串 s 表示的浮点数的类方法。 字符串 s 可以带有前导和尾随的空格。\n请注意 float.hex() 是实例方法，而 float.fromhex() 是类方法。\n十六进制字符串采用的形式为:\n[sign] ['0x'] integer ['.' fraction] ['p' exponent]\n\n|  | Added in version 3.8.\nint.is_integer()\n返回 True。 存在于兼容 float.is_integer() 的鸭子类型。\nAdded in version 3.12.\n浮点类型的附加方法\nfloat 类型实现了 numbers.Real abstract base class。 float 还具有以下附加方法。\nclassmethod float.from_number(x)\n返回基于一个数字 x 所构造的浮点数的类方法。\n如果参数是整数或浮点数，则返回一个具有相同值（在 Python 浮点精度范围内）的浮点数。\n如果参数超出了 Python 浮点数的取值范围，则会引发 OverflowError。\n对于一个普通 Python 对象 x，float.from_number(x) 会委托给 x.__float__()。 如果\n__float__() 未定义则将回退至 __index__()。\nAdded in version 3.14.\nfloat.as_integer_ratio()\n返回一对整数，其比率正好等于原浮点数。 该比率为最简形式且分母为正值。 无穷大会引发\nOverflowError 而 NaN 则会引发 ValueError。\nfloat.is_integer()\n如果 float 实例可用有限位整数表示则返回 True，否则返回 False:\n>>> (-2.0).is_integer()\nTrue\n>>> (3.2).is_integer()\nFalse\n两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因\n此浮点数与 十进制数 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精\n确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。\nfloat.hex()\n以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导\n的 0x 和尾随的 p 加指数。\nclassmethod float.fromhex(s)\n返回以十六进制字符串 s 表示的浮点数的类方法。 字符串 s 可以带有前导和尾随的空格。\n请注意 float.hex() 是实例方法，而 float.fromhex() 是类方法。\n十六进制字符串采用的形式为: |  |\n| --- | --- | --- |\n|  | [sign] ['0x'] integer ['.' fraction] ['p' exponent] |  |\n|  |  |  |\n\n可选的 sign 可以是 + 或 -，integer 和 fraction 是十六进制数码组成的字符串，exponent 是带\n有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制\n数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。\n特别地，float.hex() 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 %a 格\n式字符或 Java 的 Double.toHexString 所生成的十六进制数字符串由为 float.fromhex() 所接\n受。\n请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制\n数字符串 0x3.a7p10 表示浮点数 (3 + 10./16 + 7./16**2) * 2.0**10 即 3740.0:\n>>> float.fromhex('0x3.a7p10')\n3740.0\n对 3740.0 应用反向转换会得到另一个代表相同数值的十六进制数字符串:\n>>> float.hex(3740.0)\n'0x1.d380000000000p+11'\n复数类型的附加方法\ncomplex 类型实现了 numbers.Complex abstract base class。 complex 还具有以下附加方法。\nclassmethod complex.from_number(x)\n将数字转换为复数的类方法。\n对于一个普通 Python 对象 x，complex.from_number(x) 会委托给 x.__complex__()。 如果\n__complex__() 未定义则将回退至 __float__()。 如果 __float__() 未定义则将回退至\n__index__()。\nAdded in version 3.14.\n数字类型的哈希运算\n对于可能为不同类型的数字 x 和 y，要求当 x == y 时必定有 hash(x) == hash(y) (详情参见\n__hash__() 方法的文档)。 为了便于在各种数字类型 (包括 int, float, decimal.Decimal 和\nfractions.Fraction) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义\n统一的数学函数，因此该运算对 int 和 fractions.Fraction 的全部实例，以及 float 和\ndecimal.Decimal 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 P 进行 P\n降模给出的。 P 的值在 Python 中可以 sys.hash_info 的 modulus 属性的形式被访问。\n目前所用的质数设定，在 C long 为 32 位的机器上 P = 2**31 - 1 而在 C long 为 64 位的机器上 P\n= 2**61 - 1。\n详细规则如下所述:\n如果 x = m / n 是一个非负的有理数且 n 不可被 P 整除，则定义 hash(x) 为 m * invmod(n,\nP) % P，其中 invmod(n, P) 是对 n 模 P 取反。\n\n|  |  | 可选的 sign 可以是 + 或 -，integer 和 fraction 是十六进制数码组成的字符串，exponent 是带\n有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制\n数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。\n特别地，float.hex() 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 %a 格\n式字符或 Java 的 Double.toHexString 所生成的十六进制数字符串由为 float.fromhex() 所接\n受。\n请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制\n数字符串 0x3.a7p10 表示浮点数 (3 + 10./16 + 7./16**2) * 2.0**10 即 3740.0: |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | >>> float.fromhex('0x3.a7p10')\n3740.0 |  |  |  |\n|  |  | 对 3740.0 应用反向转换会得到另一个代表相同数值的十六进制数字符串: |  |  |  |\n|  |  | >>> float.hex(3740.0)\n'0x1.d380000000000p+11' |  |  |  |\n|  |  | 复数类型的附加方法\ncomplex 类型实现了 numbers.Complex abstract base class。 complex 还具有以下附加方法。\nclassmethod complex.from_number(x)\n将数字转换为复数的类方法。\n对于一个普通 Python 对象 x，complex.from_number(x) 会委托给 x.__complex__()。 如果\n__complex__() 未定义则将回退至 __float__()。 如果 __float__() 未定义则将回退至\n__index__()。\nAdded in version 3.14.\n数字类型的哈希运算\n对于可能为不同类型的数字 x 和 y，要求当 x == y 时必定有 hash(x) == hash(y) (详情参见\n__hash__() 方法的文档)。 为了便于在各种数字类型 (包括 int, float, decimal.Decimal 和\nfractions.Fraction) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义\n统一的数学函数，因此该运算对 int 和 fractions.Fraction 的全部实例，以及 float 和\ndecimal.Decimal 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 P 进行 P\n降模给出的。 P 的值在 Python 中可以 sys.hash_info 的 modulus 属性的形式被访问。\n目前所用的质数设定，在 C long 为 32 位的机器上 P = 2**31 - 1 而在 C long 为 64 位的机器上 P\n= 2**61 - 1。\n详细规则如下所述:\n如果 x = m / n 是一个非负的有理数且 n 不可被 P 整除，则定义 hash(x) 为 m * invmod(n,\nP) % P，其中 invmod(n, P) 是对 n 模 P 取反。 |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  | m * invmod(n, |  |  |\n|  |  |  |  |  |  |\n|  |  | P) % P |  |  |  |\n|  |  |  |  |  |  |\n\n|  | = 2**61 - 1 |\n| --- | --- |\n\n如果 x = m / n 是一个非负的有理数且 n 可被 P 整除（但 m 不能）则 n 不能对 P 降模，以上规\n则不适用；在此情况下则定义 hash(x) 为常数值 sys.hash_info.inf。\n如果 x = m / n 是一个负的有理数则定义 hash(x) 为 -hash(-x)。 如果结果哈希值为 -1 则将\n其替换为 -2。\n特殊值 sys.hash_info.inf 和 -sys.hash_info.inf 分别用于正无穷或负无穷的哈希值。\n对于一个 complex 值 z，会通过计算 hash(z.real) + sys.hash_info.imag * hash(z.imag)\n将实部和虚部的哈希值结合起来，并进行降模 2**sys.hash_info.width 以使其处于\nrange(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)) 范围之内。 同样\n地，如果结果为 -1 则将其替换为 -2。\n为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、\nfloat 或 complex 的哈希值:\nimport sys, math\ndef hash_fraction(m, n):\n\"\"\"Compute the hash of a rational number m / n.\nAssumes m and n are integers, with n positive.\nEquivalent to hash(fractions.Fraction(m, n)).\n\"\"\"\nP = sys.hash_info.modulus\n# 移除 P 的公因数。 （如果 m 和 n 互质则不需要。）\nwhile m % P == n % P == 0:\nm, n = m // P, n // P\nif n % P == 0:\nhash_value = sys.hash_info.inf\nelse:\n# 费马小定理: pow(n, P-1, P) 等于 1，\n# 则 pow(n, P-2, P) 等于 n 除以 P 的余数的倒数。\nhash_value = (abs(m) % P) * pow(n, P - 2, P) % P\nif m < 0:\nhash_value = -hash_value\nif hash_value == -1:\nhash_value = -2\nreturn hash_value\ndef hash_float(x):\n\"\"\"Compute the hash of a float x.\"\"\"\nif math.isnan(x):\nreturn object.__hash__(x)\nelif math.isinf(x):\nreturn sys.hash_info.inf if x > 0 else -sys.hash_info.inf\nelse:\nreturn hash_fraction(*x.as_integer_ratio())\ndef hash_complex(z):\n\"\"\"Compute the hash of a complex number z.\"\"\"\nhash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n# 带正负号的约减求余运算 2**sys.hash_info.width\nM = 2**(sys.hash_info.width - 1)\n\n|  | 如果 x = m / n 是一个非负的有理数且 n 可被 P 整除（但 m 不能）则 n 不能对 P 降模，以上规\n则不适用；在此情况下则定义 hash(x) 为常数值 sys.hash_info.inf。\n如果 x = m / n 是一个负的有理数则定义 hash(x) 为 -hash(-x)。 如果结果哈希值为 -1 则将\n其替换为 -2。\n特殊值 sys.hash_info.inf 和 -sys.hash_info.inf 分别用于正无穷或负无穷的哈希值。\n对于一个 complex 值 z，会通过计算 hash(z.real) + sys.hash_info.imag * hash(z.imag)\n将实部和虚部的哈希值结合起来，并进行降模 2**sys.hash_info.width 以使其处于\nrange(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)) 范围之内。 同样\n地，如果结果为 -1 则将其替换为 -2。\n为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、\nfloat 或 complex 的哈希值: |  |\n| --- | --- | --- |\n|  | import sys, math\ndef hash_fraction(m, n):\n\"\"\"Compute the hash of a rational number m / n.\nAssumes m and n are integers, with n positive.\nEquivalent to hash(fractions.Fraction(m, n)).\n\"\"\"\nP = sys.hash_info.modulus\n# 移除 P 的公因数。 （如果 m 和 n 互质则不需要。）\nwhile m % P == n % P == 0:\nm, n = m // P, n // P\nif n % P == 0:\nhash_value = sys.hash_info.inf\nelse:\n# 费马小定理: pow(n, P-1, P) 等于 1，\n# 则 pow(n, P-2, P) 等于 n 除以 P 的余数的倒数。\nhash_value = (abs(m) % P) * pow(n, P - 2, P) % P\nif m < 0:\nhash_value = -hash_value\nif hash_value == -1:\nhash_value = -2\nreturn hash_value\ndef hash_float(x):\n\"\"\"Compute the hash of a float x.\"\"\"\nif math.isnan(x):\nreturn object.__hash__(x)\nelif math.isinf(x):\nreturn sys.hash_info.inf if x > 0 else -sys.hash_info.inf\nelse:\nreturn hash_fraction(*x.as_integer_ratio())\ndef hash_complex(z):\n\"\"\"Compute the hash of a complex number z.\"\"\"\nhash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n# 带正负号的约减求余运算 2**sys.hash_info.width\nM = 2**(sys.hash_info.width - 1) |  |\n\nhash_value = (hash_value & (M - 1)) - (hash_value & M)\nif hash_value == -1:\nhash_value = -2\nreturn hash_value\n布尔类型 - bool\n代表真值的布尔对象。 bool 类型只有两个常量实例: True 和 False。\n内置函数 bool() 可将任意值转换为布尔值，如果该值可以被解读为逻辑值的话（参见上面的 逻辑\n值检测 小节）。\n对于逻辑运算，请使用 布尔运算符 and, or 和 not。 当于两个布尔值应用按位运算符 &, |, ^ 时，\n它们将返回一个等价于逻辑运算 \"与\", \"或\", \"异或\" 的布尔值。 但是，更推荐使用逻辑运算符 and,\nor 和 != 而不是 &, | 和 ^。\n自 3.12 版本弃用: 使用按位取反运算符 ~ 已被弃用并将在 Python 3.16 中引发错误。\nbool 是 int 的子类 (参见 数字类型 --- int, float, complex)。 在许多数字场景下，False 和 True 的\n行为分别与整数 0 和 1 类似。 但是，不建议这样使用；请使用 int() 显式地执行转换。\n迭代器类型\nPython 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户\n自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。\n容器对象要提供 iterable 支持，必须定义一个方法:\ncontainer.__iter__()\n返回一个 iterator 对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类\n型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象\n的例子有同时支持广度优先和深度优先遍历的树结果。） 此方法对应于 Python/C API 中\nPython 对象类型结构体的 tp_iter 槽位。\n迭代器对象自身需要支持以下两个方法，它们共同组成了 迭代器协议:\niterator.__iter__()\n返回 iterator 对象本身。 这是同时允许容器和迭代器配合 for 和 in 语句使用所必须的。 此方\n法对应于 Python/C API 中 Python 对象类型结构体的 tp_iter 槽位。\niterator.__next__()\niterator 中返回下一项。 如果已经没有可返回的项，则会引发 StopIteration 异常。 此方法对\n应于 Python/C API 中 Python 对象类型结构体的 tp_iternext 槽位。\nPython 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。\n除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。\n\n|  | hash_value = (hash_value & (M - 1)) - (hash_value & M)\nif hash_value == -1:\nhash_value = -2\nreturn hash_value |  |\n| --- | --- | --- |\n|  | 布尔类型 - bool\n代表真值的布尔对象。 bool 类型只有两个常量实例: True 和 False。\n内置函数 bool() 可将任意值转换为布尔值，如果该值可以被解读为逻辑值的话（参见上面的 逻辑\n值检测 小节）。\n对于逻辑运算，请使用 布尔运算符 and, or 和 not。 当于两个布尔值应用按位运算符 &, |, ^ 时，\n它们将返回一个等价于逻辑运算 \"与\", \"或\", \"异或\" 的布尔值。 但是，更推荐使用逻辑运算符 and,\nor 和 != 而不是 &, | 和 ^。\n自 3.12 版本弃用: 使用按位取反运算符 ~ 已被弃用并将在 Python 3.16 中引发错误。\nbool 是 int 的子类 (参见 数字类型 --- int, float, complex)。 在许多数字场景下，False 和 True 的\n行为分别与整数 0 和 1 类似。 但是，不建议这样使用；请使用 int() 显式地执行转换。\n迭代器类型\nPython 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户\n自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。\n容器对象要提供 iterable 支持，必须定义一个方法:\ncontainer.__iter__()\n返回一个 iterator 对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类\n型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象\n的例子有同时支持广度优先和深度优先遍历的树结果。） 此方法对应于 Python/C API 中\nPython 对象类型结构体的 tp_iter 槽位。\n迭代器对象自身需要支持以下两个方法，它们共同组成了 迭代器协议:\niterator.__iter__()\n返回 iterator 对象本身。 这是同时允许容器和迭代器配合 for 和 in 语句使用所必须的。 此方\n法对应于 Python/C API 中 Python 对象类型结构体的 tp_iter 槽位。\niterator.__next__()\niterator 中返回下一项。 如果已经没有可返回的项，则会引发 StopIteration 异常。 此方法对\n应于 Python/C API 中 Python 对象类型结构体的 tp_iternext 槽位。\nPython 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。\n除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。 |  |\n\n一旦迭代器的 __next__() 方法引发了 StopIteration，它必须一直对后续调用引发同样的异常。\n不遵循此行为特性的实现将无法正常使用。\n生成器类型\nPython 的 generator 提供了一种实现迭代器协议的便捷方式。 如果一个容器对象的 __iter__() 方\n法以生成器的形式实现，它将自动返回一个提供 __iter__() 和 __next__() 方法的迭代器对象\n（从技术上说，是一个生成器对象）。 有关生成器的更多信息可参阅 yield 表达式的文档。\n序列类型 --- list, tuple, range\n有三种基本序列类型：list, tuple 和 range 对象。 为处理 二进制数据 和 文本字符串 而特别定制的附\n加序列类型会在专门的小节中描述。\n通用序列操作\n大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 collections.abc.Sequence\nABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。\n此表按优先级升序列出了序列操作。 在表格中，s 和 t 是具有相同类型的序列，n, i, j 和 k 是整数而\nx 是任何满足 s 所规定的类型和值限制的任意对象。\nin 和 not in 操作具有与比较操作相同的优先级。 + (拼接) 和 * (重复) 操作具有与对应数值运算相\n同的优先级。 [3]\n运算 结果： 备注\nx in s 如果 s 中的某项等于 x 则结果为 True，否则为 False (1)\nx not in s 如果 s 中的某项等于 x 则结果为 False，否则为 True (1)\ns + t s 与 t 相拼接 (6)(7)\ns * n 或 n * s 相当于 s 与自身进行 n 次拼接 (2)(7)\ns[i] s 的第 i 项，起始为 0 (3)(8)\ns[i:j] s 从 i 到 j 的切片 (3)(4)\ns[i:j:k] s 从 i 到 j 步长为 k 的切片 (3)(5)\nlen(s) s 的长度\nmin(s) s 的最小项\nmax(s) s 的最大项\n相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意\n味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 （完整细\n节请参阅语言参考的 比较运算 部分。）\n\n|  | 一旦迭代器的 __next__() 方法引发了 StopIteration，它必须一直对后续调用引发同样的异常。\n不遵循此行为特性的实现将无法正常使用。\n生成器类型\nPython 的 generator 提供了一种实现迭代器协议的便捷方式。 如果一个容器对象的 __iter__() 方\n法以生成器的形式实现，它将自动返回一个提供 __iter__() 和 __next__() 方法的迭代器对象\n（从技术上说，是一个生成器对象）。 有关生成器的更多信息可参阅 yield 表达式的文档。\n序列类型 --- list, tuple, range\n有三种基本序列类型：list, tuple 和 range 对象。 为处理 二进制数据 和 文本字符串 而特别定制的附\n加序列类型会在专门的小节中描述。\n通用序列操作\n大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 collections.abc.Sequence\nABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。\n此表按优先级升序列出了序列操作。 在表格中，s 和 t 是具有相同类型的序列，n, i, j 和 k 是整数而\nx 是任何满足 s 所规定的类型和值限制的任意对象。\nin 和 not in 操作具有与比较操作相同的优先级。 + (拼接) 和 * (重复) 操作具有与对应数值运算相\n同的优先级。 [3]\n运算 结果： 备注\nx in s 如果 s 中的某项等于 x 则结果为 True，否则为 False (1)\nx not in s 如果 s 中的某项等于 x 则结果为 False，否则为 True (1)\ns + t s 与 t 相拼接 (6)(7)\ns * n 或 n * s 相当于 s 与自身进行 n 次拼接 (2)(7)\ns[i] s 的第 i 项，起始为 0 (3)(8)\ns[i:j] s 从 i 到 j 的切片 (3)(4)\ns[i:j:k] s 从 i 到 j 步长为 k 的切片 (3)(5)\nlen(s) s 的长度\nmin(s) s 的最小项\nmax(s) s 的最大项\n相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意\n味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 （完整细\n节请参阅语言参考的 比较运算 部分。） |  |\n| --- | --- | --- |\n\n| 运算 | 结果： | 备注 |\n| --- | --- | --- |\n| x in s | 如果 s 中的某项等于 x 则结果为 True，否则为 False | (1) |\n| x not in s | 如果 s 中的某项等于 x 则结果为 False，否则为 True | (1) |\n| s + t | s 与 t 相拼接 | (6)(7) |\n| s * n 或 n * s | 相当于 s 与自身进行 n 次拼接 | (2)(7) |\n| s[i] | s 的第 i 项，起始为 0 | (3)(8) |\n| s[i:j] | s 从 i 到 j 的切片 | (3)(4) |\n| s[i:j:k] | s 从 i 到 j 步长为 k 的切片 | (3)(5) |\n| len(s) | s 的长度 |  |\n| min(s) | s 的最小项 |  |\n| max(s) | s 的最大项 |  |\n\n可变序列的正向和逆向迭代器使用一个索引来访问值。 即使底层序列被改变该索引也将持续向前\n（或向后）步进。 迭代器只有在遇到 IndexError 或 a StopIteration 时才会终结（或是当索引降\n至零以下）。\n注释：\n1. 虽然 in 和 not in 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 str,\nbytes 和 bytearray) 也使用它们进行子序列检测:\n>>> \"gg\" in \"eggs\"\nTrue\n2. 小于 0 的 n 值会被当作 0 来处理 (生成一个与 s 同类型的空序列)。 请注意序列 s 中的项并不\n会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:\n>>> lists = [[]] * 3\n>>> lists\n[[], [], []]\n>>> lists[0].append(3)\n>>> lists\n[[3], [3], [3]]\n具体的原因在于 [[]] 是一个包含了一个空列表的单元素列表，所以 [[]] * 3 结果中的三个\n元素都是对这一个空列表的引用。 修改 lists 中的任何一个元素实际上都是对这一个空列表\n的修改。 你可以用以下方式创建以不同列表为元素的列表:\n>>> lists = [[] for i in range(3)]\n>>> lists[0].append(3)\n>>> lists[1].append(5)\n>>> lists[2].append(7)\n>>> lists\n[[3], [5], [7]]\n进一步的解释可以在 FAQ 条目 如何创建多维列表？ 中查看。\n3. 如果 i 或 j 为负值，则索引顺序是相对于序列 s 的末尾: 索引号会被替换为 len(s) + i 或\nlen(s) + j。 但要注意 -0 仍然为 0。\n4. s 从 i 到 j 的切片被定义为所有满足 i <= k < j 的索引号 k 的项组成的序列。 如果 i 或 j 大\n于 len(s)，则使用 len(s)。 如果 i 被省略或为 None，则使用 0。 如果 j 被省略或为\nNone，则使用 len(s)。 如果 i 大于等于 j，则切片为空。\n5. s 从 i 到 j 步长为 k 的切片被定义为所有满足 0 <= n < (j-i)/k 的索引号 x = i + n*k 的\n项组成的序列。 换句话说，索引号为 i, i+k, i+2*k, i+3*k，以此类推，当达到 j 时停止 (但\n一定不包括 j)。 当 k 为正值时，i 和 j 会被减至不大于 len(s)。 当 k 为负值时，i 和 j 会被减\n至不大于 len(s) - 1。 如果 i 或 j 被省略或为 None，它们会成为“终止”值 (是哪一端的终止\n值则取决于 k 的符号)。 请注意，k 不可为零。 如果 k 为 None，则当作 1 处理。\n6. 拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会\n基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：\n\n|  | 可变序列的正向和逆向迭代器使用一个索引来访问值。 即使底层序列被改变该索引也将持续向前\n（或向后）步进。 迭代器只有在遇到 IndexError 或 a StopIteration 时才会终结（或是当索引降\n至零以下）。\n注释：\n1. 虽然 in 和 not in 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 str,\nbytes 和 bytearray) 也使用它们进行子序列检测:\n>>> \"gg\" in \"eggs\"\nTrue\n2. 小于 0 的 n 值会被当作 0 来处理 (生成一个与 s 同类型的空序列)。 请注意序列 s 中的项并不\n会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:\n>>> lists = [[]] * 3\n>>> lists\n[[], [], []]\n>>> lists[0].append(3)\n>>> lists\n[[3], [3], [3]]\n具体的原因在于 [[]] 是一个包含了一个空列表的单元素列表，所以 [[]] * 3 结果中的三个\n元素都是对这一个空列表的引用。 修改 lists 中的任何一个元素实际上都是对这一个空列表\n的修改。 你可以用以下方式创建以不同列表为元素的列表:\n>>> lists = [[] for i in range(3)]\n>>> lists[0].append(3)\n>>> lists[1].append(5)\n>>> lists[2].append(7)\n>>> lists\n[[3], [5], [7]]\n进一步的解释可以在 FAQ 条目 如何创建多维列表？ 中查看。\n3. 如果 i 或 j 为负值，则索引顺序是相对于序列 s 的末尾: 索引号会被替换为 len(s) + i 或\nlen(s) + j。 但要注意 -0 仍然为 0。\n4. s 从 i 到 j 的切片被定义为所有满足 i <= k < j 的索引号 k 的项组成的序列。 如果 i 或 j 大\n于 len(s)，则使用 len(s)。 如果 i 被省略或为 None，则使用 0。 如果 j 被省略或为\nNone，则使用 len(s)。 如果 i 大于等于 j，则切片为空。\n5. s 从 i 到 j 步长为 k 的切片被定义为所有满足 0 <= n < (j-i)/k 的索引号 x = i + n*k 的\n项组成的序列。 换句话说，索引号为 i, i+k, i+2*k, i+3*k，以此类推，当达到 j 时停止 (但\n一定不包括 j)。 当 k 为正值时，i 和 j 会被减至不大于 len(s)。 当 k 为负值时，i 和 j 会被减\n至不大于 len(s) - 1。 如果 i 或 j 被省略或为 None，它们会成为“终止”值 (是哪一端的终止\n值则取决于 k 的符号)。 请注意，k 不可为零。 如果 k 为 None，则当作 1 处理。\n6. 拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会\n基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一： |  |\n| --- | --- | --- |\n\n如果拼接 str 对象，你可以构建一个列表并在最后使用 str.join() 或是写入一个\nio.StringIO 实例并在结束时获取它的值\n如果拼接 bytes 对象，你可以类似地使用 bytes.join() 或 io.BytesIO，或者你也可以\n使用 bytearray 对象进行原地拼接。 bytearray 对象是可变的，并且具有高效的重分配\n机制\n如果拼接 tuple 对象，请改为扩展 list 类\n对于其它类型，请查看相应的文档\n7. 某些序列类型 (例如 range) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。\n8. 如果 i 超出了序列范围则会引发 IndexError。\n序列方法\n序列类型还支持下列方法：\nsequence.count(value, /)\n返回 value 在 sequence 中出现的总次数。\nsequence.index(value[, start[, stop])\n返回 value 在 sequence 中首次出现所在的索引号。\n如果 value 不存在于 sequence 中则会引发 ValueError。\nstart 或 stop 参数允许对序列的一部分进行高效搜索，从 start 开始到 stop 结束。 这大致等价于\nstart + sequence[start:stop].index(value)，但不会拷贝任何数据。, only without\ncopying any data.\n小心: 不是所有序列都支持传入 start 和 stop 参数。\n不可变序列类型\n不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 hash() 内置函数的支持。\n这种支持允许不可变类型，例如 tuple 实例被用作 dict 键，以及存储在 set 和 frozenset 实例\n中。\n尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 TypeError。\n可变序列类型\n以下表格中的操作是在可变序列类型上定义的。 collections.abc.MutableSequence ABC 被提供\n用来更容易地在自定义序列类型上正确实现这些操作。\n表格中的 s 是可变序列类型的实例，t 是任意可迭代对象，而 x 是符合对 s 所规定类型与值限制的任\n何对象 (例如，bytearray 仅接受满足 0 <= x <= 255 值限制的整数)。\n\n|  | 如果拼接 str 对象，你可以构建一个列表并在最后使用 str.join() 或是写入一个\nio.StringIO 实例并在结束时获取它的值\n如果拼接 bytes 对象，你可以类似地使用 bytes.join() 或 io.BytesIO，或者你也可以\n使用 bytearray 对象进行原地拼接。 bytearray 对象是可变的，并且具有高效的重分配\n机制\n如果拼接 tuple 对象，请改为扩展 list 类\n对于其它类型，请查看相应的文档\n7. 某些序列类型 (例如 range) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。\n8. 如果 i 超出了序列范围则会引发 IndexError。\n序列方法\n序列类型还支持下列方法：\nsequence.count(value, /)\n返回 value 在 sequence 中出现的总次数。\nsequence.index(value[, start[, stop])\n返回 value 在 sequence 中首次出现所在的索引号。\n如果 value 不存在于 sequence 中则会引发 ValueError。\nstart 或 stop 参数允许对序列的一部分进行高效搜索，从 start 开始到 stop 结束。 这大致等价于\nstart + sequence[start:stop].index(value)，但不会拷贝任何数据。, only without\ncopying any data.\n小心: 不是所有序列都支持传入 start 和 stop 参数。\n不可变序列类型\n不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 hash() 内置函数的支持。\n这种支持允许不可变类型，例如 tuple 实例被用作 dict 键，以及存储在 set 和 frozenset 实例\n中。\n尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 TypeError。\n可变序列类型\n以下表格中的操作是在可变序列类型上定义的。 collections.abc.MutableSequence ABC 被提供\n用来更容易地在自定义序列类型上正确实现这些操作。\n表格中的 s 是可变序列类型的实例，t 是任意可迭代对象，而 x 是符合对 s 所规定类型与值限制的任\n何对象 (例如，bytearray 仅接受满足 0 <= x <= 255 值限制的整数)。 |  |\n| --- | --- | --- |\n\n运算 结果： 备注\ns[i] = x 将 s 的第 i 项替换为 x\ndel s[i] 移除 s 的 i 号项。\ns[i:j] = t 将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容\ndel s[i:j] 从列表中移除切片 s[i:j] 的元素（等同于执行 s[i:j] = [] 操作）\ns[i:j:k] = t 将 s[i:j:k] 的元素替换为 t 的元素 (1)\ndel s[i:j:k] 从列表中移除 s[i:j:k] 的元素\ns += t 用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t)\ns *= n 使用 s 的内容重复 n 次来对其进行更新 (2)\n注释：\n1. 如果 k 不等于 1，则 t 必须与它所替换的切片具有相同的长度。\n2. n 值为一个整数，或是一个实现了 __index__() 的对象。 n 值为零或负数将清空序列。 序列\n中的项不会被拷贝；它们会被多次引用，正如 通用序列操作 中有关 s * n 的说明。\n可变序列方法\n可变序列类型还支持下列方法：\nsequence.append(value, /)\n将 value 添加到序列的末尾。 这等价于 seq[len(seq):len(seq)] = [value]。\nsequence.clear()\nAdded in version 3.3.\n移除 sequence 中的所有条目。 这等价于 del sequence[:]。\nsequence.copy()\nAdded in version 3.3.\n创建 sequence 的浅拷贝。 这等价于 sequence[:]。\n提示: copy() 方法不是 MutableSequence ABC 的一部分，但大多数实体可变序列类型都提\n供此方法。\nsequence.extend(iterable, /)\n使用 iterable 的内容扩展 sequence。 大体上，这与 seq[len(seq):len(seq)] = iterable 相\n同。\n\n|  | 运算 结果： 备注\ns[i] = x 将 s 的第 i 项替换为 x\ndel s[i] 移除 s 的 i 号项。\ns[i:j] = t 将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容\ndel s[i:j] 从列表中移除切片 s[i:j] 的元素（等同于执行 s[i:j] = [] 操作）\ns[i:j:k] = t 将 s[i:j:k] 的元素替换为 t 的元素 (1)\ndel s[i:j:k] 从列表中移除 s[i:j:k] 的元素\ns += t 用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t)\ns *= n 使用 s 的内容重复 n 次来对其进行更新 (2)\n注释：\n1. 如果 k 不等于 1，则 t 必须与它所替换的切片具有相同的长度。\n2. n 值为一个整数，或是一个实现了 __index__() 的对象。 n 值为零或负数将清空序列。 序列\n中的项不会被拷贝；它们会被多次引用，正如 通用序列操作 中有关 s * n 的说明。\n可变序列方法\n可变序列类型还支持下列方法：\nsequence.append(value, /)\n将 value 添加到序列的末尾。 这等价于 seq[len(seq):len(seq)] = [value]。\nsequence.clear()\nAdded in version 3.3.\n移除 sequence 中的所有条目。 这等价于 del sequence[:]。\nsequence.copy()\nAdded in version 3.3.\n创建 sequence 的浅拷贝。 这等价于 sequence[:]。\n提示: copy() 方法不是 MutableSequence ABC 的一部分，但大多数实体可变序列类型都提\n供此方法。\nsequence.extend(iterable, /)\n使用 iterable 的内容扩展 sequence。 大体上，这与 seq[len(seq):len(seq)] = iterable 相\n同。 |  |\n| --- | --- | --- |\n\n| 运算 | 结果： | 备注 |\n| --- | --- | --- |\n| s[i] = x | 将 s 的第 i 项替换为 x |  |\n| del s[i] | 移除 s 的 i 号项。 |  |\n| s[i:j] = t | 将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容 |  |\n| del s[i:j] | 从列表中移除切片 s[i:j] 的元素（等同于执行 s[i:j] = [] 操作） |  |\n| s[i:j:k] = t | 将 s[i:j:k] 的元素替换为 t 的元素 | (1) |\n| del s[i:j:k] | 从列表中移除 s[i:j:k] 的元素 |  |\n| s += t | 用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t) |  |\n| s *= n | 使用 s 的内容重复 n 次来对其进行更新 | (2) |\n\nsequence.insert(index, value, /)\n将 value 在给定的 index 位置插入到 sequence 中。 这等价于 sequence[index:index] =\n[value]。\nsequence.pop(index=-1, /)\n提取位于 index 上的条目并从 sequence 中将其移除。 在默认情况下，将移除并返回 sequence\n中的最后一个条目。\nsequence.remove(value, /)\n从 sequence 中移除满足 sequence[i] == value 的第一个条目。\n如果 value 不存在于 sequence 中则会引发 ValueError。\nsequence.reverse()\n原地反转 sequence 的条目。 此方法会在反转大尺寸序列时保持空间经济性。 为提醒用户此操\n作是通过间接影响进行的，它的返回值为 None。\n列表\n列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。\nclass list(iterable=(), /)\n可以用多种方式构建列表：\n使用一对方括号来表示空列表: []\n使用方括号，其中的项以逗号分隔: [a], [a, b, c]\n使用列表推导式: [x for x in iterable]\n使用类型的构造器: list() 或 list(iterable)\n构造器将构造一个列表，其中的项与 iterable 中的项具有相同的的值与顺序。 iterable 可以是序\n列、支持迭代的容器或其它可迭代对象。 如果 iterable 已经是一个列表，将创建并返回其副\n本，类似于 iterable[:]。 例如，list('abc') 返回 ['a', 'b', 'c'] 而 list( (1, 2,\n3) ) 返回 [1, 2, 3]。 如果没有给出参数，构造器将创建一个空列表 []。\n其它许多操作也会产生列表，包括 sorted() 内置函数。\n列表实现了所有 一般 和 可变 序列的操作。 列表还额外提供了以下方法：\nsort(*, key=None, reverse=False)\n此方法会对列表进行原地排序，只使用 < 来进行各项间比较。 异常不会被屏蔽 —— 如果\n有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。\nsort() 接受两个仅限以关键字形式传入的参数 (仅限关键字参数):\nkey 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如\nkey=str.lower)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使\n用。 默认值 None 表示直接对列表项排序而不计算一个单独的键值。\n\n|  |  |  | sequence.insert(index, value, /)\n将 value 在给定的 index 位置插入到 sequence 中。 这等价于 sequence[index:index] =\n[value]。\nsequence.pop(index=-1, /)\n提取位于 index 上的条目并从 sequence 中将其移除。 在默认情况下，将移除并返回 sequence\n中的最后一个条目。\nsequence.remove(value, /)\n从 sequence 中移除满足 sequence[i] == value 的第一个条目。\n如果 value 不存在于 sequence 中则会引发 ValueError。\nsequence.reverse()\n原地反转 sequence 的条目。 此方法会在反转大尺寸序列时保持空间经济性。 为提醒用户此操\n作是通过间接影响进行的，它的返回值为 None。\n列表\n列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。\nclass list(iterable=(), /)\n可以用多种方式构建列表：\n使用一对方括号来表示空列表: []\n使用方括号，其中的项以逗号分隔: [a], [a, b, c]\n使用列表推导式: [x for x in iterable]\n使用类型的构造器: list() 或 list(iterable)\n构造器将构造一个列表，其中的项与 iterable 中的项具有相同的的值与顺序。 iterable 可以是序\n列、支持迭代的容器或其它可迭代对象。 如果 iterable 已经是一个列表，将创建并返回其副\n本，类似于 iterable[:]。 例如，list('abc') 返回 ['a', 'b', 'c'] 而 list( (1, 2,\n3) ) 返回 [1, 2, 3]。 如果没有给出参数，构造器将创建一个空列表 []。\n其它许多操作也会产生列表，包括 sorted() 内置函数。\n列表实现了所有 一般 和 可变 序列的操作。 列表还额外提供了以下方法：\nsort(*, key=None, reverse=False)\n此方法会对列表进行原地排序，只使用 < 来进行各项间比较。 异常不会被屏蔽 —— 如果\n有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。\nsort() 接受两个仅限以关键字形式传入的参数 (仅限关键字参数):\nkey 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如\nkey=str.lower)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使\n用。 默认值 None 表示直接对列表项排序而不计算一个单独的键值。 |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  |  | sequence[index:index] = |  |\n|  |  |  |  |  |  |\n|  |  |  | [value |  |  |\n|  |  |  |  |  |  |\n|  |  |  | 3) ) |  |  |\n|  |  |  |  |  |  |\n\n| list( (1, 2, |  |\n| --- | --- |\n\n可以使用 functools.cmp_to_key() 将 2.x 风格的 cmp 函数转换为 key 函数。\nreverse 为一个布尔值。 如果设为 True，则每个列表元素将按反向顺序比较进行排序。\n当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通\n过间接影响进行的，它并不会返回排序后的序列（请使用 sorted() 显示地请求一个新的\n已排序列表实例）。\nsort() 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序\n就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再接薪级排序）。\n有关排序示例和简要排序教程，请参阅 排序的技术 。\n在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实\n现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发\nValueError。\n元组\n元组是不可变序列，通常用于储存异构数据的多项集（例如由 enumerate() 内置函数所产生的二元\n组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 set 或 dict 的实例）。\nclass tuple(iterable=(), /)\n可以用多种方式构建元组：\n使用一对圆括号来表示空元组: ()\n使用一个后缀的逗号来表示单元组: a, 或 (a,)\n使用以逗号分隔的多个项: a, b, c or (a, b, c)\n使用内置的 tuple(): tuple() 或 tuple(iterable)\n构造器将构造一个元组，其中的项与 iterable 中的项具有相同的值与顺序。 iterable 可以是序\n列、支持迭代的容器或其他可迭代对象。 如果 iterable 已经是一个元组，会不加改变地将其返\n回。 例如，tuple('abc') 返回 ('a', 'b', 'c') 而 tuple( [1, 2, 3] ) 返回 (1, 2,\n3)。 如果没有给出参数，构造器将创建一个空元组 ()。\n请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免\n语法歧义的情况除外。 例如，f(a, b, c) 是在调用函数时附带三个参数，而 f((a, b, c))\n则是在调用函数时附带一个三元组。\n元组实现了所有 一般 序列的操作。\n对于通过名称访问相比通过索引访问更清晰的异构数据多项集，collections.namedtuple() 可能\n是比简单元组对象更为合适的选择。\nrange 对象\nrange 类型表示不可变的数字序列，通常用于在 for 循环中循环指定的次数。\nclass range(stop, /)\n\n|  | 可以使用 functools.cmp_to_key() 将 2.x 风格的 cmp 函数转换为 key 函数。\nreverse 为一个布尔值。 如果设为 True，则每个列表元素将按反向顺序比较进行排序。\n当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通\n过间接影响进行的，它并不会返回排序后的序列（请使用 sorted() 显示地请求一个新的\n已排序列表实例）。\nsort() 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序\n就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再接薪级排序）。\n有关排序示例和简要排序教程，请参阅 排序的技术 。\n在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实\n现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发\nValueError。\n元组\n元组是不可变序列，通常用于储存异构数据的多项集（例如由 enumerate() 内置函数所产生的二元\n组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 set 或 dict 的实例）。\nclass tuple(iterable=(), /)\n可以用多种方式构建元组：\n使用一对圆括号来表示空元组: ()\n使用一个后缀的逗号来表示单元组: a, 或 (a,)\n使用以逗号分隔的多个项: a, b, c or (a, b, c)\n使用内置的 tuple(): tuple() 或 tuple(iterable)\n构造器将构造一个元组，其中的项与 iterable 中的项具有相同的值与顺序。 iterable 可以是序\n列、支持迭代的容器或其他可迭代对象。 如果 iterable 已经是一个元组，会不加改变地将其返\n回。 例如，tuple('abc') 返回 ('a', 'b', 'c') 而 tuple( [1, 2, 3] ) 返回 (1, 2,\n3)。 如果没有给出参数，构造器将创建一个空元组 ()。\n请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免\n语法歧义的情况除外。 例如，f(a, b, c) 是在调用函数时附带三个参数，而 f((a, b, c))\n则是在调用函数时附带一个三元组。\n元组实现了所有 一般 序列的操作。\n对于通过名称访问相比通过索引访问更清晰的异构数据多项集，collections.namedtuple() 可能\n是比简单元组对象更为合适的选择。\nrange 对象\nrange 类型表示不可变的数字序列，通常用于在 for 循环中循环指定的次数。\nclass range(stop, /) |  |\n| --- | --- | --- |\n|  | 3) |  |\n|  |  |  |\n\nclass range(start, stop, step=1, /)\nrange 构造器的参数必须为整数（可以是内置的 int 或任何实现了 __index__() 特殊方法的对\n象）。 如果省略 step 参数，则默认为 1。 如果省略 start 参数，则默认为 0。 如果 step 为\n零，则会引发 ValueError。\n如果 step 为正值，确定 range r 内容的公式为 r[i] = start + step*i 其中 i >= 0 且 r[i]\n< stop。\n如果 step 为负值，确定 range 内容的公式仍然为 r[i] = start + step*i，但限制条件改为\ni >= 0 且 r[i] > stop.\n如果 r[0] 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会\n将其解读为从正索引所确定的序列的末尾开始索引。\n元素绝对值大于 sys.maxsize 的 range 对象是被允许的，但某些特性 (例如 len()) 可能引发\nOverflowError。\n一些 range 对象的例子:\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> list(range(0, 30, 5))\n[0, 5, 10, 15, 20, 25]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(0, -10, -1))\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n>>> list(range(0))\n[]\n>>> list(range(1, 0))\n[]\nrange 对象实现了 一般 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符\n合严格模式的序列，而重复和拼接通常都会违反这样的模式）。\nstart\nstart 形参的值 (如果该形参未提供则为 0)\nstop\nstop 形参的值\nstep\nstep 形参的值 (如果该形参未提供则为 1)\nrange 类型相比常规 list 或 tuple 的优势在于一个 range 对象总是占用固定数量的（较小）内\n存，不论其所表示的范围有多大（因为它只保存了 start, stop 和 step 值，并会根据需要计算具\n体单项或子范围的值）。\n\n|  | class range(start, stop, step=1, /)\nrange 构造器的参数必须为整数（可以是内置的 int 或任何实现了 __index__() 特殊方法的对\n象）。 如果省略 step 参数，则默认为 1。 如果省略 start 参数，则默认为 0。 如果 step 为\n零，则会引发 ValueError。\n如果 step 为正值，确定 range r 内容的公式为 r[i] = start + step*i 其中 i >= 0 且 r[i]\n< stop。\n如果 step 为负值，确定 range 内容的公式仍然为 r[i] = start + step*i，但限制条件改为\ni >= 0 且 r[i] > stop.\n如果 r[0] 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会\n将其解读为从正索引所确定的序列的末尾开始索引。\n元素绝对值大于 sys.maxsize 的 range 对象是被允许的，但某些特性 (例如 len()) 可能引发\nOverflowError。\n一些 range 对象的例子:\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> list(range(0, 30, 5))\n[0, 5, 10, 15, 20, 25]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(0, -10, -1))\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n>>> list(range(0))\n[]\n>>> list(range(1, 0))\n[]\nrange 对象实现了 一般 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符\n合严格模式的序列，而重复和拼接通常都会违反这样的模式）。\nstart\nstart 形参的值 (如果该形参未提供则为 0)\nstop\nstop 形参的值\nstep\nstep 形参的值 (如果该形参未提供则为 1)\nrange 类型相比常规 list 或 tuple 的优势在于一个 range 对象总是占用固定数量的（较小）内\n存，不论其所表示的范围有多大（因为它只保存了 start, stop 和 step 值，并会根据需要计算具\n体单项或子范围的值）。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | r[i] |  |  |\n|  |  |  |  |  |\n\nrange 对象实现了 collections.abc.Sequence ABC，提供如包含检测、元素索引查找、切片等特\n性，并支持负索引 (参见 序列类型 --- list, tuple, range):\n>>> r = range(0, 20, 2)\n>>> r\nrange(0, 20, 2)\n>>> 11 in r\nFalse\n>>> 10 in r\nTrue\n>>> r.index(10)\n5\n>>> r[5]\n10\n>>> r[:5]\nrange(0, 10, 2)\n>>> r[-1]\n18\n使用 == 和 != 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象\n表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同\n的 start, stop 和 step 属性，例如 range(0) == range(2, 1, 3) 而 range(0, 3, 2) ==\nrange(0, 4, 2)。）\n在 3.2 版本发生变更: 实现 Sequence ABC。 支持切片和负数索引。 使用 int 对象在固定时间\n内进行成员检测，而不是逐一迭代所有项。\n在 3.3 版本发生变更: 定义 '==' 和 '!=' 以根据 range 对象所定义的值序列来进行比较（而不是\n根据对象的标识）。\n增加了 start, stop 和 step 属性。\n参见:\nlinspace recipe 演示了如何实现一个惰性求值版本的适合浮点数应用的 range 对象。\n文本和二进制序列类型方法摘要\n下表按类别总结了文本和二进制序列类型方法。\n类别 str 方法 bytes 和 bytearray 方法\nstr.format()\nstr.format_map()\n格式化\nf-字符串\nprintf 风格的字符串格式化 printf 风格的字节串格式化\n搜索和替换 str.find() str.rfind() bytes.find() bytes.rfind()\n\n|  |  | range 对象实现了 collections.abc.Sequence ABC，提供如包含检测、元素索引查找、切片等特\n性，并支持负索引 (参见 序列类型 --- list, tuple, range): |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | >>> r = range(0, 20, 2)\n>>> r\nrange(0, 20, 2)\n>>> 11 in r\nFalse\n>>> 10 in r\nTrue\n>>> r.index(10)\n5\n>>> r[5]\n10\n>>> r[:5]\nrange(0, 10, 2)\n>>> r[-1]\n18 |  |  |\n|  |  | 使用 == 和 != 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象\n表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同\n的 start, stop 和 step 属性，例如 range(0) == range(2, 1, 3) 而 range(0, 3, 2) ==\nrange(0, 4, 2)。）\n在 3.2 版本发生变更: 实现 Sequence ABC。 支持切片和负数索引。 使用 int 对象在固定时间\n内进行成员检测，而不是逐一迭代所有项。\n在 3.3 版本发生变更: 定义 '==' 和 '!=' 以根据 range 对象所定义的值序列来进行比较（而不是\n根据对象的标识）。\n增加了 start, stop 和 step 属性。 |  |  |\n|  |  |  |  |  |\n|  |  |  |  |  |\n|  |  | range(0, 4, 2) |  |  |\n|  |  |  |  |  |\n|  |  | 参见:\nlinspace recipe 演示了如何实现一个惰性求值版本的适合浮点数应用的 range 对象。 |  |  |\n|  |  | 文本和二进制序列类型方法摘要\n下表按类别总结了文本和二进制序列类型方法。\n类别 str 方法 bytes 和 bytearray 方法\nstr.format()\nstr.format_map()\n格式化\nf-字符串\nprintf 风格的字符串格式化 printf 风格的字节串格式化\n搜索和替换 str.find() str.rfind() bytes.find() bytes.rfind() |  |  |\n\n| 类别 | str 方法 |  | bytes 和 bytearray 方法 |  |\n| --- | --- | --- | --- | --- |\n| 格式化 | str.format() |  |  |  |\n|  | str.format_map() |  |  |  |\n|  | f-字符串 |  |  |  |\n|  | printf 风格的字符串格式化 |  | printf 风格的字节串格式化 |  |\n|  | str.find() | str.rfind() | bytes.find() | bytes.rfind() |\n\n类别 str 方法 bytes 和 bytearray 方法\nstr.index() str.rindex() bytes.index() bytes.rindex()\nstr.startswith() bytes.startswith()\nstr.endswith() bytes.endswith()\nstr.count() bytes.count()\nstr.replace() bytes.replace()\nstr.split() str.rsplit() bytes.split() bytes.rsplit()\nstr.splitlines() bytes.splitlines()\n拆分与合并 str.partition() bytes.partition()\nstr.rpartition() bytes.rpartition()\nstr.join() bytes.join()\nstr.isalpha() bytes.isalpha()\nstr.isdecimal()\nstr.isdigit() bytes.isdigit()\nstr.isnumeric()\nstr.isalnum() bytes.isalnum()\n字符串分类 str.isidentifier()\nstr.islower() bytes.islower()\nstr.isupper() bytes.isupper()\nstr.istitle() bytes.istitle()\nstr.isspace() bytes.isspace()\nstr.isprintable()\nstr.lower() bytes.lower()\nstr.upper() bytes.upper()\nstr.casefold()\n大小写操作\nstr.capitalize() bytes.capitalize()\nstr.title() bytes.title()\nstr.swapcase() bytes.swapcase()\n填充与去除 str.ljust() str.rjust() bytes.ljust() bytes.rjust()\nstr.center() bytes.center()\n\n|  | 类别 str 方法 bytes 和 bytearray 方法\nstr.index() str.rindex() bytes.index() bytes.rindex()\nstr.startswith() bytes.startswith()\nstr.endswith() bytes.endswith()\nstr.count() bytes.count()\nstr.replace() bytes.replace()\nstr.split() str.rsplit() bytes.split() bytes.rsplit()\nstr.splitlines() bytes.splitlines()\n拆分与合并 str.partition() bytes.partition()\nstr.rpartition() bytes.rpartition()\nstr.join() bytes.join()\nstr.isalpha() bytes.isalpha()\nstr.isdecimal()\nstr.isdigit() bytes.isdigit()\nstr.isnumeric()\nstr.isalnum() bytes.isalnum()\n字符串分类 str.isidentifier()\nstr.islower() bytes.islower()\nstr.isupper() bytes.isupper()\nstr.istitle() bytes.istitle()\nstr.isspace() bytes.isspace()\nstr.isprintable()\nstr.lower() bytes.lower()\nstr.upper() bytes.upper()\nstr.casefold()\n大小写操作\nstr.capitalize() bytes.capitalize()\nstr.title() bytes.title()\nstr.swapcase() bytes.swapcase()\n填充与去除 str.ljust() str.rjust() bytes.ljust() bytes.rjust()\nstr.center() bytes.center() |  |\n| --- | --- | --- |\n\n| 类别 | str 方法 |  | bytes 和 bytearray 方法 |  |\n| --- | --- | --- | --- | --- |\n|  | str.index() | str.rindex() | bytes.index() | bytes.rindex() |\n|  | str.startswith() |  | bytes.startswith() |  |\n|  | str.endswith() |  | bytes.endswith() |  |\n|  | str.count() |  | bytes.count() |  |\n|  | str.replace() |  | bytes.replace() |  |\n| 拆分与合并 | str.split() | str.rsplit() | bytes.split() | bytes.rsplit() |\n|  | str.splitlines() |  | bytes.splitlines() |  |\n|  | str.partition() |  | bytes.partition() |  |\n|  | str.rpartition() |  | bytes.rpartition() |  |\n|  | str.join() |  | bytes.join() |  |\n| 字符串分类 | str.isalpha() |  | bytes.isalpha() |  |\n|  | str.isdecimal() |  |  |  |\n|  | str.isdigit() |  | bytes.isdigit() |  |\n|  | str.isnumeric() |  |  |  |\n|  | str.isalnum() |  | bytes.isalnum() |  |\n|  | str.isidentifier() |  |  |  |\n|  | str.islower() |  | bytes.islower() |  |\n|  | str.isupper() |  | bytes.isupper() |  |\n|  | str.istitle() |  | bytes.istitle() |  |\n|  | str.isspace() |  | bytes.isspace() |  |\n|  | str.isprintable() |  |  |  |\n| 大小写操作 | str.lower() |  | bytes.lower() |  |\n|  | str.upper() |  | bytes.upper() |  |\n|  | str.casefold() |  |  |  |\n|  | str.capitalize() |  | bytes.capitalize() |  |\n|  | str.title() |  | bytes.title() |  |\n|  | str.swapcase() |  | bytes.swapcase() |  |\n|  | str.ljust() | str.rjust() | bytes.ljust() | bytes.rjust() |\n|  | str.center() |  | bytes.center() |  |\n\n类别 str 方法 bytes 和 bytearray 方法\nstr.expandtabs() bytes.expandtabs()\nstr.strip() bytes.strip()\nstr.lstrip() str.rstrip() bytes.lstrip() bytes.rstrip()\nstr.translate() bytes.translate()\nstr.maketrans() bytes.maketrans()\n转写和编码格式\nstr.encode()\nbytes.decode()\n文本序列类型 --- str\n在 Python 中处理文本数据是使用 str 对象，也称为 字符串。 字符串是由 Unicode 码位构成的不可\n变 序列。 字符串字面值有多种不同的写法：\n单引号: '允许包含有 \"双\" 引号'\n双引号: \"允许嵌入 '单' 引号\"\n三重引号: '''三重单引号''', \"\"\"三重双引号\"\"\"\n使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。\n作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字\n面值。 也就是说，(\"spam \" \"eggs\") == \"spam eggs\"。\n请参阅 字符串与字节串字面量 了解有关各种字符串字面值形式的更多信息，包括所支持的 转义序\n列，以及禁用大多数转义序列处理的 r (\"raw\") 前缀。\n字符串也可以通过使用 str 构造器从其他对象创建。\n由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对\n于一个非空字符串 s, s[0] == s[0:1]。\n不存在可变的字符串类型，但是 str.join() 或 io.StringIO 可以被被用来根据多个片段高效率地\n构建字符串。\n在 3.3 版本发生变更: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 u 前缀。\n它对字符串字面值的含义没有影响，并且不能与 r 前缀同时出现。\nclass str(*, encoding='utf-8', errors='strict')\nclass str(object)\nclass str(object, encoding, errors='strict')\nclass str(object, *, errors)\n返回 object 的 字符串 版本。 如果未提供 object 则返回空字符串。 在其他情况下 str() 的行为\n取决于 encoding 或 errors 是否有给出，具体见下。\n\n|  | 类别 str 方法 bytes 和 bytearray 方法\nstr.expandtabs() bytes.expandtabs()\nstr.strip() bytes.strip()\nstr.lstrip() str.rstrip() bytes.lstrip() bytes.rstrip()\nstr.translate() bytes.translate()\nstr.maketrans() bytes.maketrans()\n转写和编码格式\nstr.encode()\nbytes.decode()\n文本序列类型 --- str\n在 Python 中处理文本数据是使用 str 对象，也称为 字符串。 字符串是由 Unicode 码位构成的不可\n变 序列。 字符串字面值有多种不同的写法：\n单引号: '允许包含有 \"双\" 引号'\n双引号: \"允许嵌入 '单' 引号\"\n三重引号: '''三重单引号''', \"\"\"三重双引号\"\"\"\n使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。\n作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字\n面值。 也就是说，(\"spam \" \"eggs\") == \"spam eggs\"。\n请参阅 字符串与字节串字面量 了解有关各种字符串字面值形式的更多信息，包括所支持的 转义序\n列，以及禁用大多数转义序列处理的 r (\"raw\") 前缀。\n字符串也可以通过使用 str 构造器从其他对象创建。\n由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对\n于一个非空字符串 s, s[0] == s[0:1]。\n不存在可变的字符串类型，但是 str.join() 或 io.StringIO 可以被被用来根据多个片段高效率地\n构建字符串。\n在 3.3 版本发生变更: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 u 前缀。\n它对字符串字面值的含义没有影响，并且不能与 r 前缀同时出现。\nclass str(*, encoding='utf-8', errors='strict')\nclass str(object)\nclass str(object, encoding, errors='strict')\nclass str(object, *, errors)\n返回 object 的 字符串 版本。 如果未提供 object 则返回空字符串。 在其他情况下 str() 的行为\n取决于 encoding 或 errors 是否有给出，具体见下。 |  |\n| --- | --- | --- |\n\n| 类别 | str 方法 |  | bytes 和 bytearray 方法 |  |\n| --- | --- | --- | --- | --- |\n|  | str.expandtabs() |  | bytes.expandtabs() |  |\n|  | str.strip() |  | bytes.strip() |  |\n|  | str.lstrip() | str.rstrip() | bytes.lstrip() | bytes.rstrip() |\n| 转写和编码格式 | str.translate() |  | bytes.translate() |  |\n|  | str.maketrans() |  | bytes.maketrans() |  |\n|  | str.encode() |  |  |  |\n|  |  |  | bytes.decode() |  |\n\n如果 encoding 或 errors 均未给出，则 str(object) 将返回\ntype(object).__str__(object)，这是 object 的“非正式”而适合显示的字符串表示形式。 对\n于字符串对象，这就是该字符串本身。 如果 object 没有 __str__() 方法，则 str() 将回退为\n返回 repr(object)。\n如果 encoding 或 errors 至少给出其中之一，则 object 应该是一个 bytes-like object (例如\nbytes 或 bytearray)。 在此情况下，如果 object 是一个 bytes (或 bytearray) 对象，则\nstr(bytes, encoding, errors) 等价于 bytes.decode(encoding, errors)。 否则的话，\n会在调用 bytes.decode() 之前获取缓冲区对象下层的 bytes 对象。 请参阅 二进制序列类型 --\n- bytes, bytearray, memoryview 与 缓冲协议 了解有关缓冲区对象的信息。\n将一个 bytes 对象传入 str() 而不给出 encoding 或 errors 参数的操作属于第一种情况， 将返\n回非正式的字符串表示（另请参阅 Python 的 -b 命令行选项）。 例如:\n>>> str(b'Zoot!')\n\"b'Zoot!'\"\n有关 str 类及其方法的更多信息，请参阅下面的 文本序列类型 --- str 和 字符串的方法 小节。\n要输出格式化字符串，请参阅 f-字符串 和 格式字符串语法 小节。 此外还可以参阅 文本处理服\n务 小节。\n字符串的方法\n字符串实现了所有 一般 序列的操作，还额外提供了以下列出的一些附加方法。\n字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅\nstr.format(), 格式字符串语法 和 自定义字符串格式化) 而另一种是基于 C printf 样式的格式\n化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速\n(printf 风格的字符串格式化)。\n标准库的 文本处理服务 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 re 模块中\n的正则表达式支持）。\nstr.capitalize()\n返回原字符串的副本，其首个字符大写，其余为小写。\n在 3.8 版本发生变更: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复\n合字母类字符将只有首个字母改为大写，而再不是全部字符大写。\nstr.casefold()\n返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。\n消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形\n式。 例如，德语小写字母 'ß' 相当于 \"ss\"。 由于它已经是小写了，lower() 不会对 'ß' 做\n任何改变；而 casefold() 则会将其转换为 \"ss\"。\n大小写折叠算法在 Unicode 标准 3.13 节 'Default Case Folding' 中描述。\n\n|  | 如果 encoding 或 errors 均未给出，则 str(object) 将返回\ntype(object).__str__(object)，这是 object 的“非正式”而适合显示的字符串表示形式。 对\n于字符串对象，这就是该字符串本身。 如果 object 没有 __str__() 方法，则 str() 将回退为\n返回 repr(object)。\n如果 encoding 或 errors 至少给出其中之一，则 object 应该是一个 bytes-like object (例如\nbytes 或 bytearray)。 在此情况下，如果 object 是一个 bytes (或 bytearray) 对象，则\nstr(bytes, encoding, errors) 等价于 bytes.decode(encoding, errors)。 否则的话，\n会在调用 bytes.decode() 之前获取缓冲区对象下层的 bytes 对象。 请参阅 二进制序列类型 --\n- bytes, bytearray, memoryview 与 缓冲协议 了解有关缓冲区对象的信息。\n将一个 bytes 对象传入 str() 而不给出 encoding 或 errors 参数的操作属于第一种情况， 将返\n回非正式的字符串表示（另请参阅 Python 的 -b 命令行选项）。 例如:\n>>> str(b'Zoot!')\n\"b'Zoot!'\"\n有关 str 类及其方法的更多信息，请参阅下面的 文本序列类型 --- str 和 字符串的方法 小节。\n要输出格式化字符串，请参阅 f-字符串 和 格式字符串语法 小节。 此外还可以参阅 文本处理服\n务 小节。\n字符串的方法\n字符串实现了所有 一般 序列的操作，还额外提供了以下列出的一些附加方法。\n字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅\nstr.format(), 格式字符串语法 和 自定义字符串格式化) 而另一种是基于 C printf 样式的格式\n化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速\n(printf 风格的字符串格式化)。\n标准库的 文本处理服务 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 re 模块中\n的正则表达式支持）。\nstr.capitalize()\n返回原字符串的副本，其首个字符大写，其余为小写。\n在 3.8 版本发生变更: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复\n合字母类字符将只有首个字母改为大写，而再不是全部字符大写。\nstr.casefold()\n返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。\n消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形\n式。 例如，德语小写字母 'ß' 相当于 \"ss\"。 由于它已经是小写了，lower() 不会对 'ß' 做\n任何改变；而 casefold() 则会将其转换为 \"ss\"。\n大小写折叠算法在 Unicode 标准 3.13 节 'Default Case Folding' 中描述。 |  |\n| --- | --- | --- |\n\nAdded in version 3.3.\nstr.center(width, fillchar=' ', /)\n返回长度为 width 的居中字符串。 使用指定的 fillchar 填充空位（默认为 ASCII 空格）。 如果\nwidth 小于等于 len(s) 则返回原字符串。 例如:\n>>> 'Python'.center(10)\n' Python '\n>>> 'Python'.center(10, '-')\n'--Python--'\n>>> 'Python'.center(4)\n'Python'\nstr.count(sub[, start[, end]])\n返回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为\n切片表示法。\n如果 sub 为空，则返回字符之间的空字符串数，即字符串的长度加一。 例如:\n>>> 'spam, spam, spam'.count('spam')\n3\n>>> 'spam, spam, spam'.count('spam', 5)\n2\n>>> 'spam, spam, spam'.count('spam', 5, 10)\n1\n>>> 'spam, spam, spam'.count('eggs')\n0\n>>> 'spam, spam, spam'.count('')\n17\nstr.encode(encoding='utf-8', errors='strict')\n返回编码为 bytes 的字符串。\nencoding 默认为 'utf-8' ；请参阅 标准编码 了解其他可能的值。\nerrors 控制如何处理编码错误。 如为 'strict' (默认值)，则会引发 UnicodeError。 其他可能\n的值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过\ncodecs.register_error() 注册的任何其他名称。 请参阅 错误处理方案 了解详情。\n出于性能原因，errors 的值不会被执行有效性检查除非真的发生了编码错误、启用了 Python 开\n发模式 或是使用了 调试编译版。 例如:\n>>> encoded_str_to_bytes = 'Python'.encode()\n>>> type(encoded_str_to_bytes)\n<class 'bytes'>\n>>> encoded_str_to_bytes\nb'Python'\n在 3.1 版本发生变更: 加入了对关键字参数的支持。\n在 3.9 版本发生变更: 现在会在 Python 开发模式 和 调试模式 下检查 errors 参数的值。\n\n|  | Added in version 3.3.\nstr.center(width, fillchar=' ', /)\n返回长度为 width 的居中字符串。 使用指定的 fillchar 填充空位（默认为 ASCII 空格）。 如果\nwidth 小于等于 len(s) 则返回原字符串。 例如:\n>>> 'Python'.center(10)\n' Python '\n>>> 'Python'.center(10, '-')\n'--Python--'\n>>> 'Python'.center(4)\n'Python'\nstr.count(sub[, start[, end]])\n返回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为\n切片表示法。\n如果 sub 为空，则返回字符之间的空字符串数，即字符串的长度加一。 例如:\n>>> 'spam, spam, spam'.count('spam')\n3\n>>> 'spam, spam, spam'.count('spam', 5)\n2\n>>> 'spam, spam, spam'.count('spam', 5, 10)\n1\n>>> 'spam, spam, spam'.count('eggs')\n0\n>>> 'spam, spam, spam'.count('')\n17\nstr.encode(encoding='utf-8', errors='strict')\n返回编码为 bytes 的字符串。\nencoding 默认为 'utf-8' ；请参阅 标准编码 了解其他可能的值。\nerrors 控制如何处理编码错误。 如为 'strict' (默认值)，则会引发 UnicodeError。 其他可能\n的值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过\ncodecs.register_error() 注册的任何其他名称。 请参阅 错误处理方案 了解详情。\n出于性能原因，errors 的值不会被执行有效性检查除非真的发生了编码错误、启用了 Python 开\n发模式 或是使用了 调试编译版。 例如:\n>>> encoded_str_to_bytes = 'Python'.encode()\n>>> type(encoded_str_to_bytes)\n<class 'bytes'>\n>>> encoded_str_to_bytes\nb'Python'\n在 3.1 版本发生变更: 加入了对关键字参数的支持。\n在 3.9 版本发生变更: 现在会在 Python 开发模式 和 调试模式 下检查 errors 参数的值。 |  |\n| --- | --- | --- |\n\nstr.endswith(suffix[, start[, end]])\n如果字符串以指定的 suffix 结束则返回 True，否则返回 False。 suffix 也可以是一个由供查找\n的后缀组成的元组。 如果有可选项 start，测试将从该位置开始。 如果有可选项 end，将在该位\n置停止比较。 使用 start 和 end 等价于 str[start:end].endswith(suffix)。 例如:\n>>> 'Python'.endswith('on')\nTrue\n>>> 'a tuple of suffixes'.endswith(('at', 'in'))\nFalse\n>>> 'a tuple of suffixes'.endswith(('at', 'es'))\nTrue\n>>> 'Python is amazing'.endswith('is', 0, 9)\nTrue\n另请参阅 startswith() 和 removesuffix()。\nstr.expandtabs(tabsize=8)\n返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给\n定的制表符宽度。 每 tabsize 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依\n次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制\n表符 (\\t)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本\n身不会被复制。） 如果字符为换行符 (\\n) 或回车符 (\\r)，它会被复制并将当前列重设为零。\n任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。 例如:\n>>> '01\\t012\\t0123\\t01234'.expandtabs()\n'01 012 0123 01234'\n>>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n'01 012 0123 01234'\n>>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n01 012\n0123 01234\nstr.find(sub[, start[, end]])\n返回子字符串 sub 在 s[start:end] 切片内被找到的最小索引。 可选参数 start 与 end 会被解\n读为切片表示法。 如果 sub 未被找到则返回 -1。例如:\n>>> 'spam, spam, spam'.find('sp')\n0\n>>> 'spam, spam, spam'.find('sp', 5)\n6\n另请参阅 rfind() 和 index()。\n备注: find() 方法应该只在你需要知道 sub 所在位置时使用。 要检查 sub 是否为子字符\n串，请使用 in 操作符:\n>>> 'Py' in 'Python'\nTrue\n\n|  | str.endswith(suffix[, start[, end]])\n如果字符串以指定的 suffix 结束则返回 True，否则返回 False。 suffix 也可以是一个由供查找\n的后缀组成的元组。 如果有可选项 start，测试将从该位置开始。 如果有可选项 end，将在该位\n置停止比较。 使用 start 和 end 等价于 str[start:end].endswith(suffix)。 例如:\n>>> 'Python'.endswith('on')\nTrue\n>>> 'a tuple of suffixes'.endswith(('at', 'in'))\nFalse\n>>> 'a tuple of suffixes'.endswith(('at', 'es'))\nTrue\n>>> 'Python is amazing'.endswith('is', 0, 9)\nTrue\n另请参阅 startswith() 和 removesuffix()。\nstr.expandtabs(tabsize=8)\n返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给\n定的制表符宽度。 每 tabsize 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依\n次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制\n表符 (\\t)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本\n身不会被复制。） 如果字符为换行符 (\\n) 或回车符 (\\r)，它会被复制并将当前列重设为零。\n任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。 例如:\n>>> '01\\t012\\t0123\\t01234'.expandtabs()\n'01 012 0123 01234'\n>>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n'01 012 0123 01234'\n>>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n01 012\n0123 01234\nstr.find(sub[, start[, end]])\n返回子字符串 sub 在 s[start:end] 切片内被找到的最小索引。 可选参数 start 与 end 会被解\n读为切片表示法。 如果 sub 未被找到则返回 -1。例如:\n>>> 'spam, spam, spam'.find('sp')\n0\n>>> 'spam, spam, spam'.find('sp', 5)\n6\n另请参阅 rfind() 和 index()。\n备注: find() 方法应该只在你需要知道 sub 所在位置时使用。 要检查 sub 是否为子字符\n串，请使用 in 操作符:\n>>> 'Py' in 'Python'\nTrue |  |\n| --- | --- | --- |\n\nstr.format(*args, **kwargs)\n执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 {} 括起来\n的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回\n的字符串副本中每个替换域都会被替换为对应参数的字符串值。\n>>> \"The sum of 1 + 2 is {0}\".format(1+2)\n'The sum of 1 + 2 is 3'\n请参阅 格式字符串语法 了解有关可以在格式字符串中指定的各种格式选项的说明。\n备注: 当使用 n 类型 (例如: '{:n}'.format(1234)) 来格式化数字 (int, float, complex,\ndecimal.Decimal 及其子类) 的时候，该函数会临时性地将 LC_CTYPE 区域设置为\nLC_NUMERIC 区域以解码 localeconv() 的 decimal_point 和 thousands_sep 字段，如果\n它们是非 ASCII 字符或长度超过 1 字节的话，并且 LC_NUMERIC 区域会与 LC_CTYPE 区域不\n一致。 这个临时更改会影响其他线程。\n在 3.7 版本发生变更: 当使用 n 类型格式化数字时，该函数在某些情况下会临时性地将\nLC_CTYPE 区域设置为 LC_NUMERIC 区域。\nstr.format_map(mapping, /)\n类似于 str.format(**mapping)，不同之处在于 mapping 会被直接使用而不是复制到一个\ndict。 适宜使用此方法的一个例子是当 mapping 为 dict 的子类的情况：\n>>> class Default(dict):\n... def __missing__(self, key):\n... return key\n...\n>>> '{name} was born in {country}'.format_map(Default(name='Guido'))\n'Guido was born in country'\nAdded in version 3.2.\nstr.index(sub[, start[, end]])\n类似于 find()，但在找不到子字符串时会引发 ValueError。\nstr.isalnum()\n如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 True ， 否则返回 False\n。 如果 c.isalpha() ， c.isdecimal() ， c.isdigit() ，或 c.isnumeric() 之中有一个返\n回 True ，则字符 c 是字母或数字。\nstr.isalpha()\n如果字符串中的所有字符都为字母类并且至少有一个字符则返回 True，否则返回 False。 字\n母类字符是指在 Unicode 字符数据库中被定义为 \"Letter\" 的字符，即通用类别属性为 \"Lm\",\n\"Lt\", \"Lu\", \"Ll\" 或 \"Lo\" 之一的字符。 请注意这不同于 在 Unicode 标准 4.10 节 'Letters,\nAlphabetic, and Ideographic' 中定义的 Alphabetic 属性。\nstr.isascii()\n\n|  | str.format(*args, **kwargs)\n执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 {} 括起来\n的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回\n的字符串副本中每个替换域都会被替换为对应参数的字符串值。\n>>> \"The sum of 1 + 2 is {0}\".format(1+2)\n'The sum of 1 + 2 is 3'\n请参阅 格式字符串语法 了解有关可以在格式字符串中指定的各种格式选项的说明。\n备注: 当使用 n 类型 (例如: '{:n}'.format(1234)) 来格式化数字 (int, float, complex,\ndecimal.Decimal 及其子类) 的时候，该函数会临时性地将 LC_CTYPE 区域设置为\nLC_NUMERIC 区域以解码 localeconv() 的 decimal_point 和 thousands_sep 字段，如果\n它们是非 ASCII 字符或长度超过 1 字节的话，并且 LC_NUMERIC 区域会与 LC_CTYPE 区域不\n一致。 这个临时更改会影响其他线程。\n在 3.7 版本发生变更: 当使用 n 类型格式化数字时，该函数在某些情况下会临时性地将\nLC_CTYPE 区域设置为 LC_NUMERIC 区域。\nstr.format_map(mapping, /)\n类似于 str.format(**mapping)，不同之处在于 mapping 会被直接使用而不是复制到一个\ndict。 适宜使用此方法的一个例子是当 mapping 为 dict 的子类的情况：\n>>> class Default(dict):\n... def __missing__(self, key):\n... return key\n...\n>>> '{name} was born in {country}'.format_map(Default(name='Guido'))\n'Guido was born in country'\nAdded in version 3.2.\nstr.index(sub[, start[, end]])\n类似于 find()，但在找不到子字符串时会引发 ValueError。\nstr.isalnum()\n如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 True ， 否则返回 False\n。 如果 c.isalpha() ， c.isdecimal() ， c.isdigit() ，或 c.isnumeric() 之中有一个返\n回 True ，则字符 c 是字母或数字。\nstr.isalpha()\n如果字符串中的所有字符都为字母类并且至少有一个字符则返回 True，否则返回 False。 字\n母类字符是指在 Unicode 字符数据库中被定义为 \"Letter\" 的字符，即通用类别属性为 \"Lm\",\n\"Lt\", \"Lu\", \"Ll\" 或 \"Lo\" 之一的字符。 请注意这不同于 在 Unicode 标准 4.10 节 'Letters,\nAlphabetic, and Ideographic' 中定义的 Alphabetic 属性。\nstr.isascii() |  |\n| --- | --- | --- |\n\n如果字符串为空或字符串中的所有字符都是 ASCII ，返回 True ，否则返回 False 。ASCII 字符\n的码点范围是 U+0000-U+007F 。\nAdded in version 3.7.\nstr.isdecimal()\n如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 True ， 否则返\n回 False 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母\n数字0 。 严格地讲，十进制字符是 Unicode 通用类别 \"Nd\" 中的一个字符。\nstr.isdigit()\n如果字符串中的所有字符都是数字，并且至少有一个字符，返回 True ，否则返回 False 。 数\n字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制\n数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或\nNumeric_Type=Decimal 的字符。\nstr.isidentifier()\n如果字符串是有效的标识符，返回 True ，依据语言定义， 名称（标识符和关键字） 节。\nkeyword.iskeyword() 可被用来测试字符串 s 是否为保留的标识符，如 def 和 class。\n示例：\n>>> from keyword import iskeyword\n>>> 'hello'.isidentifier(), iskeyword('hello')\n(True, False)\n>>> 'def'.isidentifier(), iskeyword('def')\n(True, True)\nstr.islower()\n如果字符串中至少有一个区分大小写的字符 [4] 且此类字符均为小写则返回 True ，否则返回\nFalse 。\nstr.isnumeric()\n如果字符串中至少有一个字符且所有字符均为数值字符则返回 True ，否则返回 False 。 数值\n字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155,\nVULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值\nNumeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。\nstr.isprintable()\n如果字符串中的所有字符均为可打印字符则返回``True``，如果包含至少一个不可打印字符则返\n回``False``。\n这里的“可打印”是指字符适用于在其输出中 repr() 中；“不可打印”则意味着内置类型的\nrepr() 将以十六进制转义代码表示该字符。 它不会影响对写入到 sys.stdout 或 sys.stderr\n的字符串的处理。\n\n|  | 如果字符串为空或字符串中的所有字符都是 ASCII ，返回 True ，否则返回 False 。ASCII 字符\n的码点范围是 U+0000-U+007F 。\nAdded in version 3.7.\nstr.isdecimal()\n如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 True ， 否则返\n回 False 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母\n数字0 。 严格地讲，十进制字符是 Unicode 通用类别 \"Nd\" 中的一个字符。\nstr.isdigit()\n如果字符串中的所有字符都是数字，并且至少有一个字符，返回 True ，否则返回 False 。 数\n字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制\n数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或\nNumeric_Type=Decimal 的字符。\nstr.isidentifier()\n如果字符串是有效的标识符，返回 True ，依据语言定义， 名称（标识符和关键字） 节。\nkeyword.iskeyword() 可被用来测试字符串 s 是否为保留的标识符，如 def 和 class。\n示例：\n>>> from keyword import iskeyword\n>>> 'hello'.isidentifier(), iskeyword('hello')\n(True, False)\n>>> 'def'.isidentifier(), iskeyword('def')\n(True, True)\nstr.islower()\n如果字符串中至少有一个区分大小写的字符 [4] 且此类字符均为小写则返回 True ，否则返回\nFalse 。\nstr.isnumeric()\n如果字符串中至少有一个字符且所有字符均为数值字符则返回 True ，否则返回 False 。 数值\n字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155,\nVULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值\nNumeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。\nstr.isprintable()\n如果字符串中的所有字符均为可打印字符则返回``True``，如果包含至少一个不可打印字符则返\n回``False``。\n这里的“可打印”是指字符适用于在其输出中 repr() 中；“不可打印”则意味着内置类型的\nrepr() 将以十六进制转义代码表示该字符。 它不会影响对写入到 sys.stdout 或 sys.stderr\n的字符串的处理。 |  |\n| --- | --- | --- |\n\n可打印字符就是在 Unicode 字符数据库 (参见 unicodedata) 中分组为主类别 Letter, Mark,\nNumber, Punctuation 或 Symbol (L, M, N, P 或 S) 的字符；加上 ASCII 空格符 0x20。 不可打印\n字符就是分组为 Separator 或 Other (Z 或 C) 的字符，ASCII 空格符除外。\nstr.isspace()\n如果字符串中只有空白字符且至少有一个字符则返回 True ，否则返回 False 。\n空白 字符是指在 Unicode 字符数据库 (参见 unicodedata) 中主要类别为 Zs (\"Separator,\nspace\") 或所属双向类为 WS, B 或 S 的字符。\nstr.istitle()\n如果字符串中至少有一个字符且为标题字符串则返回 True ，例如大写字符之后只能带非大写\n字符而小写字符必须有大写字符打头。 否则返回 False 。\n例如:\n>>> 'Spam, Spam, Spam'.istitle()\nTrue\n>>> 'spam, spam, spam'.istitle()\nFalse\n>>> 'SPAM, SPAM, SPAM'.istitle()\nFalse\n另请参阅 title()。\nstr.isupper()\n如果字符串中至少有一个区分大小写的字符 [4] 且此类字符均为大写则返回 True ，否则返回\nFalse 。\n>>> 'BANANA'.isupper()\nTrue\n>>> 'banana'.isupper()\nFalse\n>>> 'baNana'.isupper()\nFalse\n>>> ' '.isupper()\nFalse\nstr.join(iterable, /)\n返回一个由 iterable 中的字符串拼接而成的字符串。 如果 iterable 中存在任何非字符串值包括\nbytes 对象则会引发 TypeError。 调用该方法的字符串将作为元素之间的分隔。\nstr.ljust(width, fillchar=' ', /)\n返回长度为 width 的字符串，原字符串在其中靠左对齐。 使用指定的 fillchar 填充空位 (默认使\n用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。\nstr.lower()\n返回原字符串的副本，其所有区分大小写的字符 [4] 均转换为小写。\n使用的小写算法在 Unicode标准3.13节 'Default Case Folding' 中有描述。\n\n|  | 可打印字符就是在 Unicode 字符数据库 (参见 unicodedata) 中分组为主类别 Letter, Mark,\nNumber, Punctuation 或 Symbol (L, M, N, P 或 S) 的字符；加上 ASCII 空格符 0x20。 不可打印\n字符就是分组为 Separator 或 Other (Z 或 C) 的字符，ASCII 空格符除外。\nstr.isspace()\n如果字符串中只有空白字符且至少有一个字符则返回 True ，否则返回 False 。\n空白 字符是指在 Unicode 字符数据库 (参见 unicodedata) 中主要类别为 Zs (\"Separator,\nspace\") 或所属双向类为 WS, B 或 S 的字符。\nstr.istitle()\n如果字符串中至少有一个字符且为标题字符串则返回 True ，例如大写字符之后只能带非大写\n字符而小写字符必须有大写字符打头。 否则返回 False 。\n例如:\n>>> 'Spam, Spam, Spam'.istitle()\nTrue\n>>> 'spam, spam, spam'.istitle()\nFalse\n>>> 'SPAM, SPAM, SPAM'.istitle()\nFalse\n另请参阅 title()。\nstr.isupper()\n如果字符串中至少有一个区分大小写的字符 [4] 且此类字符均为大写则返回 True ，否则返回\nFalse 。\n>>> 'BANANA'.isupper()\nTrue\n>>> 'banana'.isupper()\nFalse\n>>> 'baNana'.isupper()\nFalse\n>>> ' '.isupper()\nFalse\nstr.join(iterable, /)\n返回一个由 iterable 中的字符串拼接而成的字符串。 如果 iterable 中存在任何非字符串值包括\nbytes 对象则会引发 TypeError。 调用该方法的字符串将作为元素之间的分隔。\nstr.ljust(width, fillchar=' ', /)\n返回长度为 width 的字符串，原字符串在其中靠左对齐。 使用指定的 fillchar 填充空位 (默认使\n用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。\nstr.lower()\n返回原字符串的副本，其所有区分大小写的字符 [4] 均转换为小写。\n使用的小写算法在 Unicode标准3.13节 'Default Case Folding' 中有描述。 |  |\n| --- | --- | --- |\n\nstr.lstrip(chars=None, /)\n返回原字符串的副本，移除其中的前导字符。 chars 参数为指定要移除字符的字符串。 如果省\n略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个前缀；而是会移\n除参数值的所有组合:\n>>> ' spacious '.lstrip()\n'spacious '\n>>> 'www.example.com'.lstrip('cmowz.')\n'example.com'\n参见 str.removeprefix() ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。\n例如:\n>>> 'Arthur: three!'.lstrip('Arthur: ')\n'ee!'\n>>> 'Arthur: three!'.removeprefix('Arthur: ')\n'three!'\nstatic str.maketrans(dict, /)\nstatic str.maketrans(from, to, remove='', /)\n此静态方法返回一个可供 str.translate() 使用的转换对照表。\n如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符\n串）映射到 Unicode 码位序号、（任意长度的）字符串或 None 的字典。 字符键将会被转换为\n码位序号。\n如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，from 中每个字符\n将被映射到 to 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在\n结果中被映射到 None。\nstr.partition(sep, /)\n在 sep 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本\n身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空\n字符串。\nstr.removeprefix(prefix, /)\n如果字符串以 prefix 字符串开头，返回 string[len(prefix):]。 否则，返回原始字符串的副\n本：\n>>> 'TestHook'.removeprefix('Test')\n'Hook'\n>>> 'BaseTestCase'.removeprefix('Test')\n'BaseTestCase'\nAdded in version 3.9.\nstr.removesuffix(suffix, /)\n如果字符串以 suffix 字符串结尾，并且 suffix 非空，返回 string[:-len(suffix)]。 否则，返\n回原始字符串的副本:\n\n|  | str.lstrip(chars=None, /)\n返回原字符串的副本，移除其中的前导字符。 chars 参数为指定要移除字符的字符串。 如果省\n略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个前缀；而是会移\n除参数值的所有组合:\n>>> ' spacious '.lstrip()\n'spacious '\n>>> 'www.example.com'.lstrip('cmowz.')\n'example.com'\n参见 str.removeprefix() ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。\n例如:\n>>> 'Arthur: three!'.lstrip('Arthur: ')\n'ee!'\n>>> 'Arthur: three!'.removeprefix('Arthur: ')\n'three!'\nstatic str.maketrans(dict, /)\nstatic str.maketrans(from, to, remove='', /)\n此静态方法返回一个可供 str.translate() 使用的转换对照表。\n如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符\n串）映射到 Unicode 码位序号、（任意长度的）字符串或 None 的字典。 字符键将会被转换为\n码位序号。\n如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，from 中每个字符\n将被映射到 to 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在\n结果中被映射到 None。\nstr.partition(sep, /)\n在 sep 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本\n身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空\n字符串。\nstr.removeprefix(prefix, /)\n如果字符串以 prefix 字符串开头，返回 string[len(prefix):]。 否则，返回原始字符串的副\n本：\n>>> 'TestHook'.removeprefix('Test')\n'Hook'\n>>> 'BaseTestCase'.removeprefix('Test')\n'BaseTestCase'\nAdded in version 3.9.\nstr.removesuffix(suffix, /)\n如果字符串以 suffix 字符串结尾，并且 suffix 非空，返回 string[:-len(suffix)]。 否则，返\n回原始字符串的副本: |  |\n| --- | --- | --- |\n\n>>> 'MiscTests'.removesuffix('Tests')\n'Misc'\n>>> 'TmpDirMixin'.removesuffix('Tests')\n'TmpDirMixin'\nAdded in version 3.9.\nstr.replace(old, new, /, count=-1)\n返回字符串的副本，其中出现的所有子字符串 old 都将被替换为 new。 如果给出了 count，则\n只替换前 count 次出现。 如果 count 未指定或为 -1，则全部替换。\n在 3.13 版本发生变更: 现在可支持 count 关键字参数。\nstr.rfind(sub[, start[, end]])\n返回子字符串 sub 在字符串内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end]\n当中。 可选参数 start 与 end 会被解读为切片表示法。 如果未找到则返回 -1。\nstr.rindex(sub[, start[, end]])\n类似于 rfind()，但在子字符串 sub 未找到时会引发 ValueError。\nstr.rjust(width, fillchar=' ', /)\n返回长度为 width 的字符串，原字符串在其中靠右对齐。 使用指定的 fillchar 填充空位 (默认使\n用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。\nstr.rpartition(sep, /)\n在 sep 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔\n符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以\n及字符串本身。\nstr.rsplit(sep=None, maxsplit=-1)\n返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。 如果给出了 maxsplit，则最\n多进行 maxsplit 次拆分，从 最右边 开始。 如果 sep 未指定或为 None，任何空白字符串都会被\n作为分隔符。 除了从右边开始拆分，rsplit() 的其他行为都类似于下文所述的 split()。\nstr.rstrip(chars=None, /)\n返回原字符串的副本，移除其中的末尾字符。 chars 参数为指定要移除字符的字符串。 如果省\n略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个后缀；而是会移\n除参数值的所有组合:\n>>> ' spacious '.rstrip()\n' spacious'\n>>> 'mississippi'.rstrip('ipz')\n'mississ'\n要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 str.removesuffix() 方法。\n例如:\n\n|  | >>> 'MiscTests'.removesuffix('Tests')\n'Misc'\n>>> 'TmpDirMixin'.removesuffix('Tests')\n'TmpDirMixin'\nAdded in version 3.9.\nstr.replace(old, new, /, count=-1)\n返回字符串的副本，其中出现的所有子字符串 old 都将被替换为 new。 如果给出了 count，则\n只替换前 count 次出现。 如果 count 未指定或为 -1，则全部替换。\n在 3.13 版本发生变更: 现在可支持 count 关键字参数。\nstr.rfind(sub[, start[, end]])\n返回子字符串 sub 在字符串内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end]\n当中。 可选参数 start 与 end 会被解读为切片表示法。 如果未找到则返回 -1。\nstr.rindex(sub[, start[, end]])\n类似于 rfind()，但在子字符串 sub 未找到时会引发 ValueError。\nstr.rjust(width, fillchar=' ', /)\n返回长度为 width 的字符串，原字符串在其中靠右对齐。 使用指定的 fillchar 填充空位 (默认使\n用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。\nstr.rpartition(sep, /)\n在 sep 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔\n符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以\n及字符串本身。\nstr.rsplit(sep=None, maxsplit=-1)\n返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。 如果给出了 maxsplit，则最\n多进行 maxsplit 次拆分，从 最右边 开始。 如果 sep 未指定或为 None，任何空白字符串都会被\n作为分隔符。 除了从右边开始拆分，rsplit() 的其他行为都类似于下文所述的 split()。\nstr.rstrip(chars=None, /)\n返回原字符串的副本，移除其中的末尾字符。 chars 参数为指定要移除字符的字符串。 如果省\n略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个后缀；而是会移\n除参数值的所有组合:\n>>> ' spacious '.rstrip()\n' spacious'\n>>> 'mississippi'.rstrip('ipz')\n'mississ'\n要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 str.removesuffix() 方法。\n例如: | >>> 'MiscTests'.removesuffix('Tests')\n'Misc'\n>>> 'TmpDirMixin'.removesuffix('Tests')\n'TmpDirMixin' |  |\n| --- | --- | --- | --- |\n\n>>> 'Monty Python'.rstrip(' Python')\n'M'\n>>> 'Monty Python'.removesuffix(' Python')\n'Monty'\nstr.split(sep=None, maxsplit=-1)\n返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。 如果给出了 maxsplit，则最\n多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。 如果 maxsplit 未指定或\n为 -1，则不限制拆分次数（进行所有可能的拆分）。\n如果给出了 sep，则连续的分隔符不会被组合在一起而是会被视为分隔空字符串 (例如\n'1,,2'.split(',') 将返回 ['1', '', '2'])。 sep 参数可能是由多个字符组成的单个分隔符\n(要使用多个分隔符进行拆分，请使用 re.split())。 使用指定的分隔符拆分一个空字符串将返\n回 ['']。\n例如：\n>>> '1,2,3'.split(',')\n['1', '2', '3']\n>>> '1,2,3'.split(',', maxsplit=1)\n['1', '2,3']\n>>> '1,2,,3,'.split(',')\n['1', '2', '', '3', '']\n>>> '1<>2<>3<4'.split('<>')\n['1', '2', '3<4']\n如果 sep 未指定或为 None，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结\n果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 None\n拆分空字符串或仅包含空格的字符串将返回 []。\n例如：\n>>> '1 2 3'.split()\n['1', '2', '3']\n>>> '1 2 3'.split(maxsplit=1)\n['1', '2 3']\n>>> ' 1 2 3 '.split()\n['1', '2', '3']\n如果 sep 未指定或为 None 且 maxsplit 为 0，则只有开头的连连续空格会被纳入考虑。\n例如：\n>>> \"\".split(None, 0)\n[]\n>>> \" \".split(None, 0)\n[]\n>>> \" foo \".split(maxsplit=0)\n['foo ']\nstr.splitlines(keepends=False)\n\n|  | >>> 'Monty Python'.rstrip(' Python')\n'M'\n>>> 'Monty Python'.removesuffix(' Python')\n'Monty'\nstr.split(sep=None, maxsplit=-1)\n返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。 如果给出了 maxsplit，则最\n多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。 如果 maxsplit 未指定或\n为 -1，则不限制拆分次数（进行所有可能的拆分）。\n如果给出了 sep，则连续的分隔符不会被组合在一起而是会被视为分隔空字符串 (例如\n'1,,2'.split(',') 将返回 ['1', '', '2'])。 sep 参数可能是由多个字符组成的单个分隔符\n(要使用多个分隔符进行拆分，请使用 re.split())。 使用指定的分隔符拆分一个空字符串将返\n回 ['']。\n例如：\n>>> '1,2,3'.split(',')\n['1', '2', '3']\n>>> '1,2,3'.split(',', maxsplit=1)\n['1', '2,3']\n>>> '1,2,,3,'.split(',')\n['1', '2', '', '3', '']\n>>> '1<>2<>3<4'.split('<>')\n['1', '2', '3<4']\n如果 sep 未指定或为 None，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结\n果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 None\n拆分空字符串或仅包含空格的字符串将返回 []。\n例如：\n>>> '1 2 3'.split()\n['1', '2', '3']\n>>> '1 2 3'.split(maxsplit=1)\n['1', '2 3']\n>>> ' 1 2 3 '.split()\n['1', '2', '3']\n如果 sep 未指定或为 None 且 maxsplit 为 0，则只有开头的连连续空格会被纳入考虑。\n例如：\n>>> \"\".split(None, 0)\n[]\n>>> \" \".split(None, 0)\n[]\n>>> \" foo \".split(maxsplit=0)\n['foo ']\nstr.splitlines(keepends=False) | >>> 'Monty Python'.rstrip(' Python')\n'M'\n>>> 'Monty Python'.removesuffix(' Python')\n'Monty' |  |\n| --- | --- | --- | --- |\n\n返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给\n出了 keepends 且为真值。\n此方法会以下列行边界进行拆分。 特别地，行边界是 universal newlines 的一个超集。\n表示符 描述\n\\n 换行\n\\r 回车\n\\r\\n 回车 + 换行\n\\v 或 \\x0b 行制表符\n\\f 或 \\x0c 换表单\n\\x1c 文件分隔符\n\\x1d 组分隔符\n\\x1e 记录分隔符\n\\x85 下一行 (C1 控制码)\n\\u2028 行分隔符\n\\u2029 段分隔符\n在 3.2 版本发生变更: \\v 和 \\f 被添加到行边界列表\n例如：\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n['ab c', '', 'de fg', 'kl']\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\n不同于 split()，当给出了分隔字符串 sep 时，对于空字符串此方法将返回一个空列表，而末\n尾的换行不会令结果中增加额外的行:\n>>> \"\".splitlines()\n[]\n>>> \"One line\\n\".splitlines()\n['One line']\n作为比较，split('\\n') 的结果为:\n>>> ''.split('\\n')\n['']\n>>> 'Two lines\\n'.split('\\n')\n['Two lines', '']\n\n|  | 返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给\n出了 keepends 且为真值。\n此方法会以下列行边界进行拆分。 特别地，行边界是 universal newlines 的一个超集。\n表示符 描述\n\\n 换行\n\\r 回车\n\\r\\n 回车 + 换行\n\\v 或 \\x0b 行制表符\n\\f 或 \\x0c 换表单\n\\x1c 文件分隔符\n\\x1d 组分隔符\n\\x1e 记录分隔符\n\\x85 下一行 (C1 控制码)\n\\u2028 行分隔符\n\\u2029 段分隔符\n在 3.2 版本发生变更: \\v 和 \\f 被添加到行边界列表\n例如：\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n['ab c', '', 'de fg', 'kl']\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\n不同于 split()，当给出了分隔字符串 sep 时，对于空字符串此方法将返回一个空列表，而末\n尾的换行不会令结果中增加额外的行:\n>>> \"\".splitlines()\n[]\n>>> \"One line\\n\".splitlines()\n['One line']\n作为比较，split('\\n') 的结果为:\n>>> ''.split('\\n')\n['']\n>>> 'Two lines\\n'.split('\\n')\n['Two lines', ''] |  |\n| --- | --- | --- |\n\n| 表示符 | 描述 |\n| --- | --- |\n| \\n | 换行 |\n| \\r | 回车 |\n| \\r\\n | 回车 + 换行 |\n| \\v 或 \\x0b | 行制表符 |\n| \\f 或 \\x0c | 换表单 |\n| \\x1c | 文件分隔符 |\n| \\x1d | 组分隔符 |\n| \\x1e | 记录分隔符 |\n| \\x85 | 下一行 (C1 控制码) |\n| \\u2028 | 行分隔符 |\n| \\u2029 | 段分隔符 |\n\nstr.startswith(prefix[, start[, end]])\n如果字符串以指定的 prefix 开始则返回 True，否则返回 False。 prefix 也可以为由多个供查找\n的前缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，将在\n所指定位置停止比较。\nstr.strip(chars=None, /)\n返回原字符串的副本，移除其中的前导和末尾字符。 chars 参数为指定要移除字符的字符串。\n如果省略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个前缀或后\n缀；而是会移除参数值的所有组合:\n>>> ' spacious '.strip()\n'spacious'\n>>> 'www.example.com'.strip('cmowz.')\n'example'\n最外侧的前导和末尾 chars 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包\n含于 chars 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:\n>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n>>> comment_string.strip('.#! ')\n'Section 3.2.1 Issue #32'\nstr.swapcase()\n返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意\ns.swapcase().swapcase() == s 并不一定为真值。\nstr.title()\n返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。\n例如：\n>>> 'Hello world'.title()\n'Hello World'\n该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下\n都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望\n的结果:\n>>> \"they're bill's friends from the UK\".title()\n\"They'Re Bill'S Friends From The Uk\"\nstring.capwords() 函数没有此问题，因为它只用空格来拆分单词。\n作为替代，可以使用正则表达式来构造针对撇号的变通处理:\n>>> import re\n>>> def titlecase(s):\n... return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n... lambda mo: mo.group(0).capitalize(),\n... s)\n\n|  | str.startswith(prefix[, start[, end]])\n如果字符串以指定的 prefix 开始则返回 True，否则返回 False。 prefix 也可以为由多个供查找\n的前缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，将在\n所指定位置停止比较。\nstr.strip(chars=None, /)\n返回原字符串的副本，移除其中的前导和末尾字符。 chars 参数为指定要移除字符的字符串。\n如果省略或为 None，则 chars 参数默认移除空白符。 实际上 chars 参数并非指定单个前缀或后\n缀；而是会移除参数值的所有组合:\n>>> ' spacious '.strip()\n'spacious'\n>>> 'www.example.com'.strip('cmowz.')\n'example'\n最外侧的前导和末尾 chars 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包\n含于 chars 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:\n>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n>>> comment_string.strip('.#! ')\n'Section 3.2.1 Issue #32'\nstr.swapcase()\n返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意\ns.swapcase().swapcase() == s 并不一定为真值。\nstr.title()\n返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。\n例如：\n>>> 'Hello world'.title()\n'Hello World'\n该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下\n都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望\n的结果:\n>>> \"they're bill's friends from the UK\".title()\n\"They'Re Bill'S Friends From The Uk\"\nstring.capwords() 函数没有此问题，因为它只用空格来拆分单词。\n作为替代，可以使用正则表达式来构造针对撇号的变通处理:\n>>> import re\n>>> def titlecase(s):\n... return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n... lambda mo: mo.group(0).capitalize(),\n... s) |  |  |\n| --- | --- | --- | --- |\n|  |  | >>> import re\n>>> def titlecase(s):\n... return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n... lambda mo: mo.group(0).capitalize(),\n... s) |  |\n\n...\n>>> titlecase(\"they're bill's friends.\")\n\"They're Bill's Friends.\"\n另请参阅 istitle()。\nstr.translate(table, /)\n返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个通过\n__getitem__() 来实现索引操作的对象，通常为 mapping 或 sequence。 当以 Unicode 码位\n序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 码位序号或字符\n串，将字符映射为一个或多个其他字符；返回 None，将字符从返回的字符串中删除；或引发\nLookupError 异常，将字符映射为其自身。\n你可以使用 str.maketrans() 基于不同格式的字符到字符映射来创建一个转换映射表。\n另请参阅 codecs 模块以了解定制字符映射的更灵活方式。\nstr.upper()\n返回原字符串的副本，其中所有区分大小写的字符 [4] 均转换为大写。 请注意如果 s 包含不区\n分大小写的字符或者如果结果字符的 Unicode 类别不是 \"Lu\" (Letter, uppercase) 而是 \"Lt\"\n(Letter, titlecase) 则 s.upper().isupper() 有可能为 False。\n使用的大写算法在 Unicode标准3.13节 'Default Case Folding' 中有描述。\nstr.zfill(width, /)\n返回原字符串的副本，在左边填充 ASCII '0' 数码使其长度变为 width。 正负值前缀 ('+'/'-')\n的处理方式是在正负符号 之后 填充而非在之前。 如果 width 小于等于 len(s) 则返回原字符串\n的副本。\n例如：\n>>> \"42\".zfill(5)\n'00042'\n>>> \"-42\".zfill(5)\n'-0042'\n格式化字符串字面值（f-字符串）\nAdded in version 3.6.\n在 3.7 版本发生变更: await 和 async for 可在 f-字符串内部的表达式中使用。\n在 3.8 版本发生变更: 增加了调试运算符 (=)\n在 3.12 版本发生变更: 许多针对 f-字符串内部的表达式的限制已被移除。 例如，嵌套字符串、\n注释和反斜杠现在都是允许的。\nf-字符串 (正式名称为 格式化字符串字面值) 是带有 f 或 F 前缀的字符串字面值。 这种类型的字符串\n字面值允许将任意 Python 表达式嵌入到由花括号 ({}) 标记的 替换字段 内部。 这些表达式将在运行\n时被求值，这与 str.format() 类似，并被转换为常规的 str 对象。 例如：\n\n|  | ...\n>>> titlecase(\"they're bill's friends.\")\n\"They're Bill's Friends.\"\n另请参阅 istitle()。\nstr.translate(table, /)\n返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个通过\n__getitem__() 来实现索引操作的对象，通常为 mapping 或 sequence。 当以 Unicode 码位\n序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 码位序号或字符\n串，将字符映射为一个或多个其他字符；返回 None，将字符从返回的字符串中删除；或引发\nLookupError 异常，将字符映射为其自身。\n你可以使用 str.maketrans() 基于不同格式的字符到字符映射来创建一个转换映射表。\n另请参阅 codecs 模块以了解定制字符映射的更灵活方式。\nstr.upper()\n返回原字符串的副本，其中所有区分大小写的字符 [4] 均转换为大写。 请注意如果 s 包含不区\n分大小写的字符或者如果结果字符的 Unicode 类别不是 \"Lu\" (Letter, uppercase) 而是 \"Lt\"\n(Letter, titlecase) 则 s.upper().isupper() 有可能为 False。\n使用的大写算法在 Unicode标准3.13节 'Default Case Folding' 中有描述。\nstr.zfill(width, /)\n返回原字符串的副本，在左边填充 ASCII '0' 数码使其长度变为 width。 正负值前缀 ('+'/'-')\n的处理方式是在正负符号 之后 填充而非在之前。 如果 width 小于等于 len(s) 则返回原字符串\n的副本。\n例如：\n>>> \"42\".zfill(5)\n'00042'\n>>> \"-42\".zfill(5)\n'-0042'\n格式化字符串字面值（f-字符串）\nAdded in version 3.6.\n在 3.7 版本发生变更: await 和 async for 可在 f-字符串内部的表达式中使用。\n在 3.8 版本发生变更: 增加了调试运算符 (=)\n在 3.12 版本发生变更: 许多针对 f-字符串内部的表达式的限制已被移除。 例如，嵌套字符串、\n注释和反斜杠现在都是允许的。\nf-字符串 (正式名称为 格式化字符串字面值) 是带有 f 或 F 前缀的字符串字面值。 这种类型的字符串\n字面值允许将任意 Python 表达式嵌入到由花括号 ({}) 标记的 替换字段 内部。 这些表达式将在运行\n时被求值，这与 str.format() 类似，并被转换为常规的 str 对象。 例如： | ...\n>>> titlecase(\"they're bill's friends.\")\n\"They're Bill's Friends.\" |  |\n| --- | --- | --- | --- |\n\n>>> who = 'nobody'\n>>> nationality = 'Spanish'\n>>> f'{who.title()} expects the {nationality} Inquisition!'\n'Nobody expects the Spanish Inquisition!'\n也可以使用包含多行的 f-字符串：\n>>> f'''This is a string\n... on two lines'''\n'This is a string\\non two lines'\n一个单独的左花括号，'{'，标记一个可包含任意 Python 表达式的 替换字段：\n>>> nationality = 'Spanish'\n>>> f'The {nationality} Inquisition!'\n'The Spanish Inquisition!'\n要包括 { 或 } 字面值，请使用双花括号：\n>>> x = 42\n>>> f'{{x}} is {x}'\n'{x} is 42'\n还可以使用函数，以及 格式说明符:\n>>> from math import sqrt\n>>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n'√2 ≈ 1.41421'\n在默认情况下，任何非字符串表达式都将使用 str() 来转换：\n>>> from fractions import Fraction\n>>> f'{Fraction(1, 3)}'\n'1/3'\n要使用显式转换，请使用 ! (叹号) 运算符，后面跟任意的有效格式说明符，包括：\n转换符 含意\n!a ascii()\n!r repr()\n!s str()\n例如:\n>>> from fractions import Fraction\n>>> f'{Fraction(1, 3)!s}'\n'1/3'\n>>> f'{Fraction(1, 3)!r}'\n'Fraction(1, 3)'\n\n|  | >>> who = 'nobody'\n>>> nationality = 'Spanish'\n>>> f'{who.title()} expects the {nationality} Inquisition!'\n'Nobody expects the Spanish Inquisition!' |  |\n| --- | --- | --- |\n|  | 也可以使用包含多行的 f-字符串： |  |\n|  | >>> f'''This is a string\n... on two lines'''\n'This is a string\\non two lines' |  |\n|  | 一个单独的左花括号，'{'，标记一个可包含任意 Python 表达式的 替换字段： |  |\n|  | >>> nationality = 'Spanish'\n>>> f'The {nationality} Inquisition!'\n'The Spanish Inquisition!' |  |\n|  | 要包括 { 或 } 字面值，请使用双花括号： |  |\n|  | >>> x = 42\n>>> f'{{x}} is {x}'\n'{x} is 42' |  |\n|  | 还可以使用函数，以及 格式说明符: |  |\n|  | >>> from math import sqrt\n>>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n'√2 ≈ 1.41421' |  |\n|  | 在默认情况下，任何非字符串表达式都将使用 str() 来转换： |  |\n|  | >>> from fractions import Fraction\n>>> f'{Fraction(1, 3)}'\n'1/3' |  |\n|  | 要使用显式转换，请使用 ! (叹号) 运算符，后面跟任意的有效格式说明符，包括：\n转换符 含意\n!a ascii()\n!r repr()\n!s str()\n例如: |  |\n|  | >>> from fractions import Fraction\n>>> f'{Fraction(1, 3)!s}'\n'1/3'\n>>> f'{Fraction(1, 3)!r}'\n'Fraction(1, 3)' |  |\n\n| 转换符 | 含意 |\n| --- | --- |\n| !a | ascii() |\n| !r | repr() |\n| !s | str() |\n\n>>> question = '¿Dónde está el Presidente?'\n>>> print(f'{question!a}')\n'\\xbfD\\xf3nde est\\xe1 el Presidente?'\n在调试期间同时看到表达式和值会很有帮助，具体是在表达式后使用等号 (=)。 这将保留花括号内部\n的空格，并可以使用转换器。 在默认情况下，调试运算符使用 repr() (!r) 转换器。 例如：\n>>> from fractions import Fraction\n>>> calculation = Fraction(1, 3)\n>>> f'{calculation=}'\n'calculation=Fraction(1, 3)'\n>>> f'{calculation = }'\n'calculation = Fraction(1, 3)'\n>>> f'{calculation = !s}'\n'calculation = 1/3'\n输出一旦已被求值，就可以用 格式说明符 后面跟一个冒号 (':') 来格式化它。 在表达式已被求值，\n并可能被转换为字符串之后，就会调用结果的 __format__() 方法并附带该格式说明符，或者如果\n未给出格式说明符则附带空字符串。 随后将使用已格式化的结果作为替换字段最终的值。 例如：\n>>> from fractions import Fraction\n>>> f'{Fraction(1, 7):.6f}'\n'0.142857'\n>>> f'{Fraction(1, 7):_^+10}'\n'___+1/7___'\nprintf 风格的字符串格式化\n备注: 此处介绍的格式化操作具有多种怪异特性，可能导致多种常见错误（例如无法正确显示元\n组和字典）。\n使用 格式字符串字面值、str.format() 接口或 string.Template 类可能有助于避免这些错误。\n每种替代方案在简洁性、灵活性和/或可扩展性方面都有各自的权衡和优势。\n字符串具有一种特殊的内置操作即 % (求模) 运算符。 这也被称为字符串的 格式化 或 插值 运算符。\n对于给定的 format % values (其中 format 是一个字符串)，在 format 中的 % 转换标记符将被替换\n为零个或多个 values 中的元素。 其效果类似于在 C 语言中使用 sprintf() 函数。 例如：\n>>> print('%s has %d quote types.' % ('Python', 2))\nPython has 2 quote types.\n如果 format 要求一个单独参数，则 values 可以为一个非元组对象。 [5] 否则的话，values 必须或者\n是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字\n典）。\n转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：\n1. '%' 字符，用于标记转换符的起始。\n2. 映射键（可选），由加圆括号的字符序列组成 (例如 (somename))。\n3. 转换旗标（可选），用于影响某些转换类型的结果。\n\n|  | >>> question = '¿Dónde está el Presidente?'\n>>> print(f'{question!a}')\n'\\xbfD\\xf3nde est\\xe1 el Presidente?' |  |\n| --- | --- | --- |\n|  | 在调试期间同时看到表达式和值会很有帮助，具体是在表达式后使用等号 (=)。 这将保留花括号内部\n的空格，并可以使用转换器。 在默认情况下，调试运算符使用 repr() (!r) 转换器。 例如： |  |\n|  | >>> from fractions import Fraction\n>>> calculation = Fraction(1, 3)\n>>> f'{calculation=}'\n'calculation=Fraction(1, 3)'\n>>> f'{calculation = }'\n'calculation = Fraction(1, 3)'\n>>> f'{calculation = !s}'\n'calculation = 1/3' |  |\n|  | 输出一旦已被求值，就可以用 格式说明符 后面跟一个冒号 (':') 来格式化它。 在表达式已被求值，\n并可能被转换为字符串之后，就会调用结果的 __format__() 方法并附带该格式说明符，或者如果\n未给出格式说明符则附带空字符串。 随后将使用已格式化的结果作为替换字段最终的值。 例如： |  |\n|  | >>> from fractions import Fraction\n>>> f'{Fraction(1, 7):.6f}'\n'0.142857'\n>>> f'{Fraction(1, 7):_^+10}'\n'___+1/7___' |  |\n|  | printf 风格的字符串格式化 |  |\n|  | 备注: 此处介绍的格式化操作具有多种怪异特性，可能导致多种常见错误（例如无法正确显示元\n组和字典）。\n使用 格式字符串字面值、str.format() 接口或 string.Template 类可能有助于避免这些错误。\n每种替代方案在简洁性、灵活性和/或可扩展性方面都有各自的权衡和优势。 |  |\n|  | 字符串具有一种特殊的内置操作即 % (求模) 运算符。 这也被称为字符串的 格式化 或 插值 运算符。\n对于给定的 format % values (其中 format 是一个字符串)，在 format 中的 % 转换标记符将被替换\n为零个或多个 values 中的元素。 其效果类似于在 C 语言中使用 sprintf() 函数。 例如： |  |\n|  | >>> print('%s has %d quote types.' % ('Python', 2))\nPython has 2 quote types. |  |\n|  | 如果 format 要求一个单独参数，则 values 可以为一个非元组对象。 [5] 否则的话，values 必须或者\n是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字\n典）。\n转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：\n1. '%' 字符，用于标记转换符的起始。\n2. 映射键（可选），由加圆括号的字符序列组成 (例如 (somename))。\n3. 转换旗标（可选），用于影响某些转换类型的结果。 |  |\n\n4. 最小字段宽度（可选）。 如果指定为 '*' (星号)，则实际宽度会从 values 元组的下一元素中\n读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。\n5. 精度（可选），以在 '.' (点号) 之后加精度值的形式给出。 如果指定为 '*' (星号)，则实际\n精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。\n6. 长度修饰符（可选）。\n7. 转换类型。\n当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 必须 包含加圆括号的映射键，对\n应 '%' 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：\n>>> print('%(language)s has %(number)03d quote types.' %\n... {'language': \"Python\", \"number\": 2})\nPython has 002 quote types.\n在此情况下格式中不能出现 * 标记符（因其需要一个序列类的参数列表）。\n转换旗标为：\n旗标 含意\n'#' 值的转换将使用“替代形式”（具体定义见下文）。\n'0' 转换将为数字值填充零字符。\n'-' 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。\n' ' (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。\n'+' 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。\n可以给出长度修饰符 (h, l 或 L)，但会被忽略，因为对 Python 来说没有必要 -- 所以 %ld 等价于\n%d。\n转换类型为：\n转换 备\n含意\n符 注\n'd' 有符号十进制整数。\n'i' 有符号十进制整数。\n'o' 有符号八进制数。 (1)\n'u' 过时类型 -- 等价于 'd'。 (6)\n'x' 有符号十六进制数（小写）。 (2)\n'X' 有符号十六进制数（大写）。 (2)\n'e' 浮点指数格式（小写）。 (3)\n\n|  | 4. 最小字段宽度（可选）。 如果指定为 '*' (星号)，则实际宽度会从 values 元组的下一元素中\n读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。\n5. 精度（可选），以在 '.' (点号) 之后加精度值的形式给出。 如果指定为 '*' (星号)，则实际\n精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。\n6. 长度修饰符（可选）。\n7. 转换类型。\n当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 必须 包含加圆括号的映射键，对\n应 '%' 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如： |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | >>> print('%(language)s has %(number)03d quote types.' %\n... {'language': \"Python\", \"number\": 2})\nPython has 002 quote types. |  |  |  |\n|  | 在此情况下格式中不能出现 * 标记符（因其需要一个序列类的参数列表）。\n转换旗标为：\n旗标 含意\n'#' 值的转换将使用“替代形式”（具体定义见下文）。\n'0' 转换将为数字值填充零字符。\n'-' 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。\n' ' (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。\n'+' 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。\n可以给出长度修饰符 (h, l 或 L)，但会被忽略，因为对 Python 来说没有必要 -- 所以 %ld 等价于\n%d。\n转换类型为： |  |  |  |\n|  | 转换\n符 | 含意 | 备\n注 |  |\n|  | 'd' | 有符号十进制整数。 |  |  |\n|  | 'i' | 有符号十进制整数。 |  |  |\n|  | 'o' | 有符号八进制数。 | (1) |  |\n|  | 'u' | 过时类型 -- 等价于 'd'。 | (6) |  |\n|  | 'x' | 有符号十六进制数（小写）。 | (2) |  |\n|  | 'X' | 有符号十六进制数（大写）。 | (2) |  |\n|  | 'e' | 浮点指数格式（小写）。 | (3) |  |\n|  |  |  |  |  |\n\n| 旗标 | 含意 |\n| --- | --- |\n| '#' | 值的转换将使用“替代形式”（具体定义见下文）。 |\n| '0' | 转换将为数字值填充零字符。 |\n| '-' | 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。 |\n| ' ' | (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。 |\n| '+' | 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。 |\n\n转换 备\n含意\n符 注\n'E' 浮点指数格式（大写）。 (3)\n'f' 浮点十进制格式。 (3)\n'F' 浮点十进制格式。 (3)\n浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进\n'g' (4)\n制格式。\n浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进\n'G' (4)\n制格式。\n'c' 单个字符（接受整数或单个字符的字符串）。\n'r' 字符串（使用 repr() 转换任何 Python 对象）。 (5)\n's' 字符串（使用 str() 转换任何 Python 对象）。 (5)\n'a' 字符串（使用 ascii() 转换任何 Python 对象）。 (5)\n'%' 不转换参数，在结果中输出一个 '%' 字符。\n注释：\n1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 ('0o')。\n2. 此替代形式会在第一个数码之前插入 '0x' 或 '0X' 前缀（取决于是使用 'x' 还是 'X' 格\n式）。\n3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。\n小数点后的数码位数由精度决定，默认为 6。\n4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。\n小数点前后的有效数码位数由精度决定，默认为 6。\n5. 如果精度为 N，输出将截短为 N 个字符。\n6. 参见 PEP 237。\n由于 Python 字符串显式指明长度，%s 转换不会将 '\\0' 视为字符串的结束。\n在 3.1 版本发生变更: 绝对值超过 1e50 的 %f 转换不会再被替换为 %g 转换。\n二进制序列类型 --- bytes, bytearray, memoryview\n操作二进制数据的核心内置类型是 bytes 和 bytearray。 它们由 memoryview 提供支持，该对象使\n用 缓冲区协议 来访问其他二进制对象所在内存，不需要创建对象的副本。\n\n|  | 转换\n符 | 含意 | 备\n注 |  |\n| --- | --- | --- | --- | --- |\n|  | 'E' | 浮点指数格式（大写）。 | (3) |  |\n|  | 'f' | 浮点十进制格式。 | (3) |  |\n|  | 'F' | 浮点十进制格式。 | (3) |  |\n|  | 'g' | 浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进\n制格式。 | (4) |  |\n|  | 'G' | 浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进\n制格式。 | (4) |  |\n|  | 'c' | 单个字符（接受整数或单个字符的字符串）。 |  |  |\n|  | 'r' | 字符串（使用 repr() 转换任何 Python 对象）。 | (5) |  |\n|  | 's' | 字符串（使用 str() 转换任何 Python 对象）。 | (5) |  |\n|  | 'a' | 字符串（使用 ascii() 转换任何 Python 对象）。 | (5) |  |\n|  | '%' | 不转换参数，在结果中输出一个 '%' 字符。 |  |  |\n|  | 注释：\n1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 ('0o')。\n2. 此替代形式会在第一个数码之前插入 '0x' 或 '0X' 前缀（取决于是使用 'x' 还是 'X' 格\n式）。\n3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。\n小数点后的数码位数由精度决定，默认为 6。\n4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。\n小数点前后的有效数码位数由精度决定，默认为 6。\n5. 如果精度为 N，输出将截短为 N 个字符。\n6. 参见 PEP 237。\n由于 Python 字符串显式指明长度，%s 转换不会将 '\\0' 视为字符串的结束。\n在 3.1 版本发生变更: 绝对值超过 1e50 的 %f 转换不会再被替换为 %g 转换。\n二进制序列类型 --- bytes, bytearray, memoryview\n操作二进制数据的核心内置类型是 bytes 和 bytearray。 它们由 memoryview 提供支持，该对象使\n用 缓冲区协议 来访问其他二进制对象所在内存，不需要创建对象的副本。 |  |  |  |\n\narray 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。\nbytes 对象\nbytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此\nbytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的\n方法。\nclass bytes(source=b'')\nclass bytes(source, encoding, errors='strict')\n首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 b 前缀：\n单引号: b'同样允许嵌入 \"双\" 引号'。\n双引号: b\"仍然允许嵌入 '单' 引号\"\n三重引号: b'''三重单引号''', b\"\"\"三重双引号\"\"\"\nbytes 字面值中只允许 ASCII 字符（无论源代码声明的编码格式为何）。 任何超出 127 的二进\n制值必须使用相应的转义序列形式加入 bytes 字面值。\n像字符串字面值一样，bytes 字面值也可以使用 r 前缀来禁用转义序列处理。 请参阅 字符串与\n字节串字面量 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。\n虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整\n数序列，序列中的每个值的大小被限制为 0 <= x < 256 (如果违反此限制将引发\nValueError)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII\n的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常\n却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损\n坏）。\n除了字面值形式，bytes 对象还可以通过其他几种方式来创建：\n指定长度的以零值填充的 bytes 对象: bytes(10)\n通过由整数组成的可迭代对象: bytes(range(20))\n通过缓冲区协议复制现有的二进制数据: bytes(obj)\n另请参阅 bytes 内置类型。\n由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相\n应地，bytes 类型具有从此种格式读取数据的附加类方法：\nclassmethod fromhex(string, /)\n此 bytes 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两\n个十六进制数码构成，其中的 ASCII 空白符会被忽略。\n>>> bytes.fromhex('2Ef0 F1f2 ')\nb'.\\xf0\\xf1\\xf2'\n\n|  | array 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。\nbytes 对象\nbytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此\nbytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的\n方法。\nclass bytes(source=b'')\nclass bytes(source, encoding, errors='strict')\n首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 b 前缀：\n单引号: b'同样允许嵌入 \"双\" 引号'。\n双引号: b\"仍然允许嵌入 '单' 引号\"\n三重引号: b'''三重单引号''', b\"\"\"三重双引号\"\"\"\nbytes 字面值中只允许 ASCII 字符（无论源代码声明的编码格式为何）。 任何超出 127 的二进\n制值必须使用相应的转义序列形式加入 bytes 字面值。\n像字符串字面值一样，bytes 字面值也可以使用 r 前缀来禁用转义序列处理。 请参阅 字符串与\n字节串字面量 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。\n虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整\n数序列，序列中的每个值的大小被限制为 0 <= x < 256 (如果违反此限制将引发\nValueError)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII\n的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常\n却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损\n坏）。\n除了字面值形式，bytes 对象还可以通过其他几种方式来创建：\n指定长度的以零值填充的 bytes 对象: bytes(10)\n通过由整数组成的可迭代对象: bytes(range(20))\n通过缓冲区协议复制现有的二进制数据: bytes(obj)\n另请参阅 bytes 内置类型。\n由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相\n应地，bytes 类型具有从此种格式读取数据的附加类方法：\nclassmethod fromhex(string, /)\n此 bytes 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两\n个十六进制数码构成，其中的 ASCII 空白符会被忽略。\n>>> bytes.fromhex('2Ef0 F1f2 ')\nb'.\\xf0\\xf1\\xf2' |  |\n| --- | --- | --- |\n\n在 3.7 版本发生变更: bytes.fromhex() 现在会忽略所有 ASCII 空白符而不只是空格\n符。\n在 3.14 版本发生变更: bytes.fromhex() 现在接受 ASCII bytes 和 字节型对象 作为\n输入。\n存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。\n>>> b'\\xf0\\xf1\\xf2'.hex()\n'f0f1f2'\n如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 sep 形参包含于\n输出中。 默认情况下，该分隔符会放在每个字节之间。 第二个可选的 bytes_per_sep 形参\n控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。\n>>> value = b'\\xf0\\xf1\\xf2'\n>>> value.hex('-')\n'f0-f1-f2'\n>>> value.hex('_', 2)\n'f0_f1f2'\n>>> b'UUDDLRLRAB'.hex(' ', -4)\n'55554444 4c524c52 4142'\nAdded in version 3.5.\n在 3.8 版本发生变更: bytes.hex() 现在支持可选的 sep 和 bytes_per_sep 形参以在十\n六进制输出的字节之间插入分隔符。\n由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 b，b[0] 将为一个\n整数，而 b[0:1] 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的\n将都是一个长度为 1 的字符串）。\nbytes 对象的表示使用字面值格式 (b'...')，因为它通常都要比像 bytes([46, 46, 46]) 这样的格\n式更好用。 你总是可以使用 list(b) 将 bytes 对象转换为一个由整数构成的列表。\nbytearray 对象\nbytearray 对象是 bytes 对象的可变对应物。\nclass bytearray(source=b'')\nclass bytearray(source, encoding, errors='strict')\nbytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：\n创建一个空实例: bytearray()\n创建一个指定长度的以零值填充的实例: bytearray(10)\n\n|  | 在 3.7 版本发生变更: bytes.fromhex() 现在会忽略所有 ASCII 空白符而不只是空格\n符。\n在 3.14 版本发生变更: bytes.fromhex() 现在接受 ASCII bytes 和 字节型对象 作为\n输入。\n存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。\n>>> b'\\xf0\\xf1\\xf2'.hex()\n'f0f1f2'\n如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 sep 形参包含于\n输出中。 默认情况下，该分隔符会放在每个字节之间。 第二个可选的 bytes_per_sep 形参\n控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。\n>>> value = b'\\xf0\\xf1\\xf2'\n>>> value.hex('-')\n'f0-f1-f2'\n>>> value.hex('_', 2)\n'f0_f1f2'\n>>> b'UUDDLRLRAB'.hex(' ', -4)\n'55554444 4c524c52 4142'\nAdded in version 3.5.\n在 3.8 版本发生变更: bytes.hex() 现在支持可选的 sep 和 bytes_per_sep 形参以在十\n六进制输出的字节之间插入分隔符。\n由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 b，b[0] 将为一个\n整数，而 b[0:1] 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的\n将都是一个长度为 1 的字符串）。\nbytes 对象的表示使用字面值格式 (b'...')，因为它通常都要比像 bytes([46, 46, 46]) 这样的格\n式更好用。 你总是可以使用 list(b) 将 bytes 对象转换为一个由整数构成的列表。\nbytearray 对象\nbytearray 对象是 bytes 对象的可变对应物。\nclass bytearray(source=b'')\nclass bytearray(source, encoding, errors='strict')\nbytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：\n创建一个空实例: bytearray()\n创建一个指定长度的以零值填充的实例: bytearray(10) |  |\n| --- | --- | --- |\n\n通过由整数组成的可迭代对象: bytearray(range(20))\n通过缓冲区协议复制现有的二进制数据: bytearray(b'Hi!')\n由于 bytearray 对象是可变的，该对象除了 bytes 和 bytearray 操作 中所描述的 bytes 和\nbytearray 共有操作之外，还支持 可变 序列操作。\n另请参见 bytearray 内置类型。\n由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相\n应地，bytearray 类型具有从此种格式读取数据的附加类方法：\nclassmethod fromhex(string, /)\nbytearray 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字\n节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。\n>>> bytearray.fromhex('2Ef0 F1f2 ')\nbytearray(b'.\\xf0\\xf1\\xf2')\n在 3.7 版本发生变更: bytearray.fromhex() 现在会忽略所有 ASCII 空白符而不只是\n空格符。\n在 3.14 版本发生变更: bytearray.fromhex() 现在接受 ASCII bytes 和 字节型对象\n作为输入。\n存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。\n>>> bytearray(b'\\xf0\\xf1\\xf2').hex()\n'f0f1f2'\nAdded in version 3.5.\n在 3.8 版本发生变更: 与 bytes.hex() 相似， bytearray.hex() 现在支持可选的\nsep 和 bytes_per_sep 参数以在十六进制输出的字节之间插入分隔符。\nresize(size, /)\n调整 bytearray 的大小以包含 size 字节。size 必须大于等于 0。\n如果 bytearray 需要缩小，超过 size 的字节将被截断。\n如果 bytearray 需要增长，那些超过 size 的所有新字节，将被设置为空字节。\n这相当于：\n\n|  | 通过由整数组成的可迭代对象: bytearray(range(20))\n通过缓冲区协议复制现有的二进制数据: bytearray(b'Hi!')\n由于 bytearray 对象是可变的，该对象除了 bytes 和 bytearray 操作 中所描述的 bytes 和\nbytearray 共有操作之外，还支持 可变 序列操作。\n另请参见 bytearray 内置类型。\n由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相\n应地，bytearray 类型具有从此种格式读取数据的附加类方法：\nclassmethod fromhex(string, /)\nbytearray 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字\n节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。\n>>> bytearray.fromhex('2Ef0 F1f2 ')\nbytearray(b'.\\xf0\\xf1\\xf2')\n在 3.7 版本发生变更: bytearray.fromhex() 现在会忽略所有 ASCII 空白符而不只是\n空格符。\n在 3.14 版本发生变更: bytearray.fromhex() 现在接受 ASCII bytes 和 字节型对象\n作为输入。\n存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。\n>>> bytearray(b'\\xf0\\xf1\\xf2').hex()\n'f0f1f2'\nAdded in version 3.5.\n在 3.8 版本发生变更: 与 bytes.hex() 相似， bytearray.hex() 现在支持可选的\nsep 和 bytes_per_sep 参数以在十六进制输出的字节之间插入分隔符。\nresize(size, /)\n调整 bytearray 的大小以包含 size 字节。size 必须大于等于 0。\n如果 bytearray 需要缩小，超过 size 的字节将被截断。\n如果 bytearray 需要增长，那些超过 size 的所有新字节，将被设置为空字节。\n这相当于： |  |\n| --- | --- | --- |\n\n>>> def resize(ba, size):\n... if len(ba) > size:\n... del ba[size:]\n... else:\n... ba += b'\\0' * (size - len(ba))\n示例：\n>>> shrink = bytearray(b'abc')\n>>> shrink.resize(1)\n>>> (shrink, len(shrink))\n(bytearray(b'a'), 1)\n>>> grow = bytearray(b'abc')\n>>> grow.resize(5)\n>>> (grow, len(grow))\n(bytearray(b'abc\\x00\\x00'), 5)\nAdded in version 3.14.\n由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 b，b[0] 将\n为一个整数，而 b[0:1] 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切\n片所产生的将都是一个长度为 1 的字符串）。\nbytearray 对象的表示使用 bytes 对象字面值格式 (bytearray(b'...'))，因为它通常都要比\nbytearray([46, 46, 46]) 这样的格式更好用。 你总是可以使用 list(b) 将 bytearray 对象转换\n为一个由整数构成的列表。\nbytes 和 bytearray 操作\nbytes 和 bytearray 对象都支持 通用 序列操作。 它们不仅能与相同类型的操作数，也能与任何\nbytes-like object 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。\n但是，操作结果的返回值类型可能取决于操作数的顺序。\n备注: bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes\n对象作为其参数一样。 例如，你必须使用以下写法:\na = \"abc\"\nb = a.replace(\"a\", \"f\")\n和:\na = b\"abc\"\nb = a.replace(b\"a\", b\"f\")\n某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当\n避免使用。 这些限制会在下文中说明。\n备注: 使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数\n据损坏。\n\n|  | >>> def resize(ba, size):\n... if len(ba) > size:\n... del ba[size:]\n... else:\n... ba += b'\\0' * (size - len(ba))\n示例：\n>>> shrink = bytearray(b'abc')\n>>> shrink.resize(1)\n>>> (shrink, len(shrink))\n(bytearray(b'a'), 1)\n>>> grow = bytearray(b'abc')\n>>> grow.resize(5)\n>>> (grow, len(grow))\n(bytearray(b'abc\\x00\\x00'), 5)\nAdded in version 3.14.\n由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 b，b[0] 将\n为一个整数，而 b[0:1] 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切\n片所产生的将都是一个长度为 1 的字符串）。\nbytearray 对象的表示使用 bytes 对象字面值格式 (bytearray(b'...'))，因为它通常都要比\nbytearray([46, 46, 46]) 这样的格式更好用。 你总是可以使用 list(b) 将 bytearray 对象转换\n为一个由整数构成的列表。\nbytes 和 bytearray 操作\nbytes 和 bytearray 对象都支持 通用 序列操作。 它们不仅能与相同类型的操作数，也能与任何\nbytes-like object 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。\n但是，操作结果的返回值类型可能取决于操作数的顺序。 | >>> def resize(ba, size):\n... if len(ba) > size:\n... del ba[size:]\n... else:\n... ba += b'\\0' * (size - len(ba)) |  |\n| --- | --- | --- | --- |\n|  | 备注: bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes\n对象作为其参数一样。 例如，你必须使用以下写法:\na = \"abc\"\nb = a.replace(\"a\", \"f\")\n和:\na = b\"abc\"\nb = a.replace(b\"a\", b\"f\") |  |  |\n|  | 某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当\n避免使用。 这些限制会在下文中说明。 |  |  |\n|  | 备注: 使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数\n据损坏。 |  |  |\n|  |  |  |  |\n\nbytes 和 bytearray 对象的下列方法可以用于任意二进制数据。\nbytes.count(sub[, start[, end]])\nbytearray.count(sub[, start[, end]])\n返回子序列 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为切\n片表示法。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n如果 sub 为空，则返回字符之间的空切片的数量即字节串对象的长度加一。\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.removeprefix(prefix, /)\nbytearray.removeprefix(prefix, /)\n如果二进制数据以 prefix 字符串开头，返回 bytes[len(prefix):]。 否则，返回原始二进制\n数据的副本：\n>>> b'TestHook'.removeprefix(b'Test')\nb'Hook'\n>>> b'BaseTestCase'.removeprefix(b'Test')\nb'BaseTestCase'\nprefix 可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nAdded in version 3.9.\nbytes.removesuffix(suffix, /)\nbytearray.removesuffix(suffix, /)\n如果二进制数据以 suffix 字符串结尾，并且 suffix 非空，返回 bytes[:-len(suffix)]。 否\n则，返回原始二进制数据的副本:\n>>> b'MiscTests'.removesuffix(b'Tests')\nb'Misc'\n>>> b'TmpDirMixin'.removesuffix(b'Tests')\nb'TmpDirMixin'\nsuffix 可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nAdded in version 3.9.\nbytes.decode(encoding='utf-8', errors='strict')\nbytearray.decode(encoding='utf-8', errors='strict')\n\n|  | bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。\nbytes.count(sub[, start[, end]])\nbytearray.count(sub[, start[, end]])\n返回子序列 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为切\n片表示法。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n如果 sub 为空，则返回字符之间的空切片的数量即字节串对象的长度加一。\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.removeprefix(prefix, /)\nbytearray.removeprefix(prefix, /)\n如果二进制数据以 prefix 字符串开头，返回 bytes[len(prefix):]。 否则，返回原始二进制\n数据的副本：\n>>> b'TestHook'.removeprefix(b'Test')\nb'Hook'\n>>> b'BaseTestCase'.removeprefix(b'Test')\nb'BaseTestCase'\nprefix 可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nAdded in version 3.9.\nbytes.removesuffix(suffix, /)\nbytearray.removesuffix(suffix, /)\n如果二进制数据以 suffix 字符串结尾，并且 suffix 非空，返回 bytes[:-len(suffix)]。 否\n则，返回原始二进制数据的副本:\n>>> b'MiscTests'.removesuffix(b'Tests')\nb'Misc'\n>>> b'TmpDirMixin'.removesuffix(b'Tests')\nb'TmpDirMixin'\nsuffix 可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nAdded in version 3.9.\nbytes.decode(encoding='utf-8', errors='strict')\nbytearray.decode(encoding='utf-8', errors='strict') |  |\n| --- | --- | --- |\n\n返回解码为 str 的字节串。\nencoding 默认为 'utf-8' ；请参阅 标准编码 了解其他可能的值。\nerrors 控制如何处理编码错误。 如为 'strict' (默认值)，则会引发 UnicodeError。 其他可能\n的值有 'ignore', 'replace' 以及通过 codecs.register_error() 注册的任何其他名称。 请\n参阅 错误处理方案 了解详情。\n出于性能原因，除非真正发生了编码错误，启用了 Python 开发模式 或使用了 调试编译版 否则\n不会检查 errors 值的有效性。\n备注: 将 encoding 参数传给 str 允许直接解码任何 bytes-like object，无须创建临时的\nbytes 或 bytearray 对象。\n在 3.1 版本发生变更: 加入了对关键字参数的支持。\n在 3.9 版本发生变更: 现在会在 Python 开发模式 和 调试模式 下检查 errors 参数的值。\nbytes.endswith(suffix[, start[, end]])\nbytearray.endswith(suffix[, start[, end]])\n如果二进制数据以指定的 suffix 结束则返回 True，否则返回 False。 suffix 也可以为由多个供\n查找的后缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，\n将在所指定位置停止比较。\n要搜索的后缀可以是任意 bytes-like object。\nbytes.find(sub[, start[, end]])\nbytearray.find(sub[, start[, end]])\n返回子序列 sub 在数据中被找到的最小索引，sub 包含于切片 s[start:end] 之内。 可选参数\nstart 与 end 会被解读为切片表示法。 如果 sub 未被找到则返回 -1。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n备注: find() 方法应该只在你需要知道 sub 所在位置时使用。 要检查 sub 是否为子串，请\n使用 in 操作符:\n>>> b'Py' in b'Python'\nTrue\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.index(sub[, start[, end]])\nbytearray.index(sub[, start[, end]])\n类似于 find()，但在找不到子序列时会引发 ValueError。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n\n|  | 返回解码为 str 的字节串。\nencoding 默认为 'utf-8' ；请参阅 标准编码 了解其他可能的值。\nerrors 控制如何处理编码错误。 如为 'strict' (默认值)，则会引发 UnicodeError。 其他可能\n的值有 'ignore', 'replace' 以及通过 codecs.register_error() 注册的任何其他名称。 请\n参阅 错误处理方案 了解详情。\n出于性能原因，除非真正发生了编码错误，启用了 Python 开发模式 或使用了 调试编译版 否则\n不会检查 errors 值的有效性。\n备注: 将 encoding 参数传给 str 允许直接解码任何 bytes-like object，无须创建临时的\nbytes 或 bytearray 对象。\n在 3.1 版本发生变更: 加入了对关键字参数的支持。\n在 3.9 版本发生变更: 现在会在 Python 开发模式 和 调试模式 下检查 errors 参数的值。\nbytes.endswith(suffix[, start[, end]])\nbytearray.endswith(suffix[, start[, end]])\n如果二进制数据以指定的 suffix 结束则返回 True，否则返回 False。 suffix 也可以为由多个供\n查找的后缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，\n将在所指定位置停止比较。\n要搜索的后缀可以是任意 bytes-like object。\nbytes.find(sub[, start[, end]])\nbytearray.find(sub[, start[, end]])\n返回子序列 sub 在数据中被找到的最小索引，sub 包含于切片 s[start:end] 之内。 可选参数\nstart 与 end 会被解读为切片表示法。 如果 sub 未被找到则返回 -1。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n备注: find() 方法应该只在你需要知道 sub 所在位置时使用。 要检查 sub 是否为子串，请\n使用 in 操作符:\n>>> b'Py' in b'Python'\nTrue\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.index(sub[, start[, end]])\nbytearray.index(sub[, start[, end]])\n类似于 find()，但在找不到子序列时会引发 ValueError。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。 |  |\n| --- | --- | --- |\n\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.join(iterable, /)\nbytearray.join(iterable, /)\n返回一个由 iterable 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 iterable 中\n存在任何非 字节类对象 包括存在 str 对象值则会引发 TypeError。 提供该方法的 bytes 或\nbytearray 对象的内容将作为元素之间的分隔。\nstatic bytes.maketrans(from, to, /)\nstatic bytearray.maketrans(from, to, /)\n此静态方法返回一个可用于 bytes.translate() 的转换对照表，它将把 from 中的每个字符映\n射为 to 中相同位置上的字符；from 与 to 必须都是 字节类对象 并且具有相同的长度。\nAdded in version 3.1.\nbytes.partition(sep, /)\nbytearray.partition(sep, /)\n在 sep 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身\n或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原\n序列以及两个空的 bytes 或 bytearray 对象。\n要搜索的分隔符可以是任意 bytes-like object。\nbytes.replace(old, new, count=-1, /)\nbytearray.replace(old, new, count=-1, /)\n返回序列的副本，其中出现的所有子序列 old 都将被替换为 new。 如果给出了可选参数\ncount，则只替换前 count 次出现。\n要搜索的子序列及其替换序列可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rfind(sub[, start[, end]])\nbytearray.rfind(sub[, start[, end]])\n返回子序列 sub 在序列内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end] 当\n中。 可选参数 start 与 end 会被解读为切片表示法。 如果未找到则返回 -1。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.rindex(sub[, start[, end]])\nbytearray.rindex(sub[, start[, end]])\n类似于 rfind()，但在子序列 sub 未找到时会引发 ValueError。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n\n|  | 在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.join(iterable, /)\nbytearray.join(iterable, /)\n返回一个由 iterable 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 iterable 中\n存在任何非 字节类对象 包括存在 str 对象值则会引发 TypeError。 提供该方法的 bytes 或\nbytearray 对象的内容将作为元素之间的分隔。\nstatic bytes.maketrans(from, to, /)\nstatic bytearray.maketrans(from, to, /)\n此静态方法返回一个可用于 bytes.translate() 的转换对照表，它将把 from 中的每个字符映\n射为 to 中相同位置上的字符；from 与 to 必须都是 字节类对象 并且具有相同的长度。\nAdded in version 3.1.\nbytes.partition(sep, /)\nbytearray.partition(sep, /)\n在 sep 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身\n或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原\n序列以及两个空的 bytes 或 bytearray 对象。\n要搜索的分隔符可以是任意 bytes-like object。\nbytes.replace(old, new, count=-1, /)\nbytearray.replace(old, new, count=-1, /)\n返回序列的副本，其中出现的所有子序列 old 都将被替换为 new。 如果给出了可选参数\ncount，则只替换前 count 次出现。\n要搜索的子序列及其替换序列可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rfind(sub[, start[, end]])\nbytearray.rfind(sub[, start[, end]])\n返回子序列 sub 在序列内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end] 当\n中。 可选参数 start 与 end 会被解读为切片表示法。 如果未找到则返回 -1。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.rindex(sub[, start[, end]])\nbytearray.rindex(sub[, start[, end]])\n类似于 rfind()，但在子序列 sub 未找到时会引发 ValueError。\n要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。 |  |\n| --- | --- | --- |\n\n在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.rpartition(sep, /)\nbytearray.rpartition(sep, /)\n在 sep 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符\n本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包\n含两个空的 bytes 或 bytearray 对象以及原序列的副本。\n要搜索的分隔符可以是任意 bytes-like object。\nbytes.startswith(prefix[, start[, end]])\nbytearray.startswith(prefix[, start[, end]])\n如果二进制数据以指定的 prefix 开头则返回 True，否则返回 False。 prefix 也可以为由多个供\n查找的前缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，\n将在所指定位置停止比较。\n要搜索的前缀可以是任意 bytes-like object。\nbytes.translate(table, /, delete=b'')\nbytearray.translate(table, /, delete=b'')\n返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 delete 中出现的 bytes，其余\nbytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。\n你可以使用 bytes.maketrans() 方法来创建转换表。\n对于仅需移除字符的转换，请将 table 参数设为 None:\n>>> b'read this short text'.translate(None, b'aeiou')\nb'rd ths shrt txt'\n在 3.6 版本发生变更: 现在支持将 delete 作为关键字参数。\n以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适\n当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 不是 原地执行操\n作，而是会产生新的对象。\nbytes.center(width, fillbyte=b' ', /)\nbytearray.center(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列内居中，使用指定的 fillbyte 填充两边的空位（默认\n使用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.ljust(width, fillbyte=b' ', /)\nbytearray.ljust(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列中靠左对齐。 使用指定的 fillbyte 填充空位（默认使\n用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。\n\n|  | 在 3.3 版本发生变更: 也接受 0 至 255 范围内的整数作为子序列。\nbytes.rpartition(sep, /)\nbytearray.rpartition(sep, /)\n在 sep 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符\n本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包\n含两个空的 bytes 或 bytearray 对象以及原序列的副本。\n要搜索的分隔符可以是任意 bytes-like object。\nbytes.startswith(prefix[, start[, end]])\nbytearray.startswith(prefix[, start[, end]])\n如果二进制数据以指定的 prefix 开头则返回 True，否则返回 False。 prefix 也可以为由多个供\n查找的前缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，\n将在所指定位置停止比较。\n要搜索的前缀可以是任意 bytes-like object。\nbytes.translate(table, /, delete=b'')\nbytearray.translate(table, /, delete=b'')\n返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 delete 中出现的 bytes，其余\nbytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。\n你可以使用 bytes.maketrans() 方法来创建转换表。\n对于仅需移除字符的转换，请将 table 参数设为 None:\n>>> b'read this short text'.translate(None, b'aeiou')\nb'rd ths shrt txt'\n在 3.6 版本发生变更: 现在支持将 delete 作为关键字参数。\n以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适\n当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 不是 原地执行操\n作，而是会产生新的对象。\nbytes.center(width, fillbyte=b' ', /)\nbytearray.center(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列内居中，使用指定的 fillbyte 填充两边的空位（默认\n使用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.ljust(width, fillbyte=b' ', /)\nbytearray.ljust(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列中靠左对齐。 使用指定的 fillbyte 填充空位（默认使\n用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。 |  |\n| --- | --- | --- |\n\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.lstrip(bytes=None, /)\nbytearray.lstrip(bytes=None, /)\n返回移除指定起始字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数并非前\n缀匹配；实际上，它会移除所有匹配该参数值组合的字节:\n>>> b' spacious '.lstrip()\nb'spacious '\n>>> b'www.example.com'.lstrip(b'cmowz.')\nb'example.com'\n要移除的二进制序列可以是任意 bytes-like object 。 要删除单个前缀字符串，而不是全部给定\n集合中的字符，请参见 str.removeprefix() 方法。 例如:\n>>> b'Arthur: three!'.lstrip(b'Arthur: ')\nb'ee!'\n>>> b'Arthur: three!'.removeprefix(b'Arthur: ')\nb'three!'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rjust(width, fillbyte=b' ', /)\nbytearray.rjust(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列中靠右对齐。 使用指定的 fillbyte 填充空位（默认使\n用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rsplit(sep=None, maxsplit=-1)\nbytearray.rsplit(sep=None, maxsplit=-1)\n将二进制序列拆分为相同类型的子序列，使用 sep 作为分隔符。 如果给出了 maxsplit，则最多\n进行 maxsplit 次拆分，从 最右边 开始。 如果 sep 未指定或为 None，任何只包含 ASCII 空白符\n的子序列都会被作为分隔符。 除了从右边开始拆分，rsplit() 的其他行为都类似于下文所述\n的 split()。\nbytes.rstrip(bytes=None, /)\nbytearray.rstrip(bytes=None, /)\n返回移除指定尾部字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数并非后\n缀匹配；实际上，它会移除所有匹配该参数值组合的字节:\n\n|  | 备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.lstrip(bytes=None, /)\nbytearray.lstrip(bytes=None, /)\n返回移除指定起始字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数并非前\n缀匹配；实际上，它会移除所有匹配该参数值组合的字节:\n>>> b' spacious '.lstrip()\nb'spacious '\n>>> b'www.example.com'.lstrip(b'cmowz.')\nb'example.com'\n要移除的二进制序列可以是任意 bytes-like object 。 要删除单个前缀字符串，而不是全部给定\n集合中的字符，请参见 str.removeprefix() 方法。 例如:\n>>> b'Arthur: three!'.lstrip(b'Arthur: ')\nb'ee!'\n>>> b'Arthur: three!'.removeprefix(b'Arthur: ')\nb'three!'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rjust(width, fillbyte=b' ', /)\nbytearray.rjust(width, fillbyte=b' ', /)\n返回原对象的副本，在长度为 width 的序列中靠右对齐。 使用指定的 fillbyte 填充空位（默认使\n用 ASCII 空格符）。 对于 bytes 对象，如果 width 小于等于 len(s) 则返回原序列的副本。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.rsplit(sep=None, maxsplit=-1)\nbytearray.rsplit(sep=None, maxsplit=-1)\n将二进制序列拆分为相同类型的子序列，使用 sep 作为分隔符。 如果给出了 maxsplit，则最多\n进行 maxsplit 次拆分，从 最右边 开始。 如果 sep 未指定或为 None，任何只包含 ASCII 空白符\n的子序列都会被作为分隔符。 除了从右边开始拆分，rsplit() 的其他行为都类似于下文所述\n的 split()。\nbytes.rstrip(bytes=None, /)\nbytearray.rstrip(bytes=None, /)\n返回移除指定尾部字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数并非后\n缀匹配；实际上，它会移除所有匹配该参数值组合的字节: | 备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。 |  |\n| --- | --- | --- | --- |\n\n>>> b' spacious '.rstrip()\nb' spacious'\n>>> b'mississippi'.rstrip(b'ipz')\nb'mississ'\n要移除的二进制序列可以是任意 bytes-like object 。 要删除单个后缀字符串，而不是全部给定\n集合中的字符，请参见 str.removesuffix() 方法。 例如:\n>>> b'Monty Python'.rstrip(b' Python')\nb'M'\n>>> b'Monty Python'.removesuffix(b' Python')\nb'Monty'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.split(sep=None, maxsplit=-1)\nbytearray.split(sep=None, maxsplit=-1)\n将二进制序列拆分为相同类型的子序列，使用 sep 作为分隔符。 如果给出了 maxsplit 且非负\n值，则最多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。 如果 maxsplit\n未指定或为 -1，则不限制拆分次数（进行所有可能的拆分）。\n如果给出了 sep，则连续的分隔符不会被组合在一起而是会被视为分隔空子序列 (例如\nb'1,,2'.split(b',') 将将返回 [b'1', b'', b'2'])。 sep 参数可能是由多个序列组成的单\n个分隔符。 使用指定的分隔符拆分一个空序列将返回 [b''] 或 [bytearray(b'')]，具体取决\n于被拆分对象的类型。 sep 参数可以是任何 bytes-like object。\n例如：\n>>> b'1,2,3'.split(b',')\n[b'1', b'2', b'3']\n>>> b'1,2,3'.split(b',', maxsplit=1)\n[b'1', b'2,3']\n>>> b'1,2,,3,'.split(b',')\n[b'1', b'2', b'', b'3', b'']\n>>> b'1<>2<>3<4'.split(b'<>')\n[b'1', b'2', b'3<4']\n如果 sep 未指定或为 None，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔\n符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅\n包含 ASCII 空白符的序列进行拆分将返回 []。\n例如：\n>>> b'1 2 3'.split()\n[b'1', b'2', b'3']\n>>> b'1 2 3'.split(maxsplit=1)\n[b'1', b'2 3']\n>>> b' 1 2 3 '.split()\n[b'1', b'2', b'3']\n\n|  | >>> b' spacious '.rstrip()\nb' spacious'\n>>> b'mississippi'.rstrip(b'ipz')\nb'mississ'\n要移除的二进制序列可以是任意 bytes-like object 。 要删除单个后缀字符串，而不是全部给定\n集合中的字符，请参见 str.removesuffix() 方法。 例如:\n>>> b'Monty Python'.rstrip(b' Python')\nb'M'\n>>> b'Monty Python'.removesuffix(b' Python')\nb'Monty'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.split(sep=None, maxsplit=-1)\nbytearray.split(sep=None, maxsplit=-1)\n将二进制序列拆分为相同类型的子序列，使用 sep 作为分隔符。 如果给出了 maxsplit 且非负\n值，则最多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。 如果 maxsplit\n未指定或为 -1，则不限制拆分次数（进行所有可能的拆分）。\n如果给出了 sep，则连续的分隔符不会被组合在一起而是会被视为分隔空子序列 (例如\nb'1,,2'.split(b',') 将将返回 [b'1', b'', b'2'])。 sep 参数可能是由多个序列组成的单\n个分隔符。 使用指定的分隔符拆分一个空序列将返回 [b''] 或 [bytearray(b'')]，具体取决\n于被拆分对象的类型。 sep 参数可以是任何 bytes-like object。\n例如：\n>>> b'1,2,3'.split(b',')\n[b'1', b'2', b'3']\n>>> b'1,2,3'.split(b',', maxsplit=1)\n[b'1', b'2,3']\n>>> b'1,2,,3,'.split(b',')\n[b'1', b'2', b'', b'3', b'']\n>>> b'1<>2<>3<4'.split(b'<>')\n[b'1', b'2', b'3<4']\n如果 sep 未指定或为 None，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔\n符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅\n包含 ASCII 空白符的序列进行拆分将返回 []。\n例如：\n>>> b'1 2 3'.split()\n[b'1', b'2', b'3']\n>>> b'1 2 3'.split(maxsplit=1)\n[b'1', b'2 3']\n>>> b' 1 2 3 '.split()\n[b'1', b'2', b'3'] | >>> b' spacious '.rstrip()\nb' spacious'\n>>> b'mississippi'.rstrip(b'ipz')\nb'mississ' |  |\n| --- | --- | --- | --- |\n\nbytes.strip(bytes=None, /)\nbytearray.strip(bytes=None, /)\n返回移除指定首尾字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数既非前\n缀也非后缀匹配；实际上，它会移除所有匹配该参数值组合的首尾字节:\n>>> b' spacious '.strip()\nb'spacious'\n>>> b'www.example.com'.strip(b'cmowz.')\nb'example'\n要移除的字节值二进制序列可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\n以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进\n制数据。 请注意本小节中所有的 bytearray 方法都 不是 原地执行操作，而是会产生新的对象。\nbytes.capitalize()\nbytearray.capitalize()\n返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大\n写而其余的小写。 非 ASCII 字节值将保持原样不变。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.expandtabs(tabsize=8)\nbytearray.expandtabs(tabsize=8)\n返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前\n列位置和给定的制表符宽度。 每 tabsize 个字节设为一个制表位（默认值 8 时设定的制表位在\n列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。\n如果字节为 ASCII 制表符 (b'\\t')，则并在结果中插入一个或多个空格符，直到当前列等于下一\n个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (b'\\n') 或回车符\n(b'\\r')，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加\n一，不论该字节值在被打印时会如何显示:\n>>> b'01\\t012\\t0123\\t01234'.expandtabs()\nb'01 012 0123 01234'\n>>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\nb'01 012 0123 01234'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.isalnum()\n\n|  | bytes.strip(bytes=None, /)\nbytearray.strip(bytes=None, /)\n返回移除指定首尾字节后的序列副本。bytes 参数是一个二进制序列，用于指定要移除的字节值\n集合。如果省略或设为 None，则 bytes 参数默认移除 ASCII 空白符。需注意，bytes 参数既非前\n缀也非后缀匹配；实际上，它会移除所有匹配该参数值组合的首尾字节:\n>>> b' spacious '.strip()\nb'spacious'\n>>> b'www.example.com'.strip(b'cmowz.')\nb'example'\n要移除的字节值二进制序列可以是任意 bytes-like object。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\n以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进\n制数据。 请注意本小节中所有的 bytearray 方法都 不是 原地执行操作，而是会产生新的对象。\nbytes.capitalize()\nbytearray.capitalize()\n返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大\n写而其余的小写。 非 ASCII 字节值将保持原样不变。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.expandtabs(tabsize=8)\nbytearray.expandtabs(tabsize=8)\n返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前\n列位置和给定的制表符宽度。 每 tabsize 个字节设为一个制表位（默认值 8 时设定的制表位在\n列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。\n如果字节为 ASCII 制表符 (b'\\t')，则并在结果中插入一个或多个空格符，直到当前列等于下一\n个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (b'\\n') 或回车符\n(b'\\r')，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加\n一，不论该字节值在被打印时会如何显示:\n>>> b'01\\t012\\t0123\\t01234'.expandtabs()\nb'01 012 0123 01234'\n>>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\nb'01 012 0123 01234'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.isalnum() |  |\n| --- | --- | --- |\n\nbytearray.isalnum()\n如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 True ，否\n则返回 False 。 字母类 ASCII 字符就是字节值包含在序列\nb'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。 ASCII 十进制数\n码就是字节值包含在序列 b'0123456789' 中的字符。\n例如：\n>>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\nbytes.isalpha()\nbytearray.isalpha()\n如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 True ，否则返回 False 。\n字母类 ASCII 字符就是字节值包含在序列\nb'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n例如：\n>>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\nbytes.isascii()\nbytearray.isascii()\n如果序列为空或序列中所有字节都是 ASCII 字节则返回 True ，否则返回 False 。 ASCII 字节\n的取值范围是 0-0x7F。\nAdded in version 3.7.\nbytes.isdigit()\nbytearray.isdigit()\n如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 True ，否则返回 False 。\nASCII 十进制数码就是字节值包含在序列 b'0123456789' 中的字符。\n例如：\n>>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\nbytes.islower()\nbytearray.islower()\n如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 True ，否则返回\nFalse 。\n\n|  | bytearray.isalnum()\n如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 True ，否\n则返回 False 。 字母类 ASCII 字符就是字节值包含在序列\nb'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。 ASCII 十进制数\n码就是字节值包含在序列 b'0123456789' 中的字符。\n例如：\n>>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\nbytes.isalpha()\nbytearray.isalpha()\n如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 True ，否则返回 False 。\n字母类 ASCII 字符就是字节值包含在序列\nb'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n例如：\n>>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\nbytes.isascii()\nbytearray.isascii()\n如果序列为空或序列中所有字节都是 ASCII 字节则返回 True ，否则返回 False 。 ASCII 字节\n的取值范围是 0-0x7F。\nAdded in version 3.7.\nbytes.isdigit()\nbytearray.isdigit()\n如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 True ，否则返回 False 。\nASCII 十进制数码就是字节值包含在序列 b'0123456789' 中的字符。\n例如：\n>>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\nbytes.islower()\nbytearray.islower()\n如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 True ，否则返回\nFalse 。 |  |\n| --- | --- | --- |\n\n例如：\n>>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\nbytes.isspace()\nbytearray.isspace()\n如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 True ，否则返回 False 。 ASCII\n空白符就是字节值包含在序列 b' \\t\\n\\r\\x0b\\f' (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的\n字符。\nbytes.istitle()\nbytearray.istitle()\n如果序列为 ASCII 标题大小写形式并且序列非空则返回 True ，否则返回 False 。 请参阅\nbytes.title() 了解有关“标题大小写”的详细定义。\n例如：\n>>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\nbytes.isupper()\nbytearray.isupper()\n如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 True ，否则返回\nFalse 。\n例如：\n>>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\nbytes.lower()\nbytearray.lower()\n返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。\n例如：\n\n|  | 例如：\n>>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\nbytes.isspace()\nbytearray.isspace()\n如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 True ，否则返回 False 。 ASCII\n空白符就是字节值包含在序列 b' \\t\\n\\r\\x0b\\f' (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的\n字符。\nbytes.istitle()\nbytearray.istitle()\n如果序列为 ASCII 标题大小写形式并且序列非空则返回 True ，否则返回 False 。 请参阅\nbytes.title() 了解有关“标题大小写”的详细定义。\n例如：\n>>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\nbytes.isupper()\nbytearray.isupper()\n如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 True ，否则返回\nFalse 。\n例如：\n>>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\nbytes.lower()\nbytearray.lower()\n返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。\n例如： |  |\n| --- | --- | --- |\n\n>>> b'Hello World'.lower()\nb'hello world'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.splitlines(keepends=False)\nbytearray.splitlines(keepends=False)\n返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 universal\nnewlines 方式来分行。 结果列表中不包含换行符，除非给出了 keepends 且为真值。\n例如：\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n不同于 split()，当给出了分隔符 sep 时，对于空字符串此方法将返回一个空列表，而末尾的\n换行不会令结果中增加额外的行:\n>>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n([b''], [b'Two lines', b''])\n>>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n([], [b'One line'])\nbytes.swapcase()\nbytearray.swapcase()\n返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。\n例如：\n>>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n不同于 str.swapcase()，在二进制版本下 bin.swapcase().swapcase() == bin 始终成立。\n大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.title()\n\n|  | >>> b'Hello World'.lower()\nb'hello world'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.splitlines(keepends=False)\nbytearray.splitlines(keepends=False)\n返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 universal\nnewlines 方式来分行。 结果列表中不包含换行符，除非给出了 keepends 且为真值。\n例如：\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n不同于 split()，当给出了分隔符 sep 时，对于空字符串此方法将返回一个空列表，而末尾的\n换行不会令结果中增加额外的行:\n>>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n([b''], [b'Two lines', b''])\n>>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n([], [b'One line'])\nbytes.swapcase()\nbytearray.swapcase()\n返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。\n例如：\n>>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n不同于 str.swapcase()，在二进制版本下 bin.swapcase().swapcase() == bin 始终成立。\n大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.title() | >>> b'Hello World'.lower()\nb'hello world' |  |\n| --- | --- | --- | --- |\n\nbytearray.title()\n返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小\n写。 不区别大小写的字节值将保持原样不变。\n例如：\n>>> b'Hello world'.title()\nb'Hello World'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。 所有其他字\n节值都不区分大小写。\n该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下\n都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望\n的结果:\n>>> b\"they're bill's friends from the UK\".title()\nb\"They'Re Bill'S Friends From The Uk\"\n可以使用正则表达式来构建针对撇号的特别处理:\n>>> import re\n>>> def titlecase(s):\n... return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n... lambda mo: mo.group(0)[0:1].upper() +\n... mo.group(0)[1:].lower(),\n... s)\n...\n>>> titlecase(b\"they're bill's friends.\")\nb\"They're Bill's Friends.\"\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.upper()\nbytearray.upper()\n返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。\n例如：\n>>> b'Hello World'.upper()\nb'HELLO WORLD'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\n\n|  | bytearray.title()\n返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小\n写。 不区别大小写的字节值将保持原样不变。\n例如：\n>>> b'Hello world'.title()\nb'Hello World'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。 所有其他字\n节值都不区分大小写。\n该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下\n都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望\n的结果:\n>>> b\"they're bill's friends from the UK\".title()\nb\"They'Re Bill'S Friends From The Uk\"\n可以使用正则表达式来构建针对撇号的特别处理:\n>>> import re\n>>> def titlecase(s):\n... return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n... lambda mo: mo.group(0)[0:1].upper() +\n... mo.group(0)[1:].lower(),\n... s)\n...\n>>> titlecase(b\"they're bill's friends.\")\nb\"They're Bill's Friends.\"\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nbytes.upper()\nbytearray.upper()\n返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。\n例如：\n>>> b'Hello World'.upper()\nb'HELLO WORLD'\n小写 ASCII 字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyz' 中的字符。 大写\nASCII 字符就是字节值包含在序列 b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 中的字符。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。 |  |  |\n| --- | --- | --- | --- |\n|  |  | 备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。 |  |\n\nbytes.zfill(width, /)\nbytearray.zfill(width, /)\n返回原序列的副本，在左边填充 b'0' 数码使序列长度为 width。 正负值前缀 (b'+'/ b'-') 的\n处理方式是在正负符号 之后 填充而非在之前。 对于 bytes 对象，如果 width 小于等于\nlen(seq) 则返回原序列。\n例如：\n>>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nprintf 风格的字节串格式化\n备注: 此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元\n组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。\n字节串对象 (bytes/bytearray) 具有一种特殊的内置操作：使用 % (取模) 运算符。 这也被称为字节\n串的 格式化 或 插值 运算符。 对于 format % values (其中 format 为一个字节串对象)，在 format\n中的 % 转换标记符将被替换为零个或多个 values 条目。 其效果类似于在 C 语言中使用\nsprintf()。\n如果 format 要求一个单独参数，则 values 可以为一个非元组对象。 [5] 否则的话，values 必须或是\n是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象\n（例如元组）。\n转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：\n1. '%' 字符，用于标记转换符的起始。\n2. 映射键（可选），由加圆括号的字符序列组成 (例如 (somename))。\n3. 转换旗标（可选），用于影响某些转换类型的结果。\n4. 最小字段宽度（可选）。 如果指定为 '*' (星号)，则实际宽度会从 values 元组的下一元素中\n读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。\n5. 精度（可选），以在 '.' (点号) 之后加精度值的形式给出。 如果指定为 '*' (星号)，则实际\n精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。\n6. 长度修饰符（可选）。\n7. 转换类型。\n当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 必须 包含加圆括号的映射\n键，对应 '%' 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：\n>>> print(b'%(language)s has %(number)03d quote types.' %\n... {b'language': b\"Python\", b\"number\": 2})\n\n|  | bytes.zfill(width, /)\nbytearray.zfill(width, /)\n返回原序列的副本，在左边填充 b'0' 数码使序列长度为 width。 正负值前缀 (b'+'/ b'-') 的\n处理方式是在正负符号 之后 填充而非在之前。 对于 bytes 对象，如果 width 小于等于\nlen(seq) 则返回原序列。\n例如：\n>>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任\n何改变。\nprintf 风格的字节串格式化 |  |\n| --- | --- | --- |\n|  | 备注: 此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元\n组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。 |  |\n|  | 字节串对象 (bytes/bytearray) 具有一种特殊的内置操作：使用 % (取模) 运算符。 这也被称为字节\n串的 格式化 或 插值 运算符。 对于 format % values (其中 format 为一个字节串对象)，在 format\n中的 % 转换标记符将被替换为零个或多个 values 条目。 其效果类似于在 C 语言中使用\nsprintf()。\n如果 format 要求一个单独参数，则 values 可以为一个非元组对象。 [5] 否则的话，values 必须或是\n是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象\n（例如元组）。\n转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：\n1. '%' 字符，用于标记转换符的起始。\n2. 映射键（可选），由加圆括号的字符序列组成 (例如 (somename))。\n3. 转换旗标（可选），用于影响某些转换类型的结果。\n4. 最小字段宽度（可选）。 如果指定为 '*' (星号)，则实际宽度会从 values 元组的下一元素中\n读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。\n5. 精度（可选），以在 '.' (点号) 之后加精度值的形式给出。 如果指定为 '*' (星号)，则实际\n精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。\n6. 长度修饰符（可选）。\n7. 转换类型。\n当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 必须 包含加圆括号的映射\n键，对应 '%' 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如： |  |\n|  | >>> print(b'%(language)s has %(number)03d quote types.' %\n... {b'language': b\"Python\", b\"number\": 2}) |  |\n\nb'Python has 002 quote types.'\n在此情况下格式中不能出现 * 标记符（因其需要一个序列类的参数列表）。\n转换旗标为：\n旗标 含意\n'#' 值的转换将使用“替代形式”（具体定义见下文）。\n'0' 转换将为数字值填充零字符。\n'-' 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。\n' ' (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。\n'+' 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。\n可以给出长度修饰符 (h, l 或 L)，但会被忽略，因为对 Python 来说没有必要 -- 所以 %ld 等价于\n%d。\n转换类型为：\n转换 备\n含意\n符 注\n'd' 有符号十进制整数。\n'i' 有符号十进制整数。\n'o' 有符号八进制数。 (1)\n'u' 过时类型 -- 等价于 'd'。 (8)\n'x' 有符号十六进制数（小写）。 (2)\n'X' 有符号十六进制数（大写）。 (2)\n'e' 浮点指数格式（小写）。 (3)\n'E' 浮点指数格式（大写）。 (3)\n'f' 浮点十进制格式。 (3)\n'F' 浮点十进制格式。 (3)\n浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制\n'g' (4)\n格式。\n浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制\n'G' (4)\n格式。\n'c' 单个字节（接受整数或单个字节对象）。\n\n|  | b'Python has 002 quote types.' |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | 在此情况下格式中不能出现 * 标记符（因其需要一个序列类的参数列表）。\n转换旗标为：\n旗标 含意\n'#' 值的转换将使用“替代形式”（具体定义见下文）。\n'0' 转换将为数字值填充零字符。\n'-' 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。\n' ' (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。\n'+' 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。\n可以给出长度修饰符 (h, l 或 L)，但会被忽略，因为对 Python 来说没有必要 -- 所以 %ld 等价于\n%d。\n转换类型为： |  |  |  |\n|  | 转换\n符 | 含意 | 备\n注 |  |\n|  | 'd' | 有符号十进制整数。 |  |  |\n|  | 'i' | 有符号十进制整数。 |  |  |\n|  | 'o' | 有符号八进制数。 | (1) |  |\n|  | 'u' | 过时类型 -- 等价于 'd'。 | (8) |  |\n|  | 'x' | 有符号十六进制数（小写）。 | (2) |  |\n|  | 'X' | 有符号十六进制数（大写）。 | (2) |  |\n|  | 'e' | 浮点指数格式（小写）。 | (3) |  |\n|  | 'E' | 浮点指数格式（大写）。 | (3) |  |\n|  | 'f' | 浮点十进制格式。 | (3) |  |\n|  | 'F' | 浮点十进制格式。 | (3) |  |\n|  | 'g' | 浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制\n格式。 | (4) |  |\n|  | 'G' | 浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制\n格式。 | (4) |  |\n|  | 'c' | 单个字节（接受整数或单个字节对象）。 |  |  |\n|  |  |  |  |  |\n\n| 旗标 | 含意 |\n| --- | --- |\n| '#' | 值的转换将使用“替代形式”（具体定义见下文）。 |\n| '0' | 转换将为数字值填充零字符。 |\n| '-' | 转换值将靠左对齐（如果同时给出 '0' 转换，则会覆盖后者）。 |\n| ' ' | (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。 |\n| '+' | 符号字符 ('+' 或 '-') 将显示于转换结果的开头（会覆盖 \"空格\" 旗标）。 |\n\n转换 备\n含意\n符 注\n'b' 字节串（任何遵循 缓冲区协议 或是具有 __bytes__() 的对象）。 (5)\n's' 's' 是 'b' 的一个别名，只应当在基于 Python2/3 的代码中使用。 (6)\n字节串（使用 repr(obj).encode('ascii', 'backslashreplace') 来转换任意\n'a' (5)\nPython 对象）。\n'r' 'r' 是 'a' 的一个别名，只应当在基于 Python2/3 的代码中使用。 (7)\n'%' 不转换参数，在结果中输出一个 '%' 字符。\n注释：\n1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 ('0o')。\n2. 此替代形式会在第一个数码之前插入 '0x' 或 '0X' 前缀（取决于是使用 'x' 还是 'X' 格\n式）。\n3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。\n小数点后的数码位数由精度决定，默认为 6。\n4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。\n小数点前后的有效数码位数由精度决定，默认为 6。\n5. 如果精度为 N，输出将截短为 N 个字符。\n6. b'%s' 已弃用，但在 3.x 系列中将不会被移除。\n7. b'%r' 已弃用，但在 3.x 系列中将不会被移除。\n8. 参见 PEP 237。\n备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任何改\n变。\n参见: PEP 461 - 为 bytes 和 bytearray 添加 % 格式化\nAdded in version 3.5.\n内存视图\nmemoryview 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 缓冲区协议 而无需\n进行拷贝。\nclass memoryview(object)\n\n|  | 转换\n符 | 含意 | 备\n注 |  |\n| --- | --- | --- | --- | --- |\n|  | 'b' | 字节串（任何遵循 缓冲区协议 或是具有 __bytes__() 的对象）。 | (5) |  |\n|  | 's' | 's' 是 'b' 的一个别名，只应当在基于 Python2/3 的代码中使用。 | (6) |  |\n|  | 'a' | 字节串（使用 repr(obj).encode('ascii', 'backslashreplace') 来转换任意\nPython 对象）。 | (5) |  |\n|  | 'r' | 'r' 是 'a' 的一个别名，只应当在基于 Python2/3 的代码中使用。 | (7) |  |\n|  | '%' | 不转换参数，在结果中输出一个 '%' 字符。 |  |  |\n|  | 注释：\n1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 ('0o')。\n2. 此替代形式会在第一个数码之前插入 '0x' 或 '0X' 前缀（取决于是使用 'x' 还是 'X' 格\n式）。\n3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。\n小数点后的数码位数由精度决定，默认为 6。\n4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。\n小数点前后的有效数码位数由精度决定，默认为 6。\n5. 如果精度为 N，输出将截短为 N 个字符。\n6. b'%s' 已弃用，但在 3.x 系列中将不会被移除。\n7. b'%r' 已弃用，但在 3.x 系列中将不会被移除。\n8. 参见 PEP 237。 |  |  |  |\n|  | 备注: 此方法的 bytearray 版本 并非 原地操作 —— 它总是产生一个新对象，即便没有做任何改\n变。 |  |  |  |\n|  |  |  |  |  |\n|  | 参见: PEP 461 - 为 bytes 和 bytearray 添加 % 格式化 |  |  |  |\n|  | Added in version 3.5.\n内存视图\nmemoryview 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 缓冲区协议 而无需\n进行拷贝。\nclass memoryview(object) |  |  |  |\n\n创建一个引用 object 的 memoryview 。 object 必须支持缓冲区协议。支持缓冲区协议的内置\n对象有 bytes 和 bytearray 。\nmemoryview 有 元素 的概念， 元素 指由原始 object 处理的原子内存单元。对于许多简单的\n类型，如 bytes 和 bytearray ，一个元素是一个字节，但其他类型，如 array.array 可能\n有更大的元素。\nlen(view) 等于 tolist 的长度，即视图的嵌套列表表示形式。 如果 view.ndim = 1，它\n将等于视图中元素的数量。\n在 3.12 版本发生变更: 如果 view.ndim == 0，现在 len(view) 将引发 TypeError 而\n不是返回 1.\nitemsize 属性将给出单个元素的字节数。\nmemoryview 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:\n>>> v = memoryview(b'abcefg')\n>>> v[1]\n98\n>>> v[-1]\n103\n>>> v[1:4]\n<memory at 0x7f3ddc9f4350>\n>>> bytes(v[1:4])\nb'bce'\n如果 format 是一个来自于 struct 模块的原生格式说明符，则也支持使用整数或由整数构\n成的元组进行索引，并返回具有正确类型的单个 元素。 一维内存视图可以使用一个整数或由\n一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 ndim 个整数构成的元素进行\n索引，ndim 即其维度。 零维内存视图可以使用空元组进行索引。\n这里是一个使用非字节格式的例子:\n>>> import array\n>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n>>> m = memoryview(a)\n>>> m[0]\n-11111111\n>>> m[-1]\n44444444\n>>> m[::2].tolist()\n[-11111111, -33333333]\n如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:\n>>> data = bytearray(b'abcefg')\n>>> v = memoryview(data)\n>>> v.readonly\nFalse\n>>> v[0] = ord(b'z')\n>>> data\nbytearray(b'zbcefg')\n\n|  | 创建一个引用 object 的 memoryview 。 object 必须支持缓冲区协议。支持缓冲区协议的内置\n对象有 bytes 和 bytearray 。\nmemoryview 有 元素 的概念， 元素 指由原始 object 处理的原子内存单元。对于许多简单的\n类型，如 bytes 和 bytearray ，一个元素是一个字节，但其他类型，如 array.array 可能\n有更大的元素。\nlen(view) 等于 tolist 的长度，即视图的嵌套列表表示形式。 如果 view.ndim = 1，它\n将等于视图中元素的数量。\n在 3.12 版本发生变更: 如果 view.ndim == 0，现在 len(view) 将引发 TypeError 而\n不是返回 1.\nitemsize 属性将给出单个元素的字节数。\nmemoryview 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:\n>>> v = memoryview(b'abcefg')\n>>> v[1]\n98\n>>> v[-1]\n103\n>>> v[1:4]\n<memory at 0x7f3ddc9f4350>\n>>> bytes(v[1:4])\nb'bce'\n如果 format 是一个来自于 struct 模块的原生格式说明符，则也支持使用整数或由整数构\n成的元组进行索引，并返回具有正确类型的单个 元素。 一维内存视图可以使用一个整数或由\n一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 ndim 个整数构成的元素进行\n索引，ndim 即其维度。 零维内存视图可以使用空元组进行索引。\n这里是一个使用非字节格式的例子:\n>>> import array\n>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n>>> m = memoryview(a)\n>>> m[0]\n-11111111\n>>> m[-1]\n44444444\n>>> m[::2].tolist()\n[-11111111, -33333333]\n如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:\n>>> data = bytearray(b'abcefg')\n>>> v = memoryview(data)\n>>> v.readonly\nFalse\n>>> v[0] = ord(b'z')\n>>> data\nbytearray(b'zbcefg') |  |  |\n| --- | --- | --- | --- |\n|  |  | >>> data = bytearray(b'abcefg')\n>>> v = memoryview(data)\n>>> v.readonly\nFalse\n>>> v[0] = ord(b'z')\n>>> data\nbytearray(b'zbcefg') |  |\n\n>>> v[1:4] = b'123'\n>>> data\nbytearray(b'z123fg')\n>>> v[2:3] = b'spam'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: memoryview assignment: lvalue and rvalue have different structur\n>>> v[2:6] = b'spam'\n>>> data\nbytearray(b'z1spam')\n格式符为 'B', 'b' 或 'c' 的 hashable (只读) 类型的一维内存视图也是可哈希对象。 哈希被定义\n为 hash(m) == hash(m.tobytes()):\n>>> v = memoryview(b'abcefg')\n>>> hash(v) == hash(b'abcefg')\nTrue\n>>> hash(v[2:4]) == hash(b'ce')\nTrue\n>>> hash(v[::-2]) == hash(b'abcefg'[::-2])\nTrue\n在 3.3 版本发生变更: 一维内存视图现在可以被切片。 格式符为 'B', 'b' 或 'c' 的一维内\n存视图现在是 hashable。\n在 3.4 版本发生变更: 内存视图现在会自动注册为 collections.abc.Sequence\n在 3.5 版本发生变更: 内存视图现在可使用整数元组进行索引。\n在 3.14 版本发生变更: memoryview 现在是一个 generic type。\nmemoryview 具有以下一些方法：\n__eq__(exporter)\nmemoryview 与 PEP 3118 中的导出器这两者如果形状相同，并且如果当使用 struct\n语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。\n对于 tolist() 当前所支持的 struct 格式字符串子集，如果 v.tolist() ==\nw.tolist() 则 v 和 w 相等:\n>>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue\n\n|  |  | >>> v[1:4] = b'123'\n>>> data\nbytearray(b'z123fg')\n>>> v[2:3] = b'spam'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: memoryview assignment: lvalue and rvalue have different structur\n>>> v[2:6] = b'spam'\n>>> data\nbytearray(b'z1spam')\n格式符为 'B', 'b' 或 'c' 的 hashable (只读) 类型的一维内存视图也是可哈希对象。 哈希被定义\n为 hash(m) == hash(m.tobytes()):\n>>> v = memoryview(b'abcefg')\n>>> hash(v) == hash(b'abcefg')\nTrue\n>>> hash(v[2:4]) == hash(b'ce')\nTrue\n>>> hash(v[::-2]) == hash(b'abcefg'[::-2])\nTrue\n在 3.3 版本发生变更: 一维内存视图现在可以被切片。 格式符为 'B', 'b' 或 'c' 的一维内\n存视图现在是 hashable。\n在 3.4 版本发生变更: 内存视图现在会自动注册为 collections.abc.Sequence\n在 3.5 版本发生变更: 内存视图现在可使用整数元组进行索引。\n在 3.14 版本发生变更: memoryview 现在是一个 generic type。\nmemoryview 具有以下一些方法：\n__eq__(exporter)\nmemoryview 与 PEP 3118 中的导出器这两者如果形状相同，并且如果当使用 struct\n语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。\n对于 tolist() 当前所支持的 struct 格式字符串子集，如果 v.tolist() ==\nw.tolist() 则 v 和 w 相等:\n>>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue | >>> v[1:4] = b'123'\n>>> data\nbytearray(b'z123fg')\n>>> v[2:3] = b'spam'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: memoryview assignment: lvalue and rvalue have different structur\n>>> v[2:6] = b'spam'\n>>> data\nbytearray(b'z1spam') |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | 格式符为 'B', 'b' 或 'c' 的 hashable (只读) 类型的一维内存视图也是可哈希对象。 哈希被定义\n为 hash(m) == hash(m.tobytes()): |  |  |  |\n|  |  |  | >>> v = memoryview(b'abcefg')\n>>> hash(v) == hash(b'abcefg')\nTrue |  |  |  |\n|  |  |  | >>> hash(v[2:4]) == hash(b'ce')\nTrue\n>>> hash(v[::-2]) == hash(b'abcefg'[::-2])\nTrue |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  | w.tolist() |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  | >>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue |  |  |\n\n>>> z.tolist() == c.tolist()\nTrue\n如果两边的格式字符串都不被 struct 模块所支持，则两对象比较结果总是不相等（即\n使格式字符串和缓冲区内容相同）:\n>>> from ctypes import BigEndianStructure, c_long\n>>> class BEPoint(BigEndianStructure):\n... _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n...\n>>> point = BEPoint(100, 200)\n>>> a = memoryview(point)\n>>> b = memoryview(point)\n>>> a == point\nFalse\n>>> a == b\nFalse\n请注意，与浮点数的情况一样，对于内存视图对象来说，v is w 也 并不 意味着 v ==\nw。\n在 3.3 版本发生变更: 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结\n构。\ntobytes(order='C')\n将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 bytes 构造器。\n>>> m = memoryview(b\"abc\")\n>>> m.tobytes()\nb'abc'\n>>> bytes(m)\nb'abc'\n对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。\ntobytes() 支持所有格式字符串，不符合 struct 模块语法的那些也包括在内。\nAdded in version 3.8: order 可以为 {'C', 'F', 'A'}。 当 order 为 'C' 或 'F' 时，原始数\n组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，'A' 会返回物理内存的精\n确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先\n被转换为 C 形式。 order=None 与 order='C' 是相同的。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。\n>>> m = memoryview(b\"abc\")\n>>> m.hex()\n'616263'\nAdded in version 3.5.\n\n|  | >>> z.tolist() == c.tolist()\nTrue\n如果两边的格式字符串都不被 struct 模块所支持，则两对象比较结果总是不相等（即\n使格式字符串和缓冲区内容相同）:\n>>> from ctypes import BigEndianStructure, c_long\n>>> class BEPoint(BigEndianStructure):\n... _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n...\n>>> point = BEPoint(100, 200)\n>>> a = memoryview(point)\n>>> b = memoryview(point)\n>>> a == point\nFalse\n>>> a == b\nFalse\n请注意，与浮点数的情况一样，对于内存视图对象来说，v is w 也 并不 意味着 v ==\nw。\n在 3.3 版本发生变更: 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结\n构。\ntobytes(order='C')\n将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 bytes 构造器。\n>>> m = memoryview(b\"abc\")\n>>> m.tobytes()\nb'abc'\n>>> bytes(m)\nb'abc'\n对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。\ntobytes() 支持所有格式字符串，不符合 struct 模块语法的那些也包括在内。\nAdded in version 3.8: order 可以为 {'C', 'F', 'A'}。 当 order 为 'C' 或 'F' 时，原始数\n组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，'A' 会返回物理内存的精\n确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先\n被转换为 C 形式。 order=None 与 order='C' 是相同的。\nhex(*, bytes_per_sep=1)\nhex(sep, bytes_per_sep=1)\n返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。\n>>> m = memoryview(b\"abc\")\n>>> m.hex()\n'616263'\nAdded in version 3.5. | >>> z.tolist() == c.tolist()\nTrue |  |\n| --- | --- | --- | --- |\n\n在 3.8 版本发生变更: 与 bytes.hex() 相似， memoryview.hex() 现在支持可选\n的 sep 和 bytes_per_sep 参数以在十六进制输出的字节之间插入分隔符。\ntolist()\n将缓冲区内的数据以一个元素列表的形式返回。\n>>> memoryview(b'abc').tolist()\n[97, 98, 99]\n>>> import array\n>>> a = array.array('d', [1.1, 2.2, 3.3])\n>>> m = memoryview(a)\n>>> m.tolist()\n[1.1, 2.2, 3.3]\n在 3.3 版本发生变更: tolist() 现在支持 struct 模块语法中的所有单字符原生格\n式以及多维表示形式。\ntoreadonly()\n返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。\n>>> m = memoryview(bytearray(b'abc'))\n>>> mm = m.toreadonly()\n>>> mm.tolist()\n[97, 98, 99]\n>>> mm[0] = 42\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: cannot modify read-only memory\n>>> m[0] = 43\n>>> mm.tolist()\n[43, 98, 99]\nAdded in version 3.8.\nrelease()\n释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动\n作（例如，bytearray 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽\n早去除这些限制（并释放任何多余的资源）。\n在此方法被调用后，任何对该视图的进一步操作都将引发 ValueError (除了可被多次调\n用的 release() 本身):\n>>> m = memoryview(b'abc')\n>>> m.release()\n>>> m[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n使用 with 语句，可以通过上下文管理协议达到类似的效果:\n\n|  | 在 3.8 版本发生变更: 与 bytes.hex() 相似， memoryview.hex() 现在支持可选\n的 sep 和 bytes_per_sep 参数以在十六进制输出的字节之间插入分隔符。\ntolist()\n将缓冲区内的数据以一个元素列表的形式返回。\n>>> memoryview(b'abc').tolist()\n[97, 98, 99]\n>>> import array\n>>> a = array.array('d', [1.1, 2.2, 3.3])\n>>> m = memoryview(a)\n>>> m.tolist()\n[1.1, 2.2, 3.3]\n在 3.3 版本发生变更: tolist() 现在支持 struct 模块语法中的所有单字符原生格\n式以及多维表示形式。\ntoreadonly()\n返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。\n>>> m = memoryview(bytearray(b'abc'))\n>>> mm = m.toreadonly()\n>>> mm.tolist()\n[97, 98, 99]\n>>> mm[0] = 42\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: cannot modify read-only memory\n>>> m[0] = 43\n>>> mm.tolist()\n[43, 98, 99]\nAdded in version 3.8.\nrelease()\n释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动\n作（例如，bytearray 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽\n早去除这些限制（并释放任何多余的资源）。\n在此方法被调用后，任何对该视图的进一步操作都将引发 ValueError (除了可被多次调\n用的 release() 本身):\n>>> m = memoryview(b'abc')\n>>> m.release()\n>>> m[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n使用 with 语句，可以通过上下文管理协议达到类似的效果: |  |\n| --- | --- | --- |\n\n>>> with memoryview(b'abc') as m:\n... m[0]\n...\n97\n>>> m[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\nAdded in version 3.2.\ncast(format, /)\ncast(format, shape, /)\n将内存视图转化为新的格式或形状。 shape 默认为 [byte_length//new_itemsize]，\n这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复\n制。 支持的转化有 1D -> C-contiguous 和 C-contiguous -> 1D。\n目标格式被限制为 struct 语法中的单一元素的原生格式。 这些格式中的一种必须为字\n节格式 ('B', 'b' 或 'c')。 结果的字节长度必须与原始长度相同。 请注意全部字节长度可\n能取决于具体操作系统。\n将 1D/long 转换为 1D/unsigned bytes:\n>>> import array\n>>> a = array.array('l', [1,2,3])\n>>> x = memoryview(a)\n>>> x.format\n'l'\n>>> x.itemsize\n8\n>>> len(x)\n3\n>>> x.nbytes\n24\n>>> y = x.cast('B')\n>>> y.format\n'B'\n>>> y.itemsize\n1\n>>> len(y)\n24\n>>> y.nbytes\n24\n将 1D/unsigned bytes 转换为 1D/char:\n>>> b = bytearray(b'zyz')\n>>> x = memoryview(b)\n>>> x[0] = b'a'\nTraceback (most recent call last):\n...\nTypeError: memoryview: invalid type for format 'B'\n>>> y = x.cast('c')\n>>> y[0] = b'a'\n\n|  | >>> with memoryview(b'abc') as m:\n... m[0]\n...\n97\n>>> m[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\nAdded in version 3.2.\ncast(format, /)\ncast(format, shape, /)\n将内存视图转化为新的格式或形状。 shape 默认为 [byte_length//new_itemsize]，\n这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复\n制。 支持的转化有 1D -> C-contiguous 和 C-contiguous -> 1D。\n目标格式被限制为 struct 语法中的单一元素的原生格式。 这些格式中的一种必须为字\n节格式 ('B', 'b' 或 'c')。 结果的字节长度必须与原始长度相同。 请注意全部字节长度可\n能取决于具体操作系统。\n将 1D/long 转换为 1D/unsigned bytes:\n>>> import array\n>>> a = array.array('l', [1,2,3])\n>>> x = memoryview(a)\n>>> x.format\n'l'\n>>> x.itemsize\n8\n>>> len(x)\n3\n>>> x.nbytes\n24\n>>> y = x.cast('B')\n>>> y.format\n'B'\n>>> y.itemsize\n1\n>>> len(y)\n24\n>>> y.nbytes\n24\n将 1D/unsigned bytes 转换为 1D/char:\n>>> b = bytearray(b'zyz')\n>>> x = memoryview(b)\n>>> x[0] = b'a'\nTraceback (most recent call last):\n...\nTypeError: memoryview: invalid type for format 'B'\n>>> y = x.cast('c')\n>>> y[0] = b'a' | >>> with memoryview(b'abc') as m:\n... m[0]\n...\n97\n>>> m[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object |  |\n| --- | --- | --- | --- |\n|  |  | >>> b = bytearray(b'zyz')\n>>> x = memoryview(b)\n>>> x[0] = b'a'\nTraceback (most recent call last):\n...\nTypeError: memoryview: invalid type for format 'B'\n>>> y = x.cast('c')\n>>> y[0] = b'a' |  |\n\n>>> b\nbytearray(b'ayz')\n将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char:\n>>> import struct\n>>> buf = struct.pack(\"i\"*12, *list(range(12)))\n>>> x = memoryview(buf)\n>>> y = x.cast('i', shape=[2,2,3])\n>>> y.tolist()\n[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n>>> y.format\n'i'\n>>> y.itemsize\n4\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> z = y.cast('b')\n>>> z.format\n'b'\n>>> z.itemsize\n1\n>>> len(z)\n48\n>>> z.nbytes\n48\n将 1D/unsigned long 转换为 2D/unsigned long:\n>>> buf = struct.pack(\"L\"*6, *list(range(6)))\n>>> x = memoryview(buf)\n>>> y = x.cast('L', shape=[2,3])\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> y.tolist()\n[[0, 1, 2], [3, 4, 5]]\nAdded in version 3.3.\n在 3.5 版本发生变更: 当转换为字节视图时，源格式将不再受限。\ncount(value, /)\n统计 value 出现的次数。\nAdded in version 3.14.\nindex(value, start=0, stop=sys.maxsize, /)\n返回 value 首次出现的项的索引号（在索引号 start 或其后且在索引号 stop 之前）。\n如果找不到 value 则会引发 ValueError。\n\n|  | >>> b\nbytearray(b'ayz')\n将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char:\n>>> import struct\n>>> buf = struct.pack(\"i\"*12, *list(range(12)))\n>>> x = memoryview(buf)\n>>> y = x.cast('i', shape=[2,2,3])\n>>> y.tolist()\n[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n>>> y.format\n'i'\n>>> y.itemsize\n4\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> z = y.cast('b')\n>>> z.format\n'b'\n>>> z.itemsize\n1\n>>> len(z)\n48\n>>> z.nbytes\n48\n将 1D/unsigned long 转换为 2D/unsigned long:\n>>> buf = struct.pack(\"L\"*6, *list(range(6)))\n>>> x = memoryview(buf)\n>>> y = x.cast('L', shape=[2,3])\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> y.tolist()\n[[0, 1, 2], [3, 4, 5]]\nAdded in version 3.3.\n在 3.5 版本发生变更: 当转换为字节视图时，源格式将不再受限。\ncount(value, /)\n统计 value 出现的次数。\nAdded in version 3.14.\nindex(value, start=0, stop=sys.maxsize, /)\n返回 value 首次出现的项的索引号（在索引号 start 或其后且在索引号 stop 之前）。\n如果找不到 value 则会引发 ValueError。 | >>> b\nbytearray(b'ayz') |  |\n| --- | --- | --- | --- |\n\nAdded in version 3.14.\n还存在一些可用的只读属性：\nobj\n内存视图的下层对象:\n>>> b = bytearray(b'xyz')\n>>> m = memoryview(b)\n>>> m.obj is b\nTrue\nAdded in version 3.3.\nnbytes\nnbytes == product(shape) * itemsize == len(m.tobytes())。 这是数组在连\n续表示时将会占用的空间总字节数。 它不一定等于 len(m):\n>>> import array\n>>> a = array.array('i', [1,2,3,4,5])\n>>> m = memoryview(a)\n>>> len(m)\n5\n>>> m.nbytes\n20\n>>> y = m[::2]\n>>> len(y)\n3\n>>> y.nbytes\n12\n>>> len(y.tobytes())\n12\n多维数组:\n>>> import struct\n>>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n>>> x = memoryview(buf)\n>>> y = x.cast('d', shape=[3,4])\n>>> y.tolist()\n[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]\n>>> len(y)\n3\n>>> y.nbytes\n96\nAdded in version 3.3.\nreadonly\n一个表明内存是否只读的布尔值。\nformat\n\n|  | Added in version 3.14.\n还存在一些可用的只读属性：\nobj\n内存视图的下层对象:\n>>> b = bytearray(b'xyz')\n>>> m = memoryview(b)\n>>> m.obj is b\nTrue\nAdded in version 3.3.\nnbytes\nnbytes == product(shape) * itemsize == len(m.tobytes())。 这是数组在连\n续表示时将会占用的空间总字节数。 它不一定等于 len(m):\n>>> import array\n>>> a = array.array('i', [1,2,3,4,5])\n>>> m = memoryview(a)\n>>> len(m)\n5\n>>> m.nbytes\n20\n>>> y = m[::2]\n>>> len(y)\n3\n>>> y.nbytes\n12\n>>> len(y.tobytes())\n12\n多维数组:\n>>> import struct\n>>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n>>> x = memoryview(buf)\n>>> y = x.cast('d', shape=[3,4])\n>>> y.tolist()\n[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]\n>>> len(y)\n3\n>>> y.nbytes\n96\nAdded in version 3.3.\nreadonly\n一个表明内存是否只读的布尔值。\nformat |  |  |\n| --- | --- | --- | --- |\n|  |  | >>> import struct\n>>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n>>> x = memoryview(buf)\n>>> y = x.cast('d', shape=[3,4])\n>>> y.tolist()\n[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]\n>>> len(y)\n3\n>>> y.nbytes\n96 |  |\n|  |  |  |  |\n\n一个字符串，包含视图中每个元素的格式（表示为 struct 模块样式）。 内存视图可\n以从具有任意格式字符串的导出器创建，但某些方法 (例如 tolist()) 仅限于原生的\n单元素格式。\n在 3.3 版本发生变更: 格式 'B' 现在会按照 struct 模块语法来处理。 这意味着\nmemoryview(b'abc')[0] == b'abc'[0] == 97。\nitemsize\nmemoryview 中每个元素以字节表示的大小:\n>>> import array, struct\n>>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n>>> m.itemsize\n2\n>>> m[0]\n32000\n>>> struct.calcsize('H') == m.itemsize\nTrue\nndim\n一个整数，表示内存所代表的多维数组具有多少个维度。\nshape\n一个整数元组，通过 ndim 的长度值给出内存所代表的 N 维数组的形状。\n在 3.3 版本发生变更: 当 ndim = 0 时值为空元组而不再为 None。\nstrides\n一个整数元组，通过 ndim 的长度给出以字节表示的大小，以便访问数组中每个维度\n上的每个元素。\n在 3.3 版本发生变更: 当 ndim = 0 时值为空元组而不再为 None。\nsuboffsets\n供 PIL 风格的数组内部使用。 该值仅作为参考信息。\nc_contiguous\n一个表明内存是否为 C-contiguous 的布尔值。\nAdded in version 3.3.\nf_contiguous\n一个表明内存是否为 Fortran contiguous 的布尔值。\nAdded in version 3.3.\ncontiguous\n一个表明内存是否为 contiguous 的布尔值。\n\n|  | 一个字符串，包含视图中每个元素的格式（表示为 struct 模块样式）。 内存视图可\n以从具有任意格式字符串的导出器创建，但某些方法 (例如 tolist()) 仅限于原生的\n单元素格式。\n在 3.3 版本发生变更: 格式 'B' 现在会按照 struct 模块语法来处理。 这意味着\nmemoryview(b'abc')[0] == b'abc'[0] == 97。\nitemsize\nmemoryview 中每个元素以字节表示的大小:\n>>> import array, struct\n>>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n>>> m.itemsize\n2\n>>> m[0]\n32000\n>>> struct.calcsize('H') == m.itemsize\nTrue\nndim\n一个整数，表示内存所代表的多维数组具有多少个维度。\nshape\n一个整数元组，通过 ndim 的长度值给出内存所代表的 N 维数组的形状。\n在 3.3 版本发生变更: 当 ndim = 0 时值为空元组而不再为 None。\nstrides\n一个整数元组，通过 ndim 的长度给出以字节表示的大小，以便访问数组中每个维度\n上的每个元素。\n在 3.3 版本发生变更: 当 ndim = 0 时值为空元组而不再为 None。\nsuboffsets\n供 PIL 风格的数组内部使用。 该值仅作为参考信息。\nc_contiguous\n一个表明内存是否为 C-contiguous 的布尔值。\nAdded in version 3.3.\nf_contiguous\n一个表明内存是否为 Fortran contiguous 的布尔值。\nAdded in version 3.3.\ncontiguous\n一个表明内存是否为 contiguous 的布尔值。 |  |\n| --- | --- | --- |\n\nAdded in version 3.3.\n集合类型 --- set, frozenset\nset 对象是由具有唯一性的 hashable 对象所组成的无序多项集。 常见的用途包括成员检测、从序列\n中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器\n对象请参看 dict, list 与 tuple 等内置类，以及 collections 模块。）\n与其他多项集一样，集合也支持 x in set, len(set) 和 for x in set。 作为一种无序的多项\n集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。\n目前有两种内置集合类型，set 和 frozenset。 set 类型是可变的 --- 其内容可以使用 add() 和\nremove() 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集\n合的元素。 frozenset 类型是不可变并且为 hashable --- 其内容在被创建后不能再改变；因此它可\n以被用作字典的键或其他集合的元素。\n除了可以使用 set 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于\n花括号之内来创建，例如: {'jack', 'sjoerd'}。\n两个类的构造器具有相同的作用方式：\nclass set(iterable=(), /)\nclass frozenset(iterable=(), /)\n返回一个新的 set 或 frozenset 对象，其元素来自于 iterable。 集合的元素必须为 hashable。\n要表示由集合对象构成的集合，所有的内层集合必须为 frozenset 对象。 如果未指定\niterable，则将返回一个新的空集合。\n集合可用多种方式来创建:\n使用花括号内以逗号分隔元素的方式: {'jack', 'sjoerd'}\n使用集合推导式: {c for c in 'abracadabra' if c not in 'abc'}\n使用类型构造器: set(), set('foobar'), set(['a', 'b', 'foo'])\nset 和 frozenset 的实例提供以下操作：\nlen(s)\n返回集合 s 中的元素数量（即 s 的基数）。\nx in s\n检测 x 是否为 s 中的成员。\nx not in s\n检测 x 是否非 s 中的成员。\nisdisjoint(other, /)\n如果集合中没有与 other 共有的元素则返回 True。 当且仅当两个集合的交集为空集合\n时，两者为不相交集合。\n\n|  | Added in version 3.3.\n集合类型 --- set, frozenset\nset 对象是由具有唯一性的 hashable 对象所组成的无序多项集。 常见的用途包括成员检测、从序列\n中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器\n对象请参看 dict, list 与 tuple 等内置类，以及 collections 模块。）\n与其他多项集一样，集合也支持 x in set, len(set) 和 for x in set。 作为一种无序的多项\n集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。\n目前有两种内置集合类型，set 和 frozenset。 set 类型是可变的 --- 其内容可以使用 add() 和\nremove() 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集\n合的元素。 frozenset 类型是不可变并且为 hashable --- 其内容在被创建后不能再改变；因此它可\n以被用作字典的键或其他集合的元素。\n除了可以使用 set 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于\n花括号之内来创建，例如: {'jack', 'sjoerd'}。\n两个类的构造器具有相同的作用方式：\nclass set(iterable=(), /)\nclass frozenset(iterable=(), /)\n返回一个新的 set 或 frozenset 对象，其元素来自于 iterable。 集合的元素必须为 hashable。\n要表示由集合对象构成的集合，所有的内层集合必须为 frozenset 对象。 如果未指定\niterable，则将返回一个新的空集合。\n集合可用多种方式来创建:\n使用花括号内以逗号分隔元素的方式: {'jack', 'sjoerd'}\n使用集合推导式: {c for c in 'abracadabra' if c not in 'abc'}\n使用类型构造器: set(), set('foobar'), set(['a', 'b', 'foo'])\nset 和 frozenset 的实例提供以下操作：\nlen(s)\n返回集合 s 中的元素数量（即 s 的基数）。\nx in s\n检测 x 是否为 s 中的成员。\nx not in s\n检测 x 是否非 s 中的成员。\nisdisjoint(other, /)\n如果集合中没有与 other 共有的元素则返回 True。 当且仅当两个集合的交集为空集合\n时，两者为不相交集合。 |  |\n| --- | --- | --- |\n\nissubset(other, /)\nset <= other\n检测是否集合中的每个元素都在 other 之中。\nset < other\n检测集合是否为 other 的真子集，即 set <= other and set != other。\nissuperset(other, /)\nset >= other\n检测是否 other 中的每个元素都在集合之中。\nset > other\n检测集合是否为 other 的真超集，即 set >= other and set != other。\nunion(*others)\nset | other | ...\n返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。\nintersection(*others)\nset & other & ...\n返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。\ndifference(*others)\nset - other - ...\n返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。\nsymmetric_difference(other, /)\nset ^ other\n返回一个新集合，其中的元素或属于原集合或属于 other 指定的其他集合，但不能同时属\n于两者。\ncopy()\n返回原集合的浅拷贝。\n注意， union() 、 intersection() 、 difference() 、 symmetric_difference() 、\nissubset() 和 issuperset() 方法的非运算符版本可以接受任何可迭代对象作为一个参数。\n相比之下，基于运算符的对应方法则要求参数为集合对象。这就避开了像 set('abc') &\n'cbs' 这样容易出错的结构，而换成了可读性更好的 set('abc').intersection('cbs')。\nset 和 frozenset 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包\n含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真\n子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集\n合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。\n\n|  |  | issubset(other, /)\nset <= other\n检测是否集合中的每个元素都在 other 之中。\nset < other\n检测集合是否为 other 的真子集，即 set <= other and set != other。\nissuperset(other, /)\nset >= other\n检测是否 other 中的每个元素都在集合之中。\nset > other\n检测集合是否为 other 的真超集，即 set >= other and set != other。\nunion(*others)\nset | other | ...\n返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。\nintersection(*others)\nset & other & ...\n返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。\ndifference(*others)\nset - other - ...\n返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。\nsymmetric_difference(other, /)\nset ^ other\n返回一个新集合，其中的元素或属于原集合或属于 other 指定的其他集合，但不能同时属\n于两者。\ncopy()\n返回原集合的浅拷贝。\n注意， union() 、 intersection() 、 difference() 、 symmetric_difference() 、\nissubset() 和 issuperset() 方法的非运算符版本可以接受任何可迭代对象作为一个参数。\n相比之下，基于运算符的对应方法则要求参数为集合对象。这就避开了像 set('abc') &\n'cbs' 这样容易出错的结构，而换成了可读性更好的 set('abc').intersection('cbs')。\nset 和 frozenset 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包\n含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真\n子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集\n合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。 |  |\n| --- | --- | --- | --- |\n|  |  | 'cbs' |  |\n|  |  |  |  |\n\nset 的实例与 frozenset 的实例之间基于它们的成员进行比较。 例如 set('abc') ==\nfrozenset('abc') 返回 True，set('abc') in set([frozenset('abc')]) 也一样。\n子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互\n不为对方的子集，因此以下 所有 比较均返回 False: a<b, a==b, or a>b。\n由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 list.sort() 方法的输出并\n无定义。\n集合的元素，与字典的键类似，必须为 hashable。\n混合了 set 实例与 frozenset 的二进制位运算将返回与第一个操作数相同的类型。例如:\nfrozenset('ab') | set('bc') 将返回 frozenset 的实例。\n下表列出了可用于 set 而不能用于不可变的 frozenset 实例的操作：\nupdate(*others)\nset |= other | ...\n更新集合，添加来自 others 中的所有元素。\nintersection_update(*others)\nset &= other & ...\n更新集合，只保留其中在所有 others 中也存在的元素。\ndifference_update(*others)\nset -= other | ...\n更新集合，移除其中也存在于 others 中的元素。\nsymmetric_difference_update(other, /)\nset ^= other\n更新集合，只保留存在于集合的一方而非共同存在的元素。\nadd(elem, /)\n将元素 elem 添加到集合中。\nremove(elem, /)\n从集合中移除元素 elem。 如果 elem 不存在于集合中则会引发 KeyError。\ndiscard(elem, /)\n如果元素 elem 存在于集合中则将其移除。\npop()\n从集合中移除并返回任意一个元素。 如果集合为空则会引发 KeyError。\nclear()\n\n|  |  | set 的实例与 frozenset 的实例之间基于它们的成员进行比较。 例如 set('abc') ==\nfrozenset('abc') 返回 True，set('abc') in set([frozenset('abc')]) 也一样。\n子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互\n不为对方的子集，因此以下 所有 比较均返回 False: a<b, a==b, or a>b。\n由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 list.sort() 方法的输出并\n无定义。\n集合的元素，与字典的键类似，必须为 hashable。\n混合了 set 实例与 frozenset 的二进制位运算将返回与第一个操作数相同的类型。例如:\nfrozenset('ab') | set('bc') 将返回 frozenset 的实例。\n下表列出了可用于 set 而不能用于不可变的 frozenset 实例的操作：\nupdate(*others)\nset |= other | ...\n更新集合，添加来自 others 中的所有元素。\nintersection_update(*others)\nset &= other & ...\n更新集合，只保留其中在所有 others 中也存在的元素。\ndifference_update(*others)\nset -= other | ...\n更新集合，移除其中也存在于 others 中的元素。\nsymmetric_difference_update(other, /)\nset ^= other\n更新集合，只保留存在于集合的一方而非共同存在的元素。\nadd(elem, /)\n将元素 elem 添加到集合中。\nremove(elem, /)\n从集合中移除元素 elem。 如果 elem 不存在于集合中则会引发 KeyError。\ndiscard(elem, /)\n如果元素 elem 存在于集合中则将其移除。\npop()\n从集合中移除并返回任意一个元素。 如果集合为空则会引发 KeyError。\nclear() |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  |  |  |\n|  |  | frozenset('abc' |  |  |\n|  |  |  |  |  |\n\n从集合中移除所有元素。\n请注意，非运算符版本的 update(), intersection_update(), difference_update() 和\nsymmetric_difference_update() 方法将接受任意可迭代对象作为参数。\n请注意，__contains__(), remove() 和 discard() 方法的 elem 参数可以是一个集合。 为支\n持搜索等价的冻结集合，将根据 elem 临时创建一个相应的对象。\n映射类型 --- dict\nmapping 对象会将 hashable 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型\n字典。 （关于其他容器对象请参看 list, set 与 tuple 等内置类，以及 collections 模块。）\n字典的键 几乎 可以为任何值。 不是 hashable 的值，即包含列表、字典或其他可变类型（按值比较\n而非按对象标识比较）的值不可被用作键。 比较结果相等的值（如 1, 1.0 和 True 等）可被互换使\n用以索引同一个字典条目。\nclass dict(**kwargs)\nclass dict(mapping, /, **kwargs)\nclass dict(iterable, /, **kwargs)\n返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。\n字典可用多种方式来创建:\n使用花括号内以逗号分隔 键: 值 对的方式: {'jack': 4098, 'sjoerd': 4127} or {4098:\n'jack', 4127: 'sjoerd'}\n使用字典推导式: {}, {x: x ** 2 for x in range(10)}\n使用类型构造器: dict(), dict([('foo', 100), ('bar', 200)]), dict(foo=100,\nbar=200)\n如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其定义了 keys() 方\n法，则通过在该参数上调用 __getitem__() 创建一个字典并包含从该方法返回的每个键。 在\n其他情况下，位置参数必须是一个 iterable 对象。 该可迭代对象中的每一项本身必须是一个恰\n好包含两个元素的可迭代对象。 每一项中的第一个元素将成为新字典的一个键，第二个元素将\n成为其对应的值。 如果一个键出现多次，该键的最后一个值将成为其在新字典中的对应值。\n如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加\n入的键已存在，来自关键字参数的值将替代来自位置参数的值。\n像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则\n可使用任何有效的键。\n字典比较结果当且仅当它们有相同的 (key, value) 对时（无论顺序如何）才会相等。 顺序比\n较（'<', '<=', '>=', '>'）会引发 TypeError。 为了说明字典的创建和相等性规则，下面的示例\n都返回一个等于 {\"one\": 1, \"two\": 2, \"three\": 3} 的字典:\n>>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3}\n\n|  |  | 从集合中移除所有元素。\n请注意，非运算符版本的 update(), intersection_update(), difference_update() 和\nsymmetric_difference_update() 方法将接受任意可迭代对象作为参数。\n请注意，__contains__(), remove() 和 discard() 方法的 elem 参数可以是一个集合。 为支\n持搜索等价的冻结集合，将根据 elem 临时创建一个相应的对象。\n映射类型 --- dict\nmapping 对象会将 hashable 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型\n字典。 （关于其他容器对象请参看 list, set 与 tuple 等内置类，以及 collections 模块。）\n字典的键 几乎 可以为任何值。 不是 hashable 的值，即包含列表、字典或其他可变类型（按值比较\n而非按对象标识比较）的值不可被用作键。 比较结果相等的值（如 1, 1.0 和 True 等）可被互换使\n用以索引同一个字典条目。\nclass dict(**kwargs)\nclass dict(mapping, /, **kwargs)\nclass dict(iterable, /, **kwargs)\n返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。\n字典可用多种方式来创建:\n使用花括号内以逗号分隔 键: 值 对的方式: {'jack': 4098, 'sjoerd': 4127} or {4098:\n'jack', 4127: 'sjoerd'}\n使用字典推导式: {}, {x: x ** 2 for x in range(10)}\n使用类型构造器: dict(), dict([('foo', 100), ('bar', 200)]), dict(foo=100,\nbar=200)\n如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其定义了 keys() 方\n法，则通过在该参数上调用 __getitem__() 创建一个字典并包含从该方法返回的每个键。 在\n其他情况下，位置参数必须是一个 iterable 对象。 该可迭代对象中的每一项本身必须是一个恰\n好包含两个元素的可迭代对象。 每一项中的第一个元素将成为新字典的一个键，第二个元素将\n成为其对应的值。 如果一个键出现多次，该键的最后一个值将成为其在新字典中的对应值。\n如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加\n入的键已存在，来自关键字参数的值将替代来自位置参数的值。\n像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则\n可使用任何有效的键。\n字典比较结果当且仅当它们有相同的 (key, value) 对时（无论顺序如何）才会相等。 顺序比\n较（'<', '<=', '>=', '>'）会引发 TypeError。 为了说明字典的创建和相等性规则，下面的示例\n都返回一个等于 {\"one\": 1, \"two\": 2, \"three\": 3} 的字典:\n>>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3} |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | {4098: |  |  |\n|  |  |  |  |  |  |  |\n|  |  | bar=200) |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | >>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3} |  |  |  |\n\n| dict(foo=100, |  |\n| --- | --- |\n\n>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue\n像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则\n可使用任何有效的键。\n字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到\n末尾。\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(d)\n['one', 'two', 'three', 'four']\n>>> list(d.values())\n[1, 2, 3, 4]\n>>> d[\"one\"] = 42\n>>> d\n{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n>>> del d[\"two\"]\n>>> d[\"two\"] = None\n>>> d\n{'one': 42, 'three': 3, 'four': 4, 'two': None}\n在 3.7 版本发生变更: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实\n现细节。\n这些是字典所支持的操作（因而自定义的映射类型也应当支持）：\nlist(d)\n返回字典 d 中使用的所有键的列表。\nlen(d)\n返回字典 d 中的项数。\nd[key]\n返回 d 中以 key 为键的项。 如果映射中不存在 key 则会引发 KeyError。\n如果字典的子类定义了方法 __missing__() 并且 key 不存在，则 d[key] 操作将调用该方\n法并附带键 key 作为参数。 d[key] 随后将返回或引发 __missing__(key) 调用所返回或\n引发的任何对象或异常。 没有其他操作或方法会唤起 __missing__()。 如果未定义\n__missing__()，则会引发 KeyError。 __missing__() 必须是一个方法；它不能是一个\n实例变量:\n>>> class Counter(dict):\n... def __missing__(self, key):\n... return 0\n\n|  | >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue\n像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则\n可使用任何有效的键。\n字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到\n末尾。\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(d)\n['one', 'two', 'three', 'four']\n>>> list(d.values())\n[1, 2, 3, 4]\n>>> d[\"one\"] = 42\n>>> d\n{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n>>> del d[\"two\"]\n>>> d[\"two\"] = None\n>>> d\n{'one': 42, 'three': 3, 'four': 4, 'two': None}\n在 3.7 版本发生变更: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实\n现细节。\n这些是字典所支持的操作（因而自定义的映射类型也应当支持）：\nlist(d)\n返回字典 d 中使用的所有键的列表。\nlen(d)\n返回字典 d 中的项数。\nd[key]\n返回 d 中以 key 为键的项。 如果映射中不存在 key 则会引发 KeyError。\n如果字典的子类定义了方法 __missing__() 并且 key 不存在，则 d[key] 操作将调用该方\n法并附带键 key 作为参数。 d[key] 随后将返回或引发 __missing__(key) 调用所返回或\n引发的任何对象或异常。 没有其他操作或方法会唤起 __missing__()。 如果未定义\n__missing__()，则会引发 KeyError。 __missing__() 必须是一个方法；它不能是一个\n实例变量:\n>>> class Counter(dict):\n... def __missing__(self, key):\n... return 0 | >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  | >>> class Counter(dict):\n... def __missing__(self, key):\n... return 0 |  |\n\n...\n>>> c = Counter()\n>>> c['red']\n0\n>>> c['red'] += 1\n>>> c['red']\n1\n上面的例子显示了 collections.Counter 实现的部分代码。 还有另一个不同的\n__missing__() 方法是由 collections.defaultdict 所使用的。\nd[key] = value\n将 d[key] 设为 value。\ndel d[key]\n将 d[key] 从 d 中移除。 如果映射中不存在 key 则会引发 KeyError。\nkey in d\n如果 d 中存在键 key 则返回 True，否则返回 False。\nkey not in d\n等价于 not key in d。\niter(d)\n返回以字典的键为元素的迭代器。 这是 iter(d.keys()) 的快捷方式。\nclear()\n移除字典中的所有元素。\ncopy()\n返回原字典的浅拷贝。\nclassmethod fromkeys(iterable, value=None, /)\n使用来自 iterable 的键创建一个新字典，并将键值设为 value。\nfromkeys() 是一个返回新字典的类方法。 value 默认为 None。 所有值都只引用一个单独\n的实例，因此让 value 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的\n值，请改用 字典推导式。\nget(key, default=None, /)\n如果 key 存在于字典中则返回 key 的值，否则返回 default。 如果 default 未给出则默认为\nNone，因而此方法绝不会引发 KeyError。\nitems()\n返回由字典项 ((键, 值) 对) 组成的一个新视图。 参见 视图对象文档。\n\n|  | ...\n>>> c = Counter()\n>>> c['red']\n0\n>>> c['red'] += 1\n>>> c['red']\n1\n上面的例子显示了 collections.Counter 实现的部分代码。 还有另一个不同的\n__missing__() 方法是由 collections.defaultdict 所使用的。\nd[key] = value\n将 d[key] 设为 value。\ndel d[key]\n将 d[key] 从 d 中移除。 如果映射中不存在 key 则会引发 KeyError。\nkey in d\n如果 d 中存在键 key 则返回 True，否则返回 False。\nkey not in d\n等价于 not key in d。\niter(d)\n返回以字典的键为元素的迭代器。 这是 iter(d.keys()) 的快捷方式。\nclear()\n移除字典中的所有元素。\ncopy()\n返回原字典的浅拷贝。\nclassmethod fromkeys(iterable, value=None, /)\n使用来自 iterable 的键创建一个新字典，并将键值设为 value。\nfromkeys() 是一个返回新字典的类方法。 value 默认为 None。 所有值都只引用一个单独\n的实例，因此让 value 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的\n值，请改用 字典推导式。\nget(key, default=None, /)\n如果 key 存在于字典中则返回 key 的值，否则返回 default。 如果 default 未给出则默认为\nNone，因而此方法绝不会引发 KeyError。\nitems()\n返回由字典项 ((键, 值) 对) 组成的一个新视图。 参见 视图对象文档。 | ...\n>>> c = Counter()\n>>> c['red']\n0\n>>> c['red'] += 1\n>>> c['red']\n1 |  |\n| --- | --- | --- | --- |\n\nkeys()\n返回由字典键组成的一个新视图。 参见 视图对象文档。\npop(key, /)\npop(key, default, /)\n如果 key 存在于字典中则将其移除并返回其值，否则返回 default。 如果 default 未给出且\nkey 不存在于字典中，则会引发 KeyError。\npopitem()\n从字典中移除并返回一个 (键, 值) 对。 键值对会按 LIFO 的顺序被返回。\npopitem() 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为\n空，调用 popitem() 将引发 KeyError。\n在 3.7 版本发生变更: 现在会确保采用 LIFO 顺序。 在之前的版本中，popitem() 会\n返回一个任意的键/值对。\nreversed(d)\n返回一个逆序获取字典键的迭代器。 这是 reversed(d.keys()) 的快捷方式。\nAdded in version 3.8.\nsetdefault(key, default=None, /)\n如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回\ndefault 。 default 默认为 None。\nupdate(**kwargs)\nupdate(mapping, /, **kwargs)\nupdate(iterable, /, **kwargs)\n使用 mapping 或 iterable 以及 kwargs 中的键值对更新字典，并覆盖现有键。返回 None。\nupdate() 接受另一个具有 keys() 方法的对象（在此情况下 __getitem__() 将被调用并\n附带从该方法返回的键）或一个包含键/值对（以长度为二的元组或其他可迭代对象表示）\n的可迭代对象。 如果指定了关键字参数，则会以其所对应的键/值对更新字典:\nd.update(red=1, blue=2)。\nvalues()\n返回由字典值组成的一个新视图。 参见 视图对象文档。\n两个 dict.values() 视图之间的相等性比较将总是返回 False。 这在 dict.values() 与\n其自身比较时也同样适用:\n>>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse\n\n|  | keys()\n返回由字典键组成的一个新视图。 参见 视图对象文档。\npop(key, /)\npop(key, default, /)\n如果 key 存在于字典中则将其移除并返回其值，否则返回 default。 如果 default 未给出且\nkey 不存在于字典中，则会引发 KeyError。\npopitem()\n从字典中移除并返回一个 (键, 值) 对。 键值对会按 LIFO 的顺序被返回。\npopitem() 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为\n空，调用 popitem() 将引发 KeyError。\n在 3.7 版本发生变更: 现在会确保采用 LIFO 顺序。 在之前的版本中，popitem() 会\n返回一个任意的键/值对。\nreversed(d)\n返回一个逆序获取字典键的迭代器。 这是 reversed(d.keys()) 的快捷方式。\nAdded in version 3.8.\nsetdefault(key, default=None, /)\n如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回\ndefault 。 default 默认为 None。\nupdate(**kwargs)\nupdate(mapping, /, **kwargs)\nupdate(iterable, /, **kwargs)\n使用 mapping 或 iterable 以及 kwargs 中的键值对更新字典，并覆盖现有键。返回 None。\nupdate() 接受另一个具有 keys() 方法的对象（在此情况下 __getitem__() 将被调用并\n附带从该方法返回的键）或一个包含键/值对（以长度为二的元组或其他可迭代对象表示）\n的可迭代对象。 如果指定了关键字参数，则会以其所对应的键/值对更新字典:\nd.update(red=1, blue=2)。\nvalues()\n返回由字典值组成的一个新视图。 参见 视图对象文档。\n两个 dict.values() 视图之间的相等性比较将总是返回 False。 这在 dict.values() 与\n其自身比较时也同样适用:\n>>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse |  |  |\n| --- | --- | --- | --- |\n|  |  | >>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse |  |\n\nd | other\n合并 d 和 other 中的键和值来创建一个新的字典，两者必须都是字典。当 d 和 other 有相\n同键时， other 的值优先。\nAdded in version 3.9.\nd |= other\n用 other 的键和值更新字典 d ，other 可以是 mapping 或 iterable 的键值对。当 d 和 other\n有相同键时， other 的值优先。\nAdded in version 3.9.\n字典和字典视图都是可逆的。\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(reversed(d))\n['four', 'three', 'two', 'one']\n>>> list(reversed(d.values()))\n[4, 3, 2, 1]\n>>> list(reversed(d.items()))\n[('four', 4), ('three', 3), ('two', 2), ('one', 1)]\n在 3.8 版本发生变更: 字典现在是可逆的。\n参见: types.MappingProxyType 可被用来创建一个 dict 的只读视图。\n字典视图对象\n由 dict.keys(), dict.values() 和 dict.items() 所返回的对象是 视图对象。 该对象提供字典条\n目的一个动态视图，这意味着当字典改变时，视图也会相应改变。\n字典视图可以被迭代以产生与其对应的数据，并支持成员检测：\nlen(dictview)\n返回字典中的条目数。\niter(dictview)\n返回字典中的键、值或项（以 (键, 值) 为元素的元组表示）的迭代器。\n键和值是按插入时的顺序进行迭代的。 这样就允许使用 zip() 来创建 (值, 键) 对: pairs =\nzip(d.values(), d.keys())。 另一个创建相同列表的方式是 pairs = [(v, k) for (k,\nv) in d.items()].\n在添加或删除字典中的条目期间对视图进行迭代可能引发 RuntimeError 或者无法完全迭代所\n有条目。\n在 3.7 版本发生变更: 字典顺序会确保为插入顺序。\n\n|  |  |  | d | other\n合并 d 和 other 中的键和值来创建一个新的字典，两者必须都是字典。当 d 和 other 有相\n同键时， other 的值优先。\nAdded in version 3.9.\nd |= other\n用 other 的键和值更新字典 d ，other 可以是 mapping 或 iterable 的键值对。当 d 和 other\n有相同键时， other 的值优先。\nAdded in version 3.9.\n字典和字典视图都是可逆的。\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(reversed(d))\n['four', 'three', 'two', 'one']\n>>> list(reversed(d.values()))\n[4, 3, 2, 1]\n>>> list(reversed(d.items()))\n[('four', 4), ('three', 3), ('two', 2), ('one', 1)]\n在 3.8 版本发生变更: 字典现在是可逆的。 |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | 参见: types.MappingProxyType 可被用来创建一个 dict 的只读视图。 |  |  |  |  |\n|  |  |  | 字典视图对象\n由 dict.keys(), dict.values() 和 dict.items() 所返回的对象是 视图对象。 该对象提供字典条\n目的一个动态视图，这意味着当字典改变时，视图也会相应改变。\n字典视图可以被迭代以产生与其对应的数据，并支持成员检测：\nlen(dictview)\n返回字典中的条目数。\niter(dictview)\n返回字典中的键、值或项（以 (键, 值) 为元素的元组表示）的迭代器。\n键和值是按插入时的顺序进行迭代的。 这样就允许使用 zip() 来创建 (值, 键) 对: pairs =\nzip(d.values(), d.keys())。 另一个创建相同列表的方式是 pairs = [(v, k) for (k,\nv) in d.items()].\n在添加或删除字典中的条目期间对视图进行迭代可能引发 RuntimeError 或者无法完全迭代所\n有条目。\n在 3.7 版本发生变更: 字典顺序会确保为插入顺序。 |  |  |  |  |\n|  |  |  |  |  | pairs = |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | zip(d.values(), d.keys()) | pairs = [(v, k) for (k, |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | v) in d.items()] |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n\nx in dictview\n如果 x 是对应字典中存在的键、值或项（在最后一种情况下 x 应为一个 (键, 值) 元组） 则返\n回 True。\nreversed(dictview)\n返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。\n在 3.8 版本发生变更: 字典视图现在是可逆的。\ndictview.mapping\n返回 types.MappingProxyType 对象，封装了字典视图指向的原始字典。\nAdded in version 3.10.\n键视图与集合类似因为其条目是唯一的并且为 hashable。 条视图也有类似集合的操作因为 (键, 值)\n对是唯一的并且键是可哈希的。 如果条目视图中的所有值也都是可哈希的，那么条目视图就可以与\n其他集合执行互操作。 （值视图不会被认为与集合类似因为条目通常不是唯一的）。 对于与集合类\n似的视图，可以使用为抽象基类 collections.abc.Set 定义的所有操作（例如，==, < 或 ^ 等）。\n虽然使用了集合运算符，但与集合类似的视图接受任何可迭代对象作为其操作数，而不像集合那样\n只接受集合作为输入。\n一个使用字典视图的示例:\n>>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n>>> keys = dishes.keys()\n>>> values = dishes.values()\n>>> # 迭代\n>>> n = 0\n>>> for val in values:\n... n += val\n...\n>>> print(n)\n504\n>>> # 键和值将以相同顺序（插入顺序）被迭代\n>>> list(keys)\n['eggs', 'sausage', 'bacon', 'spam']\n>>> list(values)\n[2, 1, 1, 500]\n>>> # 视图对象是动态的并会反映字典的改变\n>>> del dishes['eggs']\n>>> del dishes['sausage']\n>>> list(keys)\n['bacon', 'spam']\n>>> # 集合运算\n>>> keys & {'eggs', 'bacon', 'salad'}\n{'bacon'}\n>>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\nTrue\n>>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\nTrue\n\n|  | x in dictview\n如果 x 是对应字典中存在的键、值或项（在最后一种情况下 x 应为一个 (键, 值) 元组） 则返\n回 True。\nreversed(dictview)\n返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。\n在 3.8 版本发生变更: 字典视图现在是可逆的。\ndictview.mapping\n返回 types.MappingProxyType 对象，封装了字典视图指向的原始字典。\nAdded in version 3.10.\n键视图与集合类似因为其条目是唯一的并且为 hashable。 条视图也有类似集合的操作因为 (键, 值)\n对是唯一的并且键是可哈希的。 如果条目视图中的所有值也都是可哈希的，那么条目视图就可以与\n其他集合执行互操作。 （值视图不会被认为与集合类似因为条目通常不是唯一的）。 对于与集合类\n似的视图，可以使用为抽象基类 collections.abc.Set 定义的所有操作（例如，==, < 或 ^ 等）。\n虽然使用了集合运算符，但与集合类似的视图接受任何可迭代对象作为其操作数，而不像集合那样\n只接受集合作为输入。\n一个使用字典视图的示例: |  |\n| --- | --- | --- |\n|  | >>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n>>> keys = dishes.keys()\n>>> values = dishes.values()\n>>> # 迭代\n>>> n = 0\n>>> for val in values:\n... n += val\n...\n>>> print(n)\n504\n>>> # 键和值将以相同顺序（插入顺序）被迭代\n>>> list(keys)\n['eggs', 'sausage', 'bacon', 'spam']\n>>> list(values)\n[2, 1, 1, 500]\n>>> # 视图对象是动态的并会反映字典的改变\n>>> del dishes['eggs']\n>>> del dishes['sausage']\n>>> list(keys)\n['bacon', 'spam']\n>>> # 集合运算\n>>> keys & {'eggs', 'bacon', 'salad'}\n{'bacon'}\n>>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\nTrue\n>>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\nTrue |  |\n\n>>> # 获取原始字典的只读代理\n>>> values.mapping\nmappingproxy({'bacon': 1, 'spam': 500})\n>>> values.mapping['spam']\n500\n上下文管理器类型\nPython 的 with 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了\n一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语\n句执行完毕时退出该上下文：\ncontextmanager.__enter__()\n进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定\n到使用此上下文管理器的 with 语句的 as 子句中的标识符。\n一个返回其自身的上下文管理器的例子是 file object。 文件对象会从 __enter__() 返回其自身，\n以允许 open() 被用作 with 语句中的上下文表达式。\n一个返回关联对象的上下文管理器的例子是 decimal.localcontext() 所返回的对象。 此种管\n理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对\nwith 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 with 语句以外的代码。\ncontextmanager.__exit__(exc_type, exc_val, exc_tb)\n退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执\n行 with 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他\n情况下三个参数均为 None。\n自此方法返回一个真值将导致 with 语句屏蔽异常并继续执行紧随在 with 语句之后的语句。\n否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 with 语句\n的语句体中发生的任何异常。\n传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已\n成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 __exit__() 方法\n是否确实已失败。\nPython 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便\n地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 请参\n阅 contextlib 模块查看相关的示例。\nPython 的 generator 和 contextlib.contextmanager 装饰器提供了实现这些协议的便捷方式。 如\n果使用 contextlib.contextmanager 装饰器来装饰一个生成器函数，它将返回一个实现了必要的\n__enter__() 和 __exit__() 方法的上下文管理器，而不再是由未经装饰的生成器所产生的迭代\n器。\n请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这\n些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销\n\n|  | >>> # 获取原始字典的只读代理\n>>> values.mapping\nmappingproxy({'bacon': 1, 'spam': 500})\n>>> values.mapping['spam']\n500 |  |\n| --- | --- | --- |\n|  | 上下文管理器类型\nPython 的 with 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了\n一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语\n句执行完毕时退出该上下文：\ncontextmanager.__enter__()\n进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定\n到使用此上下文管理器的 with 语句的 as 子句中的标识符。\n一个返回其自身的上下文管理器的例子是 file object。 文件对象会从 __enter__() 返回其自身，\n以允许 open() 被用作 with 语句中的上下文表达式。\n一个返回关联对象的上下文管理器的例子是 decimal.localcontext() 所返回的对象。 此种管\n理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对\nwith 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 with 语句以外的代码。\ncontextmanager.__exit__(exc_type, exc_val, exc_tb)\n退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执\n行 with 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他\n情况下三个参数均为 None。\n自此方法返回一个真值将导致 with 语句屏蔽异常并继续执行紧随在 with 语句之后的语句。\n否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 with 语句\n的语句体中发生的任何异常。\n传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已\n成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 __exit__() 方法\n是否确实已失败。\nPython 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便\n地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 请参\n阅 contextlib 模块查看相关的示例。\nPython 的 generator 和 contextlib.contextmanager 装饰器提供了实现这些协议的便捷方式。 如\n果使用 contextlib.contextmanager 装饰器来装饰一个生成器函数，它将返回一个实现了必要的\n__enter__() 和 __exit__() 方法的上下文管理器，而不再是由未经装饰的生成器所产生的迭代\n器。\n请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这\n些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销 |  |\n\n相比，单个类字典查找的开销可以忽略不计。\n类型注解的类型 --- Generic Alias 、 Union\ntype annotations 的内置类型为 Generic Alias 和 Union。\nGenericAlias 类型\nGenericAlias 对象通常是通过 抽取 一个类来创建的。 它们最常被用于 容器类，如 list 或\ndict。 举例来说，list[int] 这个 GenericAlias 对象是通过附带 int 参数抽取 list 类来创建\n的。 GenericAlias 对象的主要目的是用于 类型标注。\n备注: 通常一个类只有在实现了特殊方法 __class_getitem__() 时才支持抽取操作。\nGenericAlias 对象可作为 generic type 的代理，实现了 形参化泛型。\n对于一个容器类，提供给类的 抽取 操作的参数可以指明对象所包含的元素类型。 例如，\nset[bytes] 可在类型标注中用来表示一个 set 中的所有元素均为 bytes 类型。\n对于一个定义了 __class_getitem__() 但不属于容器的类，提供给类的抽取操作的参数往往会指明\n在对象上定义的一个或多个方法的返回值类型。 例如，正则表达式 可以被用在 str 数据类型和\nbytes 数据类型上:\n如果 x = re.search('foo', 'foo')，则 x 将为一个 re.Match 对象而 x.group(0) 和 x[0] 的\n返回值将均为 str 类型。 我们可以在类型标注中使用 GenericAlias re.Match[str] 来代表这\n种对象。\n如果 y = re.search(b'bar', b'bar')，(注意 b 表示 bytes)，则 y 也将为一个 re.Match 的\n实例，但 y.group(0) 和 y[0] 的返回值将均为 bytes 类型。 在类型标注中，我们将使用\nre.Match[bytes] 来代表这种形式的 re.Match 对象。\nGenericAlias 对象是 types.GenericAlias 类的实例，该类也可被用来直接创建 GenericAlias\n对象。\nT[X, Y, ...]\n创建一个代表由类型 X, Y 来参数化的类型 T 的 GenericAlias，此类型会更依赖于所使用的\nT。 例如，一个接受包含 float 元素的 list 的函数:\ndef average(values: list[float]) -> float:\nreturn sum(values) / len(values)\n另一个例子是关于 mapping 对象的，用到了 dict，泛型的两个类型参数分别代表了键类型和\n值类型。本例中的函数需要一个 dict，其键的类型为 str，值的类型为 int:。\ndef send_post_request(url: str, body: dict[str, int]) -> None:\n...\n内置函数 isinstance() 和 issubclass() 不接受第二个参数为 GenericAlias 类型：\n\n|  | 相比，单个类字典查找的开销可以忽略不计。\n类型注解的类型 --- Generic Alias 、 Union\ntype annotations 的内置类型为 Generic Alias 和 Union。\nGenericAlias 类型\nGenericAlias 对象通常是通过 抽取 一个类来创建的。 它们最常被用于 容器类，如 list 或\ndict。 举例来说，list[int] 这个 GenericAlias 对象是通过附带 int 参数抽取 list 类来创建\n的。 GenericAlias 对象的主要目的是用于 类型标注。 |  |\n| --- | --- | --- |\n|  | 备注: 通常一个类只有在实现了特殊方法 __class_getitem__() 时才支持抽取操作。 |  |\n|  | GenericAlias 对象可作为 generic type 的代理，实现了 形参化泛型。\n对于一个容器类，提供给类的 抽取 操作的参数可以指明对象所包含的元素类型。 例如，\nset[bytes] 可在类型标注中用来表示一个 set 中的所有元素均为 bytes 类型。\n对于一个定义了 __class_getitem__() 但不属于容器的类，提供给类的抽取操作的参数往往会指明\n在对象上定义的一个或多个方法的返回值类型。 例如，正则表达式 可以被用在 str 数据类型和\nbytes 数据类型上:\n如果 x = re.search('foo', 'foo')，则 x 将为一个 re.Match 对象而 x.group(0) 和 x[0] 的\n返回值将均为 str 类型。 我们可以在类型标注中使用 GenericAlias re.Match[str] 来代表这\n种对象。\n如果 y = re.search(b'bar', b'bar')，(注意 b 表示 bytes)，则 y 也将为一个 re.Match 的\n实例，但 y.group(0) 和 y[0] 的返回值将均为 bytes 类型。 在类型标注中，我们将使用\nre.Match[bytes] 来代表这种形式的 re.Match 对象。\nGenericAlias 对象是 types.GenericAlias 类的实例，该类也可被用来直接创建 GenericAlias\n对象。\nT[X, Y, ...]\n创建一个代表由类型 X, Y 来参数化的类型 T 的 GenericAlias，此类型会更依赖于所使用的\nT。 例如，一个接受包含 float 元素的 list 的函数:\ndef average(values: list[float]) -> float:\nreturn sum(values) / len(values)\n另一个例子是关于 mapping 对象的，用到了 dict，泛型的两个类型参数分别代表了键类型和\n值类型。本例中的函数需要一个 dict，其键的类型为 str，值的类型为 int:。\ndef send_post_request(url: str, body: dict[str, int]) -> None:\n...\n内置函数 isinstance() 和 issubclass() 不接受第二个参数为 GenericAlias 类型： |  |\n\n>>> isinstance([1, 2], list[str])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: isinstance() argument 2 cannot be a parameterized generic\nPython 运行时不会强制执行 类型标注。 这种行为扩展到了泛型及其类型形参。 当由\nGenericAlias 创建容器对象时，并不会检查容器中为元素指定的类型。 例如，以下代码虽然不被\n鼓励，但运行时并不会报错:\n>>> t = list[str]\n>>> t([1, 2, 3])\n[1, 2, 3]\n不仅如此，在创建对象的过程中，应用了参数后的泛型还会抹除类型参数：\n>>> t = list[str]\n>>> type(t)\n<class 'types.GenericAlias'>\n>>> l = t()\n>>> type(l)\n<class 'list'>\n在泛型上调用 repr() 或 str() 会显示应用参数之后的类型：\n>>> repr(list[int])\n'list[int]'\n>>> str(list[int])\n'list[int]'\n调用泛型容器的 __getitem__() 方法将引发异常以防出现 dict[str][str] 之类的错误:\n>>> dict[str][str]\nTraceback (most recent call last):\n...\nTypeError: dict[str] is not a generic class\n不过，当使用了 类型变量 时这种表达式是无效的。 索引必须有与 GenericAlias 对象的 __args__\n中的类型变量条目数量相当的元素。\n>>> from typing import TypeVar\n>>> Y = TypeVar('Y')\n>>> dict[str, Y][int]\ndict[str, int]\n标准泛型类\n下列标准库类支持形参化的泛型。 此列表并不是详尽无遗的。\ntuple\nlist\n\n|  | >>> isinstance([1, 2], list[str])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: isinstance() argument 2 cannot be a parameterized generic |  |\n| --- | --- | --- |\n|  | Python 运行时不会强制执行 类型标注。 这种行为扩展到了泛型及其类型形参。 当由\nGenericAlias 创建容器对象时，并不会检查容器中为元素指定的类型。 例如，以下代码虽然不被\n鼓励，但运行时并不会报错: |  |\n|  | >>> t = list[str]\n>>> t([1, 2, 3])\n[1, 2, 3] |  |\n|  | 不仅如此，在创建对象的过程中，应用了参数后的泛型还会抹除类型参数： |  |\n|  | >>> t = list[str]\n>>> type(t)\n<class 'types.GenericAlias'>\n>>> l = t()\n>>> type(l)\n<class 'list'> |  |\n|  | 在泛型上调用 repr() 或 str() 会显示应用参数之后的类型： |  |\n|  | >>> repr(list[int])\n'list[int]'\n>>> str(list[int])\n'list[int]' |  |\n|  | 调用泛型容器的 __getitem__() 方法将引发异常以防出现 dict[str][str] 之类的错误: |  |\n|  | >>> dict[str][str]\nTraceback (most recent call last):\n...\nTypeError: dict[str] is not a generic class |  |\n|  | 不过，当使用了 类型变量 时这种表达式是无效的。 索引必须有与 GenericAlias 对象的 __args__\n中的类型变量条目数量相当的元素。 |  |\n|  | >>> from typing import TypeVar\n>>> Y = TypeVar('Y')\n>>> dict[str, Y][int]\ndict[str, int] |  |\n|  | 标准泛型类\n下列标准库类支持形参化的泛型。 此列表并不是详尽无遗的。\ntuple\nlist |  |\n\ndict\nset\nfrozenset\ntype\nasyncio.Future\nasyncio.Task\ncollections.deque\ncollections.defaultdict\ncollections.OrderedDict\ncollections.Counter\ncollections.ChainMap\ncollections.abc.Awaitable\ncollections.abc.Coroutine\ncollections.abc.AsyncIterable\ncollections.abc.AsyncIterable\ncollections.abc.AsyncGenerator\ncollections.abc.Iterable\ncollections.abc.Iterator\ncollections.abc.Generator\ncollections.abc.Reversible\ncollections.abc.Container\ncollections.abc.Collection\ncollections.abc.Callable\ncollections.abc.Set\ncollections.abc.MutableSet\ncollections.abc.Mapping\ncollections.abc.MutableMapping\ncollections.abc.Sequence\ncollections.abc.MutableSequence\ncollections.abc.ByteString\ncollections.abc.MappingView\ncollections.abc.KeysView\ncollections.abc.ItemsView\ncollections.abc.ValuesView\ncontextlib.AbstractContextManager\ncontextlib.AbstractAsyncContextManager\ndataclasses.Field\nfunctools.cached_property\nfunctools.partialmethod\nos.PathLike\nqueue.LifoQueue\nqueue.Queue\nqueue.PriorityQueue\n\n|  | dict\nset\nfrozenset\ntype\nasyncio.Future\nasyncio.Task\ncollections.deque\ncollections.defaultdict\ncollections.OrderedDict\ncollections.Counter\ncollections.ChainMap\ncollections.abc.Awaitable\ncollections.abc.Coroutine\ncollections.abc.AsyncIterable\ncollections.abc.AsyncIterable\ncollections.abc.AsyncGenerator\ncollections.abc.Iterable\ncollections.abc.Iterator\ncollections.abc.Generator\ncollections.abc.Reversible\ncollections.abc.Container\ncollections.abc.Collection\ncollections.abc.Callable\ncollections.abc.Set\ncollections.abc.MutableSet\ncollections.abc.Mapping\ncollections.abc.MutableMapping\ncollections.abc.Sequence\ncollections.abc.MutableSequence\ncollections.abc.ByteString\ncollections.abc.MappingView\ncollections.abc.KeysView\ncollections.abc.ItemsView\ncollections.abc.ValuesView\ncontextlib.AbstractContextManager\ncontextlib.AbstractAsyncContextManager\ndataclasses.Field\nfunctools.cached_property\nfunctools.partialmethod\nos.PathLike\nqueue.LifoQueue\nqueue.Queue\nqueue.PriorityQueue |  |\n| --- | --- | --- |\n\nqueue.SimpleQueue\nre.Pattern\nre.Match\nshelve.BsdDbShelf\nshelve.DbfilenameShelf\nshelve.Shelf\ntypes.MappingProxyType\nweakref.WeakKeyDictionary\nweakref.WeakMethod\nweakref.WeakSet\nweakref.WeakValueDictionary\nGenericAlias 对象的特殊属性\n应用参数后的泛型都实现了一些特殊的只读属性：\ngenericalias.__origin__\n本属性指向未应用参数之前的泛型类：\n>>> list[int].__origin__\n<class 'list'>\ngenericalias.__args__\n该属性是传给泛型类的原始 __class_getitem__() 的泛型所组成的 tuple (长度可能为 1):\n>>> dict[str, list[int]].__args__\n(<class 'str'>, list[int])\ngenericalias.__parameters__\n该属性是延迟计算出来的一个元组（可能为空），包含了 __args__ 中的类型变量。\n>>> from typing import TypeVar\n>>> T = TypeVar('T')\n>>> list[T].__parameters__\n(~T,)\n备注: 带有参数 typing.ParamSpec 的 GenericAlias 对象，在类型替换后其\n__parameters__ 可能会不准确，因为 typing.ParamSpec 主要用于静态类型检查。\ngenericalias.__unpacked__\n一个布尔值，如果别名已使用 * 运算符进行解包则为真值 (参见 TypeVarTuple)。\nAdded in version 3.11.\n参见:\nPEP 484 —— 类型注解\n\n|  | queue.SimpleQueue\nre.Pattern\nre.Match\nshelve.BsdDbShelf\nshelve.DbfilenameShelf\nshelve.Shelf\ntypes.MappingProxyType\nweakref.WeakKeyDictionary\nweakref.WeakMethod\nweakref.WeakSet\nweakref.WeakValueDictionary\nGenericAlias 对象的特殊属性\n应用参数后的泛型都实现了一些特殊的只读属性：\ngenericalias.__origin__\n本属性指向未应用参数之前的泛型类：\n>>> list[int].__origin__\n<class 'list'>\ngenericalias.__args__\n该属性是传给泛型类的原始 __class_getitem__() 的泛型所组成的 tuple (长度可能为 1):\n>>> dict[str, list[int]].__args__\n(<class 'str'>, list[int])\ngenericalias.__parameters__\n该属性是延迟计算出来的一个元组（可能为空），包含了 __args__ 中的类型变量。\n>>> from typing import TypeVar\n>>> T = TypeVar('T')\n>>> list[T].__parameters__\n(~T,)\n备注: 带有参数 typing.ParamSpec 的 GenericAlias 对象，在类型替换后其\n__parameters__ 可能会不准确，因为 typing.ParamSpec 主要用于静态类型检查。\ngenericalias.__unpacked__\n一个布尔值，如果别名已使用 * 运算符进行解包则为真值 (参见 TypeVarTuple)。\nAdded in version 3.11. |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 484 —— 类型注解 |  |\n\n介绍 Python 中用于类型标注的框架。\nPEP 585 - 标准多项集中的类型提示泛型\n介绍了对标准库类进行原生形参化的能力，只要它们实现了特殊的类方法\n__class_getitem__()。\n泛型（Generic）, 用户自定义泛型 和 typing.Generic\n有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。\nAdded in version 3.9.\nunion 类型\nunion 对象包含了在多个 类型对象 上执行 | (按位或) 运算后的值。 这些类型主要用于 类型注解。\n与 typing.Union 下标相比，联合类型表达式可以实现更简洁的类型提示语法。\nX | Y | ...\n定义包含了 X、Y 等类型的 union 对象。 X | Y 表示 X 或 Y。相当于 typing.Union[X, Y] 。\n比如以下函数的参数应为类型 int 或 float ：\ndef square(number: int | float) -> int | float:\nreturn number ** 2\n备注: 不可在运行时使用 | 操作数来定义有一个或多个成员为前向引用的并集。 例如，int\n| \"Foo\"，其中 \"Foo\" 是指向某个尚未定义的类的引用，在运行时将会失败。 对于包括前向\n引用的并集，请将整个表达式用字符串来表示，例如 \"int | Foo\"。\nunion_object == other\nunion 对象可与其他 union 对象进行比较。详细结果如下：\n多次组合的结果会平推：\n(int | str) | float == int | str | float\n冗余的类型会被删除：\nint | str | int == int | str\n在相互比较时，会忽略顺序：\nint | str == str | int\n它创建 typing.Union 的实例:\nint | str == typing.Union[int, str]\ntype(int | str) is typing.Union\nOptional 类型可表示为与 None 的组合。\n\n|  | 介绍 Python 中用于类型标注的框架。\nPEP 585 - 标准多项集中的类型提示泛型\n介绍了对标准库类进行原生形参化的能力，只要它们实现了特殊的类方法\n__class_getitem__()。\n泛型（Generic）, 用户自定义泛型 和 typing.Generic\n有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | Added in version 3.9.\nunion 类型\nunion 对象包含了在多个 类型对象 上执行 | (按位或) 运算后的值。 这些类型主要用于 类型注解。\n与 typing.Union 下标相比，联合类型表达式可以实现更简洁的类型提示语法。\nX | Y | ...\n定义包含了 X、Y 等类型的 union 对象。 X | Y 表示 X 或 Y。相当于 typing.Union[X, Y] 。\n比如以下函数的参数应为类型 int 或 float ：\ndef square(number: int | float) -> int | float:\nreturn number ** 2\n备注: 不可在运行时使用 | 操作数来定义有一个或多个成员为前向引用的并集。 例如，int\n| \"Foo\"，其中 \"Foo\" 是指向某个尚未定义的类的引用，在运行时将会失败。 对于包括前向\n引用的并集，请将整个表达式用字符串来表示，例如 \"int | Foo\"。\nunion_object == other\nunion 对象可与其他 union 对象进行比较。详细结果如下：\n多次组合的结果会平推：\n(int | str) | float == int | str | float\n冗余的类型会被删除：\nint | str | int == int | str\n在相互比较时，会忽略顺序：\nint | str == str | int\n它创建 typing.Union 的实例:\nint | str == typing.Union[int, str]\ntype(int | str) is typing.Union\nOptional 类型可表示为与 None 的组合。 |  |  |  |\n|  |  | int |  |  |\n|  |  |  |  |  |\n\n|  | | \"Foo\" |\n| --- | --- |\n\nstr | None == typing.Optional[str]\nisinstance(obj, union_object)\nissubclass(obj, union_object)\nisinstance() 和 issubclass() 也支持 union 对象：\n>>> isinstance(\"\", int | str)\nTrue\n但是联合对象中的 参数化泛型 将无法被检测:\n>>> isinstance(1, int | list[int]) # 短路求值\nTrue\n>>> isinstance([1], int | list[int])\nTraceback (most recent call last):\n...\nTypeError: isinstance() argument 2 cannot be a parameterized generic\nunion 对象构成的用户类型可以经由 typing.Union 访问，并可用于 isinstance() 检查:\n>>> import typing\n>>> isinstance(int | str, typing.Union)\nTrue\n>>> typing.Union()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: cannot create 'typing.Union' instances\n备注: 为了支持 X | Y 语法，类型对象加入了 __or__() 方法。 如果一个元类实现了\n__or__()，Union 可以重载它：\n>>> class M(type):\n... def __or__(self, other):\n... return \"Hello\"\n...\n>>> class C(metaclass=M):\n... pass\n...\n>>> C | int\n'Hello'\n>>> int | C\nint | C\n参见: PEP 604 —— 提出了 X | Y 语法和 union 类型。\nAdded in version 3.10.\n在 3.14 版本发生变更: 联合对象现在是 typing.Union 的实例。 在之前版本中，它们是\ntypes.UnionType 的实例，后者仍保留作为 typing.Union 的别名。\n\n|  | str | None == typing.Optional[str]\nisinstance(obj, union_object)\nissubclass(obj, union_object)\nisinstance() 和 issubclass() 也支持 union 对象：\n>>> isinstance(\"\", int | str)\nTrue\n但是联合对象中的 参数化泛型 将无法被检测:\n>>> isinstance(1, int | list[int]) # 短路求值\nTrue\n>>> isinstance([1], int | list[int])\nTraceback (most recent call last):\n...\nTypeError: isinstance() argument 2 cannot be a parameterized generic\nunion 对象构成的用户类型可以经由 typing.Union 访问，并可用于 isinstance() 检查: | str | None == typing.Optional[str] |  |\n| --- | --- | --- | --- |\n|  | >>> import typing\n>>> isinstance(int | str, typing.Union)\nTrue\n>>> typing.Union()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: cannot create 'typing.Union' instances |  |  |\n|  |  |  |  |\n|  | 备注: 为了支持 X | Y 语法，类型对象加入了 __or__() 方法。 如果一个元类实现了\n__or__()，Union 可以重载它：\n>>> class M(type):\n... def __or__(self, other):\n... return \"Hello\"\n...\n>>> class C(metaclass=M):\n... pass\n...\n>>> C | int\n'Hello'\n>>> int | C\nint | C |  |  |\n|  |  |  |  |\n|  | 参见: PEP 604 —— 提出了 X | Y 语法和 union 类型。 |  |  |\n|  | Added in version 3.10.\n在 3.14 版本发生变更: 联合对象现在是 typing.Union 的实例。 在之前版本中，它们是\ntypes.UnionType 的实例，后者仍保留作为 typing.Union 的别名。 |  |  |\n\n其他内置类型\n解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。\n模块\n模块唯一的特殊操作是属性访问: m.name，这里 m 为一个模块而 name 访问定义在 m 的符号表中的\n一个名称。 模块属性可以被赋值。 （请注意 import 语句严格来说也是对模块对象的一种操作；\nimport foo 不要求存在一个名为 foo 的模块对象，而是要求存在一个对于名为 foo 的模块的 (永久\n性) 定义。）\n每个模块都有一个特殊属性 __dict__。 这是包含模块的符号表的字典。 修改此字典将实际改变模\n块的符号表，但是无法直接对 __dict__ 赋值 (你可以写 m.__dict__['a'] = 1，这会将 m.a 定义\n为 1，但是你不能写 m.__dict__ = {})。 不建议直接修改 __dict__。\n内置于解释器中的模块会写成这样: <module 'sys' (built-in)>。 如果是从一个文件加载，则会\n写成 <module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>。\n类与类实例\n关于这些类型请参阅 对象、值与类型 和 类定义。\n函数\n函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: func(argument-list)。\n实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函\n数），但实现方式不同，因此对象类型也不同。\n更多信息请参阅 函数定义。\n方法\n方法是使用属性表示法执行调用的函数。 存在两种类别: 内置方法 (如列表的 append()) 和 类实例方\n法。 内置方法由支持它们的类型来描述。\n如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: 绑定方\n法 (或称 实例方法) 对象。 当被调用时，它会将 self 参数添加到参数列表。 绑定方法具有两个特殊\n的只读属性: m.__self__ 操作该方法的对象，而 m.__func__ 是实现该方法的函数。 调用 m(arg-\n1, arg-2, ..., arg-n) 完全等价于调用 m.__func__(m.__self__, arg-1, arg-2, ..., arg-\nn)。\n与 函数对象 类似，绑定方法对象也支持获取任意属性。 但是，由于方法属性实际上保存于下层的函\n数对象中 (method.__func__)，因此不允许设置绑定方法的方法属性。 尝试设置方法的属性将会导\n致引发 AttributeError。 想要设置方法属性，你必须在下层的函数对象中显式地设置它。\n\n|  |  |  | 其他内置类型\n解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。\n模块\n模块唯一的特殊操作是属性访问: m.name，这里 m 为一个模块而 name 访问定义在 m 的符号表中的\n一个名称。 模块属性可以被赋值。 （请注意 import 语句严格来说也是对模块对象的一种操作；\nimport foo 不要求存在一个名为 foo 的模块对象，而是要求存在一个对于名为 foo 的模块的 (永久\n性) 定义。）\n每个模块都有一个特殊属性 __dict__。 这是包含模块的符号表的字典。 修改此字典将实际改变模\n块的符号表，但是无法直接对 __dict__ 赋值 (你可以写 m.__dict__['a'] = 1，这会将 m.a 定义\n为 1，但是你不能写 m.__dict__ = {})。 不建议直接修改 __dict__。\n内置于解释器中的模块会写成这样: <module 'sys' (built-in)>。 如果是从一个文件加载，则会\n写成 <module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>。\n类与类实例\n关于这些类型请参阅 对象、值与类型 和 类定义。\n函数\n函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: func(argument-list)。\n实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函\n数），但实现方式不同，因此对象类型也不同。\n更多信息请参阅 函数定义。\n方法\n方法是使用属性表示法执行调用的函数。 存在两种类别: 内置方法 (如列表的 append()) 和 类实例方\n法。 内置方法由支持它们的类型来描述。\n如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: 绑定方\n法 (或称 实例方法) 对象。 当被调用时，它会将 self 参数添加到参数列表。 绑定方法具有两个特殊\n的只读属性: m.__self__ 操作该方法的对象，而 m.__func__ 是实现该方法的函数。 调用 m(arg-\n1, arg-2, ..., arg-n) 完全等价于调用 m.__func__(m.__self__, arg-1, arg-2, ..., arg-\nn)。\n与 函数对象 类似，绑定方法对象也支持获取任意属性。 但是，由于方法属性实际上保存于下层的函\n数对象中 (method.__func__)，因此不允许设置绑定方法的方法属性。 尝试设置方法的属性将会导\n致引发 AttributeError。 想要设置方法属性，你必须在下层的函数对象中显式地设置它。 |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  | 1, arg-2, ..., arg-n) |  |  |\n|  |  |  |  |  |  |\n|  |  |  | n) |  |  |\n|  |  |  |  |  |  |\n\n| m.__func__(m.__self__, arg-1, arg-2, ..., arg- |  |\n| --- | --- |\n\n>>> class C:\n... def method(self):\n... pass\n...\n>>> c = C()\n>>> c.method.whoami = 'my name is method' # can't set on the method\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAttributeError: 'method' object has no attribute 'whoami'\n>>> c.method.__func__.whoami = 'my name is method'\n>>> c.method.whoami\n'my name is method'\n请参阅 实例方法 了解更多信息。\n代码对象\n代码对象被具体实现用来表示“伪编译”的可执行 Python 代码例如一个函数体。 它们不同于函数对\n象，因为它们不包含对其全局执行环境的引用。 代码对象由内置的 compile() 函数返回，并可通过\n函数对象的 __code__ 属性来提取。 另请参阅 code 模块。\n访问 __code__ 会引发一个 审计事件 object.__getattr__，并附带参数 obj 和 \"__code__\"。\n可以通过将代码对象（而非源码字符串）传给 exec() 或 eval() 内置函数来执行或求值。\n更多信息请参阅 标准类型层级结构。\n类型对象\n类型对象表示各种对象类型。 对象的类型可通过内置函数 type() 来获取。 类型没有特殊的操作。\n标准库模块 types 定义了所有标准内置类型的名称。\n类型以这样的写法来表示: <class 'int'>。\n空对象\n此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 None (这\n是个内置名称)。 type(None)() 会生成同一个单例。\n该对象的写法为 None。\n省略符对象\n此对象通常被用于表示有内容被省略。 它不支持任何特殊操作。 只有一个 ellipsis 对象，名为\nEllipsis (属于内置名称)。 type(Ellipsis)() 将产生 Ellipsis 单例。\n该对象的写法为 Ellipsis 或 ...。\n作为典型为用法，... 在几个不同的场合中代表 Ellipsis 对象，例如：\n在类型注解中，例如 可调用对象参数 或 元组元素。\n\n|  | >>> class C:\n... def method(self):\n... pass\n...\n>>> c = C()\n>>> c.method.whoami = 'my name is method' # can't set on the method\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAttributeError: 'method' object has no attribute 'whoami'\n>>> c.method.__func__.whoami = 'my name is method'\n>>> c.method.whoami\n'my name is method' |  |\n| --- | --- | --- |\n|  | 请参阅 实例方法 了解更多信息。\n代码对象\n代码对象被具体实现用来表示“伪编译”的可执行 Python 代码例如一个函数体。 它们不同于函数对\n象，因为它们不包含对其全局执行环境的引用。 代码对象由内置的 compile() 函数返回，并可通过\n函数对象的 __code__ 属性来提取。 另请参阅 code 模块。\n访问 __code__ 会引发一个 审计事件 object.__getattr__，并附带参数 obj 和 \"__code__\"。\n可以通过将代码对象（而非源码字符串）传给 exec() 或 eval() 内置函数来执行或求值。\n更多信息请参阅 标准类型层级结构。\n类型对象\n类型对象表示各种对象类型。 对象的类型可通过内置函数 type() 来获取。 类型没有特殊的操作。\n标准库模块 types 定义了所有标准内置类型的名称。\n类型以这样的写法来表示: <class 'int'>。\n空对象\n此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 None (这\n是个内置名称)。 type(None)() 会生成同一个单例。\n该对象的写法为 None。\n省略符对象\n此对象通常被用于表示有内容被省略。 它不支持任何特殊操作。 只有一个 ellipsis 对象，名为\nEllipsis (属于内置名称)。 type(Ellipsis)() 将产生 Ellipsis 单例。\n该对象的写法为 Ellipsis 或 ...。\n作为典型为用法，... 在几个不同的场合中代表 Ellipsis 对象，例如：\n在类型注解中，例如 可调用对象参数 或 元组元素。 |  |\n\n作为函数体，替代 pass 语句。\n在第三方库中，如 NumPy 中的切片和步进。\nPython 还会以非 Ellipsis 对象的形式使用三个点，例如：\nDoctest 的 ELLIPSIS 选项，用作匹配缺失内容的模式。\nPython interactive shell 在输入不完整时的默认提示符。\n最后，Python文档在传统英语用法中经常使用三个点表示省略内容，即使在那些同时使用 Ellipsis\n的代码示例中也是如此。\n未实现对象\n此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。 请参阅 比较运算 了解更\n多信息。 未实现对象只有一种值 NotImplemented。 type(NotImplemented)() 会生成这个单例。\n其写法为 NotImplemented。\n内部对象\n相关信息请参阅 标准类型层级结构。 其中描述了 栈帧对象, 回溯对象 以及切片对象等。\n特殊属性\n语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被\ndir() 内置函数所列出。\ndefinition.__name__\n类、函数、方法、描述器或生成器实例的名称。\ndefinition.__qualname__\n类、函数、方法、描述器或生成器实例的 qualified name。\nAdded in version 3.3.\ndefinition.__module__\n类或函数定义所在的模块的名称。\ndefinition.__doc__\n类或函数的文档字符串，如果未定义则为 None。\ndefinition.__type_params__\n泛型类、函数和 类型别名 的 类型形参。 对于非泛型类和函数，这将为空元组。\nAdded in version 3.12.\n整数字符串转换长度限制\n\n|  | 作为函数体，替代 pass 语句。\n在第三方库中，如 NumPy 中的切片和步进。\nPython 还会以非 Ellipsis 对象的形式使用三个点，例如：\nDoctest 的 ELLIPSIS 选项，用作匹配缺失内容的模式。\nPython interactive shell 在输入不完整时的默认提示符。\n最后，Python文档在传统英语用法中经常使用三个点表示省略内容，即使在那些同时使用 Ellipsis\n的代码示例中也是如此。\n未实现对象\n此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。 请参阅 比较运算 了解更\n多信息。 未实现对象只有一种值 NotImplemented。 type(NotImplemented)() 会生成这个单例。\n其写法为 NotImplemented。\n内部对象\n相关信息请参阅 标准类型层级结构。 其中描述了 栈帧对象, 回溯对象 以及切片对象等。\n特殊属性\n语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被\ndir() 内置函数所列出。\ndefinition.__name__\n类、函数、方法、描述器或生成器实例的名称。\ndefinition.__qualname__\n类、函数、方法、描述器或生成器实例的 qualified name。\nAdded in version 3.3.\ndefinition.__module__\n类或函数定义所在的模块的名称。\ndefinition.__doc__\n类或函数的文档字符串，如果未定义则为 None。\ndefinition.__type_params__\n泛型类、函数和 类型别名 的 类型形参。 对于非泛型类和函数，这将为空元组。\nAdded in version 3.12.\n整数字符串转换长度限制 |  |\n| --- | --- | --- |\n\nCPython 对于 int 和 str 之间的转换有一个全局限制以缓解拒绝服务攻击。 此限制 仅会 作用于十\n进制或其他以非二的乘方为基数的数字。 十六进制、八进制和二进制转换不受限制。 该限制可以被\n配置。\nint 类型在 CPython 中是存储为二进制形式的任意长度的数字（通常称为“大数字”）。 不存在可在\n线性时间内将一个字符串转换为二进制整数或将一个二进制整数转换为字符串的算法，除非 基数为\n2 的乘方。 对于基数为 10 来说已知最好的算法也有亚二次方复杂度。 转换一个大数值如 int('1'\n* 500_000) 在快速的 CPU 上也会花费一秒以上的时间。\n限制转换大小是一项避免 CVE 2020-10735 的务实解决方式。\n此限制会在可能涉及非线性转换算法时作用于输入或输出字符串中的数字型字符数量。 下划线和正\n负号不计入限制数量。\n当一个操作会超出限制时，将引发 ValueError:\n>>> import sys\n>>> sys.set_int_max_str_digits(4300) # 含义如名称所示，这是默认值。\n>>> _ = int('2' * 5432)\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion: value h\n>>> i = int('2' * 4300)\n>>> len(str(i))\n4300\n>>> i_squared = i*i\n>>> len(str(i_squared))\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys\n>>> len(hex(i_squared))\n7144\n>>> assert int(hex(i_squared), base=16) == i*i # 十六进制数没有限制。\n默认限制为 4300 位即 sys.int_info.default_max_str_digits 的值。 最低限制可被配置为 640\n位即 sys.int_info.str_digits_check_threshold。\n验证:\n>>> import sys\n>>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n>>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n>>> msg = int('578966293710682886880994035146873798396722250538762761564'\n... '9252925514383915483333812743580549779436104706260696366600'\n... '571186405732').to_bytes(53, 'big')\n...\nAdded in version 3.11.\n受影响的 API\n此限制仅会作用于 int 和 str 和 bytes 之间存在速度变慢可能的转换:\n\n|  |  | CPython 对于 int 和 str 之间的转换有一个全局限制以缓解拒绝服务攻击。 此限制 仅会 作用于十\n进制或其他以非二的乘方为基数的数字。 十六进制、八进制和二进制转换不受限制。 该限制可以被\n配置。\nint 类型在 CPython 中是存储为二进制形式的任意长度的数字（通常称为“大数字”）。 不存在可在\n线性时间内将一个字符串转换为二进制整数或将一个二进制整数转换为字符串的算法，除非 基数为\n2 的乘方。 对于基数为 10 来说已知最好的算法也有亚二次方复杂度。 转换一个大数值如 int('1'\n* 500_000) 在快速的 CPU 上也会花费一秒以上的时间。\n限制转换大小是一项避免 CVE 2020-10735 的务实解决方式。\n此限制会在可能涉及非线性转换算法时作用于输入或输出字符串中的数字型字符数量。 下划线和正\n负号不计入限制数量。\n当一个操作会超出限制时，将引发 ValueError: |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | int('1' |  |  |\n|  |  |  |  |  |  |\n|  |  | * 500_000) |  |  |  |\n|  |  |  |  |  |  |\n|  |  | >>> import sys\n>>> sys.set_int_max_str_digits(4300) # 含义如名称所示，这是默认值。\n>>> _ = int('2' * 5432)\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion: value h\n>>> i = int('2' * 4300)\n>>> len(str(i))\n4300\n>>> i_squared = i*i\n>>> len(str(i_squared))\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys\n>>> len(hex(i_squared))\n7144\n>>> assert int(hex(i_squared), base=16) == i*i # 十六进制数没有限制。 |  |  |  |\n|  |  | 默认限制为 4300 位即 sys.int_info.default_max_str_digits 的值。 最低限制可被配置为 640\n位即 sys.int_info.str_digits_check_threshold。\n验证: |  |  |  |\n|  |  | >>> import sys\n>>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n>>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n>>> msg = int('578966293710682886880994035146873798396722250538762761564'\n... '9252925514383915483333812743580549779436104706260696366600'\n... '571186405732').to_bytes(53, 'big')\n... |  |  |  |\n|  |  | Added in version 3.11.\n受影响的 API\n此限制仅会作用于 int 和 str 和 bytes 之间存在速度变慢可能的转换: |  |  |  |\n\nint(string) 默认以 10 为基数。\nint(string, base) 用于所有不为 2 的乘方的基数。\nstr(integer)。\nrepr(integer)。\n任何其他目标是以 10 为基数的字符串转换，例如 f\"{integer}\", \"{}\".format(integer) 或\nb\"%d\" % integer。\n此限制不会作用于使用线性算法的函数:\nint(string, base) 中 base 可以为 2, 4, 8, 16 或 32。\nint.from_bytes() 和 int.to_bytes()。\nhex(), oct(), bin()。\n格式规格迷你语言 用于十六进制、八进制和二进制数。\nstr 至 float。\nstr 至 decimal.Decimal。\n配置限制值\n在 Python 启动之前你可以使用环境变量或解释器命令行旗标来配置限制值:\nPYTHONINTMAXSTRDIGITS，例如 PYTHONINTMAXSTRDIGITS=640 python3 是将限制设为 640 而\nPYTHONINTMAXSTRDIGITS=0 python3 是禁用此限制。\n-X int_max_str_digits，例如 python3 -X int_max_str_digits=640\nsys.flags.int_max_str_digits 包含 PYTHONINTMAXSTRDIGITS 或 -X int_max_str_digits\n的值。 如果环境变量和 -X 选项均有设置，则 -X 选项优先。 值为 -1 表示两者均未设置，因此会\n在初始化时使用 sys.int_info.default_max_str_digits 的值。\n从代码中，你可以检查当前的限制并使用这些 sys API 来设置新值:\nsys.get_int_max_str_digits() 和 sys.set_int_max_str_digits() 是解释器级限制的读取\n器和设置器。 子解释器具有它们自己的限制。\n有关默认值和最小值的信息可在 sys.int_info 中找到:\nsys.int_info.default_max_str_digits 是已编译的默认限制。\nsys.int_info.str_digits_check_threshold 是该限制可接受的最低值（禁用该限制的 0 除\n外）。\nAdded in version 3.11.\n小心: 设置较低的限制值 可能 导致问题。 虽然不常见，但还是会有在其源代码中包含超出最小\n阈值的十进制整数常量的代码存在。 设置此限制的一个后果将是包含比此限制长的十进制整数字\n面值的 Python 源代码将在解析期间遇到错误，通常是在启动时或导入时甚至是在安装时 —— 只\n要对于某个代码还不存在已更新的 .pyc 就会发生。 一种在包含此类大数值常量的源代码中绕过\n该问题的办法是将它们转换为不受限制的 0x 十六进制形式。\n\n|  | int(string) 默认以 10 为基数。\nint(string, base) 用于所有不为 2 的乘方的基数。\nstr(integer)。\nrepr(integer)。\n任何其他目标是以 10 为基数的字符串转换，例如 f\"{integer}\", \"{}\".format(integer) 或\nb\"%d\" % integer。\n此限制不会作用于使用线性算法的函数:\nint(string, base) 中 base 可以为 2, 4, 8, 16 或 32。\nint.from_bytes() 和 int.to_bytes()。\nhex(), oct(), bin()。\n格式规格迷你语言 用于十六进制、八进制和二进制数。\nstr 至 float。\nstr 至 decimal.Decimal。\n配置限制值\n在 Python 启动之前你可以使用环境变量或解释器命令行旗标来配置限制值:\nPYTHONINTMAXSTRDIGITS，例如 PYTHONINTMAXSTRDIGITS=640 python3 是将限制设为 640 而\nPYTHONINTMAXSTRDIGITS=0 python3 是禁用此限制。\n-X int_max_str_digits，例如 python3 -X int_max_str_digits=640\nsys.flags.int_max_str_digits 包含 PYTHONINTMAXSTRDIGITS 或 -X int_max_str_digits\n的值。 如果环境变量和 -X 选项均有设置，则 -X 选项优先。 值为 -1 表示两者均未设置，因此会\n在初始化时使用 sys.int_info.default_max_str_digits 的值。\n从代码中，你可以检查当前的限制并使用这些 sys API 来设置新值:\nsys.get_int_max_str_digits() 和 sys.set_int_max_str_digits() 是解释器级限制的读取\n器和设置器。 子解释器具有它们自己的限制。\n有关默认值和最小值的信息可在 sys.int_info 中找到:\nsys.int_info.default_max_str_digits 是已编译的默认限制。\nsys.int_info.str_digits_check_threshold 是该限制可接受的最低值（禁用该限制的 0 除\n外）。\nAdded in version 3.11. |  |\n| --- | --- | --- |\n|  | 小心: 设置较低的限制值 可能 导致问题。 虽然不常见，但还是会有在其源代码中包含超出最小\n阈值的十进制整数常量的代码存在。 设置此限制的一个后果将是包含比此限制长的十进制整数字\n面值的 Python 源代码将在解析期间遇到错误，通常是在启动时或导入时甚至是在安装时 —— 只\n要对于某个代码还不存在已更新的 .pyc 就会发生。 一种在包含此类大数值常量的源代码中绕过\n该问题的办法是将它们转换为不受限制的 0x 十六进制形式。 |  |\n\n如果你使用了较低的限制则请要彻底地测试你的应用程序。 确保你的测试通过环境变量或旗标尽\n早设置该限制来运行以便在启动期间甚至是在可能唤起 Python 来将 .py 源文件预编译为 .pyc\n文件的任何安装步骤其间应用该限制。\n推荐配置\n默认的 sys.int_info.default_max_str_digits 被预期对于大多数应用程序来说都是合理的。 如\n果你的应用程序需要不同的限制值，请使用不预设 Python 版本的代码从你的主入口点进行设置，因\n为这些 API 是在 3.12 之前的版本所发布的安全补丁中添加的。\n示例：\n>>> import sys\n>>> if hasattr(sys, \"set_int_max_str_digits\"):\n... upper_bound = 68000\n... lower_bound = 4004\n... current_limit = sys.get_int_max_str_digits()\n... if current_limit == 0 or current_limit > upper_bound:\n... sys.set_int_max_str_digits(upper_bound)\n... elif current_limit < lower_bound:\n... sys.set_int_max_str_digits(lower_bound)\n如果你需要完全禁用它，请将其设为 0。\n备注\n[1] 有关这些特殊方法的额外信息可参看 Python 参考指南 (基本定制)。\n[2] 作为结果，列表 [1, 2] 与 [1.0, 2.0] 是相等的，元组的情况也类似。\n[3] 必须如此，因为解析器无法判断操作数的类型。\n[4](1,2,3,4) 区分大小写的字符是指所属一般类别属性为 \"Lu\" (Letter, uppercase), \"Ll\" (Letter,\nlowercase) 或 \"Lt\" (Letter, titlecase) 之一的字符。\n[5](1,2) 若只是要格式化一个元组，则应提供一个单例元组，其中只包含一个元素，就是需要格式化\n的那个元组。\n\n| 如果你使用了较低的限制则请要彻底地测试你的应用程序。 确保你的测试通过环境变量或旗标尽\n早设置该限制来运行以便在启动期间甚至是在可能唤起 Python 来将 .py 源文件预编译为 .pyc\n文件的任何安装步骤其间应用该限制。 |\n| --- |\n| 推荐配置\n默认的 sys.int_info.default_max_str_digits 被预期对于大多数应用程序来说都是合理的。 如\n果你的应用程序需要不同的限制值，请使用不预设 Python 版本的代码从你的主入口点进行设置，因\n为这些 API 是在 3.12 之前的版本所发布的安全补丁中添加的。\n示例： |\n| >>> import sys\n>>> if hasattr(sys, \"set_int_max_str_digits\"):\n... upper_bound = 68000\n... lower_bound = 4004\n... current_limit = sys.get_int_max_str_digits()\n... if current_limit == 0 or current_limit > upper_bound:\n... sys.set_int_max_str_digits(upper_bound)\n... elif current_limit < lower_bound:\n... sys.set_int_max_str_digits(lower_bound) |\n| 如果你需要完全禁用它，请将其设为 0。\n备注\n[1] 有关这些特殊方法的额外信息可参看 Python 参考指南 (基本定制)。\n[2] 作为结果，列表 [1, 2] 与 [1.0, 2.0] 是相等的，元组的情况也类似。\n[3] 必须如此，因为解析器无法判断操作数的类型。\n[4](1,2,3,4) 区分大小写的字符是指所属一般类别属性为 \"Lu\" (Letter, uppercase), \"Ll\" (Letter,\nlowercase) 或 \"Lt\" (Letter, titlecase) 之一的字符。\n[5](1,2) 若只是要格式化一个元组，则应提供一个单例元组，其中只包含一个元素，就是需要格式化\n的那个元组。 |", "metadata": {"title": "00_内置类型", "source": "md_docs\\python_library_md\\00_内置类型.md", "doc_type": "标准库", "language": "中文", "doc_id": "be308111"}}
{"doc_id": "96ab844a", "content": "函数式编程模块\n本章里描述的模块提供了函数和类，以支持函数式编程风格和在可调用对象上的通用操作。\n本章包含以下模块的文档：\nitertools --- 为高效循环创建迭代器的函数\nItertool 函数\nitertools 配方\nfunctools —— 高阶函数，以及可调用对象上的操作\npartial 对象\noperator --- 标准运算符对应函数\n将运算符映射到函数\n原地运算符", "metadata": {"title": "00_函数式编程模块", "source": "md_docs\\python_library_md\\00_函数式编程模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "96ab844a"}}
{"doc_id": "f8966144", "content": "加密服务\n本章中介绍的模块实现了多种加密性质的算法。 它们可在安装时选择使用。 以下是内容概要：\nhashlib --- 安全哈希与消息摘要\n哈希算法\n用法\n构造器\n属性\n哈希对象\nSHAKE 可变长度摘要\n文件哈希\n密钥派生\nBLAKE2\n创建哈希对象\n常量\n例子\n简单哈希\n使用不同的摘要大小\n密钥哈希\n随机哈希\n个性化\n树形模式\n开发人员\nhmac --- 用于消息验证的密钥哈希\nsecrets --- 生成管理密码的安全随机数\n随机数\n生成 Token\nToken 应当使用多少个字节？\n其他功能\n应用技巧与最佳实践", "metadata": {"title": "00_加密服务", "source": "md_docs\\python_library_md\\00_加密服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "f8966144"}}
{"doc_id": "6ec7299b", "content": "命令行界面库\n本章介绍的模块可以为应用程序实现命令行和终端界面。\n以下是一个概览：\nargparse --- 用于命令行选项、参数和子命令的解析器\noptparse --- 命令行选项的解析器\ngetpass --- 可移植的密码输入\nfileinput --- 迭代来自多个输入流的行\ncurses --- 字符单元显示的终端处理\ncurses.textpad --- 用于 curses 程序的文本输入控件\ncurses.ascii --- 用于 ASCII 字符的工具\ncurses.panel --- 针对 curses 的面板栈扩展\ncmd --- 对面向行的命令解释器的支持", "metadata": {"title": "00_命令行界面库", "source": "md_docs\\python_library_md\\00_命令行界面库.md", "doc_type": "标准库", "language": "中文", "doc_id": "6ec7299b"}}
{"doc_id": "e518ac13", "content": "国际化\n本章中介绍的模块通过提供选择要在程序信息中使用的语言的机制或通过定制输出以匹配本地约定\n来帮助你编写不依赖于语言和区域设置的软件。\n本章中描述的模块列表是：\ngettext --- 多语种国际化服务\nGNU gettext API\n基于类的 API\nNullTranslations 类\nGNUTranslations 类\nSolaris 消息编目支持\n编目构造器\n国际化 (I18N) 你的程序和模块\n本地化你的模块\n本地化你的应用程序\n即时更改语言\n延迟翻译\n致谢\nlocale --- 国际化服务\n背景、细节、提示、技巧和注意事项\n区域设置名称\n针对扩展程序编写人员和嵌入Python 运行的程序\n访问消息目录", "metadata": {"title": "00_国际化", "source": "md_docs\\python_library_md\\00_国际化.md", "doc_type": "标准库", "language": "中文", "doc_id": "e518ac13"}}
{"doc_id": "ffef0391", "content": "多媒体服务\n本章描述的模块实现了主要用于多媒体应用的各种算法或接口。 它们可在安装时自行决定。 这是一\n个概述：\nwave --- 读写 WAV 文件\nWave_read对象\nWave_write 对象\ncolorsys --- 颜色系统间的转换", "metadata": {"title": "00_多媒体服务", "source": "md_docs\\python_library_md\\00_多媒体服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "ffef0391"}}
{"doc_id": "703f1687", "content": "安全考量\n下列模块具有专门的安全事项:\nbase64: base64 安全事项，参见 RFC 4648\nhashlib: 所有构造器都接受一个 \"usedforsecurity\" 仅限关键字参数以停用已知的不安全和已封禁\n的算法\nhttp.server 不适合生产用途，只实现了基本的安全检查。 请参阅 安全性考量。\nlogging: 日志记录配置使用了 eval()\nmultiprocessing: Connection.recv() 使用了 pickle\npickle: 在 pickle 中限制全局变量\nrandom 不应当被用于安全目的，而应改用 secrets\nshelve: shelve 是基于 pickle 的因此不适用于处理不受信任的源\nssl: SSL/TLS 安全事项\nsubprocess: 子进程安全事项\ntempfile: mktemp 由于存在竞争条件缺陷已被弃用\nxml: XML 安全事项\nzipfile: 恶意处理的 .zip 文件可能导致硬盘空间耗尽\n-I 命令行选项可被用来在隔离模式下运行 Python。 当它无法使用时，可以使用 -P 选项或\nPYTHONSAFEPATH 环境变量以避免在 sys.path 中预置一个潜在的不安全路径，如当前目录、脚本的\n目录或一个空字符串。", "metadata": {"title": "00_安全考量", "source": "md_docs\\python_library_md\\00_安全考量.md", "doc_type": "标准库", "language": "中文", "doc_id": "703f1687"}}
{"doc_id": "76e4767a", "content": "导入模块\n本章中介绍的模块提供了导入其他Python模块和挂钩以自定义导入过程的新方法。\n本章描述的完整模块列表如下：\nzipimport --- 从 Zip 归档导入模块\nzipimporter 对象\n例子\npkgutil --- 包扩展工具\nmodulefinder --- 查找脚本使用的模块\nModuleFinder 的示例用法\nrunpy --- 查找并执行 Python 模块\nimportlib --- import 的实现\n概述\n函数\nimportlib.abc —— 关于导入的抽象基类\nimportlib.machinery —— 导入器和路径钩子函数。\nimportlib.util —— 导入器的工具程序代码\n例子\n用编程方式导入\n检查某模块可否导入。\n直接导入源码文件。\n实现延迟导入\n导入器的配置\nimportlib.import_module() 的近似实现\nimportlib.resources -- 包资源的读取、打开和访问\n函数式 API\nimportlib.resources.abc -- 资源的抽象基类\nimportlib.metadata -- 访问软件包元数据\n概述\n函数式 API\n入口点\n分发的元数据\n分发包的版本\n分发包的文件\n分发包的依赖\n将导入映射到分发包\n分发包对象\n分发包的发现\n实现自定义 Provider\n\n示例\nsys.path 模块搜索路径的初始化\n虚拟环境\n_pth 文件\n嵌入式 Python", "metadata": {"title": "00_导入模块", "source": "md_docs\\python_library_md\\00_导入模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "76e4767a"}}
{"doc_id": "1388f3b2", "content": "并发执行\n本章中描述的模块支持并发执行代码。 适当的工具选择取决于要执行的任务（CPU密集型或IO密集\n型）和偏好的开发风格（事件驱动的协作式多任务或抢占式多任务处理）。 这是一个概述：\nthreading --- 基于线程的并行\n概述\nGIL 和性能的考量\n参考\n线程局部数据\n线程对象\nLock 对象\nRLock 对象\nCondition 对象\nSemaphore 对象\nSemaphore 示例\nEvent 对象\nTimer 对象\nBarrier 对象\n在 with 语句中使用锁、条件和信号量\nmultiprocessing --- 基于进程的并行\n概述\nProcess 类\n上下文和启动方法\n在进程之间交换对象\n进程间同步\n进程间共享状态\n使用工作进程\n参考\nProcess 和异常\n管道和队列\n杂项\n连接对象（Connection）\n同步原语\n共享 ctypes 对象\nmultiprocessing.sharedctypes 模块\n管理器\n自定义管理器\n使用远程管理器\n代理对象\n清理\n\n进程池\n监听器及客户端\n地址格式\n认证密码\n日志记录\nmultiprocessing.dummy 模块\n编程指导\n所有start方法\nspawn 和 forkserver 启动方式\n例子\nmultiprocessing.shared_memory --- 可跨进程直接访问的共享内存\nconcurrent 包\nconcurrent.futures --- 启动并行任务\nExecutor 对象\nThreadPoolExecutor\nThreadPoolExecutor 例子\nInterpreterPoolExecutor\nProcessPoolExecutor\nProcessPoolExecutor 例子\nFuture 对象\n模块函数\nException 类\nconcurrent.interpreters --- 同一进程中的多个解释器\n关键细节\n概述\n多解释器与隔离\n在一个解释器中运行\n并发与并行\n解释器间通信\n\"共享\"对象\n参考\n解释器对象\n异常\n解释器间通信\n基本使用\nsubprocess --- 子进程管理\n使用 subprocess 模块\n常用参数\nPopen 构造函数\n异常\n安全考量\nPopen 对象\nWindows Popen 助手\n\n|  | 进程池\n监听器及客户端\n地址格式\n认证密码\n日志记录\nmultiprocessing.dummy 模块\n编程指导\n所有start方法\nspawn 和 forkserver 启动方式\n例子\nmultiprocessing.shared_memory --- 可跨进程直接访问的共享内存\nconcurrent 包\nconcurrent.futures --- 启动并行任务\nExecutor 对象\nThreadPoolExecutor\nThreadPoolExecutor 例子\nInterpreterPoolExecutor\nProcessPoolExecutor\nProcessPoolExecutor 例子\nFuture 对象\n模块函数\nException 类\nconcurrent.interpreters --- 同一进程中的多个解释器\n关键细节\n概述\n多解释器与隔离\n在一个解释器中运行\n并发与并行\n解释器间通信\n\"共享\"对象\n参考\n解释器对象\n异常\n解释器间通信\n基本使用\nsubprocess --- 子进程管理\n使用 subprocess 模块\n常用参数\nPopen 构造函数\n异常\n安全考量\nPopen 对象\nWindows Popen 助手 |  |\n| --- | --- | --- |\n\nWindows 常数\n较旧的高阶 API\n使用 subprocess 模块替换旧函数\n替代 /bin/sh shell 命令替换\n替代 shell 管道\n替代 os.system()\n替代 os.spawn 函数族\n替代 os.popen()\n旧式的 Shell 发起函数\n备注\n超时行为\n在 Windows 上将参数列表转换为一个字符串\n禁用``posix_spawn()``\nsched --- 事件调度器\n调度器对象\nqueue --- 同步队列类\nQueue对象\n等待任务完成\n终结队列\nSimpleQueue 对象\ncontextvars --- 上下文变量\n上下文变量\n手动上下文管理\nasyncio 支持\n以下是上述某些服务的支持模块：\n_thread --- 低层级多线程 API", "metadata": {"title": "00_并发执行", "source": "md_docs\\python_library_md\\00_并发执行.md", "doc_type": "标准库", "language": "中文", "doc_id": "1388f3b2"}}
{"doc_id": "348c2979", "content": "开发工具\n本章中介绍的模块可帮助你编写软件。 例如，pydoc 模块接受一个模块并根据该模块的内容来生成\n文档。 doctest 和 unittest 模块包含用于编写自动执行代码并验证是否产生预期的输出的单元测\n试的框架。\n本章中描述的模块列表是：\ntyping --- 对类型提示的支持\n有关 Python 类型系统的规范说明\n类型别名\nNewType\n标注可调用对象\n泛型（Generic）\n标注元组\n类对象的类型\n标注生成器和协程\n用户定义的泛型类型\nAny 类型\n名义子类型 vs 结构子类型\n模块内容\n特殊类型原语\n特殊类型\n特殊形式\n构造泛型类型与类型别名\n其他特殊指令\n协议\n与 IO 相关的抽象基类和协议\n函数与装饰器\n内省辅助器\n常量\n一些已被弃用的别名\n内置类型的别名\ncollections 中的类型的别名。\n其他具体类型的别名\ncollections.abc 中容器 ABC 的别名\ncollections.abc 中异步 ABC 的别名\ncollections.abc 中其他 ABC 的别名\ncontextlib ABC 的别名\n主要特性的弃用时间线\npydoc --- 文档生成器和在线帮助系统\n\nPython 开发模式\nPython 开发模式的效果\nResourceWarning 示例\n文件描述符错误示例\ndoctest --- 测试交互式的 Python 示例\n简单用法：检查Docstrings中的示例\n简单的用法：检查文本文件中的例子\n命令行用法\n它是如何工作的\n哪些文件串被检查了？\n文档串的例子是如何被识别的？\n什么是执行上下文？\n异常如何处理？\n选项标记\n指令\n警告\n基本API\nUnittest API\n高级 API\nDocTest 对象\nExample 对象\nDocTestFinder 对象\nDocTestParser 对象\nTestResults 对象\nDocTestRunner 对象\nOutputChecker 对象\n调试\n肥皂盒\nunittest --- 单元测试框架\n基本实例\n命令行接口\n命令行选项\n探索性测试\n组织你的测试代码\n复用已有的测试代码\n跳过测试与预计的失败\n使用子测试区分测试迭代\n类与函数\n测试用例\n分组测试\n加载和运行测试\nload_tests 协议\n类与模块设定\n\n|  | Python 开发模式\nPython 开发模式的效果\nResourceWarning 示例\n文件描述符错误示例\ndoctest --- 测试交互式的 Python 示例\n简单用法：检查Docstrings中的示例\n简单的用法：检查文本文件中的例子\n命令行用法\n它是如何工作的\n哪些文件串被检查了？\n文档串的例子是如何被识别的？\n什么是执行上下文？\n异常如何处理？\n选项标记\n指令\n警告\n基本API\nUnittest API\n高级 API\nDocTest 对象\nExample 对象\nDocTestFinder 对象\nDocTestParser 对象\nTestResults 对象\nDocTestRunner 对象\nOutputChecker 对象\n调试\n肥皂盒\nunittest --- 单元测试框架\n基本实例\n命令行接口\n命令行选项\n探索性测试\n组织你的测试代码\n复用已有的测试代码\n跳过测试与预计的失败\n使用子测试区分测试迭代\n类与函数\n测试用例\n分组测试\n加载和运行测试\nload_tests 协议\n类与模块设定 |  |\n| --- | --- | --- |\n\nsetUpClass 和 tearDownClass\nsetUpModule 和 tearDownModule\n信号处理\nunittest.mock --- 模拟对象库\n快速上手\nMock 类\n调用\n删除属性\nMock 的名称与 name 属性\n附加 Mock 作为属性\npatch 装饰器\npatch\npatch.object\npatch.dict\npatch.multiple\n补丁方法: start 和 stop\n为内置函数打补丁\nTEST_PREFIX\n嵌套补丁装饰器\n补丁的位置\n对描述器和代理对象打补丁\nMagicMock 与魔术方法支持\n模拟魔术方法\nMagicMock\n辅助对象\nsentinel\nDEFAULT\ncall\ncreate_autospec\nANY\nFILTER_DIR\nmock_open\n自动 spec\n将 mock 封包\nside_effect, return_value 和 wraps 的优先顺序\nunittest.mock --- 新手入门\n使用 mock\n模拟方法调用\n对象上的方法调用的 mock\n模拟类\n命名你的 mock\n追踪所有的调用\n设置返回值和属性\n\n|  | setUpClass 和 tearDownClass\nsetUpModule 和 tearDownModule\n信号处理\nunittest.mock --- 模拟对象库\n快速上手\nMock 类\n调用\n删除属性\nMock 的名称与 name 属性\n附加 Mock 作为属性\npatch 装饰器\npatch\npatch.object\npatch.dict\npatch.multiple\n补丁方法: start 和 stop\n为内置函数打补丁\nTEST_PREFIX\n嵌套补丁装饰器\n补丁的位置\n对描述器和代理对象打补丁\nMagicMock 与魔术方法支持\n模拟魔术方法\nMagicMock\n辅助对象\nsentinel\nDEFAULT\ncall\ncreate_autospec\nANY\nFILTER_DIR\nmock_open\n自动 spec\n将 mock 封包\nside_effect, return_value 和 wraps 的优先顺序\nunittest.mock --- 新手入门\n使用 mock\n模拟方法调用\n对象上的方法调用的 mock\n模拟类\n命名你的 mock\n追踪所有的调用\n设置返回值和属性 |  |\n| --- | --- | --- |\n\n通过 mock 引发异常\n附带影响函数和可迭代对象\n模拟异步迭代器\n模拟异步上下文管理器\n基于现有对象创建模拟对象\n使用 side_effect 返回每个文件的内容\n补丁装饰器\n更多示例\n模拟链式调用\n部分模拟\n模拟生成器方法\n对每个测试方法应用相同的补丁\n模拟未绑定方法\n通过 mock 检查多次调用\n处理可变参数\n嵌套补丁\n使用 MagicMock 模拟字典\n模拟子类及其属性\n通过 patch.dict 模拟导入\n追踪调用顺序和不太冗长的调用断言\n更复杂的参数匹配\ntest --- Python 回归测试包\n为 test 包编写单元测试\n使用命令行界面运行测试\ntest.support --- 针对 Python 测试套件的工具\ntest.support.socket_helper --- 用于套接字测试的工具\ntest.support.script_helper --- 用于 Python 执行测试工具\ntest.support.bytecode_helper --- 用于测试正确字节码生成的支持工具\ntest.support.threading_helper --- 用于线程测试的工具\ntest.support.os_helper --- 用于操作系统测试的工具\ntest.support.import_helper --- 用于导入测试的工具\ntest.support.warnings_helper --- 用于警告测试的工具", "metadata": {"title": "00_开发工具", "source": "md_docs\\python_library_md\\00_开发工具.md", "doc_type": "标准库", "language": "中文", "doc_id": "348c2979"}}
{"doc_id": "9bdb11df", "content": "数字和数学模块\n本章介绍的模块提供与数字和数学相关的函数和数据类型。 numbers 模块定义了数字类型的抽象层\n次结构。 math 和 cmath 模块包含浮点数和复数的各种数学函数。 decimal 模块支持使用任意精度\n算术的十进制数的精确表示。\n本章包含以下模块的文档：\nnumbers --- 数字抽象基类\n数字的层次\n有关类型实现的注释\n加入更多数字的ABC\n实现算术运算\nmath --- 数学函数\n数论函数\n浮点算数\n浮点操作函数\n幂、指数和对数函数\n加总和乘积函数\n角度转换\n三角函数\n双曲函数\n特殊函数\n常量\ncmath --- 针对复数的数学函数\n到极坐标和从极坐标的转换\n幂函数与对数函数\n三角函数\n双曲函数\n分类函数\n常量\ndecimal --- 十进制定点和浮点算术\n快速入门教程\nDecimal 对象\n逻辑操作数\n上下文对象\n常量\n舍入模式\n信号\n浮点数说明\n通过提升精度来解决舍入错误\n\n特殊的值\n使用线程\n例程\nDecimal 常见问题\nfractions --- 有理数\nrandom --- 生成伪随机数\n簿记功能\n用于字节数据的函数\n整数用函数\n序列用函数\n离散分布\n实值分布\n替代生成器\n关于再现性的说明\n例子\n例程\n命令行用法\n命令行示例\nstatistics --- 数字统计函数\n平均值以及对中心位置的评估\n对分散程度的评估\n对两个输入之间关系的统计\n函数细节\n异常\nNormalDist 对象\n例子和配方\n经典概率问题\n蒙特卡罗模拟输入\n近似二项分布\n朴素贝叶斯分类器", "metadata": {"title": "00_数字和数学模块", "source": "md_docs\\python_library_md\\00_数字和数学模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "9bdb11df"}}
{"doc_id": "fc926512", "content": "数据压缩和存档\n本章中描述的模块支持使用 zlib, gzip, bzip2, lzma 和 zstd 算法进行数据压缩，以及创建 ZIP 和 tar\n格式的归档文件。 另请参阅由 shutil 模块提供的 归档操作。\ncompression 包\ncompression.zstd --- 与 Zstandard 格式兼容的压缩\n异常\n读写压缩文件\n在内存中压缩和解压缩数据\nZstandard 字典\n高级参数控制\n杂项\n例子\nzlib --- 与 gzip 兼容的压缩\ngzip --- 对 gzip 文件的支持\n用法示例\n命令行界面\n命令行选项\nbz2 --- 对 bzip2 压缩算法的支持\n文件压缩和解压\n增量压缩和解压\n一次性压缩或解压缩\n用法示例\nlzma --- 使用 LZMA 算法进行压缩\n读写压缩文件\n在内存中压缩和解压缩数据\n杂项\n指定自定义的过滤器链\n例子\nzipfile --- 操作 ZIP 归档文件\nZipFile 对象\nPath 对象\nPyZipFile 对象\nZipInfo 对象\n命令行接口\n命令行选项\n解压缩的障碍\n由于文件本身\n文件系统限制\n资源限制\n\n中断\n提取的默认行为\ntarfile --- 读写 tar 归档文件\nTarFile 对象\nTarInfo 对象\n解压缩过滤器\n默认的命名过滤器\n过滤器错误\n进一步核验的提示\n支持较早的 Python 版本\n有状态的提取过滤器示例\n命令行接口\n命令行选项\n例子\n读取示例\n写入示例\n受支持的 tar 格式\nUnicode 问题", "metadata": {"title": "00_数据压缩和存档", "source": "md_docs\\python_library_md\\00_数据压缩和存档.md", "doc_type": "标准库", "language": "中文", "doc_id": "fc926512"}}
{"doc_id": "cb4a76e4", "content": "数据持久化\n本章中描述的模块支持在磁盘上以持久形式存储 Python 数据。 pickle 和 marshal 模块可以将许\n多 Python 数据类型转换为字节流，然后从字节中重新创建对象。 各种与 DBM 相关的模块支持一系\n列基于散列的文件格式，这些格式存储字符串到其他字符串的映射。\n本章中描述的模块列表是：\npickle --- Python 对象序列化\n与其他 Python 模块间的关系\n与 marshal 间的关系\n与 json 模块的比较\n数据流格式\n模块接口\n可以被封存/解封的对象\n封存类实例\n持久化外部对象\nDispatch 表\n处理有状态的对象\n类型，函数和其他对象的自定义归约\n外部缓冲区\n提供方 API\n使用方 API\n示例\n限制全局变量\n性能\n例子\n命令行接口\ncopyreg --- 注册 pickle 支持函数\n示例\nshelve --- Python 对象持久化\n限制\n示例\nmarshal --- 内部 Python 对象序列化\ndbm --- Unix \"数据库\" 接口\ndbm.sqlite3 --- 针对 dbm 的 SQLite 后端\ndbm.gnu --- GNU 数据库管理器\ndbm.ndbm --- 新数据库管理器\ndbm.dumb --- 便携式 DBM 实现\nsqlite3 --- SQLite 数据库的 DB-API 2.0 接口\n教程\n\n参考\n模块函数\n模块常量\n连接对象\n游标对象\nRow 对象\nBlob 对象\nPrepareProtocol 对象\n异常\nSQLite 与 Python 类型\n默认适配器和转换器（已弃用）\n命令行接口\n常用方案指引\n如何在 SQL 查询中使用占位符来绑定值\n如何将自定义 Python 类型适配到 SQLite 值\n如何编写可适配对象\n如何注册适配器可调用对象\n如何将 SQLite 值转换为自定义 Python 类型\n适配器和转换器范例程序\n如何使用连接快捷方法\n如何使用连接上下文管理器\n如何使用 SQLite URI\n如何创建并使用行工厂对象\n如何处理非 UTF-8 文本编码格式\n说明\n事务控制\n通过 autocommit 属性进行事务控制\n通过 isolation_level 属性进行事务控制", "metadata": {"title": "00_数据持久化", "source": "md_docs\\python_library_md\\00_数据持久化.md", "doc_type": "标准库", "language": "中文", "doc_id": "cb4a76e4"}}
{"doc_id": "03b3ad5d", "content": "数据类型\n本章所描述的模块提供了许多专门的数据类型，如日期和时间、固定类型的数组、堆队列、双端队\n列、以及枚举。\nPython也提供一些内置数据类型，特别是，dict、 list、set、frozenset、以及 tuple。str 这\n个类是用来存储Unicode字符串的，而 bytes 和 bytearray 这两个类是用来存储二进制数据的。\n本章包含以下模块的文档：\ndatetime --- 基本日期和时间类型\n感知型对象和简单型对象\n常量\n有效的类型\n通用的特征属性\n确定一个对象是感知型还是简单型\ntimedelta 类对象\ntimedelta 用法示例\ndate 对象\ndate 用法示例\ndatetime 对象\n用法示例: datetime\ntime 对象\n用法示例: time\ntzinfo 对象\ntimezone 对象\nstrftime() 和 strptime() 的行为\nstrftime() 和 strptime() 格式码\n技术细节\nzoneinfo --- IANA 时区支持\n使用 ZoneInfo\n数据源\n配置数据源\n编译时配置\n环境配置\n运行时配置\nZoneInfo 类\n字符串表示\n封存序列化\n函数\n全局变量\n\n异常与警告\ncalendar --- 通用日历相关函数\n命令行用法\ncollections --- 容器数据类型\nChainMap 对象\nChainMap 例子和方法\nCounter 对象\ndeque 对象\ndeque 用法\ndefaultdict 对象\ndefaultdict 例子\nnamedtuple() 命名元组的工厂函数\nOrderedDict 对象\nOrderedDict 例子和用法\nUserDict 对象\nUserList 对象\nUserString 对象\ncollections.abc --- 容器的抽象基类\n容器抽象基类\n多项集抽象基类 -- 详细描述\n例子和配方\nheapq --- 堆队列算法\n基本示例\n优先队列实现说明\n理论\nbisect --- 数组二分算法\n性能说明\n搜索有序列表\n例子\narray --- 高效的数字值数组\nweakref --- 弱引用\n弱引用对象\n示例\n终结器对象\n比较终结器与 __del__() 方法\ntypes --- 动态类型创建和内置类型名称\n动态类型创建\n标准解释器类型\n附加工具类和函数\n协程工具函数\ncopy --- 浅层及深层拷贝操作\npprint --- 数据美化输出\n函数\n\n|  | 异常与警告\ncalendar --- 通用日历相关函数\n命令行用法\ncollections --- 容器数据类型\nChainMap 对象\nChainMap 例子和方法\nCounter 对象\ndeque 对象\ndeque 用法\ndefaultdict 对象\ndefaultdict 例子\nnamedtuple() 命名元组的工厂函数\nOrderedDict 对象\nOrderedDict 例子和用法\nUserDict 对象\nUserList 对象\nUserString 对象\ncollections.abc --- 容器的抽象基类\n容器抽象基类\n多项集抽象基类 -- 详细描述\n例子和配方\nheapq --- 堆队列算法\n基本示例\n优先队列实现说明\n理论\nbisect --- 数组二分算法\n性能说明\n搜索有序列表\n例子\narray --- 高效的数字值数组\nweakref --- 弱引用\n弱引用对象\n示例\n终结器对象\n比较终结器与 __del__() 方法\ntypes --- 动态类型创建和内置类型名称\n动态类型创建\n标准解释器类型\n附加工具类和函数\n协程工具函数\ncopy --- 浅层及深层拷贝操作\npprint --- 数据美化输出\n函数 |  |\n| --- | --- | --- |\n\nPrettyPrinter 对象\n示例\nreprlib --- 替代性 repr() 实现\nRepr 对象\n子类化 Repr 对象\nenum --- 对枚举的支持\n模块内容\n数据类型\n支持的 __dunder__ 名称\n支持的 _sunder_ 名称\n工具与装饰器\n备注\ngraphlib --- 操作类似图的结构的功能\n异常", "metadata": {"title": "00_数据类型", "source": "md_docs\\python_library_md\\00_数据类型.md", "doc_type": "标准库", "language": "中文", "doc_id": "03b3ad5d"}}
{"doc_id": "4c1ecde2", "content": "文件和目录访问\n本章中描述的模块处理磁盘文件和目录。 例如，有一些模块用于读取文件的属性，以可移植的方式\n操作路径以及创建临时文件。 本章的完整模块列表如下：\npathlib --- 面向对象的文件系统路径\n基础使用\n异常\n纯路径\n通用性质\n运算符\n访问个别部分\n方法和特征属性\n具体路径\n解析和生成 URI\n扩展和计算路径\n查询文件类型和状态\n读写文件\n读取目录\n创建文件和目录\n拷贝、移动和删除\n访问权限与所有权\n模式语言\n与 glob 模块的比较\n与 os 和 os.path 模块的比较\n相关工具\n协议\nos.path --- 常用的路径操作\nstat --- 解释 stat() 的结果\nfilecmp --- 文件和目录比较\ndircmp 类\ntempfile --- 生成临时文件和目录\n例子\n已弃用的函数和变量\nglob --- Unix 风格的路径名模式扩展\n例子\nfnmatch --- Unix 文件名模式匹配\nlinecache --- 随机访问文本行\nshutil --- 高层级文件操作\n目录和文件操作\n依赖于具体平台的高效拷贝操作\n\ncopytree 示例\nrmtree 示例\n归档操作\n归档程序示例\n使用 base_dir 的归档程序示例\n查询输出终端的尺寸\n参见:\n模块 os\n操作系统接口，包括处理比 Python 文件对象 更低级别文件的功能。\n模块 io\nPython的内置 I/O 库，包括抽象类和一些具体的类，如文件 I/O 。\n内置函数 open()\n使用 Python 打开文件进行读写的标准方法。\n\n| copytree 示例\nrmtree 示例\n归档操作\n归档程序示例\n使用 base_dir 的归档程序示例\n查询输出终端的尺寸 |\n| --- |\n| 参见:\n模块 os\n操作系统接口，包括处理比 Python 文件对象 更低级别文件的功能。\n模块 io\nPython的内置 I/O 库，包括抽象类和一些具体的类，如文件 I/O 。\n内置函数 open()\n使用 Python 打开文件进行读写的标准方法。 |\n|  |", "metadata": {"title": "00_文件和目录访问", "source": "md_docs\\python_library_md\\00_文件和目录访问.md", "doc_type": "标准库", "language": "中文", "doc_id": "4c1ecde2"}}
{"doc_id": "0b0448d1", "content": "文件格式\n本章中描述的模块解析各种不是标记语言且与电子邮件无关的杂项文件格式。\ncsv --- CSV 文件读写\n模块内容\n变种与格式参数\nReader 对象\nWriter 对象\n例子\nconfigparser --- 配置文件解析器\n快速起步\n支持的数据类型\n回退值\n受支持的 INI 文件结构\n未命名小节\n值的插值\n映射协议访问\n定制解析器行为\n旧式 API 示例\nConfigParser 对象\nRawConfigParser 对象\n异常\ntomllib --- 解析 TOML 文件\n例子\n转换表\nnetrc --- netrc 文件处理\nnetrc 对象\nplistlib --- 生成与解析 Apple .plist 文件\n例子", "metadata": {"title": "00_文件格式", "source": "md_docs\\python_library_md\\00_文件格式.md", "doc_type": "标准库", "language": "中文", "doc_id": "0b0448d1"}}
{"doc_id": "5c7818af", "content": "文本处理服务\n本章介绍的模块提供了广泛的字符串操作和其他文本处理服务。\n在 二进制数据服务 之下描述的 codecs 模块也与文本处理高度相关。 此外也请参阅 Python 内置字\n符串类型的文档 文本序列类型 --- str。\nstring --- 常见的字符串操作\n字符串常量\n自定义字符串格式化\n格式字符串语法\n格式规格迷你语言\n格式示例\n模板字符串 ($-字符串)\n辅助函数\nstring.templatelib --- 对模板字符串字面值的支持\n模板字符串\n类型\n辅助函数\nre --- 正则表达式操作\n正则表达式语法\n模块内容\n标志\n函数\n异常\n正则表达式对象 （正则对象）\n匹配对象\n正则表达式例子\n检查对子\n模拟 scanf()\nsearch() vs. match()\n制作一个电话本\n文字整理\n查找所有副词\n查找所有的副词及其位置\n原始字符串标记\n写一个词法分析器\ndifflib --- 计算差异的辅助工具\nSequenceMatcher 对象\nSequenceMatcher 的示例\nDiffer 对象\n\nDiffer 示例\ndifflib 的命令行接口\nndiff 示例\ntextwrap --- 文本自动换行与填充\nunicodedata --- Unicode 数据库\nstringprep --- 因特网字符串预处理\nreadline --- GNU readline 接口\n初始化文件\n行缓冲区\n历史文件\n历史列表\n启动钩子\nCompletion\n示例\nrlcompleter --- 用于 GNU readline 的补全函数", "metadata": {"title": "00_文本处理服务", "source": "md_docs\\python_library_md\\00_文本处理服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "5c7818af"}}
{"doc_id": "6547b6e4", "content": "概述\n\"Python 库\"中包含了几种不同的组件。\n它包含通常被视为语言“核心”中的一部分的数据类型，例如数字和列表。对于这些类型，Python语言\n核心定义了文字的形式，并对它们的语义设置了一些约束，但没有完全定义语义。（另一方面，语\n言核心确实定义了语法属性，如操作符的拼写和优先级。）\n这个库也包含了内置函数和异常 --- 不需要 import 语句就可以在所有Python代码中使用的对象。有\n一些是由语言核心定义的，但是许多对于核心语义不是必需的，并且仅在这里描述。\n不过这个库主要是由一系列的模块组成。这些模块集可以不同方式分类。有些模块是用 C 编写并内\n置于 Python 解释器中；另一些模块则是用 Python 编写并以源码形式导入。有些模块提供专用于\nPython 的接口，例如打印栈追踪信息；有些模块提供专用于特定操作系统的接口，例如操作特定的\n硬件；另一些模块则提供针对特定应用领域的接口，例如万维网。有些模块在所有更新和移植版本\n的 Python 中可用；另一些模块仅在底层系统支持或要求时可用；还有些模块则仅当编译和安装\nPython 时选择了特定配置选项时才可用。\n本手册以 \"从内到外\" 的顺序组织：首先描述内置函数、数据类型和异常，最后是根据相关性进行分\n组的各种模块。\n这意味着如果你从头开始阅读本手册，并在感到厌烦时跳到下一章，你仍能对 Python 库的可用模块\n和所支持的应用领域有个大致了解。当然，你并非 必须 如同读小说一样从头读到尾 --- 你也可以先\n浏览内容目录 (在手册开头)，或在索引 (在手册末尾) 中查找某个特定函数、模块或条目。最后，如\n果你喜欢随意学习某个主题，你可以选择一个随机页码 (参见 random 模块) 并读上一两小节。无论\n你想以怎样的顺序阅读本手册，还是建议先从 内置函数 这一章开始，因为本手册的其余内容都需要\n你熟悉其中的基本概念。\n让我们开始吧！\n可用性注释\n如果出现“适用：Unix”注释，意味着相应函数通常存在于 Unix 系统中。 但这并不保证其存在于某\n个特定的操作系统中。\n如果没有单独注明，所有声称\"可用性：Unix\"的函数都支持 macOS、iOS 和 Android ，所有这些\n构建都基于 Unix 内核。\n如果一条可用性注释同时包含最低 Kernel 版本和最低 libc 版本，则两个条件都必须满足。 例如当\n某个特性带有注释 可用性: Linux >= 3.17 且 glibc >= 2.27 则表示同时要求 Linux 3.17 以上版本和\nglibc 2.27 以上版本。\nWebAssembly 平台\n\nWebAssembly 平台 wasm32-emscripten (Emscripten) 和 wasm32-wasi (WASI) 分别提供了 POSIX\nAPI 的一个子集。 WebAssembly 运行时和浏览器都处于沙盒模式中并具有对主机和外部资源的受限\n访问权。 任何使用了进程、线程、网络、信号或其他形式的进程间通信 (IPC) 的 Python 标准库模块\n都或者不可用，或者其作用方式与在其他类 Unix 系统上不同。 文件 I/O, 文件系统和 Unix 权限相关\n的函数也同样会受限。 Emscripten 不允许阻塞式 I/O。 其他阻塞式操作如 sleep() 则会阻塞浏览器\n的事件循环。\nPython 在 WebAssembly 平台上的特性与行为依赖于 Emscripten-SDK 或 WASI-SDK 的版本, WASM\n运行时 (浏览器, NodeJS, wasmtime) 以及 Python 编译时旗标。 WebAssembly, Emscripten 和 WASI\n都是尚在不断演化中的标准；某些特性例如网络可能会在未来被支持。\n对于在浏览器上运行的 Python，用户可以考虑 Pyodide 或 PyScript。 PyScript 是在 Pyodide 之上构\n建的，后者本身则是在 CPython 和 Emscripten 之上构建的。 Pyodide 提供了对浏览器的 JavaScript\n和 DOM API 的访问并通过 JavaScript 的 XMLHttpRequest 和 Fetch API 提供了受限的网络功能。\n进程相关的 API 或者不可用或者将始终报错失败。 这包括生成新进程 (fork(), execve()), 等待\n进程 (waitpid()), 发送信号 (kill()) 或者以其他方式与进程交互的 API。 subprocess 可以被导\n入但将没有任何作用。\nsocket 模块可以使用，但将会受限而使其行为与在其他平台上不一致。 在 Emscripten 上，套接\n字将始终为非阻塞式的并且要求额外的 JavaScript 代码和服务器上的辅助工具来代理通过\nWebSockets 的 TCP；请参阅 Emscripten Networking 了解详情。 WASI snapshot preview 1 只允\n许来自现有文件描述符的套接字。\n某些函数是不执行任何操作的空壳或是始终返回硬编码的值。\n有关文件描述符、文件访问权、文件所有权和链接的函数均受到限制并且不支持某些操作。 例\n如，WASI 不允许具有绝对文件名的符号链接。\n移动平台\nAndroid 和 iOS 在大多数方面都是 POSIX 操作系统。文件 I/O、套接字处理和线程的行为都与在任何\nPOSIX 操作系统上的行为相同。但是，有几个主要区别：\n移动平台只能在\"嵌入\"模式下使用Python。没有Python REPL，也不能使用单独的可执行文件，如\npython 或 pip 。要在移动应用程序中添加 Python 代码，必须使用 Python 嵌入式 API 。更多详\n情，请参阅 在Android上使用 Python 和 在 iOS 上使用 Python 。\n子进程：\n在 Android 上，创建子进程是可能的，但\"非官方支持\n<https://issuetracker.google.com/issues/128554619#comment4>`__\"。尤其是，Android 没有\n支持 System V IPC 的任何部分API ，因此 multiprocessing 不可用。\niOS 应用程序不能使用任何形式的子进程、多进程或进程间通信。如果 iOS 应用程序尝试创建\n子进程 ，创建子进程的进程要么会上锁 ，要么会崩溃。iOS 应用程序无法看到正在运行的其他\n应用 ，也无法与运行中的其他应用通信，除非使用为此目的而存在的 iOS 特定 API 。\n移动应用程序修改系统资源（如系统时钟）的权限有限。这些资源通常*可读*，但试图修改这些\n资源通常会失败。\n\n|  | WebAssembly 平台 wasm32-emscripten (Emscripten) 和 wasm32-wasi (WASI) 分别提供了 POSIX\nAPI 的一个子集。 WebAssembly 运行时和浏览器都处于沙盒模式中并具有对主机和外部资源的受限\n访问权。 任何使用了进程、线程、网络、信号或其他形式的进程间通信 (IPC) 的 Python 标准库模块\n都或者不可用，或者其作用方式与在其他类 Unix 系统上不同。 文件 I/O, 文件系统和 Unix 权限相关\n的函数也同样会受限。 Emscripten 不允许阻塞式 I/O。 其他阻塞式操作如 sleep() 则会阻塞浏览器\n的事件循环。\nPython 在 WebAssembly 平台上的特性与行为依赖于 Emscripten-SDK 或 WASI-SDK 的版本, WASM\n运行时 (浏览器, NodeJS, wasmtime) 以及 Python 编译时旗标。 WebAssembly, Emscripten 和 WASI\n都是尚在不断演化中的标准；某些特性例如网络可能会在未来被支持。\n对于在浏览器上运行的 Python，用户可以考虑 Pyodide 或 PyScript。 PyScript 是在 Pyodide 之上构\n建的，后者本身则是在 CPython 和 Emscripten 之上构建的。 Pyodide 提供了对浏览器的 JavaScript\n和 DOM API 的访问并通过 JavaScript 的 XMLHttpRequest 和 Fetch API 提供了受限的网络功能。\n进程相关的 API 或者不可用或者将始终报错失败。 这包括生成新进程 (fork(), execve()), 等待\n进程 (waitpid()), 发送信号 (kill()) 或者以其他方式与进程交互的 API。 subprocess 可以被导\n入但将没有任何作用。\nsocket 模块可以使用，但将会受限而使其行为与在其他平台上不一致。 在 Emscripten 上，套接\n字将始终为非阻塞式的并且要求额外的 JavaScript 代码和服务器上的辅助工具来代理通过\nWebSockets 的 TCP；请参阅 Emscripten Networking 了解详情。 WASI snapshot preview 1 只允\n许来自现有文件描述符的套接字。\n某些函数是不执行任何操作的空壳或是始终返回硬编码的值。\n有关文件描述符、文件访问权、文件所有权和链接的函数均受到限制并且不支持某些操作。 例\n如，WASI 不允许具有绝对文件名的符号链接。\n移动平台\nAndroid 和 iOS 在大多数方面都是 POSIX 操作系统。文件 I/O、套接字处理和线程的行为都与在任何\nPOSIX 操作系统上的行为相同。但是，有几个主要区别：\n移动平台只能在\"嵌入\"模式下使用Python。没有Python REPL，也不能使用单独的可执行文件，如\npython 或 pip 。要在移动应用程序中添加 Python 代码，必须使用 Python 嵌入式 API 。更多详\n情，请参阅 在Android上使用 Python 和 在 iOS 上使用 Python 。\n子进程：\n在 Android 上，创建子进程是可能的，但\"非官方支持\n<https://issuetracker.google.com/issues/128554619#comment4>`__\"。尤其是，Android 没有\n支持 System V IPC 的任何部分API ，因此 multiprocessing 不可用。\niOS 应用程序不能使用任何形式的子进程、多进程或进程间通信。如果 iOS 应用程序尝试创建\n子进程 ，创建子进程的进程要么会上锁 ，要么会崩溃。iOS 应用程序无法看到正在运行的其他\n应用 ，也无法与运行中的其他应用通信，除非使用为此目的而存在的 iOS 特定 API 。\n移动应用程序修改系统资源（如系统时钟）的权限有限。这些资源通常*可读*，但试图修改这些\n资源通常会失败。 |  |\n| --- | --- | --- |\n\n控制台输入与输出：\n在 Android 系统上，原生的 stdout 和 stderr 没有连接到任何设备，因此 Python 安装了自己\n的流，将信息重定向到系统日志。这些信息可分别在 python.stdout 和 python.stderr 标签\n下看到。\niOS 应用程序对控制台输出的概念有限。 stdout 和 stderr 存在，在 Xcode 中运行时，写入\nstdout 和 stderr 的内容在日志中可见，但这些内容 不会 记录在系统日志中。 如果安装了您\n的应用程序的用户提供其应用程序日志作为诊断辅助工具，这些日志将不包括写入 stdout 或\nstderr 的任何细节。\n移动应用程序根本没有可用的 stdin 。虽然应用程序可以显示屏幕键盘，但这是软件特性 ，\n而不是连接在 stdin 上的。\n因此，涉及控制台操作的 Python 模块（如 curses 和 readline ）无法在移动平台上使用。", "metadata": {"title": "00_概述", "source": "md_docs\\python_library_md\\00_概述.md", "doc_type": "标准库", "language": "中文", "doc_id": "6547b6e4"}}
{"doc_id": "725e1a0d", "content": "模块命令行界面（CLI）\n下列模块具有命令行界面。\nast\nasyncio\nbase64\ncalendar\ncode\ncompileall\ncProfile: 参见 profile\ndis\ndoctest\nencodings.rot_13\nensurepip\nfilecmp\nfileinput\nftplib\ngzip\nhttp.server\nidlelib\ninspect\njson\nmimetypes\npdb\npickle\npickletools\nplatform\npoplib\nprofile\npstats\npy_compile\npyclbr\npydoc\nquopri\nrandom\nrunpy\nsite\nsqlite3\n符号表\nsysconfig\n\ntabnanny\ntarfile\nthis\ntimeit\ntokenize\ntrace\nturtledemo\nunittest\nuuid\nvenv\nwebbrowser\nzipapp\nzipfile\n另请参阅 the Python 命令行界面。", "metadata": {"title": "00_模块命令行界面（CLI）", "source": "md_docs\\python_library_md\\00_模块命令行界面（CLI）.md", "doc_type": "标准库", "language": "中文", "doc_id": "725e1a0d"}}
{"doc_id": "f6020c38", "content": "移除的模块\n在本章节中介绍的模块已从 Python 标准库中移除。 它们被列入此文档是为了帮助人们寻找替代。\naifc --- 读写 AIFF 和 AIFC 文件\nasynchat --- 异步套接字命令/响应处理器\nasyncore --- 异步套接字处理器\naudioop --- 处理原始音频数据\ncgi --- 通用网关接口支持\ncgitb --- 用于 CGI 脚本的回溯管理器\nchunk --- 读取 IFF 分块数据\ncrypt --- 验证 Unix 口令的函数\ndistutils --- 构建和安装 Python 模块\nimghdr --- 确定图像的类型\nimp --- 访问 import 的内部对象\nmod:!mailcap --- Mailcap 文件处理\nmsilib --- 读写 Microsoft Installer 文件\nnis --- Sun 的 NIS (黄页) 接口\nnntplib --- NNTP 协议客户端\nossaudiodev --- 访问兼容 OSS 的音频设备\npipes --- 针对 shell 管道的接口\nsmtpd --- SMTP 服务器\nsndhdr --- 确定声音文件的类型\nspwd --- shadow 密码数据库\nsunau --- 读写 Sun AU 文件\ntelnetlib --- Telnet 客户端\nuu --- 对 uuencode 文件进行编码与解码\nxdrlib --- 编码与解码 XDR 数据", "metadata": {"title": "00_移除的模块", "source": "md_docs\\python_library_md\\00_移除的模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "f6020c38"}}
{"doc_id": "70610219", "content": "结构化标记处理工具\nPython 支持各种模块，以处理各种形式的结构化数据标记。 这包括使用标准通用标记语言\n（SGML）和超文本标记语言（HTML）的模块，以及使用可扩展标记语言（XML）的几个接口。\nhtml --- 超文本标记语言支持\nhtml.parser --- 简单的 HTML 和 XHTML 解析器\nHTML 解析器的示例程序\nHTMLParser 方法\n例子\nhtml.entities --- HTML 一般实体的定义\nXML处理模块\nXML 安全\nxml.etree.ElementTree --- ElementTree XML API\n教程\nXML 树和元素\n解析 XML\n用于非阻塞解析的拉取 API\n查找感兴趣的元素\n修改XML文件\n构建 XML 文档\n解析带有命名空间的 XML\nXPath支持\n示例\n支持的XPath语法\n参考\n函数\nXInclude 支持\n示例\n参考\n函数\n元素对象\nElementTree 对象\nQName 对象\nTreeBuilder 对象\nXMLParser对象\nXMLPullParser对象\n异常\nxml.dom --- 文档对象模型 API\n模块内容\nDOM 中的对象\n\nDOMImplementation 对象\n节点对象\n节点列表对象\n文档类型对象\nDocument 对象\n元素对象\nAttr 对象\nNamedNodeMap 对象\n注释对象\nText 和 CDATASection 对象\nProcessingInstruction 对象\n异常\n一致性\n类型映射\n访问器方法\nxml.dom.minidom --- 最小化的 DOM 实现\nDOM 对象\nDOM 示例\nminidom 和 DOM 标准\nxml.dom.pulldom --- 对构建部分 DOM 树的支持\nDOMEventStream 对象\nxml.sax --- SAX2 解析器支持\nSAXException 对象\nxml.sax.handler --- SAX 处理器的基类\nContentHandler 对象\nDTDHandler 对象\nEntityResolver 对象\nErrorHandler 对象\nLexicalHandler 对象\nxml.sax.saxutils --- SAX 工具集\nxml.sax.xmlreader --- 用于 XML 解析器的接口\nXMLReader 对象\nIncrementalParser 对象\nLocator 对象\nInputSource 对象\nAttributes 接口\nAttributesNS 接口\nxml.parsers.expat --- 使用 Expat 进行快速 XML 解析\nXMLParser对象\nExpatError 异常\n示例\n内容模型描述\nExpat 错误常量\n\n|  | DOMImplementation 对象\n节点对象\n节点列表对象\n文档类型对象\nDocument 对象\n元素对象\nAttr 对象\nNamedNodeMap 对象\n注释对象\nText 和 CDATASection 对象\nProcessingInstruction 对象\n异常\n一致性\n类型映射\n访问器方法\nxml.dom.minidom --- 最小化的 DOM 实现\nDOM 对象\nDOM 示例\nminidom 和 DOM 标准\nxml.dom.pulldom --- 对构建部分 DOM 树的支持\nDOMEventStream 对象\nxml.sax --- SAX2 解析器支持\nSAXException 对象\nxml.sax.handler --- SAX 处理器的基类\nContentHandler 对象\nDTDHandler 对象\nEntityResolver 对象\nErrorHandler 对象\nLexicalHandler 对象\nxml.sax.saxutils --- SAX 工具集\nxml.sax.xmlreader --- 用于 XML 解析器的接口\nXMLReader 对象\nIncrementalParser 对象\nLocator 对象\nInputSource 对象\nAttributes 接口\nAttributesNS 接口\nxml.parsers.expat --- 使用 Expat 进行快速 XML 解析\nXMLParser对象\nExpatError 异常\n示例\n内容模型描述\nExpat 错误常量 |  |\n| --- | --- | --- |", "metadata": {"title": "00_结构化标记处理工具", "source": "md_docs\\python_library_md\\00_结构化标记处理工具.md", "doc_type": "标准库", "language": "中文", "doc_id": "70610219"}}
{"doc_id": "6b10ca44", "content": "网络和进程间通信\n本章介绍的模块提供了网络和进程间通信的机制。\n某些模块仅适用于同一台机器上的两个进程，例如 signal 和 mmap 。 其他模块支持两个或多个进\n程可用于跨机器通信的网络协议。\n本章中描述的模块列表是：\nasyncio --- 异步 I/O\nsocket --- 低层级的网络接口\nssl --- 套接字对象的 TLS/SSL 包装器\nselect --- 等待 I/O 完成\nselectors --- 高层级 I/O 复用\nsignal --- 设置异步事件处理器\nmmap --- 内存映射文件支持", "metadata": {"title": "00_网络和进程间通信", "source": "md_docs\\python_library_md\\00_网络和进程间通信.md", "doc_type": "标准库", "language": "中文", "doc_id": "6b10ca44"}}
{"doc_id": "21c3a0f9", "content": "自定义 Python 解释器\n本章中描述的模块允许编写类似于 Python 的交互式解释器的接口。 如果你想要一个支持附加某些\n特殊功能到 Python 语言的 Python 解释器，你应当看一下 code 模块。 (codeop 模块是低层级的，\n用于支持编译可能不完整的 Python 代码块。\n本章描述的完整模块列表如下：\ncode --- 解释器基类\n交互解释器对象\n交互式控制台对象\ncodeop --- 编译 Python 代码", "metadata": {"title": "00_自定义_Python_解释器", "source": "md_docs\\python_library_md\\00_自定义_Python_解释器.md", "doc_type": "标准库", "language": "中文", "doc_id": "21c3a0f9"}}
{"doc_id": "a0b9934a", "content": "被取代的模块\n本章介绍的模块在大部分场合下都已被其他模块所取代，它们被保留主要是为了能够向下兼容。\n某些模块出现在本章中可能是因为它们只覆盖了某个问题空间的有限子集，而更为普遍应用的解决\n方案存在于标准库的其他地方 (例如，getopt 覆盖了非常特定的 \"在 Python 中模拟 C getopt()\nAPI\" 任务，而不是如 optparse 和 argparse 所提供的更为宽泛的命令行选项解析和参数解析功\n能)。\n另外，某些模块出现在本章中也可能是因为它们已被弃用，并将在未来的发布版中被移除，或者它\n们已被 soft deprecated 并且不再鼓励在新项目中使用。 随着多个过时模块根据 PEP 594 被移除，\n目前已不存在属于此类情况的模块。\ngetopt --- C 风格的命令行选项解析器", "metadata": {"title": "00_被取代的模块", "source": "md_docs\\python_library_md\\00_被取代的模块.md", "doc_type": "标准库", "language": "中文", "doc_id": "a0b9934a"}}
{"doc_id": "e84d834f", "content": "调试和分析\n这些库可以帮助你进行 Python 开发：调试器使你能够逐步执行代码，分析堆栈帧并设置中断点等\n等，性能分析器可以运行代码并为你提供执行时间的详细数据，使你能够找出你的程序中的瓶颈。\n审计事件提供运行时行为的可见性，如果没有此工具则需要进行侵入式调试或修补。\n审计事件表\nbdb --- 调试器框架\nfaulthandler --- 转储 Python 回溯信息\n转储跟踪信息\n对 C 栈进行转储\nC 栈兼容性Stack Compatibility\n故障处理程序的状态\n一定时间后转储跟踪数据。\n转储用户信号的跟踪信息。\n文件描述符相关话题\n示例\npdb --- Python 的调试器\n调试器命令\nPython 性能分析器\n性能分析器简介\n实时用户手册\nprofile 和 cProfile 模块参考\nStats 类\n什么是确定性性能分析？\n局限性\n准确估量\n使用自定义计时器\ntimeit --- 测量小代码片段的执行时间\n基本示例\nPython 接口\n命令行接口\n例子\ntrace --- 跟踪或记录 Python 语句的执行\n命令行用法\n主要的可选参数\n修饰器\n过滤器\n编程接口\ntracemalloc --- 跟踪内存分配\n例子\n\n显示前10项\n计算差异\n获取一个内存块的溯源\n美化的 top\n记录所有被追踪内存块的当前和峰值大小\nAPI\n函数\n域过滤器\n过滤器\n帧\n快照\n统计\nStatisticDiff\n跟踪\n回溯", "metadata": {"title": "00_调试和分析", "source": "md_docs\\python_library_md\\00_调试和分析.md", "doc_type": "标准库", "language": "中文", "doc_id": "e84d834f"}}
{"doc_id": "ab11033f", "content": "软件打包和分发\n这些库可帮助你发布和安装 Python 软件。 虽然这些模块设计为与 Python 包索引 结合使用，但它们\n也可以与本地索引服务器一起使用，或者根本不使用任何索引服务器。\nensurepip --- 初始设置 pip 安装器\n命令行界面\n模块 API\nvenv --- 虚拟环境的创建\n创建虚拟环境\n虚拟环境是如何实现的\nAPI\n一个扩展 EnvBuilder 的例子\nzipapp --- 管理可执行的 Python zip 归档文件\n简单示例\n命令行接口\nPython API\n例子\n指定解释器程序\n用 zipapp 创建独立运行的应用程序\n注意事项\nPython 打包应用程序的格式", "metadata": {"title": "00_软件打包和分发", "source": "md_docs\\python_library_md\\00_软件打包和分发.md", "doc_type": "标准库", "language": "中文", "doc_id": "ab11033f"}}
{"doc_id": "b00133a2", "content": "通用操作系统服务\n本章中描述的各模块提供了在（几乎）所有的操作系统上可用的操作系统特性的接口，例如文件和\n时钟。这些接口通常以 Unix 或 C 接口为参考对象，不过在大多数其他系统上也可用。这里有一个概\n述：\nos --- 多种操作系统接口\n文件名，命令行参数，以及环境变量。\nPython UTF-8 模式\n进程参数\n创建文件对象\n文件描述符操作\n查询终端的尺寸\n文件描述符的继承\n文件和目录\n计时器文件描述符\nLinux 扩展属性\n进程管理\n调度器接口\n其他系统信息\n随机数\nio --- 处理流的核心工具\n概述\n文本 I/O\n二进制 I/O\n原始 I/O\n文本编码格式\n选择性的 EncodingWarning\n高阶模块接口\n类的层次结构\nI/O 基类\n原始文件 I/O\n缓冲流\n文本 I/O\n静态类型\n性能\n二进制 I/O\n文本 I/O\n多线程\n可重入性\ntime --- 时间的访问和转换\n\n函数\nClock ID 常量\n时区常量\nlogging --- Python 的日志记录工具\n记录器对象\n日志级别\n处理器对象\n格式器对象\n过滤器对象\nLogRecord 属性\nLogRecord 属性\nLoggerAdapter 对象\n线程安全\n模块级函数\n模块级属性\n与警告模块集成\nlogging.config --- 日志记录配置\n配置函数\n安全考量\n配置字典架构\n字典架构细节\n增量配置\n对象连接\n用户定义对象\n处理器配置顺序\n访问外部对象\n访问内部对象\n导入解析与定制导入器\n配置 QueueHandler 和 QueueListener\n配置文件格式\nlogging.handlers --- 日志处理器\nStreamHandler\nFileHandler\nNullHandler\nWatchedFileHandler\nBaseRotatingHandler\nRotatingFileHandler\nTimedRotatingFileHandler\nSocketHandler\nDatagramHandler\nSysLogHandler\nNTEventLogHandler\nSMTPHandler\n\n|  | 函数\nClock ID 常量\n时区常量\nlogging --- Python 的日志记录工具\n记录器对象\n日志级别\n处理器对象\n格式器对象\n过滤器对象\nLogRecord 属性\nLogRecord 属性\nLoggerAdapter 对象\n线程安全\n模块级函数\n模块级属性\n与警告模块集成\nlogging.config --- 日志记录配置\n配置函数\n安全考量\n配置字典架构\n字典架构细节\n增量配置\n对象连接\n用户定义对象\n处理器配置顺序\n访问外部对象\n访问内部对象\n导入解析与定制导入器\n配置 QueueHandler 和 QueueListener\n配置文件格式\nlogging.handlers --- 日志处理器\nStreamHandler\nFileHandler\nNullHandler\nWatchedFileHandler\nBaseRotatingHandler\nRotatingFileHandler\nTimedRotatingFileHandler\nSocketHandler\nDatagramHandler\nSysLogHandler\nNTEventLogHandler\nSMTPHandler |  |\n| --- | --- | --- |\n\nMemoryHandler\nHTTPHandler\nQueueHandler\nQueueListener\nplatform --- 访问底层平台的标识数据\n跨平台\nJava 平台\nWindows 平台\nmacOS 平台\niOS 平台\nUnix 平台\nLinux 平台\nAndroid 平台\n命令行用法\nerrno --- 标准 errno 系统符号\nctypes --- Python 的外部函数库\nctypes 教程\n载入动态连接库\n操作导入的动态链接库中的函数\n调用函数\n基础数据类型\n调用函数，继续\n调用可变函数\n使用自定义的数据类型调用函数\n指定必选参数的类型(函数原型)\n返回类型\n传递指针（或以引用方式传递形参）\n结构体和联合\n结构/联合布局、对齐和字节顺序\n结构体和联合中的位域\n数组\n指针\n没有 GIL 时的线程安全性\n类型转换\n不完整类型\n回调函数\n访问 dll 的导出变量\n意外\n变长数据类型\nctypes 参考手册\n寻找动态链接库\n列出已加载的共享库\n加载共享库\n\n|  | MemoryHandler\nHTTPHandler\nQueueHandler\nQueueListener\nplatform --- 访问底层平台的标识数据\n跨平台\nJava 平台\nWindows 平台\nmacOS 平台\niOS 平台\nUnix 平台\nLinux 平台\nAndroid 平台\n命令行用法\nerrno --- 标准 errno 系统符号\nctypes --- Python 的外部函数库\nctypes 教程\n载入动态连接库\n操作导入的动态链接库中的函数\n调用函数\n基础数据类型\n调用函数，继续\n调用可变函数\n使用自定义的数据类型调用函数\n指定必选参数的类型(函数原型)\n返回类型\n传递指针（或以引用方式传递形参）\n结构体和联合\n结构/联合布局、对齐和字节顺序\n结构体和联合中的位域\n数组\n指针\n没有 GIL 时的线程安全性\n类型转换\n不完整类型\n回调函数\n访问 dll 的导出变量\n意外\n变长数据类型\nctypes 参考手册\n寻找动态链接库\n列出已加载的共享库\n加载共享库 |  |\n| --- | --- | --- |\n\n外部函数\n函数原型\n工具函数\n数据类型\n基础数据类型\n结构化数据类型\n数组与指针\n异常", "metadata": {"title": "00_通用操作系统服务", "source": "md_docs\\python_library_md\\00_通用操作系统服务.md", "doc_type": "标准库", "language": "中文", "doc_id": "b00133a2"}}
