{"doc_id": "903a84e3", "content": "1. 使用 C 或 C++ 扩展 Python\n如果你会用 C，添加新的 Python 内置模块会很简单。以下两件不能用 Python 直接做的事，可以通\n过 extension modules 来实现：实现新的内置对象类型；调用 C 的库函数和系统调用。\n为了支持扩展，Python API（应用程序编程接口）定义了一系列函数、宏和变量，可以访问 Python\n运行时系统的大部分内容。Python 的 API 可以通过在一个 C 源文件中引用 \"Python.h\" 头文件来使\n用。\n扩展模块的编写方式取决与你的目的以及系统设置；下面章节会详细介绍。\n备注: C扩展接口特指CPython，扩展模块无法在其他Python实现上工作。在大多数情况下，应该\n避免写C扩展，来保持可移植性。举个例子，如果你的用例调用了C库或系统调用，你应该考虑使\n用 ctypes 模块或 cffi 库，而不是自己写C代码。这些模块允许你写Python代码来接口C代码，并\n且相较于编写和编译C扩展模块，该方法在不同Python实现之间具有更高的可移植性。\n1.1. 一个简单的例子\n让我们创建一个扩展模块 spam (Monty Python 粉丝最喜欢的食物...) 并且想要创建对应 C 库函数\nsystem() [1] 的 Python 接口。 这个函数接受一个以 null 结尾的字符串参数并返回一个整数。 我们\n希望可以在 Python 中以如下方式调用此函数:\n>>> import spam\n>>> status = spam.system(\"ls -l\")\n首先创建一个 spammodule.c 文件。（传统上，如果一个模块叫 spam，则对应实现它的 C 文件叫\nspammodule.c；如果这个模块名字非常长，比如 spammify，则这个模块的文件可以直接叫\nspammify.c。）\n文件中开始的两行是：\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n这会导入 Python API（如果你喜欢，你可以在这里添加描述模块目标和版权信息的注释)。\n备注: 由于 Python 可能会定义一些能在某些系统上影响标准头文件的预处理器定义，因此在包\n含任何标准头文件之前，你 必须 先包含 Python.h。\n#define PY_SSIZE_T_CLEAN 被用来指明 Py_ssize_t 应当在某些 API 中代替 int 使用。 它从\nPython 3.13 起已不再需要，但我们保留它用于向下兼容。 请参阅 字符串和缓存区 获取该宏的描\n述。\n\n| 1. 使用 C 或 C++ 扩展 Python\n如果你会用 C，添加新的 Python 内置模块会很简单。以下两件不能用 Python 直接做的事，可以通\n过 extension modules 来实现：实现新的内置对象类型；调用 C 的库函数和系统调用。\n为了支持扩展，Python API（应用程序编程接口）定义了一系列函数、宏和变量，可以访问 Python\n运行时系统的大部分内容。Python 的 API 可以通过在一个 C 源文件中引用 \"Python.h\" 头文件来使\n用。\n扩展模块的编写方式取决与你的目的以及系统设置；下面章节会详细介绍。 |\n| --- |\n| 备注: C扩展接口特指CPython，扩展模块无法在其他Python实现上工作。在大多数情况下，应该\n避免写C扩展，来保持可移植性。举个例子，如果你的用例调用了C库或系统调用，你应该考虑使\n用 ctypes 模块或 cffi 库，而不是自己写C代码。这些模块允许你写Python代码来接口C代码，并\n且相较于编写和编译C扩展模块，该方法在不同Python实现之间具有更高的可移植性。 |\n| 1.1. 一个简单的例子\n让我们创建一个扩展模块 spam (Monty Python 粉丝最喜欢的食物...) 并且想要创建对应 C 库函数\nsystem() [1] 的 Python 接口。 这个函数接受一个以 null 结尾的字符串参数并返回一个整数。 我们\n希望可以在 Python 中以如下方式调用此函数: |\n| >>> import spam\n>>> status = spam.system(\"ls -l\") |\n| 首先创建一个 spammodule.c 文件。（传统上，如果一个模块叫 spam，则对应实现它的 C 文件叫\nspammodule.c；如果这个模块名字非常长，比如 spammify，则这个模块的文件可以直接叫\nspammify.c。）\n文件中开始的两行是： |\n| #define PY_SSIZE_T_CLEAN\n#include <Python.h> |\n| 这会导入 Python API（如果你喜欢，你可以在这里添加描述模块目标和版权信息的注释)。 |\n| 备注: 由于 Python 可能会定义一些能在某些系统上影响标准头文件的预处理器定义，因此在包\n含任何标准头文件之前，你 必须 先包含 Python.h。\n#define PY_SSIZE_T_CLEAN 被用来指明 Py_ssize_t 应当在某些 API 中代替 int 使用。 它从\nPython 3.13 起已不再需要，但我们保留它用于向下兼容。 请参阅 字符串和缓存区 获取该宏的描\n述。 |\n|  |\n\n由 Python.h 定义的用户可见的符号都带有 Py 或 PY 前缀，只有在标准头文件中定义的符号除外。\n小技巧: 为保持向下兼容，Python.h 包括了一些标准头文件。 C 扩展应当包括它们要使用的标\n准头文件，而不应依赖这些隐式的包括。 如果使用受限 C API 3.13 版或更新的版本，隐式的包括\n如下：\n<assert.h>\n<intrin.h> (在 Windows 上)\n<inttypes.h>\n<limits.h>\n<math.h>\n<stdarg.h>\n<wchar.h>\n<sys/types.h> (如果提供)\n如果未定义 Py_LIMITED_API，或是设为 3.12 版或更旧的版本，则还将包括如下头文件：\n<ctype.h>\n<unistd.h> (在 POSIX 上)\n如果未定义 Py_LIMITED_API，或是设为 3.10 版或更旧的版本，则还将包括如下头文件：\n<errno.h>\n<stdio.h>\n<stdlib.h>\n<string.h>\n下面添加C函数到扩展模块，当调用 spam.system(string) 时会做出响应，(我们稍后会看到调\n用)：\nstatic PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = system(command);\nreturn PyLong_FromLong(sts);\n}\n有个直接翻译参数列表的方法(举个例子，单独的 \"ls -l\" )到要传递给C函数的参数。C函数总是有\n两个参数，通常名字是 self 和 args 。\n对模块级函数， self 参数指向模块对象；对于方法则指向对象实例。\n\n|  | 由 Python.h 定义的用户可见的符号都带有 Py 或 PY 前缀，只有在标准头文件中定义的符号除外。 |  |\n| --- | --- | --- |\n|  | 小技巧: 为保持向下兼容，Python.h 包括了一些标准头文件。 C 扩展应当包括它们要使用的标\n准头文件，而不应依赖这些隐式的包括。 如果使用受限 C API 3.13 版或更新的版本，隐式的包括\n如下：\n<assert.h>\n<intrin.h> (在 Windows 上)\n<inttypes.h>\n<limits.h>\n<math.h>\n<stdarg.h>\n<wchar.h>\n<sys/types.h> (如果提供)\n如果未定义 Py_LIMITED_API，或是设为 3.12 版或更旧的版本，则还将包括如下头文件：\n<ctype.h>\n<unistd.h> (在 POSIX 上)\n如果未定义 Py_LIMITED_API，或是设为 3.10 版或更旧的版本，则还将包括如下头文件：\n<errno.h>\n<stdio.h>\n<stdlib.h>\n<string.h> |  |\n|  | 下面添加C函数到扩展模块，当调用 spam.system(string) 时会做出响应，(我们稍后会看到调\n用)： |  |\n|  | static PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = system(command);\nreturn PyLong_FromLong(sts);\n} |  |\n|  | 有个直接翻译参数列表的方法(举个例子，单独的 \"ls -l\" )到要传递给C函数的参数。C函数总是有\n两个参数，通常名字是 self 和 args 。\n对模块级函数， self 参数指向模块对象；对于方法则指向对象实例。 |  |\n\nargs 参数是指向一个 Python 的 tuple 对象的指针，其中包含参数。 每个 tuple 项对应一个调用参\n数。 这些参数也全都是 Python 对象 --- 要在我们的 C 函数中使用它们就需要先将其转换为 C 值。\nPython API 中的函数 PyArg_ParseTuple() 会检查参数类型并将其转换为 C 值。 它使用模板字符串\n确定需要的参数类型以及存储被转换的值的 C 变量类型。 细节将稍后说明。\nPyArg_ParseTuple() 在所有参数都有正确类型且组成部分按顺序放在传递进来的地址里时，返回\n真(非零)。其在传入无效参数时返回假(零)。在后续例子里，还会抛出特定异常，使得调用的函数可\n以理解返回 NULL (也就是例子里所见)。\n1.2. 关于错误和异常\n整个 Python 解释器系统有一个如下所述的重要惯例：当一个函数运行失败时，它应当设置一个异常\n条件并返回一个错误值（通常为 -1 或 NULL 指针）。 异常信息保存在解释器线程状态的三个成员\n中。 如果没有异常则它们的值为 NULL。 在其他情况下它们是 sys.exc_info() 所返回的 Python 元\n组的成员的 C 对应物。 它们分别是异常类型、异常实例和回溯对象。 理解它们对于理解错误是如何\n被传递的非常重要。\nPython API中定义了一些函数来设置这些变量。\n最常用的就是 PyErr_SetString()。 其参数是异常对象和 C 字符串。 异常对象一般是像\nPyExc_ZeroDivisionError 这样的预定义对象。 C 字符串指明异常原因，并被转换为一个 Python\n字符串对象存储为异常的“关联值”。\n另一个有用的函数是 PyErr_SetFromErrno() ，仅接受一个异常对象，异常描述包含在全局变量\nerrno 中。最通用的函数还是 PyErr_SetObject() ，包含两个参数，分别为异常对象和异常描述。\n你不需要使用 Py_INCREF() 来增加传递到其他函数的参数对象的引用计数。\n你可以通过 PyErr_Occurred() 在不造成破坏的情况下检测是否设置了异常。 这将返回当前异常对\n象，或者如果未发生异常则返回 NULL。 你通常不需要调用 PyErr_Occurred() 来查看函数调用中\n是否发生了错误，因为你应该能从返回值中看出来。\n当一个函数 f 调用另一个函数 g 时检测到后者出错了，f 应当自己返回一个错误值 (通常为 NULL 或\n-1)。 它 不应 调用某个 PyErr_* 函数 --- 这类函数已经被 g 调用过了。 f 的调用者随后也应当返回\n一个错误来提示 它的 调用者，同样 不应 调用 PyErr_*，依此类推 --- 错误的最详细原因已经由首\n先检测到它的函数报告了。 一旦这个错误到达 Python 解释器的主循环，它会中止当前执行的\nPython 代码并尝试找出由 Python 程序员所指定的异常处理器。\n（在某些情况下模块确实能够通过调用其它 PyErr_* 函数来给出更为详细的错误消息，并且在这些\n情况下是可以这样做的。 但是按照一般规则，这是不必要的，并可能导致有关错误的信息丢失：大\n多数操作会由于种种原因而失败。）\n想要忽略由一个失败的函数调用所设置的异常，异常条件必须通过调用 PyErr_Clear() 显式地被清\n除。 C 代码应当调用 PyErr_Clear() 的唯一情况是如果它不想将错误传给解释器而是想完全由自己\n来处理它（可能是尝试其他方法，或是假装没有出错）。\n每次失败的 malloc() 调用必须转换为一个异常。 malloc() (或 realloc() )的直接调用者必须调\n用 PyErr_NoMemory() 来返回错误来提示。所有对象创建函数(例如 PyLong_FromLong() )已经这么\n\n|  | args 参数是指向一个 Python 的 tuple 对象的指针，其中包含参数。 每个 tuple 项对应一个调用参\n数。 这些参数也全都是 Python 对象 --- 要在我们的 C 函数中使用它们就需要先将其转换为 C 值。\nPython API 中的函数 PyArg_ParseTuple() 会检查参数类型并将其转换为 C 值。 它使用模板字符串\n确定需要的参数类型以及存储被转换的值的 C 变量类型。 细节将稍后说明。\nPyArg_ParseTuple() 在所有参数都有正确类型且组成部分按顺序放在传递进来的地址里时，返回\n真(非零)。其在传入无效参数时返回假(零)。在后续例子里，还会抛出特定异常，使得调用的函数可\n以理解返回 NULL (也就是例子里所见)。\n1.2. 关于错误和异常\n整个 Python 解释器系统有一个如下所述的重要惯例：当一个函数运行失败时，它应当设置一个异常\n条件并返回一个错误值（通常为 -1 或 NULL 指针）。 异常信息保存在解释器线程状态的三个成员\n中。 如果没有异常则它们的值为 NULL。 在其他情况下它们是 sys.exc_info() 所返回的 Python 元\n组的成员的 C 对应物。 它们分别是异常类型、异常实例和回溯对象。 理解它们对于理解错误是如何\n被传递的非常重要。\nPython API中定义了一些函数来设置这些变量。\n最常用的就是 PyErr_SetString()。 其参数是异常对象和 C 字符串。 异常对象一般是像\nPyExc_ZeroDivisionError 这样的预定义对象。 C 字符串指明异常原因，并被转换为一个 Python\n字符串对象存储为异常的“关联值”。\n另一个有用的函数是 PyErr_SetFromErrno() ，仅接受一个异常对象，异常描述包含在全局变量\nerrno 中。最通用的函数还是 PyErr_SetObject() ，包含两个参数，分别为异常对象和异常描述。\n你不需要使用 Py_INCREF() 来增加传递到其他函数的参数对象的引用计数。\n你可以通过 PyErr_Occurred() 在不造成破坏的情况下检测是否设置了异常。 这将返回当前异常对\n象，或者如果未发生异常则返回 NULL。 你通常不需要调用 PyErr_Occurred() 来查看函数调用中\n是否发生了错误，因为你应该能从返回值中看出来。\n当一个函数 f 调用另一个函数 g 时检测到后者出错了，f 应当自己返回一个错误值 (通常为 NULL 或\n-1)。 它 不应 调用某个 PyErr_* 函数 --- 这类函数已经被 g 调用过了。 f 的调用者随后也应当返回\n一个错误来提示 它的 调用者，同样 不应 调用 PyErr_*，依此类推 --- 错误的最详细原因已经由首\n先检测到它的函数报告了。 一旦这个错误到达 Python 解释器的主循环，它会中止当前执行的\nPython 代码并尝试找出由 Python 程序员所指定的异常处理器。\n（在某些情况下模块确实能够通过调用其它 PyErr_* 函数来给出更为详细的错误消息，并且在这些\n情况下是可以这样做的。 但是按照一般规则，这是不必要的，并可能导致有关错误的信息丢失：大\n多数操作会由于种种原因而失败。）\n想要忽略由一个失败的函数调用所设置的异常，异常条件必须通过调用 PyErr_Clear() 显式地被清\n除。 C 代码应当调用 PyErr_Clear() 的唯一情况是如果它不想将错误传给解释器而是想完全由自己\n来处理它（可能是尝试其他方法，或是假装没有出错）。\n每次失败的 malloc() 调用必须转换为一个异常。 malloc() (或 realloc() )的直接调用者必须调\n用 PyErr_NoMemory() 来返回错误来提示。所有对象创建函数(例如 PyLong_FromLong() )已经这么 |  |\n| --- | --- | --- |\n\n做了，所以这个提示仅用于直接调用 malloc() 的情况。\n还要注意的是，除了 PyArg_ParseTuple() 等重要的例外，返回整数状态码的函数通常都是返回正\n值或零来表示成功，而以 -1 表示失败，如同 Unix 系统调用一样。\n最后，当你返回一个错误指示器时要注意清理垃圾（通过为你已经创建的对象执行 Py_XDECREF()\n或 Py_DECREF() 调用）！\n选择引发哪个异常完全取决于你的喜好。 所有 Python 内置异常都有对应的预声明 C 对象，例如\nPyExc_ZeroDivisionError，你可以直接使用它们。 当然，你应当明智地选择异常 --- 不要使用\nPyExc_TypeError 来表示文件无法打开（可能应该用 PyExc_OSError 比较好）。 如果参数列表有\n问题，PyArg_ParseTuple() 函数通常会引发 PyExc_TypeError。 如果你希望一个参数的值必须在\n特定范围内或必须满足其他条件，则适宜使用 PyExc_ValueError。\n你也可以定义你的模块独有的新异常。 做到这点的最简单方式是在文件的开头声明一个静态全局对\n象变量:\nstatic PyObject *SpamError = NULL;\n并通过在模块的 Py_mod_exec 函数 (spam_module_exec()) 中调用 PyErr_NewException() 来初始\n化它:\nSpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n由于 SpamError 是一个全局变量，它将在模块每次重新初始化时被覆盖，即当 Py_mod_exec 函数\n被调用时。\n在目前，让我们避免这个问题：我们将通过引发 ImportError 来阻止重复的初始化:\nstatic PyObject *SpamError = NULL;\nstatic int\nspam_module_exec(PyObject *m)\n{\nif (SpamError != NULL) {\nPyErr_SetString(PyExc_ImportError,\n\"cannot initialize spam module more than once\");\nreturn -1;\n}\nSpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\nif (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot spam_module_slots[] = {\n{Py_mod_exec, spam_module_exec},\n{0, NULL}\n};\n\n|  | 做了，所以这个提示仅用于直接调用 malloc() 的情况。\n还要注意的是，除了 PyArg_ParseTuple() 等重要的例外，返回整数状态码的函数通常都是返回正\n值或零来表示成功，而以 -1 表示失败，如同 Unix 系统调用一样。\n最后，当你返回一个错误指示器时要注意清理垃圾（通过为你已经创建的对象执行 Py_XDECREF()\n或 Py_DECREF() 调用）！\n选择引发哪个异常完全取决于你的喜好。 所有 Python 内置异常都有对应的预声明 C 对象，例如\nPyExc_ZeroDivisionError，你可以直接使用它们。 当然，你应当明智地选择异常 --- 不要使用\nPyExc_TypeError 来表示文件无法打开（可能应该用 PyExc_OSError 比较好）。 如果参数列表有\n问题，PyArg_ParseTuple() 函数通常会引发 PyExc_TypeError。 如果你希望一个参数的值必须在\n特定范围内或必须满足其他条件，则适宜使用 PyExc_ValueError。\n你也可以定义你的模块独有的新异常。 做到这点的最简单方式是在文件的开头声明一个静态全局对\n象变量: |  |\n| --- | --- | --- |\n|  | static PyObject *SpamError = NULL; |  |\n|  | 并通过在模块的 Py_mod_exec 函数 (spam_module_exec()) 中调用 PyErr_NewException() 来初始\n化它: |  |\n|  | SpamError = PyErr_NewException(\"spam.error\", NULL, NULL); |  |\n|  | 由于 SpamError 是一个全局变量，它将在模块每次重新初始化时被覆盖，即当 Py_mod_exec 函数\n被调用时。\n在目前，让我们避免这个问题：我们将通过引发 ImportError 来阻止重复的初始化: |  |\n|  | static PyObject *SpamError = NULL;\nstatic int\nspam_module_exec(PyObject *m)\n{\nif (SpamError != NULL) {\nPyErr_SetString(PyExc_ImportError,\n\"cannot initialize spam module more than once\");\nreturn -1;\n}\nSpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\nif (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot spam_module_slots[] = {\n{Py_mod_exec, spam_module_exec},\n{0, NULL}\n}; |  |\n\nstatic struct PyModuleDef spam_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"spam\",\n.m_size = 0, // non-negative\n.m_slots = spam_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n}\n请注意该异常对象的 Python 名称为 spam.error。 PyErr_NewException() 函数可以创建基类为\nException 的类 (除非传入了另一个类而不是 NULL)，如 内置异常 中所描述的。\n请注意 SpamError 变量保留了一个对新创建的异常类的引用；这是有意为之的！ 由于异常可能会被\n外部代码从模块中删除，因此需要拥有一个对该类的引用以确保它不会被丢弃，从而导致\nSpamError 成为一个悬空指针。 如果异常类成为悬空指针，则引发该异常的 C 代码可能会导致核心\n转储或其他预期之外的附带影响。\n在目前，用于移除该引用的 Py_DECREF() 调用是缺失的。 即使是在 Python 解释器关闭时，全局变\n量 SpamError 也不会被当作垃圾回收。 它将会“泄漏”。 不过，我们确实能保证这在每个进程中最多\n发生一次。\n本样例稍后将讨论 PyMODINIT_FUNC 作为函数返回类型的用法。\n可在扩展模块中调用 PyErr_SetString() 来引发 spam.error 异常，如下所示:\nstatic PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = system(command);\nif (sts < 0) {\nPyErr_SetString(SpamError, \"System command failed\");\nreturn NULL;\n}\nreturn PyLong_FromLong(sts);\n}\n1.3. 回到例子\n回到前面的例子，你应该明白下面的代码:\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\n\n|  | static struct PyModuleDef spam_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"spam\",\n.m_size = 0, // non-negative\n.m_slots = spam_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n} |  |\n| --- | --- | --- |\n|  | 请注意该异常对象的 Python 名称为 spam.error。 PyErr_NewException() 函数可以创建基类为\nException 的类 (除非传入了另一个类而不是 NULL)，如 内置异常 中所描述的。\n请注意 SpamError 变量保留了一个对新创建的异常类的引用；这是有意为之的！ 由于异常可能会被\n外部代码从模块中删除，因此需要拥有一个对该类的引用以确保它不会被丢弃，从而导致\nSpamError 成为一个悬空指针。 如果异常类成为悬空指针，则引发该异常的 C 代码可能会导致核心\n转储或其他预期之外的附带影响。\n在目前，用于移除该引用的 Py_DECREF() 调用是缺失的。 即使是在 Python 解释器关闭时，全局变\n量 SpamError 也不会被当作垃圾回收。 它将会“泄漏”。 不过，我们确实能保证这在每个进程中最多\n发生一次。\n本样例稍后将讨论 PyMODINIT_FUNC 作为函数返回类型的用法。\n可在扩展模块中调用 PyErr_SetString() 来引发 spam.error 异常，如下所示: |  |\n|  | static PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = system(command);\nif (sts < 0) {\nPyErr_SetString(SpamError, \"System command failed\");\nreturn NULL;\n}\nreturn PyLong_FromLong(sts);\n} |  |\n|  | 1.3. 回到例子\n回到前面的例子，你应该明白下面的代码: |  |\n|  | if (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL; |  |\n|  |  |  |\n\n如果在参数列表中检测到错误，它将返回 NULL (该值是返回对象指针的函数的错误提示)，这取决于\nPyArg_ParseTuple() 设置的异常。 在其他情况下参数的字符串值会被拷贝到局部变量 command。\n这是一个指针赋值并且你不应该修改它所指向的字符串 (因此在标准 C 中，变量 command 应当被正\n确地声明为 const char *command)。\n下一个语句使用UNIX系统函数 system() ，传递给他的参数是刚才从 PyArg_ParseTuple() 取出的:\nsts = system(command);\n我们的 spam.system() 函数必须以 Python 对象的形式返回 sts 的值。 这是通过使用函数\nPyLong_FromLong() 完成的。\nreturn PyLong_FromLong(sts);\n在这种情况下，会返回一个整数对象，(这个对象会在Python堆里面管理)。\n如果你有一个不返回有用参数的 C 函数（即返回 void 的函数），则对应的 Python 函数必须返回\nNone。 你必须使用这种写法（它是通过 Py_RETURN_NONE 宏来实现的）\nPy_INCREF(Py_None);\nreturn Py_None;\nPy_None 是特殊 Python 对象 None 所对应的 C 名称。 它是一个真正的 Python 对象而不是 NULL 指\n针，如我们所见，后者在大多数上下文中都意味着“错误”。\n1.4. 模块方法表和初始化函数\n我承诺过要向大家展示如何从 Python 程序中调用 spam_system()。 首先，我们需要在“方法表”中\n列出它的名称和地址:\nstatic PyMethodDef spam_methods[] = {\n...\n{\"system\", spam_system, METH_VARARGS,\n\"Execute a shell command.\"},\n...\n{NULL, NULL, 0, NULL} /* Sentinel */\n};\n注意第三个参数 ( METH_VARARGS ) ，这个标志指定会使用C的调用惯例。可选值有 METH_VARARGS\n、 METH_VARARGS | METH_KEYWORDS 。值 0 代表使用 PyArg_ParseTuple() 的陈旧变量。\n如果单独使用 METH_VARARGS ，函数会等待Python传来tuple格式的参数，并最终使用\nPyArg_ParseTuple() 进行解析。\n如果应当将关键字参数传给该函数则可以在第三个字段中设置 METH_KEYWORDS 比特位。 在此情况\n下，C 函数应当接受第三个 PyObject * 形参，它将为一个由关键字组成的字典。 使用\nPyArg_ParseTupleAndKeywords() 来将参数解析为函数。\n这个方法表必须被模块定义结构所引用。\n\n|  | 如果在参数列表中检测到错误，它将返回 NULL (该值是返回对象指针的函数的错误提示)，这取决于\nPyArg_ParseTuple() 设置的异常。 在其他情况下参数的字符串值会被拷贝到局部变量 command。\n这是一个指针赋值并且你不应该修改它所指向的字符串 (因此在标准 C 中，变量 command 应当被正\n确地声明为 const char *command)。\n下一个语句使用UNIX系统函数 system() ，传递给他的参数是刚才从 PyArg_ParseTuple() 取出的: |  |\n| --- | --- | --- |\n|  | sts = system(command); |  |\n|  | 我们的 spam.system() 函数必须以 Python 对象的形式返回 sts 的值。 这是通过使用函数\nPyLong_FromLong() 完成的。 |  |\n|  | return PyLong_FromLong(sts); |  |\n|  | 在这种情况下，会返回一个整数对象，(这个对象会在Python堆里面管理)。\n如果你有一个不返回有用参数的 C 函数（即返回 void 的函数），则对应的 Python 函数必须返回\nNone。 你必须使用这种写法（它是通过 Py_RETURN_NONE 宏来实现的） |  |\n|  | Py_INCREF(Py_None);\nreturn Py_None; |  |\n|  | Py_None 是特殊 Python 对象 None 所对应的 C 名称。 它是一个真正的 Python 对象而不是 NULL 指\n针，如我们所见，后者在大多数上下文中都意味着“错误”。\n1.4. 模块方法表和初始化函数\n我承诺过要向大家展示如何从 Python 程序中调用 spam_system()。 首先，我们需要在“方法表”中\n列出它的名称和地址: |  |\n|  | static PyMethodDef spam_methods[] = {\n...\n{\"system\", spam_system, METH_VARARGS,\n\"Execute a shell command.\"},\n...\n{NULL, NULL, 0, NULL} /* Sentinel */\n}; |  |\n|  | 注意第三个参数 ( METH_VARARGS ) ，这个标志指定会使用C的调用惯例。可选值有 METH_VARARGS\n、 METH_VARARGS | METH_KEYWORDS 。值 0 代表使用 PyArg_ParseTuple() 的陈旧变量。\n如果单独使用 METH_VARARGS ，函数会等待Python传来tuple格式的参数，并最终使用\nPyArg_ParseTuple() 进行解析。\n如果应当将关键字参数传给该函数则可以在第三个字段中设置 METH_KEYWORDS 比特位。 在此情况\n下，C 函数应当接受第三个 PyObject * 形参，它将为一个由关键字组成的字典。 使用\nPyArg_ParseTupleAndKeywords() 来将参数解析为函数。\n这个方法表必须被模块定义结构所引用。 |  |\n\nstatic struct PyModuleDef spam_module = {\n...\n.m_methods = spam_methods,\n...\n};\n这个结构体必须在模块的初始化函数中传递给解释器。 初始化函数必须命名为 PyInit_name()，其\n中 name 是模块的名称，并且应该是模块文件中定义的唯一非 static 条目:\nPyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n}\n请注意 PyMODINIT_FUNC 将函数声明为 PyObject * 返回类型，声明了平台所要求的任何特殊链接\n声明，并针对于= C++ 将函数声明为 extern \"C\"。\nPyInit_spam() 会在每个解释器首次导入其 spam 模块时被调用。 （请参看下文中有关嵌入式\nPython 的说明。） 必须通过 PyModuleDef_Init() 返回一个指向模块定义的指针，以便导入机制\n能够创建该模块并将其保存到 sys.modules 中。\n当嵌入 Python 时，PyInit_spam() 函数将不会被自动调用除非在 PyImport_Inittab 表中有条\n目。 要将模块添加到初始化表中，请使用 PyImport_AppendInittab()，并可选择随后导入该模块:\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\nint\nmain(int argc, char *argv[])\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 添加一个内置模块，在 Py_Initialize 之前 */\nif (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\nfprintf(stderr, \"Error: could not extend in-built modules table\\n\");\nexit(1);\n}\n/* 将 argv[0] 传给 Python 解释器 */\nstatus = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\n/* 初始化 Python 解释器。 必需的操作。\n如果此步骤失败，将导致致命错误。 */\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config);\n\n|  | static struct PyModuleDef spam_module = {\n...\n.m_methods = spam_methods,\n...\n}; |  |\n| --- | --- | --- |\n|  | 这个结构体必须在模块的初始化函数中传递给解释器。 初始化函数必须命名为 PyInit_name()，其\n中 name 是模块的名称，并且应该是模块文件中定义的唯一非 static 条目: |  |\n|  | PyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n} |  |\n|  | 请注意 PyMODINIT_FUNC 将函数声明为 PyObject * 返回类型，声明了平台所要求的任何特殊链接\n声明，并针对于= C++ 将函数声明为 extern \"C\"。\nPyInit_spam() 会在每个解释器首次导入其 spam 模块时被调用。 （请参看下文中有关嵌入式\nPython 的说明。） 必须通过 PyModuleDef_Init() 返回一个指向模块定义的指针，以便导入机制\n能够创建该模块并将其保存到 sys.modules 中。\n当嵌入 Python 时，PyInit_spam() 函数将不会被自动调用除非在 PyImport_Inittab 表中有条\n目。 要将模块添加到初始化表中，请使用 PyImport_AppendInittab()，并可选择随后导入该模块: |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\nint\nmain(int argc, char *argv[])\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 添加一个内置模块，在 Py_Initialize 之前 */\nif (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\nfprintf(stderr, \"Error: could not extend in-built modules table\\n\");\nexit(1);\n}\n/* 将 argv[0] 传给 Python 解释器 */\nstatus = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\n/* 初始化 Python 解释器。 必需的操作。\n如果此步骤失败，将导致致命错误。 */\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config); |  |\n\n/* 可以选择导入模块；或是作为替代，\n导入可以被延迟直到由嵌入的脚本\n来导入它。 */\nPyObject *pmodule = PyImport_ImportModule(\"spam\");\nif (!pmodule) {\nPyErr_Print();\nfprintf(stderr, \"Error: could not import module 'spam'\\n\");\n}\n// ... 在此使用 Python C API ...\nreturn 0;\nexception:\nPyConfig_Clear(&config);\nPy_ExitStatusException(status);\n}\n备注: 如果你声明一个全局变量或局部静态变量，模块可能在重新初始化时出现预料之外的附带\n影响，例如在从 sys.modules 中移除条目或将已编译的模块导入到一个进程中的多个解释器（或\n者在未干预 exec() 的情况下执行 fork() 之后）的时候。 如果模块状态没有被完全 隔离，开发\n者应当考虑将模块标记为不支持子解释器 (通过\nPy_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED)。\n在 Python 源代码发布包的 Modules/xxlimited.c 中包括了一个更详细的示例。 此文件可被用作代\n码模板或是学习样例。\n1.5. 编译和链接\n在你能使用你的新写的扩展之前，你还需要做两件事情：使用 Python 系统来编译和链接。如果你使\n用动态加载，这取决于你使用的操作系统的动态加载机制；更多信息请参考编译扩展模块的章节（\n构建 C/C++ 扩展 章节），以及在 Windows 上编译需要的额外信息（ 在 Windows 上构建 C 和 C++\n扩展 章节）。\n如果你不使用动态加载，或者想要让模块永久性的作为Python解释器的一部分，就必须修改配置设\n置，并重新构建解释器。幸运的是在Unix上很简单，只需要把你的文件 ( spammodule.c 为例) 放在\n解压缩源码发行包的 Modules/ 目录下，添加一行到 Modules/Setup.local 来描述你的文件：\nspam spammodule.o\n然后在顶层目录运行 make 来重新构建解释器。你也可以在 Modules/ 子目录使用 make，但是你必\n须先重建 Makefile 文件，然后运行 'make Makefile' 命令。（你每次修改 Setup 文件都需要这样操\n作。）\n如果你的模块需要额外的链接，这些内容可以列出在配置文件里，举个实例：\nspam spammodule.o -lX11\n1.6. 在C中调用Python函数\n\n|  | /* 可以选择导入模块；或是作为替代，\n导入可以被延迟直到由嵌入的脚本\n来导入它。 */\nPyObject *pmodule = PyImport_ImportModule(\"spam\");\nif (!pmodule) {\nPyErr_Print();\nfprintf(stderr, \"Error: could not import module 'spam'\\n\");\n}\n// ... 在此使用 Python C API ...\nreturn 0;\nexception:\nPyConfig_Clear(&config);\nPy_ExitStatusException(status);\n} |  |\n| --- | --- | --- |\n|  |  |  |\n|  | 备注: 如果你声明一个全局变量或局部静态变量，模块可能在重新初始化时出现预料之外的附带\n影响，例如在从 sys.modules 中移除条目或将已编译的模块导入到一个进程中的多个解释器（或\n者在未干预 exec() 的情况下执行 fork() 之后）的时候。 如果模块状态没有被完全 隔离，开发\n者应当考虑将模块标记为不支持子解释器 (通过\nPy_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED)。 |  |\n|  | 在 Python 源代码发布包的 Modules/xxlimited.c 中包括了一个更详细的示例。 此文件可被用作代\n码模板或是学习样例。\n1.5. 编译和链接\n在你能使用你的新写的扩展之前，你还需要做两件事情：使用 Python 系统来编译和链接。如果你使\n用动态加载，这取决于你使用的操作系统的动态加载机制；更多信息请参考编译扩展模块的章节（\n构建 C/C++ 扩展 章节），以及在 Windows 上编译需要的额外信息（ 在 Windows 上构建 C 和 C++\n扩展 章节）。\n如果你不使用动态加载，或者想要让模块永久性的作为Python解释器的一部分，就必须修改配置设\n置，并重新构建解释器。幸运的是在Unix上很简单，只需要把你的文件 ( spammodule.c 为例) 放在\n解压缩源码发行包的 Modules/ 目录下，添加一行到 Modules/Setup.local 来描述你的文件： |  |\n|  | spam spammodule.o |  |\n|  | 然后在顶层目录运行 make 来重新构建解释器。你也可以在 Modules/ 子目录使用 make，但是你必\n须先重建 Makefile 文件，然后运行 'make Makefile' 命令。（你每次修改 Setup 文件都需要这样操\n作。）\n如果你的模块需要额外的链接，这些内容可以列出在配置文件里，举个实例： |  |\n|  | spam spammodule.o -lX11 |  |\n|  | 1.6. 在C中调用Python函数 |  |\n\n迄今为止，我们一直把注意力集中于让Python调用C函数，其实反过来也很有用，就是用C调用\nPython函数。这在回调函数中尤其有用。如果一个C接口使用回调，那么就要实现这个回调机制。\n幸运的是，Python解释器是比较方便回调的，并给标准Python函数提供了标准接口。(这里就不再详\n述解析Python字符串作为输入的方式，如果有兴趣可以参考 Python/pythonmain.c 中的 -c 命令行\n代码。)\n调用Python函数很简单，首先Python程序要传递Python函数对象。应该提供个函数(或其他接口)来\n实现。当调用这个函数时，用全局变量保存Python函数对象的指针，还要调用 (Py_INCREF()) 来增\n加引用计数，当然不用全局变量也没什么关系。举个例子，如下函数可能是模块定义的一部分：\nstatic PyObject *my_callback = NULL;\nstatic PyObject *\nmy_set_callback(PyObject *dummy, PyObject *args)\n{\nPyObject *result = NULL;\nPyObject *temp;\nif (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\nif (!PyCallable_Check(temp)) {\nPyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\nreturn NULL;\n}\nPy_XINCREF(temp); /* 添加一个指向新回调的引用 */\nPy_XDECREF(my_callback); /* 丢弃之前的回调 */\nmy_callback = temp; /* 记住新的回调 */\n/* 返回 \"None\" 的样例 */\nPy_INCREF(Py_None);\nresult = Py_None;\n}\nreturn result;\n}\n此函数必须使用 METH_VARARGS 旗标注册到解释器；这将在 模块方法表和初始化函数 一节中详细描\n述。 PyArg_ParseTuple() 函数及其参数的文档见 提取扩展函数的参数 一节。\nPy_XINCREF() 和 Py_XDECREF() 这两个宏可增加/减少一个对象的引用计数，并且当存在 NULL 指\n针时仍可保证安全 (但请注意在这个上下文中 temp 将不为 NULL)。 更多相关信息请参考 引用计数\n章节。\n随后，当要调用此函数时，你将调用 C 函数 PyObject_CallObject()。 该函数有两个参数，它们\n都属于指针，指向任意 Python 对象：即 Python 函数，及其参数列表。 参数列表必须总是一个元组\n对象，其长度即参数的个数量。 要不带参数地调用 Python 函数，则传入 NULL 或一个空元组；要带\n一个参数调用它，则传入一个单元组。 Py_BuildValue() 会在其格式字符串包含一对圆括号内的零\n个或多个格式代码时返回一个元组。 例如:\nint arg;\nPyObject *arglist;\nPyObject *result;\n...\narg = 123;\n\n|  | 迄今为止，我们一直把注意力集中于让Python调用C函数，其实反过来也很有用，就是用C调用\nPython函数。这在回调函数中尤其有用。如果一个C接口使用回调，那么就要实现这个回调机制。\n幸运的是，Python解释器是比较方便回调的，并给标准Python函数提供了标准接口。(这里就不再详\n述解析Python字符串作为输入的方式，如果有兴趣可以参考 Python/pythonmain.c 中的 -c 命令行\n代码。)\n调用Python函数很简单，首先Python程序要传递Python函数对象。应该提供个函数(或其他接口)来\n实现。当调用这个函数时，用全局变量保存Python函数对象的指针，还要调用 (Py_INCREF()) 来增\n加引用计数，当然不用全局变量也没什么关系。举个例子，如下函数可能是模块定义的一部分： |  |\n| --- | --- | --- |\n|  | static PyObject *my_callback = NULL;\nstatic PyObject *\nmy_set_callback(PyObject *dummy, PyObject *args)\n{\nPyObject *result = NULL;\nPyObject *temp;\nif (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\nif (!PyCallable_Check(temp)) {\nPyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\nreturn NULL;\n}\nPy_XINCREF(temp); /* 添加一个指向新回调的引用 */\nPy_XDECREF(my_callback); /* 丢弃之前的回调 */\nmy_callback = temp; /* 记住新的回调 */\n/* 返回 \"None\" 的样例 */\nPy_INCREF(Py_None);\nresult = Py_None;\n}\nreturn result;\n} |  |\n|  | 此函数必须使用 METH_VARARGS 旗标注册到解释器；这将在 模块方法表和初始化函数 一节中详细描\n述。 PyArg_ParseTuple() 函数及其参数的文档见 提取扩展函数的参数 一节。\nPy_XINCREF() 和 Py_XDECREF() 这两个宏可增加/减少一个对象的引用计数，并且当存在 NULL 指\n针时仍可保证安全 (但请注意在这个上下文中 temp 将不为 NULL)。 更多相关信息请参考 引用计数\n章节。\n随后，当要调用此函数时，你将调用 C 函数 PyObject_CallObject()。 该函数有两个参数，它们\n都属于指针，指向任意 Python 对象：即 Python 函数，及其参数列表。 参数列表必须总是一个元组\n对象，其长度即参数的个数量。 要不带参数地调用 Python 函数，则传入 NULL 或一个空元组；要带\n一个参数调用它，则传入一个单元组。 Py_BuildValue() 会在其格式字符串包含一对圆括号内的零\n个或多个格式代码时返回一个元组。 例如: |  |\n|  | int arg;\nPyObject *arglist;\nPyObject *result;\n...\narg = 123; |  |\n\n...\n/* 此时将调用回调 */\narglist = Py_BuildValue(\"(i)\", arg);\nresult = PyObject_CallObject(my_callback, arglist);\nPy_DECREF(arglist);\nPyObject_CallObject() 返回Python对象指针，这也是Python函数的返回值。\nPyObject_CallObject() 是一个对其参数 \"引用计数无关\" 的函数。例子中新的元组创建用于参数\n列表，并且在 PyObject_CallObject() 之后立即使用了 Py_DECREF() 。\nPyObject_CallObject() 的返回值总是“新”的：要么是一个新建的对象；要么是已有对象，但增加\n了引用计数。所以除非你想把结果保存在全局变量中，你需要对这个值使用 Py_DECREF()，即使你\n对里面的内容（特别！）不感兴趣。\n但是在你这么做之前，很重要的一点是检查返回值不是 NULL。 如果是的话，Python 函数会终止并\n引发异常。 如果调用 PyObject_CallObject() 的 C 代码是在 Python 中唤起的，它应当立即返回\n一个错误来告知其 Python 调用者，以便解释器能打印栈回溯信息，或者让调用方 Python 代码能处\n理该异常。 如果这无法做到或不合本意，则应当通过调用 PyErr_Clear() 来清除异常。 例如:\nif (result == NULL)\nreturn NULL; /* 回传错误 */\n...使用 result...\nPy_DECREF(result);\n依赖于具体的回调函数，你还要提供一个参数列表到 PyObject_CallObject() 。在某些情况下参数\n列表是由Python程序提供的，通过接口再传到回调函数对象。这样就可以不改变形式直接传递。另\n外一些时候你要构造一个新的元组来传递参数。最简单的方法就是 Py_BuildValue() 函数构造\ntuple。举个例子，你要传递一个事件代码时可以用如下代码:\nPyObject *arglist;\n...\narglist = Py_BuildValue(\"(l)\", eventcode);\nresult = PyObject_CallObject(my_callback, arglist);\nPy_DECREF(arglist);\nif (result == NULL)\nreturn NULL; /* Pass error back */\n/* 可以在此使用 result */\nPy_DECREF(result);\n注意 Py_DECREF(arglist) 所在处会立即调用，在错误检查之前。当然还要注意一些常规的错误，\n比如 Py_BuildValue() 可能会遭遇内存不足等等。\n当你调用函数时还需要注意，用关键字参数调用 PyObject_Call() ，需要支持普通参数和关键字参\n数。有如如上例子中，我们使用 Py_BuildValue() 来构造字典。\nPyObject *dict;\n...\ndict = Py_BuildValue(\"{s:i}\", \"name\", val);\nresult = PyObject_Call(my_callback, NULL, dict);\nPy_DECREF(dict);\nif (result == NULL)\nreturn NULL; /* 回传错误 */\n\n|  | ...\n/* 此时将调用回调 */\narglist = Py_BuildValue(\"(i)\", arg);\nresult = PyObject_CallObject(my_callback, arglist);\nPy_DECREF(arglist); |  |\n| --- | --- | --- |\n|  | PyObject_CallObject() 返回Python对象指针，这也是Python函数的返回值。\nPyObject_CallObject() 是一个对其参数 \"引用计数无关\" 的函数。例子中新的元组创建用于参数\n列表，并且在 PyObject_CallObject() 之后立即使用了 Py_DECREF() 。\nPyObject_CallObject() 的返回值总是“新”的：要么是一个新建的对象；要么是已有对象，但增加\n了引用计数。所以除非你想把结果保存在全局变量中，你需要对这个值使用 Py_DECREF()，即使你\n对里面的内容（特别！）不感兴趣。\n但是在你这么做之前，很重要的一点是检查返回值不是 NULL。 如果是的话，Python 函数会终止并\n引发异常。 如果调用 PyObject_CallObject() 的 C 代码是在 Python 中唤起的，它应当立即返回\n一个错误来告知其 Python 调用者，以便解释器能打印栈回溯信息，或者让调用方 Python 代码能处\n理该异常。 如果这无法做到或不合本意，则应当通过调用 PyErr_Clear() 来清除异常。 例如: |  |\n|  | if (result == NULL)\nreturn NULL; /* 回传错误 */\n...使用 result...\nPy_DECREF(result); |  |\n|  | 依赖于具体的回调函数，你还要提供一个参数列表到 PyObject_CallObject() 。在某些情况下参数\n列表是由Python程序提供的，通过接口再传到回调函数对象。这样就可以不改变形式直接传递。另\n外一些时候你要构造一个新的元组来传递参数。最简单的方法就是 Py_BuildValue() 函数构造\ntuple。举个例子，你要传递一个事件代码时可以用如下代码: |  |\n|  | PyObject *arglist;\n...\narglist = Py_BuildValue(\"(l)\", eventcode);\nresult = PyObject_CallObject(my_callback, arglist);\nPy_DECREF(arglist);\nif (result == NULL)\nreturn NULL; /* Pass error back */\n/* 可以在此使用 result */\nPy_DECREF(result); |  |\n|  | 注意 Py_DECREF(arglist) 所在处会立即调用，在错误检查之前。当然还要注意一些常规的错误，\n比如 Py_BuildValue() 可能会遭遇内存不足等等。\n当你调用函数时还需要注意，用关键字参数调用 PyObject_Call() ，需要支持普通参数和关键字参\n数。有如如上例子中，我们使用 Py_BuildValue() 来构造字典。 |  |\n|  | PyObject *dict;\n...\ndict = Py_BuildValue(\"{s:i}\", \"name\", val);\nresult = PyObject_Call(my_callback, NULL, dict);\nPy_DECREF(dict);\nif (result == NULL)\nreturn NULL; /* 回传错误 */ |  |\n\n/* 可以在此使用 result */\nPy_DECREF(result);\n1.7. 提取扩展函数的参数\n函数 PyArg_ParseTuple() 的声明如下：\nint PyArg_ParseTuple(PyObject *arg, const char *format, ...);\n参数 arg 必须是一个元组对象，包含从 Python 传递给 C 函数的参数列表。format 参数必须是一个\n格式字符串，语法请参考 Python C/API 手册中的 解析参数并构建值变量。剩余参数是各个变量的地\n址，类型要与格式字符串对应。\n注意 PyArg_ParseTuple() 会检测他需要的Python参数类型，却无法检测传递给他的C变量地址，\n如果这里出错了，可能会在内存中随机写入东西，小心。\n注意任何由调用者提供的 Python 对象引用是 借来的 引用；不要递减它们的引用计数！\n一些调用的例子：\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\nint ok;\nint i, j;\nlong k, l;\nconst char *s;\nPy_ssize_t size;\nok = PyArg_ParseTuple(args, \"\"); /* 无参数 */\n/* Python 调用: f() */\nok = PyArg_ParseTuple(args, \"s\", &s); /* 一个字符串 */\n/* 可能的 Python 调用: f('whoops!') */\nok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* 两个长整型和一个字符串 */\n/* 可能的 Python 调用: f(1, 2, 'three') */\nok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n/* 一对整数和一个字符串，其大小也将被返回 */\n/* 可能的 Python 调用: f((1, 2), 'three') */\n{\nconst char *file;\nconst char *mode = \"r\";\nint bufsize = 0;\nok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n/* 一个字符串，并可选择传入另一个字符串和一个整数 */\n/* 可能的 Python 调用:\nf('spam')\nf('spam', 'w')\n\n|  | /* 可以在此使用 result */\nPy_DECREF(result); |  |\n| --- | --- | --- |\n|  | 1.7. 提取扩展函数的参数\n函数 PyArg_ParseTuple() 的声明如下： |  |\n|  | int PyArg_ParseTuple(PyObject *arg, const char *format, ...); |  |\n|  | 参数 arg 必须是一个元组对象，包含从 Python 传递给 C 函数的参数列表。format 参数必须是一个\n格式字符串，语法请参考 Python C/API 手册中的 解析参数并构建值变量。剩余参数是各个变量的地\n址，类型要与格式字符串对应。\n注意 PyArg_ParseTuple() 会检测他需要的Python参数类型，却无法检测传递给他的C变量地址，\n如果这里出错了，可能会在内存中随机写入东西，小心。\n注意任何由调用者提供的 Python 对象引用是 借来的 引用；不要递减它们的引用计数！\n一些调用的例子： |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h> |  |\n|  |  |  |\n|  | int ok;\nint i, j;\nlong k, l;\nconst char *s;\nPy_ssize_t size;\nok = PyArg_ParseTuple(args, \"\"); /* 无参数 */\n/* Python 调用: f() */ |  |\n|  |  |  |\n|  | ok = PyArg_ParseTuple(args, \"s\", &s); /* 一个字符串 */\n/* 可能的 Python 调用: f('whoops!') */ |  |\n|  |  |  |\n|  | ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* 两个长整型和一个字符串 */\n/* 可能的 Python 调用: f(1, 2, 'three') */ |  |\n|  |  |  |\n|  | ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n/* 一对整数和一个字符串，其大小也将被返回 */\n/* 可能的 Python 调用: f((1, 2), 'three') */ |  |\n|  |  |  |\n|  | {\nconst char *file;\nconst char *mode = \"r\";\nint bufsize = 0;\nok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n/* 一个字符串，并可选择传入另一个字符串和一个整数 */\n/* 可能的 Python 调用:\nf('spam')\nf('spam', 'w') |  |\n\nf('spam', 'wb', 100000) */\n}\n{\nint left, top, right, bottom, h, v;\nok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n&left, &top, &right, &bottom, &h, &v);\n/* 一个矩型和一个点 */\n/* 可能的 Python 调用:\nf(((0, 0), (400, 300)), (10, 10)) */\n}\n{\nPy_complex c;\nok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n/* 一个复数，并提供一个函数名用于错误处理 */\n/* Possible Python call: myfunction(1+2j) */\n}\n1.8. 给扩展函数的关键字参数\n函数 PyArg_ParseTupleAndKeywords() 声明如下：\nint PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\nconst char *format, char * const *kwlist, ...);\narg 与 format 形参与 PyArg_ParseTuple() 函数所定义的一致。 kwdict 形参是作为第三个参数从\nPython 运行时接收的关键字字典。 kwlist 形参是以 NULL 结尾的字符串列表，它被用来标识形参；\n名称从左至右与来自 format 的类型信息相匹配。 如果执行成功，\nPyArg_ParseTupleAndKeywords() 会返回真值，否则返回假值并引发一个适当的异常。\n备注: 嵌套的元组在使用关键字参数时无法生效，不在 kwlist 中的关键字参数会导致 TypeError\n异常。\n如下例子是使用关键字参数的例子模块，作者是 Geoff Philbrick (philbrick@hks.com):\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\nstatic PyObject *\nkeywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n{\nint voltage;\nconst char *state = \"a stiff\";\nconst char *action = \"voom\";\nconst char *type = \"Norwegian Blue\";\nstatic char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};\nif (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n&voltage, &state, &action, &type))\nreturn NULL;\n\n|  | f('spam', 'wb', 100000) */\n} |  |\n| --- | --- | --- |\n|  |  |  |\n|  | {\nint left, top, right, bottom, h, v;\nok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n&left, &top, &right, &bottom, &h, &v);\n/* 一个矩型和一个点 */\n/* 可能的 Python 调用:\nf(((0, 0), (400, 300)), (10, 10)) */\n} |  |\n|  |  |  |\n|  | {\nPy_complex c;\nok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n/* 一个复数，并提供一个函数名用于错误处理 */\n/* Possible Python call: myfunction(1+2j) */\n} |  |\n|  | 1.8. 给扩展函数的关键字参数\n函数 PyArg_ParseTupleAndKeywords() 声明如下： |  |\n|  | int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\nconst char *format, char * const *kwlist, ...); |  |\n|  | arg 与 format 形参与 PyArg_ParseTuple() 函数所定义的一致。 kwdict 形参是作为第三个参数从\nPython 运行时接收的关键字字典。 kwlist 形参是以 NULL 结尾的字符串列表，它被用来标识形参；\n名称从左至右与来自 format 的类型信息相匹配。 如果执行成功，\nPyArg_ParseTupleAndKeywords() 会返回真值，否则返回假值并引发一个适当的异常。 |  |\n|  | 备注: 嵌套的元组在使用关键字参数时无法生效，不在 kwlist 中的关键字参数会导致 TypeError\n异常。 |  |\n|  | 如下例子是使用关键字参数的例子模块，作者是 Geoff Philbrick (philbrick@hks.com): |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\nstatic PyObject *\nkeywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n{\nint voltage;\nconst char *state = \"a stiff\";\nconst char *action = \"voom\";\nconst char *type = \"Norwegian Blue\";\nstatic char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};\nif (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n&voltage, &state, &action, &type))\nreturn NULL; |  |\n\nprintf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",\naction, voltage);\nprintf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\nPy_RETURN_NONE;\n}\nstatic PyMethodDef keywdarg_methods[] = {\n/* 函数的转换是必要的因为 PyCFunction 值\n* 仅接受两个 PyObject* 形参，而 keywdarg_parrot()\n* 接受三个。\n*/\n{\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | METH_KE\n\"Print a lovely skit to standard output.\"},\n{NULL, NULL, 0, NULL} /* sentinel */\n};\nstatic struct PyModuleDef keywdarg_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"keywdarg\",\n.m_size = 0,\n.m_methods = keywdarg_methods,\n};\nPyMODINIT_FUNC\nPyInit_keywdarg(void)\n{\nreturn PyModuleDef_Init(&keywdarg_module);\n}\n1.9. 构造任意值\n这个函数与 PyArg_ParseTuple() 很相似，声明如下：\nPyObject *Py_BuildValue(const char *format, ...);\n接受一个格式字符串，与 PyArg_ParseTuple() 相同，但是参数必须是原变量的地址指针(输入给函\n数，而非输出)。最终返回一个Python对象适合于返回C函数调用给Python代码。\n一个与 PyArg_ParseTuple() 的不同是，后面可能需要的要求返回一个元组(Python参数里诶包总是\n在内部描述为元组)，比如用于传递给其他Python函数以参数。 Py_BuildValue() 并不总是生成元\n组，在多于1个格式字符串时会生成元组，而如果格式字符串为空则返回 None ，一个参数则直接返\n回该参数的对象。如果要求强制生成一个长度为0的元组，或包含一个元素的元组，需要在格式字符\n串中加上括号。\n例子(左侧是调用，右侧是Python值结果)：\nPy_BuildValue(\"\") None\nPy_BuildValue(\"i\", 123) 123\nPy_BuildValue(\"iii\", 123, 456, 789) (123, 456, 789)\nPy_BuildValue(\"s\", \"hello\") 'hello'\nPy_BuildValue(\"y\", \"hello\") b'hello'\nPy_BuildValue(\"ss\", \"hello\", \"world\") ('hello', 'world')\nPy_BuildValue(\"s#\", \"hello\", 4) 'hell'\nPy_BuildValue(\"y#\", \"hello\", 4) b'hell'\n\n|  | printf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",\naction, voltage);\nprintf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\nPy_RETURN_NONE;\n}\nstatic PyMethodDef keywdarg_methods[] = {\n/* 函数的转换是必要的因为 PyCFunction 值\n* 仅接受两个 PyObject* 形参，而 keywdarg_parrot()\n* 接受三个。\n*/\n{\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | METH_KE\n\"Print a lovely skit to standard output.\"},\n{NULL, NULL, 0, NULL} /* sentinel */\n};\nstatic struct PyModuleDef keywdarg_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"keywdarg\",\n.m_size = 0,\n.m_methods = keywdarg_methods,\n};\nPyMODINIT_FUNC\nPyInit_keywdarg(void)\n{\nreturn PyModuleDef_Init(&keywdarg_module);\n} |  |  |\n| --- | --- | --- | --- |\n|  | 1.9. 构造任意值\n这个函数与 PyArg_ParseTuple() 很相似，声明如下： |  |  |\n|  | PyObject *Py_BuildValue(const char *format, ...); |  |  |\n|  | 接受一个格式字符串，与 PyArg_ParseTuple() 相同，但是参数必须是原变量的地址指针(输入给函\n数，而非输出)。最终返回一个Python对象适合于返回C函数调用给Python代码。\n一个与 PyArg_ParseTuple() 的不同是，后面可能需要的要求返回一个元组(Python参数里诶包总是\n在内部描述为元组)，比如用于传递给其他Python函数以参数。 Py_BuildValue() 并不总是生成元\n组，在多于1个格式字符串时会生成元组，而如果格式字符串为空则返回 None ，一个参数则直接返\n回该参数的对象。如果要求强制生成一个长度为0的元组，或包含一个元素的元组，需要在格式字符\n串中加上括号。 |  |  |\n|  | 例子(左侧是调用，右侧是Python值结果)： |  |  |\n|  | Py_BuildValue(\"\") None\nPy_BuildValue(\"i\", 123) 123\nPy_BuildValue(\"iii\", 123, 456, 789) (123, 456, 789)\nPy_BuildValue(\"s\", \"hello\") 'hello'\nPy_BuildValue(\"y\", \"hello\") b'hello'\nPy_BuildValue(\"ss\", \"hello\", \"world\") ('hello', 'world')\nPy_BuildValue(\"s#\", \"hello\", 4) 'hell'\nPy_BuildValue(\"y#\", \"hello\", 4) b'hell' |  |  |\n\nPy_BuildValue(\"()\") ()\nPy_BuildValue(\"(i)\", 123) (123,)\nPy_BuildValue(\"(ii)\", 123, 456) (123, 456)\nPy_BuildValue(\"(i,i)\", 123, 456) (123, 456)\nPy_BuildValue(\"[i,i]\", 123, 456) [123, 456]\nPy_BuildValue(\"{s:i,s:i}\",\n\"abc\", 123, \"def\", 456) {'abc': 123, 'def': 456}\nPy_BuildValue(\"((ii)(ii)) (ii)\",\n1, 2, 3, 4, 5, 6) (((1, 2), (3, 4)), (5, 6))\n1.10. 引用计数\n在C/C++语言中，程序员负责动态分配和回收堆heap当中的内存。在C里，通过函数 malloc() 和\nfree() 来完成。在C++里是操作 new 和 delete 来实现相同的功能。\n每个使用 malloc() 分配的内存块最终都应当通过恰好一次对 free() 的调用返回到可用内存池中。\n调用 free() 的时机非常重要。 如果一个块地址被遗忘而没有为它执行 free() 调用，它所占用的\n内存在程序终结之前将无法被重新使用。 这就称为 内存泄漏。 另一方面，如果程序为一个块地址调\n用了 free() 然后却继续使用该内存块，它将与通过另一个 malloc() 调用对该内存块的重新使用产\n生冲突。 这就称为 使用已释放的内存。 它所造成的后果与引用未初始化数据一样糟糕 --- 核心转\n储、错误结果、意外崩溃等等。\n内存泄露往往发生在一些并不常见的代码流程上面。比如一个函数申请了内存以后，做了些计算，\n然后释放内存块。现在一些对函数的修改可能增加对计算的测试并检测错误条件，然后过早的从函\n数返回了。这很容易忘记在退出前释放内存，特别是后期修改的代码。这种内存泄漏，一旦引入，\n通常很长时间都难以检测到，错误退出被调用的频度较低，而现代电脑又有非常巨大的虚拟内存，\n所以泄漏仅在长期运行或频繁调用泄漏函数时才会变得明显。因此，有必要避免内存泄漏，通过代\n码规范会策略来最小化此类错误。\nPython通过 malloc() 和 free() 包含大量的内存分配和释放，同样需要避免内存泄漏和野指针。\n他选择的方法就是 引用计数 。其原理比较简单：每个对象都包含一个计数器，计数器的增减与对象\n引用的增减直接相关，当引用计数为0时，表示对象已经没有存在的意义了，对象就可以删除了。\n另一个叫法是 自动垃圾回收 。(有时引用计数也被看作是垃圾回收策略，于是这里的\"自动\"用以区分\n两者)。自动垃圾回收的优点是用户不需要明确的调用 free() 。(另一个优点是改善速度或内存使\n用，然而这并不难)。缺点是对C，没有可移植的自动垃圾回收器，而引用计数则可以可移植的实现\n(只要 malloc() 和 free() 函数是可用的，这也是C标准担保的)。也许以后有一天会出现可移植的\n自动垃圾回收器，但在此前我们必须与引用计数一起工作。\nPython使用传统的引用计数实现，也提供了循环监测器，用以检测引用循环。这使得应用无需担心\n直接或间接的创建了循环引用，这是引用计数垃圾收集的一个弱点。引用循环是对象(可能直接)的引\n用了本身，所以循环中的每个对象的引用计数都不是0。典型的引用计数实现无法回收处于引用循环\n中的对象，或者被循环所引用的对象，哪怕没有循环以外的引用了。\n循环检测器能够检测垃圾回收循环并能回收它们。 gc 模块提供了一种运行该检测器的方式\n(collect() 函数)，以及多个配置接口和在运行时禁用该检测器的功能。\n1.10.1. Python中的引用计数\n\n|  | Py_BuildValue(\"()\") ()\nPy_BuildValue(\"(i)\", 123) (123,)\nPy_BuildValue(\"(ii)\", 123, 456) (123, 456)\nPy_BuildValue(\"(i,i)\", 123, 456) (123, 456)\nPy_BuildValue(\"[i,i]\", 123, 456) [123, 456]\nPy_BuildValue(\"{s:i,s:i}\",\n\"abc\", 123, \"def\", 456) {'abc': 123, 'def': 456}\nPy_BuildValue(\"((ii)(ii)) (ii)\",\n1, 2, 3, 4, 5, 6) (((1, 2), (3, 4)), (5, 6)) |  |\n| --- | --- | --- |\n|  | 1.10. 引用计数\n在C/C++语言中，程序员负责动态分配和回收堆heap当中的内存。在C里，通过函数 malloc() 和\nfree() 来完成。在C++里是操作 new 和 delete 来实现相同的功能。\n每个使用 malloc() 分配的内存块最终都应当通过恰好一次对 free() 的调用返回到可用内存池中。\n调用 free() 的时机非常重要。 如果一个块地址被遗忘而没有为它执行 free() 调用，它所占用的\n内存在程序终结之前将无法被重新使用。 这就称为 内存泄漏。 另一方面，如果程序为一个块地址调\n用了 free() 然后却继续使用该内存块，它将与通过另一个 malloc() 调用对该内存块的重新使用产\n生冲突。 这就称为 使用已释放的内存。 它所造成的后果与引用未初始化数据一样糟糕 --- 核心转\n储、错误结果、意外崩溃等等。\n内存泄露往往发生在一些并不常见的代码流程上面。比如一个函数申请了内存以后，做了些计算，\n然后释放内存块。现在一些对函数的修改可能增加对计算的测试并检测错误条件，然后过早的从函\n数返回了。这很容易忘记在退出前释放内存，特别是后期修改的代码。这种内存泄漏，一旦引入，\n通常很长时间都难以检测到，错误退出被调用的频度较低，而现代电脑又有非常巨大的虚拟内存，\n所以泄漏仅在长期运行或频繁调用泄漏函数时才会变得明显。因此，有必要避免内存泄漏，通过代\n码规范会策略来最小化此类错误。\nPython通过 malloc() 和 free() 包含大量的内存分配和释放，同样需要避免内存泄漏和野指针。\n他选择的方法就是 引用计数 。其原理比较简单：每个对象都包含一个计数器，计数器的增减与对象\n引用的增减直接相关，当引用计数为0时，表示对象已经没有存在的意义了，对象就可以删除了。\n另一个叫法是 自动垃圾回收 。(有时引用计数也被看作是垃圾回收策略，于是这里的\"自动\"用以区分\n两者)。自动垃圾回收的优点是用户不需要明确的调用 free() 。(另一个优点是改善速度或内存使\n用，然而这并不难)。缺点是对C，没有可移植的自动垃圾回收器，而引用计数则可以可移植的实现\n(只要 malloc() 和 free() 函数是可用的，这也是C标准担保的)。也许以后有一天会出现可移植的\n自动垃圾回收器，但在此前我们必须与引用计数一起工作。\nPython使用传统的引用计数实现，也提供了循环监测器，用以检测引用循环。这使得应用无需担心\n直接或间接的创建了循环引用，这是引用计数垃圾收集的一个弱点。引用循环是对象(可能直接)的引\n用了本身，所以循环中的每个对象的引用计数都不是0。典型的引用计数实现无法回收处于引用循环\n中的对象，或者被循环所引用的对象，哪怕没有循环以外的引用了。\n循环检测器能够检测垃圾回收循环并能回收它们。 gc 模块提供了一种运行该检测器的方式\n(collect() 函数)，以及多个配置接口和在运行时禁用该检测器的功能。\n1.10.1. Python中的引用计数 |  |\n\n有两个宏 Py_INCREF(x) 和 Py_DECREF(x) ，会处理引用计数的增减。 Py_DECREF() 也会在引用计\n数到达0时释放对象。为了灵活，并不会直接调用 free() ，而是通过对象的 类型对象 的函数指针\n来调用。为了这个目的(或其他的)，每个对象同时包含一个指向自身类型对象的指针。\n最大的问题依旧：何时使用 Py_INCREF(x) 和 Py_DECREF(x) ？我们首先引入一些概念。没有人\"拥\n有\"一个对象，你可以 拥有一个引用 到一个对象。一个对象的引用计数定义为拥有引用的数量。引\n用的拥有者有责任调用 Py_DECREF() ，在引用不再需要时。引用的拥有关系可以被传递。有三种办\n法来处置拥有的引用：传递、存储、调用 Py_DECREF() 。忘记处置一个拥有的引用会导致内存泄\n漏。\n还可以 借用 [2] 一个对象的引用。借用的引用不应该调用 Py_DECREF() 。借用者必须确保不能持有\n对象超过拥有者借出的时间。在拥有者处置对象后使用借用的引用是有风险的，应该完全避免 [3] 。\n借用相对于引用的优点是你无需担心整条路径上代码的引用，或者说，通过借用你无需担心内存泄\n漏的风险。借用的缺点是一些看起来正确代码上的借用可能会在拥有者处置后使用对象。\n借用可以变为拥有引用，通过调用 Py_INCREF()。 这不会影响已经借出的拥有者的状态。 这会创建\n一个新的拥有引用，并给予完全的拥有者责任（新的拥有者必须恰当的处置引用，就像之前的拥有\n者那样）。\n1.10.2. 拥有规则\n当一个对象引用传递进出一个函数时，函数的接口应该指定拥有关系的传递是否包含引用。\n大多数函数返回一个对象的引用，并传递引用拥有关系。通常，所有创建对象的函数，例如\nPyLong_FromLong() 和 Py_BuildValue() ，会传递拥有关系给接收者。即便是对象不是真正新\n的，你仍然可以获得对象的新引用。一个实例是 PyLong_FromLong() 维护了一个流行值的缓存，并\n可以返回已缓存项目的新引用。\n很多另一个对象提取对象的函数，也会传递引用关系，例如 PyObject_GetAttrString() 。这里的\n情况不够清晰，一些不太常用的例程是例外的 PyTuple_GetItem() ， PyList_GetItem() ，\nPyDict_GetItem() ， PyDict_GetItemString() 都是返回从元组、列表、字典里借用的引用。\n函数 PyImport_AddModule() 也会返回借用的引用，哪怕可能会返回创建的对象：这个可能因为一\n个拥有的引用对象是存储在 sys.modules 里。\n当你传递一个对象引用到另一个函数时，通常函数是借用出去的。如果需要存储，就使用\nPy_INCREF() 来变成独立的拥有者。这个规则有两个重要的例外： PyTuple_SetItem() 和\nPyList_SetItem() 。这些函数接受传递来的引用关系，哪怕会失败！(注意 PyDict_SetItem() 及\n其同类不会接受引用关系，他们是\"正常的\")。\n当一个C函数被Python调用时，会从调用方传来的参数借用引用。调用者拥有对象的引用，所以借用\n的引用生命周期可以保证到函数返回。只要当借用的引用需要存储或传递时，就必须转换为拥有的\n引用，通过调用 Py_INCREF() 。\nPython调用从C函数返回的对象引用时必须是拥有的引用---拥有关系被从函数传递给调用者。\n1.10.3. 危险的薄冰\n\n|  | 有两个宏 Py_INCREF(x) 和 Py_DECREF(x) ，会处理引用计数的增减。 Py_DECREF() 也会在引用计\n数到达0时释放对象。为了灵活，并不会直接调用 free() ，而是通过对象的 类型对象 的函数指针\n来调用。为了这个目的(或其他的)，每个对象同时包含一个指向自身类型对象的指针。\n最大的问题依旧：何时使用 Py_INCREF(x) 和 Py_DECREF(x) ？我们首先引入一些概念。没有人\"拥\n有\"一个对象，你可以 拥有一个引用 到一个对象。一个对象的引用计数定义为拥有引用的数量。引\n用的拥有者有责任调用 Py_DECREF() ，在引用不再需要时。引用的拥有关系可以被传递。有三种办\n法来处置拥有的引用：传递、存储、调用 Py_DECREF() 。忘记处置一个拥有的引用会导致内存泄\n漏。\n还可以 借用 [2] 一个对象的引用。借用的引用不应该调用 Py_DECREF() 。借用者必须确保不能持有\n对象超过拥有者借出的时间。在拥有者处置对象后使用借用的引用是有风险的，应该完全避免 [3] 。\n借用相对于引用的优点是你无需担心整条路径上代码的引用，或者说，通过借用你无需担心内存泄\n漏的风险。借用的缺点是一些看起来正确代码上的借用可能会在拥有者处置后使用对象。\n借用可以变为拥有引用，通过调用 Py_INCREF()。 这不会影响已经借出的拥有者的状态。 这会创建\n一个新的拥有引用，并给予完全的拥有者责任（新的拥有者必须恰当的处置引用，就像之前的拥有\n者那样）。\n1.10.2. 拥有规则\n当一个对象引用传递进出一个函数时，函数的接口应该指定拥有关系的传递是否包含引用。\n大多数函数返回一个对象的引用，并传递引用拥有关系。通常，所有创建对象的函数，例如\nPyLong_FromLong() 和 Py_BuildValue() ，会传递拥有关系给接收者。即便是对象不是真正新\n的，你仍然可以获得对象的新引用。一个实例是 PyLong_FromLong() 维护了一个流行值的缓存，并\n可以返回已缓存项目的新引用。\n很多另一个对象提取对象的函数，也会传递引用关系，例如 PyObject_GetAttrString() 。这里的\n情况不够清晰，一些不太常用的例程是例外的 PyTuple_GetItem() ， PyList_GetItem() ，\nPyDict_GetItem() ， PyDict_GetItemString() 都是返回从元组、列表、字典里借用的引用。\n函数 PyImport_AddModule() 也会返回借用的引用，哪怕可能会返回创建的对象：这个可能因为一\n个拥有的引用对象是存储在 sys.modules 里。\n当你传递一个对象引用到另一个函数时，通常函数是借用出去的。如果需要存储，就使用\nPy_INCREF() 来变成独立的拥有者。这个规则有两个重要的例外： PyTuple_SetItem() 和\nPyList_SetItem() 。这些函数接受传递来的引用关系，哪怕会失败！(注意 PyDict_SetItem() 及\n其同类不会接受引用关系，他们是\"正常的\")。\n当一个C函数被Python调用时，会从调用方传来的参数借用引用。调用者拥有对象的引用，所以借用\n的引用生命周期可以保证到函数返回。只要当借用的引用需要存储或传递时，就必须转换为拥有的\n引用，通过调用 Py_INCREF() 。\nPython调用从C函数返回的对象引用时必须是拥有的引用---拥有关系被从函数传递给调用者。\n1.10.3. 危险的薄冰 |  |\n| --- | --- | --- |\n\n有少数情况下，借用的引用看起来无害，但却可能导致问题。这通常是因为解释器的隐式调用，并\n可能导致引用拥有者处置这个引用。\n首先需要特别注意的情况是使用 Py_DECREF() 到一个无关对象，而这个对象的引用是借用自一个列\n表的元素。举个实例：\nvoid\nbug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPyList_SetItem(list, 1, PyLong_FromLong(0L));\nPyObject_Print(item, stdout, 0); /* BUG! */\n}\n这个函数首先借用一个引用 list[0] ，然后替换 list[1] 为值 0 ，最后打印借用的引用。看起来\n无害是吧，但却不是。\n让我们跟随控制流进入 PyList_SetItem()。 该列表拥有对其全部条目的引用，因此当条目 1 被替\n换时，它必须丢弃原来的条目 1。 现在让我们假定原来的条目 1 是某个用户自定义类的实例，并让\n我们假定该类定义了 __del__() 方法。 如果该类实例的引用计数为 1，丢弃它将会调用其\n__del__() 方法。 在内部，PyList_SetItem() 会调用被替换条目的 Py_DECREF()，这将唤起被替\n换条目的对应的 tp_dealloc 函数。 在撤销分配期间，tp_dealloc 会调用 tp_finalize，它被映\n射到用于类实例的 __del__() 方法 (参见 PEP 442)。 以上整个过程是在 PyList_SetItem() 调用内\n部同步发生的。\n由于它是用 Python 编写的，因此 __del__() 方法可以执行任意 Python 代码。 它是否可以使\nbug() 中对 item 的引用失效呢？ 当然可以！ 假定传入 bug() 的列表可以被 __del__() 方法访\n问，它就可以执行一条语句实现 del list[0] 的效果，假定这是对该对象的最后一次引用，它就会\n释放与之相关联的内存，从而使 item 失效。\n解决方法是，当你知道了问题的根源，就容易了：临时增加引用计数。正确版本的函数代码如下：\nvoid\nno_bug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPy_INCREF(item);\nPyList_SetItem(list, 1, PyLong_FromLong(0L));\nPyObject_Print(item, stdout, 0);\nPy_DECREF(item);\n}\n这是一个真实的故事。 一个较旧版本的 Python 曾经包含此问题的变化形式，有人在 C 语言调试器\n中花费了大量时间，才弄明白为什么他的 __del__() 方法会失败……\n有关借入引用的问题的第二种情况是涉及线程的变种。 通常， Python 解释器中的多个线程不会相\n互影响，因为有一个 全局锁 在保护 Python 的整个对象空间。 不过，有可能使用宏\nPy_BEGIN_ALLOW_THREADS 来临时释放这个锁，并使用 Py_END_ALLOW_THREADS 来重新获取它。 这\n\n|  | 有少数情况下，借用的引用看起来无害，但却可能导致问题。这通常是因为解释器的隐式调用，并\n可能导致引用拥有者处置这个引用。\n首先需要特别注意的情况是使用 Py_DECREF() 到一个无关对象，而这个对象的引用是借用自一个列\n表的元素。举个实例： |  |\n| --- | --- | --- |\n|  | void\nbug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPyList_SetItem(list, 1, PyLong_FromLong(0L));\nPyObject_Print(item, stdout, 0); /* BUG! */\n} |  |\n|  | 这个函数首先借用一个引用 list[0] ，然后替换 list[1] 为值 0 ，最后打印借用的引用。看起来\n无害是吧，但却不是。\n让我们跟随控制流进入 PyList_SetItem()。 该列表拥有对其全部条目的引用，因此当条目 1 被替\n换时，它必须丢弃原来的条目 1。 现在让我们假定原来的条目 1 是某个用户自定义类的实例，并让\n我们假定该类定义了 __del__() 方法。 如果该类实例的引用计数为 1，丢弃它将会调用其\n__del__() 方法。 在内部，PyList_SetItem() 会调用被替换条目的 Py_DECREF()，这将唤起被替\n换条目的对应的 tp_dealloc 函数。 在撤销分配期间，tp_dealloc 会调用 tp_finalize，它被映\n射到用于类实例的 __del__() 方法 (参见 PEP 442)。 以上整个过程是在 PyList_SetItem() 调用内\n部同步发生的。\n由于它是用 Python 编写的，因此 __del__() 方法可以执行任意 Python 代码。 它是否可以使\nbug() 中对 item 的引用失效呢？ 当然可以！ 假定传入 bug() 的列表可以被 __del__() 方法访\n问，它就可以执行一条语句实现 del list[0] 的效果，假定这是对该对象的最后一次引用，它就会\n释放与之相关联的内存，从而使 item 失效。\n解决方法是，当你知道了问题的根源，就容易了：临时增加引用计数。正确版本的函数代码如下： |  |\n|  | void\nno_bug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPy_INCREF(item);\nPyList_SetItem(list, 1, PyLong_FromLong(0L));\nPyObject_Print(item, stdout, 0);\nPy_DECREF(item);\n} |  |\n|  | 这是一个真实的故事。 一个较旧版本的 Python 曾经包含此问题的变化形式，有人在 C 语言调试器\n中花费了大量时间，才弄明白为什么他的 __del__() 方法会失败……\n有关借入引用的问题的第二种情况是涉及线程的变种。 通常， Python 解释器中的多个线程不会相\n互影响，因为有一个 全局锁 在保护 Python 的整个对象空间。 不过，有可能使用宏\nPy_BEGIN_ALLOW_THREADS 来临时释放这个锁，并使用 Py_END_ALLOW_THREADS 来重新获取它。 这 |  |\n\n在阻塞型 I/O 调用操作中很常见，可以让其他线程在等待 I/O 结束期间使用处理器。 显然，下面的\n函数与之前那个存在相同的问题:\nvoid\nbug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPy_BEGIN_ALLOW_THREADS\n...some blocking I/O call...\nPy_END_ALLOW_THREADS\nPyObject_Print(item, stdout, 0); /* BUG! */\n}\n1.10.4. NULL指针\n通常，接受对象引用作为参数的函数不希望你传给它们 NULL 指针，并且当你这样做时将会转储核心\n（或在以后导致核心转储）。 返回对象引用的函数通常只在要指明发生了异常时才返回 NULL。 不\n检测 NULL 参数的原因在于这些函数经常要将它们所接收的对象传给其他函数 --- 如果每个函数都检\n测 NULL，将会导致大量的冗余检测而使代码运行得更缓慢。\n更好的做法是仅在“源头”上检测 NULL，即在接收到一个可能为 NULL 的指针，例如来自 malloc()\n或是一个可能引发异常的函数的时候。\nPy_INCREF() 和 Py_DECREF() 等宏不会检测 NULL 指针 --- 但是，它们的变种 Py_XINCREF() 和\nPy_XDECREF() 则会检测。\n用于检测特定对象类型的宏 (Pytype_Check()) 不会检测 NULL 指针 --- 同样地，有大量代码会连续\n调用这些宏来测试一个对象是否为几种不同预期类型之一，这将会生成冗余的测试。 不存在带有\nNULL 检测的变体。\nC 函数调用机制会保证传给 C 函数的参数列表 (本示例中为 args) 绝不会为 NULL --- 实际上它会保\n证其总是为一个元组 [4]。\n任何时候将 NULL 指针“泄露”给 Python 用户都会是个严重的错误。\n1.11. 在C++中编写扩展\n还可以在C++中编写扩展模块，只是有些限制。如果主程序(Python解释器)是使用C编译器来编译和\n链接的，全局或静态对象的构造器就不能使用。而如果是C++编译器来链接的就没有这个问题。函\n数会被Python解释器调用(通常就是模块初始化函数)必须声明为 extern \"C\" 。而是否在 extern\n\"C\" {...} 里包含Python头文件则不是那么重要，因为如果定义了符号 __cplusplus 则已经是这么\n声明的了(所有现代C++编译器都会定义这个符号)。\n1.12. 给扩展模块提供C API\n很多扩展模块提供了新的函数和类型供Python使用，但有时扩展模块里的代码也可以被其他扩展模\n块使用。例如，一个扩展模块可以实现一个类型 \"collection\" 看起来是没有顺序的。就像是Python列\n表类型，拥有C API允许扩展模块来创建和维护列表，这个新的集合类型可以有一堆C函数用于给其\n他扩展模块直接使用。\n\n|  |  | 在阻塞型 I/O 调用操作中很常见，可以让其他线程在等待 I/O 结束期间使用处理器。 显然，下面的\n函数与之前那个存在相同的问题: |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | void\nbug(PyObject *list)\n{\nPyObject *item = PyList_GetItem(list, 0);\nPy_BEGIN_ALLOW_THREADS\n...some blocking I/O call...\nPy_END_ALLOW_THREADS\nPyObject_Print(item, stdout, 0); /* BUG! */\n} |  |  |  |\n|  |  | 1.10.4. NULL指针\n通常，接受对象引用作为参数的函数不希望你传给它们 NULL 指针，并且当你这样做时将会转储核心\n（或在以后导致核心转储）。 返回对象引用的函数通常只在要指明发生了异常时才返回 NULL。 不\n检测 NULL 参数的原因在于这些函数经常要将它们所接收的对象传给其他函数 --- 如果每个函数都检\n测 NULL，将会导致大量的冗余检测而使代码运行得更缓慢。\n更好的做法是仅在“源头”上检测 NULL，即在接收到一个可能为 NULL 的指针，例如来自 malloc()\n或是一个可能引发异常的函数的时候。\nPy_INCREF() 和 Py_DECREF() 等宏不会检测 NULL 指针 --- 但是，它们的变种 Py_XINCREF() 和\nPy_XDECREF() 则会检测。\n用于检测特定对象类型的宏 (Pytype_Check()) 不会检测 NULL 指针 --- 同样地，有大量代码会连续\n调用这些宏来测试一个对象是否为几种不同预期类型之一，这将会生成冗余的测试。 不存在带有\nNULL 检测的变体。\nC 函数调用机制会保证传给 C 函数的参数列表 (本示例中为 args) 绝不会为 NULL --- 实际上它会保\n证其总是为一个元组 [4]。\n任何时候将 NULL 指针“泄露”给 Python 用户都会是个严重的错误。\n1.11. 在C++中编写扩展\n还可以在C++中编写扩展模块，只是有些限制。如果主程序(Python解释器)是使用C编译器来编译和\n链接的，全局或静态对象的构造器就不能使用。而如果是C++编译器来链接的就没有这个问题。函\n数会被Python解释器调用(通常就是模块初始化函数)必须声明为 extern \"C\" 。而是否在 extern\n\"C\" {...} 里包含Python头文件则不是那么重要，因为如果定义了符号 __cplusplus 则已经是这么\n声明的了(所有现代C++编译器都会定义这个符号)。\n1.12. 给扩展模块提供C API\n很多扩展模块提供了新的函数和类型供Python使用，但有时扩展模块里的代码也可以被其他扩展模\n块使用。例如，一个扩展模块可以实现一个类型 \"collection\" 看起来是没有顺序的。就像是Python列\n表类型，拥有C API允许扩展模块来创建和维护列表，这个新的集合类型可以有一堆C函数用于给其\n他扩展模块直接使用。 |  |  |  |\n|  |  |  | extern |  |  |\n|  |  |  |  |  |  |\n|  |  | \"C\" {...} |  |  |  |\n|  |  |  |  |  |  |\n\n开始看起来很简单：只需要编写函数(无需声明为 static )，提供恰当的头文件，以及C API的文档。\n实际上在所有扩展模块都是静态链接到Python解释器时也是可以正常工作的。当模块以共享库链接\n时，一个模块中的符号定义对另一个模块不可见。可见的细节依赖于操作系统，一些系统的Python\n解释器使用全局命名空间(例如Windows)，有些则在链接时需要一个严格的已导入符号列表(一个例\n子是AIX)，或者提供可选的不同策略(如Unix系列)。即便是符号是全局可见的，你要调用的模块也可\n能尚未加载。\n可移植性需要不能对符号可见性做任何假设。这意味着扩展模块里的所有符号都应该声明为 static\n，除了模块的初始化函数，来避免与其他扩展模块的命名冲突(在段落 模块方法表和初始化函数 中讨\n论) 。这意味着符号应该 必须 通过其他导出方式来供其他扩展模块访问。\nPython 提供了一个特别的机制用来从一个扩展模块向另一个扩展模块传递 C 层级的信息 (指针):\nCapsule。 一个 Capsule 就是一个存储了指针 (void*) 的 Python 数据类型。 Capsule 只能通过其 C\nAPI 来创建和访问，但它们可以像任何其他 Python 对象一样被传递。 特别地，它们可以被赋值给扩\n展模块命名空间中的一个名称。 其他扩展模块将可以导入这个模块，获取该名称对应的值，然后从\nCapsule 中获取指针。\nCapsule可以用多种方式导出C API给扩展模块。每个函数可以用自己的Capsule，或者所有C API指针\n可以存储在一个数组里，数组地址再发布给Capsule。存储和获取指针也可以用多种方式，供客户端\n模块使用。\n无论你选择哪个方法，为你的 Capsule 指定适当的名称都很重要。 函数 PyCapsule_New() 接受一\n个 name 形参 (const char*)；允许你传入一个 NULL 作为名称，但我们强烈推荐你指定名称。 正\n确地命名的 Capsule 提供了一定的运行时类型安全性；没有可行的方式能区别两个未命名的\nCapsule。\n通常来说，Capsule用于暴露C API，其名字应该遵循如下规范：\nmodulename.attributename\n便利函数 PyCapsule_Import() 可以方便的载入通过Capsule提供的C API，仅在Capsule的名字匹配\n时。这个行为为C API用户提供了高度的确定性来载入正确的C API。\n下面的例子演示了一种将大部分负担交给导出模块编写者的处理方式，这对于常用的库模块来说是\n合适的。 它会将所有 C API 指针（在这个例子里只有一个！）储存到一个 void 指针数组，它将成\n为一个 Capsule 的值。 与模块对应的头文件提供了一个宏用来管理导入模块和获取其 C API 指针；\n客户端模块只需要在访问 C API 之前调用这个宏即可。\n导出模块是对 一个简单的例子 部分的 spam 模块的修改。 函数 spam.system() 并不直接调用 C 库\n函数 system()，而是调用一个函数 PySpam_System()，这个函数在现实中当然会做一些更复杂的\n事情（比如在每条命令中添加“sapm”）。 该函数 PySpam_System() 也会导出给其他扩展模块。\n函数 PySpam_System() 是一个纯 C 函数，像其他函数一样声明为 static:\nstatic int\nPySpam_System(const char *command)\n{\n\n|  | 开始看起来很简单：只需要编写函数(无需声明为 static )，提供恰当的头文件，以及C API的文档。\n实际上在所有扩展模块都是静态链接到Python解释器时也是可以正常工作的。当模块以共享库链接\n时，一个模块中的符号定义对另一个模块不可见。可见的细节依赖于操作系统，一些系统的Python\n解释器使用全局命名空间(例如Windows)，有些则在链接时需要一个严格的已导入符号列表(一个例\n子是AIX)，或者提供可选的不同策略(如Unix系列)。即便是符号是全局可见的，你要调用的模块也可\n能尚未加载。\n可移植性需要不能对符号可见性做任何假设。这意味着扩展模块里的所有符号都应该声明为 static\n，除了模块的初始化函数，来避免与其他扩展模块的命名冲突(在段落 模块方法表和初始化函数 中讨\n论) 。这意味着符号应该 必须 通过其他导出方式来供其他扩展模块访问。\nPython 提供了一个特别的机制用来从一个扩展模块向另一个扩展模块传递 C 层级的信息 (指针):\nCapsule。 一个 Capsule 就是一个存储了指针 (void*) 的 Python 数据类型。 Capsule 只能通过其 C\nAPI 来创建和访问，但它们可以像任何其他 Python 对象一样被传递。 特别地，它们可以被赋值给扩\n展模块命名空间中的一个名称。 其他扩展模块将可以导入这个模块，获取该名称对应的值，然后从\nCapsule 中获取指针。\nCapsule可以用多种方式导出C API给扩展模块。每个函数可以用自己的Capsule，或者所有C API指针\n可以存储在一个数组里，数组地址再发布给Capsule。存储和获取指针也可以用多种方式，供客户端\n模块使用。\n无论你选择哪个方法，为你的 Capsule 指定适当的名称都很重要。 函数 PyCapsule_New() 接受一\n个 name 形参 (const char*)；允许你传入一个 NULL 作为名称，但我们强烈推荐你指定名称。 正\n确地命名的 Capsule 提供了一定的运行时类型安全性；没有可行的方式能区别两个未命名的\nCapsule。\n通常来说，Capsule用于暴露C API，其名字应该遵循如下规范： |  |\n| --- | --- | --- |\n|  | modulename.attributename |  |\n|  | 便利函数 PyCapsule_Import() 可以方便的载入通过Capsule提供的C API，仅在Capsule的名字匹配\n时。这个行为为C API用户提供了高度的确定性来载入正确的C API。\n下面的例子演示了一种将大部分负担交给导出模块编写者的处理方式，这对于常用的库模块来说是\n合适的。 它会将所有 C API 指针（在这个例子里只有一个！）储存到一个 void 指针数组，它将成\n为一个 Capsule 的值。 与模块对应的头文件提供了一个宏用来管理导入模块和获取其 C API 指针；\n客户端模块只需要在访问 C API 之前调用这个宏即可。\n导出模块是对 一个简单的例子 部分的 spam 模块的修改。 函数 spam.system() 并不直接调用 C 库\n函数 system()，而是调用一个函数 PySpam_System()，这个函数在现实中当然会做一些更复杂的\n事情（比如在每条命令中添加“sapm”）。 该函数 PySpam_System() 也会导出给其他扩展模块。\n函数 PySpam_System() 是一个纯 C 函数，像其他函数一样声明为 static: |  |\n|  | static int\nPySpam_System(const char *command)\n{ |  |\n\nreturn system(command);\n}\n函数 spam_system() 已按如下方式修改:\nstatic PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = PySpam_System(command);\nreturn PyLong_FromLong(sts);\n}\n在模块开头，在此行后:\n#include <Python.h>\n添加另外两行:\n#define SPAM_MODULE\n#include \"spammodule.h\"\n#define 被用来告知头文件它被包括在导出的模块中，而不是客户端模块。 最终，模块的\nmod_exec 函数必须负责初始化 C API 指针数组:\nstatic int\nspam_module_exec(PyObject *m)\n{\nstatic void *PySpam_API[PySpam_API_pointers];\nPyObject *c_api_object;\n/* 初始化 C API 指针数组 */\nPySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n/* 创建包含 API 指针数组地址的 Capsule */\nc_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);\nif (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\nreturn -1;\n}\nreturn 0;\n}\n请注意 PySpam_API 被声明为 static；否则指针数组会在 PyInit_spam() 终结时消失！\n头文件 spammodule.h 里的一堆工作，看起来如下所示:\n#ifndef Py_SPAMMODULE_H\n#define Py_SPAMMODULE_H\n#ifdef __cplusplus\n\n|  | return system(command);\n} |  |\n| --- | --- | --- |\n|  | 函数 spam_system() 已按如下方式修改: |  |\n|  | static PyObject *\nspam_system(PyObject *self, PyObject *args)\n{\nconst char *command;\nint sts;\nif (!PyArg_ParseTuple(args, \"s\", &command))\nreturn NULL;\nsts = PySpam_System(command);\nreturn PyLong_FromLong(sts);\n} |  |\n|  | 在模块开头，在此行后: |  |\n|  | #include <Python.h> |  |\n|  | 添加另外两行: |  |\n|  | #define SPAM_MODULE\n#include \"spammodule.h\" |  |\n|  | #define 被用来告知头文件它被包括在导出的模块中，而不是客户端模块。 最终，模块的\nmod_exec 函数必须负责初始化 C API 指针数组: |  |\n|  | static int\nspam_module_exec(PyObject *m)\n{\nstatic void *PySpam_API[PySpam_API_pointers];\nPyObject *c_api_object;\n/* 初始化 C API 指针数组 */\nPySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n/* 创建包含 API 指针数组地址的 Capsule */\nc_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);\nif (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\nreturn -1;\n}\nreturn 0;\n} |  |\n|  | 请注意 PySpam_API 被声明为 static；否则指针数组会在 PyInit_spam() 终结时消失！\n头文件 spammodule.h 里的一堆工作，看起来如下所示: |  |\n|  | #ifndef Py_SPAMMODULE_H\n#define Py_SPAMMODULE_H\n#ifdef __cplusplus |  |\n\nextern \"C\" {\n#endif\n/* 用于 spammodule 的头文件 */\n/* C API 函数 */\n#define PySpam_System_NUM 0\n#define PySpam_System_RETURN int\n#define PySpam_System_PROTO (const char *command)\n/* C API 指针的总数 */\n#define PySpam_API_pointers 1\n#ifdef SPAM_MODULE\n/* 该节将在编译 spammodule.c 时使用 */\nstatic PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n#else\n/* 该节将在使用 spammodule 的 API 的模块中使用 */\nstatic void **PySpam_API;\n#define PySpam_System \\\n(*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])\n/* 出错时返回 -1，成功时返回 0。\n* 如果有异常 PyCapsule_Import 将设置一个异常。\n*/\nstatic int\nimport_spam(void)\n{\nPySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\nreturn (PySpam_API != NULL) ? 0 : -1;\n}\n#endif\n#ifdef __cplusplus\n}\n#endif\n#endif /* !defined(Py_SPAMMODULE_H) */\n客户端模块要访问函数 PySpam_System() 所必须做的全部事情就是在其 mod_exec 函数中调用函数\nimport_spam() (更准确地说是宏):\nstatic int\nclient_module_exec(PyObject *m)\n{\nif (import_spam() < 0) {\nreturn -1;\n}\n/* 额外的初始化可在此进行 */\nreturn 0;\n}\n\n|  | extern \"C\" {\n#endif\n/* 用于 spammodule 的头文件 */\n/* C API 函数 */\n#define PySpam_System_NUM 0\n#define PySpam_System_RETURN int\n#define PySpam_System_PROTO (const char *command)\n/* C API 指针的总数 */\n#define PySpam_API_pointers 1\n#ifdef SPAM_MODULE\n/* 该节将在编译 spammodule.c 时使用 */\nstatic PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n#else\n/* 该节将在使用 spammodule 的 API 的模块中使用 */\nstatic void **PySpam_API;\n#define PySpam_System \\\n(*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])\n/* 出错时返回 -1，成功时返回 0。\n* 如果有异常 PyCapsule_Import 将设置一个异常。\n*/\nstatic int\nimport_spam(void)\n{\nPySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\nreturn (PySpam_API != NULL) ? 0 : -1;\n}\n#endif\n#ifdef __cplusplus\n}\n#endif\n#endif /* !defined(Py_SPAMMODULE_H) */ |  |\n| --- | --- | --- |\n|  | 客户端模块要访问函数 PySpam_System() 所必须做的全部事情就是在其 mod_exec 函数中调用函数\nimport_spam() (更准确地说是宏): |  |\n|  | static int\nclient_module_exec(PyObject *m)\n{\nif (import_spam() < 0) {\nreturn -1;\n}\n/* 额外的初始化可在此进行 */\nreturn 0;\n} |  |\n|  |  |  |\n\n这种方法的主要缺点是，文件 spammodule.h 过于复杂。当然，对每个要导出的函数，基本结构是\n相似的，所以只需要学习一次。\n最后需要提醒的是Capsule提供了额外的功能，用于存储在Capsule里的指针的内存分配和释放。细\n节参考 Python/C API参考手册的章节 Capsule 对象 和Capsule的实现(在Python源码发行包的\nInclude/pycapsule.h 和 Objects/pycapsule.c )。\n备注\n[1] 这个函数的接口已经在标准模块 os 里了，这里作为一个简单而直接的例子。\n[2] 术语\"借用\"一个引用是不完全正确的：拥有者仍然有引用的拷贝。\n[3] 检查引用计数至少为1 没有用 ，引用计数本身可以在已经释放的内存里，并有可能被其他对象\n所用。\n[4] 当你使用 \"旧式\" 风格调用约定时，这些保证不成立，尽管这依旧存在于很多旧代码中。", "metadata": {"title": "01_使用_C_或_C++_扩展_Python", "source": "md_docs\\python_extending_md\\01_使用_C_或_C++_扩展_Python.md", "doc_type": "扩展和嵌入", "language": "中文", "doc_id": "903a84e3"}}
{"doc_id": "eb1bb820", "content": "2. 自定义扩展类型：教程\nPython 允许编写 C 扩展模块定义可以从 Python 代码中操纵的新类型，这很像内置的 str 和 list\n类型。所有扩展类型的代码都遵循一个模式，但是在您开始之前，您需要了解一些细节。这份文件\n是对这个主题介绍。\n2.1. 基础\nCPython 运行时会将所有 Python 对象都视为 PyObject* 类型的变量，这是所有 Python 对象的“基\n础类型”。 PyObject 结构体本身只包含对象的 reference count 和指向对象的“类型对象”的指针。 这\n是动作所针对的目标。 类型对象决定解释器要调用哪些 (C) 函数，例如，在对象上查找一个属性，\n调用一个方法，或者与另一个对象相乘等。 这些 C 函数被称为“类型方法”。\n所以，如果你想要定义新的扩展类型，需要创建新的类型对象。\n这种事情只能通过例子来解释，下面是一个最小但完整的模块，它在 C 扩展模块 custom 中定义了\n一个名为 Custom 的新类型：\n备注: 这里展示的方法是定义 static 扩展类型的传统方法。可以适合大部分用途。C API也可以定\n义在堆上分配的扩展类型，使用 PyType_FromSpec() 函数，但不在本入门里讨论。\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\ntypedef struct {\nPyObject_HEAD\n/* 这里添加类型专属的字段。 */\n} CustomObject;\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT,\n.tp_new = PyType_GenericNew,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\n\n| 2. 自定义扩展类型：教程\nPython 允许编写 C 扩展模块定义可以从 Python 代码中操纵的新类型，这很像内置的 str 和 list\n类型。所有扩展类型的代码都遵循一个模式，但是在您开始之前，您需要了解一些细节。这份文件\n是对这个主题介绍。\n2.1. 基础\nCPython 运行时会将所有 Python 对象都视为 PyObject* 类型的变量，这是所有 Python 对象的“基\n础类型”。 PyObject 结构体本身只包含对象的 reference count 和指向对象的“类型对象”的指针。 这\n是动作所针对的目标。 类型对象决定解释器要调用哪些 (C) 函数，例如，在对象上查找一个属性，\n调用一个方法，或者与另一个对象相乘等。 这些 C 函数被称为“类型方法”。\n所以，如果你想要定义新的扩展类型，需要创建新的类型对象。\n这种事情只能通过例子来解释，下面是一个最小但完整的模块，它在 C 扩展模块 custom 中定义了\n一个名为 Custom 的新类型： |\n| --- |\n| 备注: 这里展示的方法是定义 static 扩展类型的传统方法。可以适合大部分用途。C API也可以定\n义在堆上分配的扩展类型，使用 PyType_FromSpec() 函数，但不在本入门里讨论。 |\n|  |\n| #define PY_SSIZE_T_CLEAN\n#include <Python.h>\ntypedef struct {\nPyObject_HEAD\n/* 这里添加类型专属的字段。 */\n} CustomObject;\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT,\n.tp_new = PyType_GenericNew,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n} |\n\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n// 使用静态类型时就使用这个\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n}\n这部分很容易理解，这是为了跟上一章能对接上。这个文件定义了三件事：\n1. 一个 Custom 对象 包含的东西：这是 CustomObject 结构体，它会为每个 Custom 实例分配\n一次。\n2. Custom 类型 的行为：这是 CustomType 结构体，它定义了一组旗标和函数指针供解释器在收\n到特定操作请求时进行检查。\n3. 如何定义和执行 custom 模块：这是 PyInit_custom 函数及所关联的用于定义该模块的\ncustom_module 结构体，以及用于设置新模块对象的 custom_module_exec 函数。\n结构的第一块是\ntypedef struct {\nPyObject_HEAD\n} CustomObject;\n这就是一个自定义对象将会包含的内容。 PyObject_HEAD 是强制要求放在每个对象结构体之前并定\n义一个名为 ob_base 的 PyObject 类型的字段，其中包含一个指向类型对象和引用计数的指针（这\n两者可以分别使用宏 Py_TYPE 和 Py_REFCNT 来区分）。 使用宏的理由是将布局抽象出来并在 调试\n编译版中 中启用附加字段。\n备注: 注意在宏 PyObject_HEAD 后没有分号。意外添加分号会导致编译器提示出错。\n当然，对象除了在 PyObject_HEAD 存储数据外，还有额外数据；例如，如下定义了标准的Python浮\n点数:\ntypedef struct {\nPyObject_HEAD\n\n|  | return 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n// 使用静态类型时就使用这个\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n} |  |\n| --- | --- | --- |\n|  | 这部分很容易理解，这是为了跟上一章能对接上。这个文件定义了三件事：\n1. 一个 Custom 对象 包含的东西：这是 CustomObject 结构体，它会为每个 Custom 实例分配\n一次。\n2. Custom 类型 的行为：这是 CustomType 结构体，它定义了一组旗标和函数指针供解释器在收\n到特定操作请求时进行检查。\n3. 如何定义和执行 custom 模块：这是 PyInit_custom 函数及所关联的用于定义该模块的\ncustom_module 结构体，以及用于设置新模块对象的 custom_module_exec 函数。\n结构的第一块是 |  |\n|  | typedef struct {\nPyObject_HEAD\n} CustomObject; |  |\n|  | 这就是一个自定义对象将会包含的内容。 PyObject_HEAD 是强制要求放在每个对象结构体之前并定\n义一个名为 ob_base 的 PyObject 类型的字段，其中包含一个指向类型对象和引用计数的指针（这\n两者可以分别使用宏 Py_TYPE 和 Py_REFCNT 来区分）。 使用宏的理由是将布局抽象出来并在 调试\n编译版中 中启用附加字段。 |  |\n|  | 备注: 注意在宏 PyObject_HEAD 后没有分号。意外添加分号会导致编译器提示出错。 |  |\n|  | 当然，对象除了在 PyObject_HEAD 存储数据外，还有额外数据；例如，如下定义了标准的Python浮\n点数: |  |\n|  | typedef struct {\nPyObject_HEAD |  |\n\ndouble ob_fval;\n} PyFloatObject;\n第二个位是类型对象的定义:\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT,\n.tp_new = PyType_GenericNew,\n};\n备注: 推荐使用如上C99风格的初始化，以避免列出所有的 PyTypeObject 字段，其中很多是你\n不需要关心的，这样也可以避免关注字段的定义顺序。\n在 object.h 中实际定义的 PyTypeObject 具有比如上定义更多的 字段。 剩余的字段会由 C 编译器\n用零来填充，通常的做法是不显式地指定它们，除非你确实需要它们。\n我们先挑选一部分，每次一个字段:\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n这一行是强制的样板，用以初始化如上提到的 ob_base 字段:\n.tp_name = \"custom.Custom\",\n我们的类型的名称。 这将出现在我们的对象的默认文本表示形式和某些错误消息中，例如:\n>>> \"\" + custom.Custom()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"custom.Custom\") to str\n请注意此名称是一个带点号名称，它同时包括模块名称和模块中的类型名称。 本例中的模块是\ncustom 而类型是 Custom，因此我们将类型名称设为 custom.Custom。 使用真正的带点号的导入路\n径对于使你的类型与 pydoc 和 pickle 模块保持兼容是很重要的。\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n这样能让 Python 知道当创建新的 Custom 实例时需要分配多少内存。 tp_itemsize 仅用于可变大\n小的对象而在其他情况下都应为零。\n备注: 如果你希望你的类型可在 Python 中被子类化，并且你的类型和它的基类型具有相同的\ntp_basicsize，那么你可能会遇到多重继承问题。 你的类型的 Python 子类必须在其 __bases__\n中将你的类型列在最前面，否则在调用你的类型的 __new__() 方法时将会出错。 你可以通过确\n\n|  | double ob_fval;\n} PyFloatObject; |  |\n| --- | --- | --- |\n|  | 第二个位是类型对象的定义: |  |\n|  | static PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT,\n.tp_new = PyType_GenericNew,\n}; |  |\n|  |  |  |\n|  | 备注: 推荐使用如上C99风格的初始化，以避免列出所有的 PyTypeObject 字段，其中很多是你\n不需要关心的，这样也可以避免关注字段的定义顺序。 |  |\n|  | 在 object.h 中实际定义的 PyTypeObject 具有比如上定义更多的 字段。 剩余的字段会由 C 编译器\n用零来填充，通常的做法是不显式地指定它们，除非你确实需要它们。\n我们先挑选一部分，每次一个字段: |  |\n|  | .ob_base = PyVarObject_HEAD_INIT(NULL, 0) |  |\n|  | 这一行是强制的样板，用以初始化如上提到的 ob_base 字段: |  |\n|  | .tp_name = \"custom.Custom\", |  |\n|  | 我们的类型的名称。 这将出现在我们的对象的默认文本表示形式和某些错误消息中，例如: |  |\n|  | >>> \"\" + custom.Custom()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"custom.Custom\") to str |  |\n|  | 请注意此名称是一个带点号名称，它同时包括模块名称和模块中的类型名称。 本例中的模块是\ncustom 而类型是 Custom，因此我们将类型名称设为 custom.Custom。 使用真正的带点号的导入路\n径对于使你的类型与 pydoc 和 pickle 模块保持兼容是很重要的。 |  |\n|  | .tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0, |  |\n|  | 这样能让 Python 知道当创建新的 Custom 实例时需要分配多少内存。 tp_itemsize 仅用于可变大\n小的对象而在其他情况下都应为零。 |  |\n|  | 备注: 如果你希望你的类型可在 Python 中被子类化，并且你的类型和它的基类型具有相同的\ntp_basicsize，那么你可能会遇到多重继承问题。 你的类型的 Python 子类必须在其 __bases__\n中将你的类型列在最前面，否则在调用你的类型的 __new__() 方法时将会出错。 你可以通过确 |  |\n\n保你的类型具有比它的基类型更大的 tp_basicsize 值来避免这个问题。 在大多数时候，这都是\n可以的，因为要么你的类型是 object，要么你将为你的基类型添加数据成员，从而增加其大小。\n我们将类旗标设为 Py_TPFLAGS_DEFAULT。\n.tp_flags = Py_TPFLAGS_DEFAULT,\n所有类型都应当在它们的旗标中包括此常量。 该常量将启用至少在 Python 3.3 之前定义的全部成\n员。 如果你需要更多的成员，你将需要对相应的旗标进行 OR 运算。\n我们为 tp_doc 类型提供一个文档字符串.\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n要启用对象创建，我们必须提供一个 tp_new 处理器。 这等价于 Python 方法 __new__()，但必须\n显式地指定。 在这种情况下，我们可以使用 API 函数 PyType_GenericNew() 所提供的默认实现。\n.tp_new = PyType_GenericNew,\n除了 custom_module_exec() 中的某些代码以外，文件中的其他内容应该都很常见:\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\n这将初始化 Custom 类型，为一些成员填充适当的默认值，包括我们在初始时设为 NULL 的\nob_type。\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\n这将把类型添加到模块字典中。 这样我们就能通过调用 Custom 类来创建 Custom 实例：\n>>> import custom\n>>> mycustom = custom.Custom()\n就是这样！ 剩下的工作就是编译它；将上述代码放入名为 custom.c 的文件中，\n[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n[project]\nname = \"custom\"\nversion = \"1\"\n名为 pyproject.toml 的文件中，并且\n\n|  | 保你的类型具有比它的基类型更大的 tp_basicsize 值来避免这个问题。 在大多数时候，这都是\n可以的，因为要么你的类型是 object，要么你将为你的基类型添加数据成员，从而增加其大小。 |  |\n| --- | --- | --- |\n|  | 我们将类旗标设为 Py_TPFLAGS_DEFAULT。 |  |\n|  | .tp_flags = Py_TPFLAGS_DEFAULT, |  |\n|  | 所有类型都应当在它们的旗标中包括此常量。 该常量将启用至少在 Python 3.3 之前定义的全部成\n员。 如果你需要更多的成员，你将需要对相应的旗标进行 OR 运算。\n我们为 tp_doc 类型提供一个文档字符串. |  |\n|  | .tp_doc = PyDoc_STR(\"Custom objects\"), |  |\n|  | 要启用对象创建，我们必须提供一个 tp_new 处理器。 这等价于 Python 方法 __new__()，但必须\n显式地指定。 在这种情况下，我们可以使用 API 函数 PyType_GenericNew() 所提供的默认实现。 |  |\n|  | .tp_new = PyType_GenericNew, |  |\n|  | 除了 custom_module_exec() 中的某些代码以外，文件中的其他内容应该都很常见: |  |\n|  | if (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n} |  |\n|  | 这将初始化 Custom 类型，为一些成员填充适当的默认值，包括我们在初始时设为 NULL 的\nob_type。 |  |\n|  | if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n} |  |\n|  | 这将把类型添加到模块字典中。 这样我们就能通过调用 Custom 类来创建 Custom 实例： |  |\n|  | >>> import custom\n>>> mycustom = custom.Custom() |  |\n|  | 就是这样！ 剩下的工作就是编译它；将上述代码放入名为 custom.c 的文件中， |  |\n|  | [build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n[project]\nname = \"custom\"\nversion = \"1\" |  |\n|  | 名为 pyproject.toml 的文件中，并且 |  |\n\nfrom setuptools import Extension, setup\nsetup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])\n在名为 setup.py 的文件中；然后输入\n$ python -m pip install .\n在 shell 中应该会在子目录下产生一个文件 custom.so 并安装它；现在启动 Python --- 你应当能够\n执行 import custom 并尝试使用 Custom 对象。\n这并不难，对吗？\n当然，当前的自定义类型非常无趣。它没有数据，也不做任何事情。它甚至不能被子类化。\n2.2. 向基本示例添加数据和方法\n让我们通过添加一些数据和方法来扩展这个基本示例。 让我们再使该类型可以作为基类使用。 我们\n将创建一个新模块 custom2 来添加这些功能：\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\nstatic void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n\n|  | from setuptools import Extension, setup\nsetup(ext_modules=[Extension(\"custom\", [\"custom.c\"])]) |  |\n| --- | --- | --- |\n|  | 在名为 setup.py 的文件中；然后输入 |  |\n|  | $ python -m pip install . |  |\n|  | 在 shell 中应该会在子目录下产生一个文件 custom.so 并安装它；现在启动 Python --- 你应当能够\n执行 import custom 并尝试使用 Custom 对象。\n这并不难，对吗？\n当然，当前的自定义类型非常无趣。它没有数据，也不做任何事情。它甚至不能被子类化。\n2.2. 向基本示例添加数据和方法\n让我们通过添加一些数据和方法来扩展这个基本示例。 让我们再使该类型可以作为基类使用。 我们\n将创建一个新模块 custom2 来添加这些功能： |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\nstatic void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0; |  |\n\n}\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_XSETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_XSETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n\"first name\"},\n{\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n\"last name\"},\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nif (self->first == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"first\");\nreturn NULL;\n}\nif (self->last == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"last\");\nreturn NULL;\n}\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom2.Custom\",\n\n|  | }\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_XSETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_XSETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n\"first name\"},\n{\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n\"last name\"},\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nif (self->first == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"first\");\nreturn NULL;\n}\nif (self->last == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"last\");\nreturn NULL;\n}\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom2.Custom\", |  |\n| --- | --- | --- |\n\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom2\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom2(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n}\n该模块的新版本包含多处修改。\n现在 Custom 类型的 C 结构体中有三个数据属性，first、last 和 number。 其中 first 和 last 变量是包\n含名字和姓氏的 Python 字符串。 number 属性是一个 C 整数。\n对象的结构将被相应地更新:\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\n\n|  | .tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom2\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom2(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n} |  |\n| --- | --- | --- |\n|  | 该模块的新版本包含多处修改。\n现在 Custom 类型的 C 结构体中有三个数据属性，first、last 和 number。 其中 first 和 last 变量是包\n含名字和姓氏的 Python 字符串。 number 属性是一个 C 整数。\n对象的结构将被相应地更新: |  |\n|  | typedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject; |  |\n\n因为现在我们有数据需要管理，我们必须更加小心地处理对象的分配和释放。 至少，我们需要有一\n个释放方法:\nstatic void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n}\n它会被赋值给 tp_dealloc 成员:\n.tp_dealloc = Custom_dealloc,\n此方法会先清空两个 Python 属性的引用计数。 Py_XDECREF() 可以正确处理参数为 NULL 的情况\n（这可能在 tp_new 中途失败时发生）。 随后它将调用对象类型的 tp_free 成员（通过\nPy_TYPE(self) 计算得到）来释放对象的内存。 请注意对象类型可以不是 CustomType，因为对象\n可能是一个子类的实例。\n备注: 上面需要显式强制转换至 CustomObject * 是因为我们定义了 Custom_dealloc 接受一个\nPyObject * 参数，由于 tp_dealloc 函数指针预期接受一个 PyObject * 参数。 通过向\ntp_dealloc 槽位分配一个类型，我们声明它被调用时只能附带我们的 CustomObject 类的实\n例，因此强制转换至 (CustomObject *) 是安全的。 这就是 C 语言中面向对象的多态性！\n在现有代码中，或是在本教程的之前版本中，你可能会看到类似的函数接受一个直接指向子类型\n对象结构体 (CustomObject*) 的指针，就像这样:\nCustom_dealloc(CustomObject *self)\n{\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free((PyObject *) self);\n}\n...\n.tp_dealloc = (destructor) Custom_dealloc,\n这将在所有 CPython 支持的架构上做同样的事，但是根据 C 标准，它会唤起未定义的行为。\n我们希望确保头一个和末一个名称被初始化为空字符串，因此我们提供了一个 tp_new 实现:\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = PyUnicode_FromString(\"\");\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n\n|  | 因为现在我们有数据需要管理，我们必须更加小心地处理对象的分配和释放。 至少，我们需要有一\n个释放方法: |  |\n| --- | --- | --- |\n|  | static void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n} |  |\n|  | 它会被赋值给 tp_dealloc 成员: |  |\n|  | .tp_dealloc = Custom_dealloc, |  |\n|  | 此方法会先清空两个 Python 属性的引用计数。 Py_XDECREF() 可以正确处理参数为 NULL 的情况\n（这可能在 tp_new 中途失败时发生）。 随后它将调用对象类型的 tp_free 成员（通过\nPy_TYPE(self) 计算得到）来释放对象的内存。 请注意对象类型可以不是 CustomType，因为对象\n可能是一个子类的实例。 |  |\n|  | 备注: 上面需要显式强制转换至 CustomObject * 是因为我们定义了 Custom_dealloc 接受一个\nPyObject * 参数，由于 tp_dealloc 函数指针预期接受一个 PyObject * 参数。 通过向\ntp_dealloc 槽位分配一个类型，我们声明它被调用时只能附带我们的 CustomObject 类的实\n例，因此强制转换至 (CustomObject *) 是安全的。 这就是 C 语言中面向对象的多态性！\n在现有代码中，或是在本教程的之前版本中，你可能会看到类似的函数接受一个直接指向子类型\n对象结构体 (CustomObject*) 的指针，就像这样:\nCustom_dealloc(CustomObject *self)\n{\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free((PyObject *) self);\n}\n...\n.tp_dealloc = (destructor) Custom_dealloc,\n这将在所有 CPython 支持的架构上做同样的事，但是根据 C 标准，它会唤起未定义的行为。 |  |\n|  | 我们希望确保头一个和末一个名称被初始化为空字符串，因此我们提供了一个 tp_new 实现: |  |\n|  | static PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = PyUnicode_FromString(\"\");\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL; |  |\n\n}\nself->last = PyUnicode_FromString(\"\");\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n}\n并在 tp_new 成员中安装它:\n.tp_new = Custom_new,\ntp_new 处理器负责创建（而不是初始化）该类型的对象。 它在 Python 中被暴露为 __new__() 方\n法。 它不需要定义 tp_new 成员，实际上许多扩展类型会简单地重用 PyType_GenericNew()，就像\n上面 Custom 类型的第一个版本所做的那样。 在此情况下，我们使用 tp_new 处理器来将 first 和\nlast 属性初始化为非 NULL 的默认值。\ntp_new 将接受被实例化的类型（不要求为 CustomType，如果被实例化的是一个子类）以及在该类\n型被调用时传入的任何参数，并预期返回所创建的实例。 tp_new 处理器总是接受位置和关键字参\n数，但它们总是会忽略这些参数，而将参数处理留给初始化（即 C 中的 tp_init 或 Python 中的\n__init__ 函数）方法来执行。\n备注: tp_new 不应显式地调用 tp_init，因为解释器会自行调用它。\ntp_new 实现会调用 tp_alloc 槽位来分配内存:\nself = (CustomObject *) type->tp_alloc(type, 0);\n由于内存分配可能会失败，我们必须在继续执行之前检查 tp_alloc 结果确认其不为 NULL。\n备注: 我们没有自行填充 tp_alloc 槽位。 而是由 PyType_Ready() 通过从我们的基类继承来替\n我们填充它，其中默认为 object。 大部分类型都是使用默认的分配策略。\n备注: 如果您要创建一个协作式 tp_new (它会调用基类型的 tp_new 或 __new__())，那么你 不\n能 在运行时尝试使用方法解析顺序来确定要调用的方法。 必须总是静态地确定你要调用的类型，\n并直接调用它的 tp_new，或是通过 type->tp_base->tp_new。 如果你不这样做，你的类型的同\n样继承自其它由 Python 定义的类的 Python 子类可能无法正常工作。 (具体地说，你可能无法创\n建这样的子类的实例而是会引发 TypeError。)\n我们还定义了一个接受参数来为我们的实例提供初始值的初始化函数:\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\n\n|  | }\nself->last = PyUnicode_FromString(\"\");\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n} |  |\n| --- | --- | --- |\n|  | 并在 tp_new 成员中安装它: |  |\n|  | .tp_new = Custom_new, |  |\n|  | tp_new 处理器负责创建（而不是初始化）该类型的对象。 它在 Python 中被暴露为 __new__() 方\n法。 它不需要定义 tp_new 成员，实际上许多扩展类型会简单地重用 PyType_GenericNew()，就像\n上面 Custom 类型的第一个版本所做的那样。 在此情况下，我们使用 tp_new 处理器来将 first 和\nlast 属性初始化为非 NULL 的默认值。\ntp_new 将接受被实例化的类型（不要求为 CustomType，如果被实例化的是一个子类）以及在该类\n型被调用时传入的任何参数，并预期返回所创建的实例。 tp_new 处理器总是接受位置和关键字参\n数，但它们总是会忽略这些参数，而将参数处理留给初始化（即 C 中的 tp_init 或 Python 中的\n__init__ 函数）方法来执行。 |  |\n|  | 备注: tp_new 不应显式地调用 tp_init，因为解释器会自行调用它。 |  |\n|  | tp_new 实现会调用 tp_alloc 槽位来分配内存: |  |\n|  | self = (CustomObject *) type->tp_alloc(type, 0); |  |\n|  | 由于内存分配可能会失败，我们必须在继续执行之前检查 tp_alloc 结果确认其不为 NULL。 |  |\n|  | 备注: 我们没有自行填充 tp_alloc 槽位。 而是由 PyType_Ready() 通过从我们的基类继承来替\n我们填充它，其中默认为 object。 大部分类型都是使用默认的分配策略。 |  |\n|  |  |  |\n|  | 备注: 如果您要创建一个协作式 tp_new (它会调用基类型的 tp_new 或 __new__())，那么你 不\n能 在运行时尝试使用方法解析顺序来确定要调用的方法。 必须总是静态地确定你要调用的类型，\n并直接调用它的 tp_new，或是通过 type->tp_base->tp_new。 如果你不这样做，你的类型的同\n样继承自其它由 Python 定义的类的 Python 子类可能无法正常工作。 (具体地说，你可能无法创\n建这样的子类的实例而是会引发 TypeError。) |  |\n|  | 我们还定义了一个接受参数来为我们的实例提供初始值的初始化函数: |  |\n|  | static int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op; |  |\n\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL, *tmp;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\ntmp = self->first;\nPy_INCREF(first);\nself->first = first;\nPy_XDECREF(tmp);\n}\nif (last) {\ntmp = self->last;\nPy_INCREF(last);\nself->last = last;\nPy_XDECREF(tmp);\n}\nreturn 0;\n}\n通过填充 tp_init 槽位。\n.tp_init = Custom_init,\ntp_init 槽位在 Python 中暴露为 __init__() 方法。 它被用来在创建对象后对其进行初始化。 初\n始化器总是接受位置和关键字参数，它们应当在成功时返回 0 而在出错时返回 -1。\n不同于 tp_new 处理器，tp_init 不保证一定会被调用 (例如，在默认情况下 pickle 模块不会在未\n解封的实例上调用 __init__())。 它还可能被多次调用。 任何人都可以在我们的对象上调用\n__init__() 方法。 因此，我们在为属性赋新值时必须格外小心。 例如像这样给 first 成员赋值:\nif (first) {\nPy_XDECREF(self->first);\nPy_INCREF(first);\nself->first = first;\n}\n但是这可能会有风险。 我们的类型没有限制 first 成员的类型，因此它可以是任何种类的对象。\n它可以带有一个会执行尝试访问 first 成员的代码的析构器；或者该析构器可能会释放 线程状态\n并让任意代码在其他线程中运行来访问和修改我们的对象。\n为了保持谨慎并使我们避免这种可能性，我们几乎总是要在减少成员的引用计数之前给它们重新赋\n值。 什么时候我们可以不必再这样做？\n当我们明确知道引用计数大于 1 的时候;\n当我们知道对象的销毁 [1] 既不会释放 线程状态 也不会导致任何对我们的类型的代码的回调的时\n候；\n当减少一个 tp_dealloc 处理器内不支持循环垃圾回收的类型的引用计数的时候 [2].\n\n|  | static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL, *tmp;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\ntmp = self->first;\nPy_INCREF(first);\nself->first = first;\nPy_XDECREF(tmp);\n}\nif (last) {\ntmp = self->last;\nPy_INCREF(last);\nself->last = last;\nPy_XDECREF(tmp);\n}\nreturn 0;\n} |  |\n| --- | --- | --- |\n|  | 通过填充 tp_init 槽位。 |  |\n|  | .tp_init = Custom_init, |  |\n|  | tp_init 槽位在 Python 中暴露为 __init__() 方法。 它被用来在创建对象后对其进行初始化。 初\n始化器总是接受位置和关键字参数，它们应当在成功时返回 0 而在出错时返回 -1。\n不同于 tp_new 处理器，tp_init 不保证一定会被调用 (例如，在默认情况下 pickle 模块不会在未\n解封的实例上调用 __init__())。 它还可能被多次调用。 任何人都可以在我们的对象上调用\n__init__() 方法。 因此，我们在为属性赋新值时必须格外小心。 例如像这样给 first 成员赋值: |  |\n|  | if (first) {\nPy_XDECREF(self->first);\nPy_INCREF(first);\nself->first = first;\n} |  |\n|  | 但是这可能会有风险。 我们的类型没有限制 first 成员的类型，因此它可以是任何种类的对象。\n它可以带有一个会执行尝试访问 first 成员的代码的析构器；或者该析构器可能会释放 线程状态\n并让任意代码在其他线程中运行来访问和修改我们的对象。\n为了保持谨慎并使我们避免这种可能性，我们几乎总是要在减少成员的引用计数之前给它们重新赋\n值。 什么时候我们可以不必再这样做？\n当我们明确知道引用计数大于 1 的时候;\n当我们知道对象的销毁 [1] 既不会释放 线程状态 也不会导致任何对我们的类型的代码的回调的时\n候；\n当减少一个 tp_dealloc 处理器内不支持循环垃圾回收的类型的引用计数的时候 [2]. |  |\n\n我们可能会想将我们的实例变量暴露为属性。 有几种方式可以做到这一点。 最简单的方式是定义成\n员的定义:\nstatic PyMemberDef Custom_members[] = {\n{\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n\"first name\"},\n{\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n\"last name\"},\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\n并将定义放置到 tp_members 槽位中:\n.tp_members = Custom_members,\n每个成员的定义都有成员名称、类型、偏移量、访问旗标和文档字符串。 请参阅下面的 泛型属性管\n理 小节来了解详情。section below for details.\n此方式的缺点之一是它没有提供限制可被赋值给 Python 属性的对象类型的办法。 我们预期 first 和\nlast 的名称为字符串，但它们可以被赋值为任意 Python 对象。 此外，这些属性还可以被删除，并将\nC 指针设为 NULL。 即使我们可以保证这些成员被初始化为非 NULL 值，如果这些属性被删除这些成\n员仍可被设为 NULL。\n我们定义一个单独的方法，Custom.name()，它将对象名称输出为 first 和 last 名称的拼接。\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nif (self->first == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"first\");\nreturn NULL;\n}\nif (self->last == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"last\");\nreturn NULL;\n}\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\n该方法以的实现形式是一个接受 Custom (或 Custom 的子类) 实例作为第一个参数的 C 函数。 方法\n总是接受一个实例作为第一个参数。 方法往往也接受位置和关键字参数，但在本例中我们未接受任\n何参数也不需要接受位置参数元组或关键字参数字典。 该方法等价于以下 Python 方法：\ndef name(self):\nreturn \"%s %s\" % (self.first, self.last)\n请注意我们必须检查 first 和 last 成员是否可能为 NULL。 这是因为它们可以被删除，在此情况\n下它们会被设为 NULL。 更好的做法是防止删除这些属性并将属性的值限制为字符串。 我们将在下\n一节了解如何做到这一点。\n\n|  | 我们可能会想将我们的实例变量暴露为属性。 有几种方式可以做到这一点。 最简单的方式是定义成\n员的定义: |  |\n| --- | --- | --- |\n|  | static PyMemberDef Custom_members[] = {\n{\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n\"first name\"},\n{\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n\"last name\"},\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n}; |  |\n|  | 并将定义放置到 tp_members 槽位中: |  |\n|  | .tp_members = Custom_members, |  |\n|  | 每个成员的定义都有成员名称、类型、偏移量、访问旗标和文档字符串。 请参阅下面的 泛型属性管\n理 小节来了解详情。section below for details.\n此方式的缺点之一是它没有提供限制可被赋值给 Python 属性的对象类型的办法。 我们预期 first 和\nlast 的名称为字符串，但它们可以被赋值为任意 Python 对象。 此外，这些属性还可以被删除，并将\nC 指针设为 NULL。 即使我们可以保证这些成员被初始化为非 NULL 值，如果这些属性被删除这些成\n员仍可被设为 NULL。\n我们定义一个单独的方法，Custom.name()，它将对象名称输出为 first 和 last 名称的拼接。 |  |\n|  | static PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nif (self->first == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"first\");\nreturn NULL;\n}\nif (self->last == NULL) {\nPyErr_SetString(PyExc_AttributeError, \"last\");\nreturn NULL;\n}\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n} |  |\n|  | 该方法以的实现形式是一个接受 Custom (或 Custom 的子类) 实例作为第一个参数的 C 函数。 方法\n总是接受一个实例作为第一个参数。 方法往往也接受位置和关键字参数，但在本例中我们未接受任\n何参数也不需要接受位置参数元组或关键字参数字典。 该方法等价于以下 Python 方法： |  |\n|  | def name(self):\nreturn \"%s %s\" % (self.first, self.last) |  |\n|  | 请注意我们必须检查 first 和 last 成员是否可能为 NULL。 这是因为它们可以被删除，在此情况\n下它们会被设为 NULL。 更好的做法是防止删除这些属性并将属性的值限制为字符串。 我们将在下\n一节了解如何做到这一点。 |  |\n\n现在我们已经定义好了方法，我们需要创建一个方法定义数组:\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\n（请注意我们使用了 METH_NOARGS 旗标来指明该方法不准备接受除 self 以外的任何参数）\n并将其赋给 tp_methods 槽位:\n.tp_methods = Custom_methods,\n最后，我们将使我们的类型可被用作派生子类的基类。 我们精心地编写我们的方法以便它们不会随\n意假定被创建或使用的对象类型，所以我们需要做的就是将 Py_TPFLAGS_BASETYPE 添加到我们的类\n旗标定义中:\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n我们将 PyInit_custom() 重命名为 PyInit_custom2()，更新 PyModuleDef 结构体中的模块名\n称，并更新 PyTypeObject 结构体中的完整类名。\n最后，我们更新 setup.py 文件来包括新的模块，\nfrom setuptools import Extension, setup\nsetup(ext_modules=[\nExtension(\"custom\", [\"custom.c\"]),\nExtension(\"custom2\", [\"custom2.c\"]),\n])\n然后我们重新安装以便能够 import custom2:\n$ python -m pip install .\n2.3. 提供对于数据属性的更精细控制\n在本节中，我们将对 Custom 示例中 first 和 last 属性的设置进行更精细的控制。 在我们上一版\n本的模块中，实例变量 first 和 last 可以被设为非字符串值甚至被删除。 我们希望确保这些属性\n始终包含字符串。\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\n\n|  | 现在我们已经定义好了方法，我们需要创建一个方法定义数组: |  |\n| --- | --- | --- |\n|  | static PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n}; |  |\n|  | （请注意我们使用了 METH_NOARGS 旗标来指明该方法不准备接受除 self 以外的任何参数）\n并将其赋给 tp_methods 槽位: |  |\n|  | .tp_methods = Custom_methods, |  |\n|  | 最后，我们将使我们的类型可被用作派生子类的基类。 我们精心地编写我们的方法以便它们不会随\n意假定被创建或使用的对象类型，所以我们需要做的就是将 Py_TPFLAGS_BASETYPE 添加到我们的类\n旗标定义中: |  |\n|  | .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, |  |\n|  | 我们将 PyInit_custom() 重命名为 PyInit_custom2()，更新 PyModuleDef 结构体中的模块名\n称，并更新 PyTypeObject 结构体中的完整类名。\n最后，我们更新 setup.py 文件来包括新的模块， |  |\n|  | from setuptools import Extension, setup\nsetup(ext_modules=[\nExtension(\"custom\", [\"custom.c\"]),\nExtension(\"custom2\", [\"custom2.c\"]),\n]) |  |\n|  | 然后我们重新安装以便能够 import custom2: |  |\n|  | $ python -m pip install . |  |\n|  | 2.3. 提供对于数据属性的更精细控制\n在本节中，我们将对 Custom 示例中 first 和 last 属性的设置进行更精细的控制。 在我们上一版\n本的模块中，实例变量 first 和 last 可以被设为非字符串值甚至被删除。 我们希望确保这些属性\n始终包含字符串。 |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject; |  |\n\nstatic void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_SETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_SETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_getfirst(PyObject *op, void *closure)\n\n|  | static void\nCustom_dealloc(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_XDECREF(self->first);\nPy_XDECREF(self->last);\nPy_TYPE(self)->tp_free(self);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\nif (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_SETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_SETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_getfirst(PyObject *op, void *closure) |  |\n| --- | --- | --- |\n\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->first);\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The first attribute value must be a string\");\nreturn -1;\n}\nPy_SETREF(self->first, Py_NewRef(value));\nreturn 0;\n}\nstatic PyObject *\nCustom_getlast(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->last);\n}\nstatic int\nCustom_setlast(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the last attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The last attribute value must be a string\");\nreturn -1;\n}\nPy_SETREF(self->last, Py_NewRef(value));\nreturn 0;\n}\nstatic PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\n\n|  | {\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->first);\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The first attribute value must be a string\");\nreturn -1;\n}\nPy_SETREF(self->first, Py_NewRef(value));\nreturn 0;\n}\nstatic PyObject *\nCustom_getlast(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->last);\n}\nstatic int\nCustom_setlast(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the last attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The last attribute value must be a string\");\nreturn -1;\n}\nPy_SETREF(self->last, Py_NewRef(value));\nreturn 0;\n}\nstatic PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n} |  |\n| --- | --- | --- |\n\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom3.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n.tp_getset = Custom_getsetters,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom3\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom3(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n}\n为了更好地控制 first 和 last 属性，我们将使用自定义的读取器和设置器函数。 以下就是用于读\n取和设置 first 属性的函数:\n\n|  | static PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom3.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n.tp_getset = Custom_getsetters,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom3\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom3(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n} |  |\n| --- | --- | --- |\n|  | 为了更好地控制 first 和 last 属性，我们将使用自定义的读取器和设置器函数。 以下就是用于读\n取和设置 first 属性的函数: |  |\n\nstatic PyObject *\nCustom_getfirst(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nPy_INCREF(self->first);\nreturn self->first;\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nPyObject *tmp;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The first attribute value must be a string\");\nreturn -1;\n}\ntmp = self->first;\nPy_INCREF(value);\nself->first = value;\nPy_DECREF(tmp);\nreturn 0;\n}\n读取器函数接受一个 Custom 对象和一个“闭包”，后者是一个空指针。 在本例中，该闭包将被忽\n略。 （闭包支持将定义数据传递给 读取器和设置器的高级用法。 例如，这可以被用来允许一组获取\n器和设置器函数根据闭包中的数据来决定要读取或设置的属性）。\n设置器函数接受传入 Custom 对象、新值和闭包。 新值可能为 NULL，在这种情况下属性将被删除。\n在我们的设置器中，如果属性被删除或者如果其新值不是字符串则会引发一个错误。\n我们创建一个 PyGetSetDef 结构体的数组:\nstatic PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n};\n并在 tp_getset 槽位中注册它:\n.tp_getset = Custom_getsetters,\n在 PyGetSetDef 结构体中的最后一项是上面提到的“闭包”。 在本例中，我们没有使用闭包，因此我\n们只传入 NULL。\n我们还移除了这些属性的成员定义:\n\n|  | static PyObject *\nCustom_getfirst(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nPy_INCREF(self->first);\nreturn self->first;\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nPyObject *tmp;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The first attribute value must be a string\");\nreturn -1;\n}\ntmp = self->first;\nPy_INCREF(value);\nself->first = value;\nPy_DECREF(tmp);\nreturn 0;\n} |  |\n| --- | --- | --- |\n|  | 读取器函数接受一个 Custom 对象和一个“闭包”，后者是一个空指针。 在本例中，该闭包将被忽\n略。 （闭包支持将定义数据传递给 读取器和设置器的高级用法。 例如，这可以被用来允许一组获取\n器和设置器函数根据闭包中的数据来决定要读取或设置的属性）。\n设置器函数接受传入 Custom 对象、新值和闭包。 新值可能为 NULL，在这种情况下属性将被删除。\n在我们的设置器中，如果属性被删除或者如果其新值不是字符串则会引发一个错误。\n我们创建一个 PyGetSetDef 结构体的数组: |  |\n|  | static PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n}; |  |\n|  | 并在 tp_getset 槽位中注册它: |  |\n|  | .tp_getset = Custom_getsetters, |  |\n|  | 在 PyGetSetDef 结构体中的最后一项是上面提到的“闭包”。 在本例中，我们没有使用闭包，因此我\n们只传入 NULL。\n我们还移除了这些属性的成员定义: |  |\n\nstatic PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\n我们还需要将 tp_init 处理器更新为只允许传入字符串 [3]:\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL, *tmp;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\ntmp = self->first;\nPy_INCREF(first);\nself->first = first;\nPy_DECREF(tmp);\n}\nif (last) {\ntmp = self->last;\nPy_INCREF(last);\nself->last = last;\nPy_DECREF(tmp);\n}\nreturn 0;\n}\n通过这些更改，我们能够确保 first 和 last 成员一定不为 NULL 以便我们能在几乎所有情况下移\n除 NULL 值检查。 这意味着大部分 Py_XDECREF() 调用都可以被转换为 Py_DECREF() 调用。 我们\n不能更改这些调用的唯一场合是在 tp_dealloc 实现中，那里这些成员的初始化有可能在 tp_new\n中失败。\n我们还重命名了模块初始化函数和初始化函数中的模块名称，就像我们之前所做的一样，我们还向\nsetup.py 文件添加了一个额外的定义。\n2.4. 支持循环垃圾回收\nPython 具有一个可以标识不再需要的对象的 循环垃圾回收器 (GC) 即使它们的引用计数并不为零。\n这种情况会在对象被循环引用时发生。 例如，设想:\n>>> l = []\n>>> l.append(l)\n>>> del l\n在这个例子中，我们创建了一个包含其自身的列表。 当我们删除它的时候，它将仍然具有一个来自\n其本身的引用。 它的引用计数并未降为零。 幸运的是，Python 的循环垃圾回收器将最终发现该列\n\n|  | static PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n}; |  |\n| --- | --- | --- |\n|  | 我们还需要将 tp_init 处理器更新为只允许传入字符串 [3]: |  |\n|  | static int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL, *tmp;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\ntmp = self->first;\nPy_INCREF(first);\nself->first = first;\nPy_DECREF(tmp);\n}\nif (last) {\ntmp = self->last;\nPy_INCREF(last);\nself->last = last;\nPy_DECREF(tmp);\n}\nreturn 0;\n} |  |\n|  | 通过这些更改，我们能够确保 first 和 last 成员一定不为 NULL 以便我们能在几乎所有情况下移\n除 NULL 值检查。 这意味着大部分 Py_XDECREF() 调用都可以被转换为 Py_DECREF() 调用。 我们\n不能更改这些调用的唯一场合是在 tp_dealloc 实现中，那里这些成员的初始化有可能在 tp_new\n中失败。\n我们还重命名了模块初始化函数和初始化函数中的模块名称，就像我们之前所做的一样，我们还向\nsetup.py 文件添加了一个额外的定义。\n2.4. 支持循环垃圾回收\nPython 具有一个可以标识不再需要的对象的 循环垃圾回收器 (GC) 即使它们的引用计数并不为零。\n这种情况会在对象被循环引用时发生。 例如，设想: |  |\n|  | >>> l = []\n>>> l.append(l)\n>>> del l |  |\n|  | 在这个例子中，我们创建了一个包含其自身的列表。 当我们删除它的时候，它将仍然具有一个来自\n其本身的引用。 它的引用计数并未降为零。 幸运的是，Python 的循环垃圾回收器将最终发现该列 |  |\n\n表是无用的垃圾并释放它。\n在 Custom 示例的第二个版本中，我们允许任意类型的对象存储到 first 或 last 属性中 [4]。 此\n外，在第二和第三个版本中，我们还允许子类化 Custom，并且子类可以添加任意属性。 出于这两\n个原因中的任何一个，Custom 对象都可以加入循环：\n>>> import custom3\n>>> class Derived(custom3.Custom): pass\n...\n>>> n = Derived()\n>>> n.some_attribute = n\n要允许一个加入引用循环的 Custom 实例能被循环 GC 正确检测和收集，我们的 Custom 类型需要填\n充两个额外的槽位并增加一个旗标来启用这些槽位：\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\nstatic int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nPy_VISIT(self->first);\nPy_VISIT(self->last);\nreturn 0;\n}\nstatic int\nCustom_clear(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_CLEAR(self->first);\nPy_CLEAR(self->last);\nreturn 0;\n}\nstatic void\nCustom_dealloc(PyObject *op)\n{\nPyObject_GC_UnTrack(op);\n(void)Custom_clear(op);\nPy_TYPE(op)->tp_free(op);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0);\n\n|  | 表是无用的垃圾并释放它。\n在 Custom 示例的第二个版本中，我们允许任意类型的对象存储到 first 或 last 属性中 [4]。 此\n外，在第二和第三个版本中，我们还允许子类化 Custom，并且子类可以添加任意属性。 出于这两\n个原因中的任何一个，Custom 对象都可以加入循环： |  |\n| --- | --- | --- |\n|  | >>> import custom3\n>>> class Derived(custom3.Custom): pass\n...\n>>> n = Derived()\n>>> n.some_attribute = n |  |\n|  | 要允许一个加入引用循环的 Custom 实例能被循环 GC 正确检测和收集，我们的 Custom 类型需要填\n充两个额外的槽位并增加一个旗标来启用这些槽位： |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <stddef.h> /* for offsetof() */\ntypedef struct {\nPyObject_HEAD\nPyObject *first; /* first name */\nPyObject *last; /* last name */\nint number;\n} CustomObject;\nstatic int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nPy_VISIT(self->first);\nPy_VISIT(self->last);\nreturn 0;\n}\nstatic int\nCustom_clear(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_CLEAR(self->first);\nPy_CLEAR(self->last);\nreturn 0;\n}\nstatic void\nCustom_dealloc(PyObject *op)\n{\nPyObject_GC_UnTrack(op);\n(void)Custom_clear(op);\nPy_TYPE(op)->tp_free(op);\n}\nstatic PyObject *\nCustom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\nCustomObject *self;\nself = (CustomObject *) type->tp_alloc(type, 0); |  |\n\nif (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_SETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_SETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_getfirst(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->first);\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\n|  | if (self != NULL) {\nself->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->first == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\nif (self->last == NULL) {\nPy_DECREF(self);\nreturn NULL;\n}\nself->number = 0;\n}\nreturn (PyObject *) self;\n}\nstatic int\nCustom_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nCustomObject *self = (CustomObject *) op;\nstatic char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\nPyObject *first = NULL, *last = NULL;\nif (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n&first, &last,\n&self->number))\nreturn -1;\nif (first) {\nPy_SETREF(self->first, Py_NewRef(first));\n}\nif (last) {\nPy_SETREF(self->last, Py_NewRef(last));\n}\nreturn 0;\n}\nstatic PyMemberDef Custom_members[] = {\n{\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n\"custom number\"},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_getfirst(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->first);\n}\nstatic int\nCustom_setfirst(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError, |  |\n| --- | --- | --- |\n\n\"The first attribute value must be a string\");\nreturn -1;\n}\nPy_XSETREF(self->first, Py_NewRef(value));\nreturn 0;\n}\nstatic PyObject *\nCustom_getlast(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->last);\n}\nstatic int\nCustom_setlast(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the last attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The last attribute value must be a string\");\nreturn -1;\n}\nPy_XSETREF(self->last, Py_NewRef(value));\nreturn 0;\n}\nstatic PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom4.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n\n|  | \"The first attribute value must be a string\");\nreturn -1;\n}\nPy_XSETREF(self->first, Py_NewRef(value));\nreturn 0;\n}\nstatic PyObject *\nCustom_getlast(PyObject *op, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nreturn Py_NewRef(self->last);\n}\nstatic int\nCustom_setlast(PyObject *op, PyObject *value, void *closure)\n{\nCustomObject *self = (CustomObject *) op;\nif (value == NULL) {\nPyErr_SetString(PyExc_TypeError, \"Cannot delete the last attribute\");\nreturn -1;\n}\nif (!PyUnicode_Check(value)) {\nPyErr_SetString(PyExc_TypeError,\n\"The last attribute value must be a string\");\nreturn -1;\n}\nPy_XSETREF(self->last, Py_NewRef(value));\nreturn 0;\n}\nstatic PyGetSetDef Custom_getsetters[] = {\n{\"first\", Custom_getfirst, Custom_setfirst,\n\"first name\", NULL},\n{\"last\", Custom_getlast, Custom_setlast,\n\"last name\", NULL},\n{NULL} /* Sentinel */\n};\nstatic PyObject *\nCustom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nCustomObject *self = (CustomObject *) op;\nreturn PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n}\nstatic PyMethodDef Custom_methods[] = {\n{\"name\", Custom_name, METH_NOARGS,\n\"Return the name, combining the first and last name\"\n},\n{NULL} /* Sentinel */\n};\nstatic PyTypeObject CustomType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"custom4.Custom\",\n.tp_doc = PyDoc_STR(\"Custom objects\"),\n.tp_basicsize = sizeof(CustomObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, |  |\n| --- | --- | --- |\n\n.tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_traverse = Custom_traverse,\n.tp_clear = Custom_clear,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n.tp_getset = Custom_getsetters,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom4\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom4(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n}\n首先，遍历方法让循环 GC 知道能够参加循环的子对象:\nstatic int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nint vret;\nif (self->first) {\nvret = visit(self->first, arg);\nif (vret != 0)\nreturn vret;\n}\nif (self->last) {\nvret = visit(self->last, arg);\nif (vret != 0)\n\n|  | .tp_new = Custom_new,\n.tp_init = Custom_init,\n.tp_dealloc = Custom_dealloc,\n.tp_traverse = Custom_traverse,\n.tp_clear = Custom_clear,\n.tp_members = Custom_members,\n.tp_methods = Custom_methods,\n.tp_getset = Custom_getsetters,\n};\nstatic int\ncustom_module_exec(PyObject *m)\n{\nif (PyType_Ready(&CustomType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot custom_module_slots[] = {\n{Py_mod_exec, custom_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef custom_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"custom4\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = custom_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_custom4(void)\n{\nreturn PyModuleDef_Init(&custom_module);\n} |  |\n| --- | --- | --- |\n|  | 首先，遍历方法让循环 GC 知道能够参加循环的子对象: |  |\n|  | static int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nint vret;\nif (self->first) {\nvret = visit(self->first, arg);\nif (vret != 0)\nreturn vret;\n}\nif (self->last) {\nvret = visit(self->last, arg);\nif (vret != 0) |  |\n\nreturn vret;\n}\nreturn 0;\n}\n对于每个可以加入循环的子对象，我们都需要调用 visit() 函数，它会被传递给遍历方法。\nvisit() 函数接受该子对象和传递给遍历方法的额外参数 arg 作为其参数。 它返回一个在其为非零\n值时必须被返回的整数值。\nPython 提供了一个可自动调用 visit 函数的 Py_VISIT() 宏。 使用 Py_VISIT()，我们可以最小化\nCustom_traverse 中的准备工作量:\nstatic int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nPy_VISIT(self->first);\nPy_VISIT(self->last);\nreturn 0;\n}\n备注: tp_traverse 实现必须将其参数准确命名为 visit 和 arg 以便使用 Py_VISIT()。\n第二，我们需要提供一个方法用来清除任何可以参加循环的子对象:\nstatic int\nCustom_clear(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_CLEAR(self->first);\nPy_CLEAR(self->last);\nreturn 0;\n}\n请注意 Py_CLEAR() 宏的使用。 它是清除任意类型的数据属性并减少其引用计数的推荐的且安全的\n方式。 如果你要选择在将属性设为 NULL 之间在属性上调用 Py_XDECREF()，则属性的析构器有可\n能会回调再次读取该属性的代码 (特别是 如果存在引用循环的话)。\n备注: 你可以通过以下写法来模拟 Py_CLEAR():\nPyObject *tmp;\ntmp = self->first;\nself->first = NULL;\nPy_XDECREF(tmp);\n无论如何，在删除属性时始终使用Nevertheless, it is much easier and less error-prone to always\nuse Py_CLEAR() 都是更简单且更不易出错的。 请不要尝试以健壮性为代价的微小优化！\n释放器 Custom_dealloc 可能会在清除属性时调用任意代码。 这意味着循环 GC 可以在函数内部被\n触发。 由于 GC 预期引用计数不为零，我们需要通过调用 PyObject_GC_UnTrack() 来让 GC 停止追\n\n|  | return vret;\n}\nreturn 0;\n} |  |\n| --- | --- | --- |\n|  | 对于每个可以加入循环的子对象，我们都需要调用 visit() 函数，它会被传递给遍历方法。\nvisit() 函数接受该子对象和传递给遍历方法的额外参数 arg 作为其参数。 它返回一个在其为非零\n值时必须被返回的整数值。\nPython 提供了一个可自动调用 visit 函数的 Py_VISIT() 宏。 使用 Py_VISIT()，我们可以最小化\nCustom_traverse 中的准备工作量: |  |\n|  | static int\nCustom_traverse(PyObject *op, visitproc visit, void *arg)\n{\nCustomObject *self = (CustomObject *) op;\nPy_VISIT(self->first);\nPy_VISIT(self->last);\nreturn 0;\n} |  |\n|  |  |  |\n|  | 备注: tp_traverse 实现必须将其参数准确命名为 visit 和 arg 以便使用 Py_VISIT()。 |  |\n|  | 第二，我们需要提供一个方法用来清除任何可以参加循环的子对象: |  |\n|  | static int\nCustom_clear(PyObject *op)\n{\nCustomObject *self = (CustomObject *) op;\nPy_CLEAR(self->first);\nPy_CLEAR(self->last);\nreturn 0;\n} |  |\n|  | 请注意 Py_CLEAR() 宏的使用。 它是清除任意类型的数据属性并减少其引用计数的推荐的且安全的\n方式。 如果你要选择在将属性设为 NULL 之间在属性上调用 Py_XDECREF()，则属性的析构器有可\n能会回调再次读取该属性的代码 (特别是 如果存在引用循环的话)。 |  |\n|  | 备注: 你可以通过以下写法来模拟 Py_CLEAR():\nPyObject *tmp;\ntmp = self->first;\nself->first = NULL;\nPy_XDECREF(tmp);\n无论如何，在删除属性时始终使用Nevertheless, it is much easier and less error-prone to always\nuse Py_CLEAR() 都是更简单且更不易出错的。 请不要尝试以健壮性为代价的微小优化！ |  |\n|  | 释放器 Custom_dealloc 可能会在清除属性时调用任意代码。 这意味着循环 GC 可以在函数内部被\n触发。 由于 GC 预期引用计数不为零，我们需要通过调用 PyObject_GC_UnTrack() 来让 GC 停止追 |  |\n\n踪相关的对象。 下面是我们使用 PyObject_GC_UnTrack() 和 Custom_clear 重新实现的释放器:\nstatic void\nCustom_dealloc(PyObject *op)\n{\nPyObject_GC_UnTrack(op);\n(void)Custom_clear(op);\nPy_TYPE(op)->tp_free(op);\n}\n最后，我们将 Py_TPFLAGS_HAVE_GC 旗标添加到类旗标中:\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n这样就差不多了。 如果我们编写了自定义的 tp_alloc 或 tp_free 处理器，则我们需要针对循环垃\n圾回收来修改它。 大多数扩展都将使用自动提供的版本。\n2.5. 子类化其他类型\n创建派生自现有类型的新类型是有可能的。 最容易的做法是从内置类型继承，因为扩展可以方便地\n使用它所需要的 PyTypeObject。 在不同扩展模块之间共享这些 PyTypeObject 结构体则是困难\n的。\n在本例中我们将创建一个继承自内置 list 类型的 SubList 类型。 这个新类型将完全兼容常规列\n表，但将拥有一个额外的 increment() 方法用于递增内部计数器的值：\n>>> import sublist\n>>> s = sublist.SubList(range(3))\n>>> s.extend(s)\n>>> print(len(s))\n6\n>>> print(s.increment())\n1\n>>> print(s.increment())\n2\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\ntypedef struct {\nPyListObject list;\nint state;\n} SubListObject;\nstatic PyObject *\nSubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nSubListObject *self = (SubListObject *) op;\nself->state++;\nreturn PyLong_FromLong(self->state);\n}\nstatic PyMethodDef SubList_methods[] = {\n{\"increment\", SubList_increment, METH_NOARGS,\n\n|  | 踪相关的对象。 下面是我们使用 PyObject_GC_UnTrack() 和 Custom_clear 重新实现的释放器: |  |\n| --- | --- | --- |\n|  | static void\nCustom_dealloc(PyObject *op)\n{\nPyObject_GC_UnTrack(op);\n(void)Custom_clear(op);\nPy_TYPE(op)->tp_free(op);\n} |  |\n|  | 最后，我们将 Py_TPFLAGS_HAVE_GC 旗标添加到类旗标中: |  |\n|  | .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, |  |\n|  | 这样就差不多了。 如果我们编写了自定义的 tp_alloc 或 tp_free 处理器，则我们需要针对循环垃\n圾回收来修改它。 大多数扩展都将使用自动提供的版本。\n2.5. 子类化其他类型\n创建派生自现有类型的新类型是有可能的。 最容易的做法是从内置类型继承，因为扩展可以方便地\n使用它所需要的 PyTypeObject。 在不同扩展模块之间共享这些 PyTypeObject 结构体则是困难\n的。\n在本例中我们将创建一个继承自内置 list 类型的 SubList 类型。 这个新类型将完全兼容常规列\n表，但将拥有一个额外的 increment() 方法用于递增内部计数器的值： |  |\n|  | >>> import sublist\n>>> s = sublist.SubList(range(3))\n>>> s.extend(s)\n>>> print(len(s))\n6\n>>> print(s.increment())\n1\n>>> print(s.increment())\n2 |  |\n|  |  |  |\n|  | #define PY_SSIZE_T_CLEAN\n#include <Python.h>\ntypedef struct {\nPyListObject list;\nint state;\n} SubListObject;\nstatic PyObject *\nSubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n{\nSubListObject *self = (SubListObject *) op;\nself->state++;\nreturn PyLong_FromLong(self->state);\n}\nstatic PyMethodDef SubList_methods[] = {\n{\"increment\", SubList_increment, METH_NOARGS, |  |\n\nPyDoc_STR(\"increment state counter\")},\n{NULL},\n};\nstatic int\nSubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nSubListObject *self = (SubListObject *) op;\nif (PyList_Type.tp_init(op, args, kwds) < 0)\nreturn -1;\nself->state = 0;\nreturn 0;\n}\nstatic PyTypeObject SubListType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"sublist.SubList\",\n.tp_doc = PyDoc_STR(\"SubList objects\"),\n.tp_basicsize = sizeof(SubListObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_init = SubList_init,\n.tp_methods = SubList_methods,\n};\nstatic int\nsublist_module_exec(PyObject *m)\n{\nSubListType.tp_base = &PyList_Type;\nif (PyType_Ready(&SubListType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot sublist_module_slots[] = {\n{Py_mod_exec, sublist_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef sublist_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"sublist\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = sublist_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_sublist(void)\n{\nreturn PyModuleDef_Init(&sublist_module);\n}\n\n|  | PyDoc_STR(\"increment state counter\")},\n{NULL},\n};\nstatic int\nSubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nSubListObject *self = (SubListObject *) op;\nif (PyList_Type.tp_init(op, args, kwds) < 0)\nreturn -1;\nself->state = 0;\nreturn 0;\n}\nstatic PyTypeObject SubListType = {\n.ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n.tp_name = \"sublist.SubList\",\n.tp_doc = PyDoc_STR(\"SubList objects\"),\n.tp_basicsize = sizeof(SubListObject),\n.tp_itemsize = 0,\n.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n.tp_init = SubList_init,\n.tp_methods = SubList_methods,\n};\nstatic int\nsublist_module_exec(PyObject *m)\n{\nSubListType.tp_base = &PyList_Type;\nif (PyType_Ready(&SubListType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\nstatic PyModuleDef_Slot sublist_module_slots[] = {\n{Py_mod_exec, sublist_module_exec},\n{Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n{0, NULL}\n};\nstatic PyModuleDef sublist_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"sublist\",\n.m_doc = \"Example module that creates an extension type.\",\n.m_size = 0,\n.m_slots = sublist_module_slots,\n};\nPyMODINIT_FUNC\nPyInit_sublist(void)\n{\nreturn PyModuleDef_Init(&sublist_module);\n} |  |\n| --- | --- | --- |\n|  |  |  |\n\n如你所见，此源代码与之前几节中的 Custom 示例非常相似。 我们将逐一分析它们之间的主要区\n别。\ntypedef struct {\nPyListObject list;\nint state;\n} SubListObject;\n派生类型对象的主要差异在于基类型的对象结构体必须是第一个值。 基类型将已经在其结构体的开\n头包括了 PyObject_HEAD()。\n当一个 Python 对象是 SubList 的实例时，它的 PyObject * 指针可以被安全地强制转换为\nPyListObject * 和 SubListObject *:\nstatic int\nSubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nSubListObject *self = (SubListObject *) op;\nif (PyList_Type.tp_init(op, args, kwds) < 0)\nreturn -1;\nself->state = 0;\nreturn 0;\n}\n我们可以在上面看到如何将调用传递到基类型的 __init__() 方法。\n这个模式在编写具有自定义 tp_new 和 tp_dealloc 成员的类型时很重要。 tp_new 处理器不应为具\n有 tp_alloc 的对象实际分配内存，而是让基类通过调用自己的 tp_new 来处理它。\nPyTypeObject 结构体支持用 tp_base 指定类型的实体基类。 由于跨平台编译器的问题，你无法以\n对 PyList_Type 的引用来直接填充该字段；它应当在 Py_mod_exec 函数中完成:\nstatic int\nsublist_module_exec(PyObject *m)\n{\nSubListType.tp_base = &PyList_Type;\nif (PyType_Ready(&SubListType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < 0) {\nreturn -1;\n}\nreturn 0;\n}\n在调用 PyType_Ready() 之前，类型结构体必须已经填充 tp_base 槽位。 当我们从现有类型派生\n时，它不需要将 tp_alloc 槽位填充为 PyType_GenericNew() -- 来自基类型的分配函数将会被继\n承。\n在那之后，调用 PyType_Ready() 并将类型对象添加到模块中的过程与基本的 Custom 示例是一样\n的。\n\n|  | 如你所见，此源代码与之前几节中的 Custom 示例非常相似。 我们将逐一分析它们之间的主要区\n别。 |  |\n| --- | --- | --- |\n|  | typedef struct {\nPyListObject list;\nint state;\n} SubListObject; |  |\n|  | 派生类型对象的主要差异在于基类型的对象结构体必须是第一个值。 基类型将已经在其结构体的开\n头包括了 PyObject_HEAD()。\n当一个 Python 对象是 SubList 的实例时，它的 PyObject * 指针可以被安全地强制转换为\nPyListObject * 和 SubListObject *: |  |\n|  | static int\nSubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n{\nSubListObject *self = (SubListObject *) op;\nif (PyList_Type.tp_init(op, args, kwds) < 0)\nreturn -1;\nself->state = 0;\nreturn 0;\n} |  |\n|  | 我们可以在上面看到如何将调用传递到基类型的 __init__() 方法。\n这个模式在编写具有自定义 tp_new 和 tp_dealloc 成员的类型时很重要。 tp_new 处理器不应为具\n有 tp_alloc 的对象实际分配内存，而是让基类通过调用自己的 tp_new 来处理它。\nPyTypeObject 结构体支持用 tp_base 指定类型的实体基类。 由于跨平台编译器的问题，你无法以\n对 PyList_Type 的引用来直接填充该字段；它应当在 Py_mod_exec 函数中完成: |  |\n|  | static int\nsublist_module_exec(PyObject *m)\n{\nSubListType.tp_base = &PyList_Type;\nif (PyType_Ready(&SubListType) < 0) {\nreturn -1;\n}\nif (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < 0) {\nreturn -1;\n}\nreturn 0;\n} |  |\n|  | 在调用 PyType_Ready() 之前，类型结构体必须已经填充 tp_base 槽位。 当我们从现有类型派生\n时，它不需要将 tp_alloc 槽位填充为 PyType_GenericNew() -- 来自基类型的分配函数将会被继\n承。\n在那之后，调用 PyType_Ready() 并将类型对象添加到模块中的过程与基本的 Custom 示例是一样\n的。 |  |\n\n脚注\n[1] 当我们知道该对象属于基本类型，如字符串或浮点数时情况就是如此。\n[2] 在本示例中我们需要 tp_dealloc 处理器中的这一机制，因为我们的类型不支持垃圾回收。\n[3] 现在我们知道 first 和 last 成员都是字符串，因此也许我们可以对减少它们的引用计数不必太过\n小心，但是，我们还接受字符串子类的实例。 即使释放普通字符串不会对我们的对象执行回\n调，我们也不能保证释放一个字符串子类的实例不会对我们的对象执行回调。\n[4] 而且，即使是将我们的属性限制为字符串实例，用户还是可以传入任意 str 子类因而仍能造成\n引用循环。", "metadata": {"title": "02_自定义扩展类型：教程", "source": "md_docs\\python_extending_md\\02_自定义扩展类型：教程.md", "doc_type": "扩展和嵌入", "language": "中文", "doc_id": "eb1bb820"}}
{"doc_id": "b5a517ca", "content": "3. 定义扩展类型：已分类主题\n本章节目标是提供一个各种你可以实现的类型方法及其功能的简短介绍。\n这是 C 类型 PyTypeObject 的定义，省略了只用于 调试构建 的字段：\ntypedef struct _typeobject {\nPyObject_VAR_HEAD\nconst char *tp_name; /* 用于打印，格式为 \"<module>.<name>\" */\nPy_ssize_t tp_basicsize, tp_itemsize; /* 用于分配 */\n/* 用于实现标准操作的方法 */\ndestructor tp_dealloc;\nPy_ssize_t tp_vectorcall_offset;\ngetattrfunc tp_getattr;\nsetattrfunc tp_setattr;\nPyAsyncMethods *tp_as_async; /* 原名为 tp_compare (Python 2)\n或 tp_reserved (Python 3) */\nreprfunc tp_repr;\n/* 用于标准类的方法集 */\nPyNumberMethods *tp_as_number;\nPySequenceMethods *tp_as_sequence;\nPyMappingMethods *tp_as_mapping;\n/* 更多标准操作 (这些用于二进制兼容) */\nhashfunc tp_hash;\nternaryfunc tp_call;\nreprfunc tp_str;\ngetattrofunc tp_getattro;\nsetattrofunc tp_setattro;\n/* 用于以输入/输出缓冲区方式访问对象的函数 */\nPyBufferProcs *tp_as_buffer;\n/* 用于定义可选/扩展特性是否存在的旗标 */\nunsigned long tp_flags;\nconst char *tp_doc; /* 文档字符串 */\n/* 在 2.0 发布版中分配的含义 */\n/* 为所有可访问的对象调用函数 */\ntraverseproc tp_traverse;\n/* 删除对所包含对象的引用 */\ninquiry tp_clear;\n/* 在 2.1 发布版中分配的含义 */\n/* 富比较操作 */\nrichcmpfunc tp_richcompare;\n\n| 3. 定义扩展类型：已分类主题\n本章节目标是提供一个各种你可以实现的类型方法及其功能的简短介绍。\n这是 C 类型 PyTypeObject 的定义，省略了只用于 调试构建 的字段： |\n| --- |\n| typedef struct _typeobject {\nPyObject_VAR_HEAD\nconst char *tp_name; /* 用于打印，格式为 \"<module>.<name>\" */\nPy_ssize_t tp_basicsize, tp_itemsize; /* 用于分配 */\n/* 用于实现标准操作的方法 */\ndestructor tp_dealloc;\nPy_ssize_t tp_vectorcall_offset;\ngetattrfunc tp_getattr;\nsetattrfunc tp_setattr;\nPyAsyncMethods *tp_as_async; /* 原名为 tp_compare (Python 2)\n或 tp_reserved (Python 3) */\nreprfunc tp_repr;\n/* 用于标准类的方法集 */\nPyNumberMethods *tp_as_number;\nPySequenceMethods *tp_as_sequence;\nPyMappingMethods *tp_as_mapping;\n/* 更多标准操作 (这些用于二进制兼容) */\nhashfunc tp_hash;\nternaryfunc tp_call;\nreprfunc tp_str;\ngetattrofunc tp_getattro;\nsetattrofunc tp_setattro;\n/* 用于以输入/输出缓冲区方式访问对象的函数 */\nPyBufferProcs *tp_as_buffer;\n/* 用于定义可选/扩展特性是否存在的旗标 */\nunsigned long tp_flags;\nconst char *tp_doc; /* 文档字符串 */\n/* 在 2.0 发布版中分配的含义 */\n/* 为所有可访问的对象调用函数 */\ntraverseproc tp_traverse;\n/* 删除对所包含对象的引用 */\ninquiry tp_clear;\n/* 在 2.1 发布版中分配的含义 */\n/* 富比较操作 */\nrichcmpfunc tp_richcompare; |\n\n/* 启用弱引用 */\nPy_ssize_t tp_weaklistoffset;\n/* 迭代器 */\ngetiterfunc tp_iter;\niternextfunc tp_iternext;\n/* 属性描述器和子类化内容 */\nPyMethodDef *tp_methods;\nPyMemberDef *tp_members;\nPyGetSetDef *tp_getset;\n// 堆类型的强引用，静态类型的借入引用\nPyTypeObject *tp_base;\nPyObject *tp_dict;\ndescrgetfunc tp_descr_get;\ndescrsetfunc tp_descr_set;\nPy_ssize_t tp_dictoffset;\ninitproc tp_init;\nallocfunc tp_alloc;\nnewfunc tp_new;\nfreefunc tp_free; /* 层级的释放内存例程 */\ninquiry tp_is_gc; /* 用于 PyObject_IS_GC */\nPyObject *tp_bases;\nPyObject *tp_mro; /* 方法解析顺序 */\nPyObject *tp_cache; /* 不再被使用 */\nvoid *tp_subclasses; /* 对于静态内置类型这将是一个索引 */\nPyObject *tp_weaklist; /* 不被用于静态内置类型 */\ndestructor tp_del;\n/* 类型属性缓存版本标签。 在 2.6 版中添加。\n* 如果为零，则缓存无效并且必须被初始化。\n*/\nunsigned int tp_version_tag;\ndestructor tp_finalize;\nvectorcallfunc tp_vectorcall;\n/* 类型监视器针对此类型的位设置 */\nunsigned char tp_watched;\n/* 使用的 tp_version_tag 值数量。\n* 如果针对此类型的属性缓存被禁用则设为 _Py_ATTR_CACHE_UNUSED\n* （例如由于自定义的 MRO 条目而被禁用）。\n* 在其他情况下，将被限制为 MAX_VERSIONS_PER_CLASS (在其他地方定义)。\n*/\nuint16_t tp_versions_used;\n} PyTypeObject;\n这里有 很多 方法。但是不要太担心，如果你要定义一个类型，通常只需要实现少量的方法。\n正如你猜到的一样，我们正要一步一步详细介绍各种处理程序。因为有大量的历史包袱影响字段的\n排序，所以我们不会根据它们在结构体里定义的顺序讲解。通常非常容易找到一个包含你需要的字\n段的例子，然后改变值去适应你新的类型。\nconst char *tp_name; /* 用于打印 */\n\n|  | /* 启用弱引用 */\nPy_ssize_t tp_weaklistoffset;\n/* 迭代器 */\ngetiterfunc tp_iter;\niternextfunc tp_iternext;\n/* 属性描述器和子类化内容 */\nPyMethodDef *tp_methods;\nPyMemberDef *tp_members;\nPyGetSetDef *tp_getset;\n// 堆类型的强引用，静态类型的借入引用\nPyTypeObject *tp_base;\nPyObject *tp_dict;\ndescrgetfunc tp_descr_get;\ndescrsetfunc tp_descr_set;\nPy_ssize_t tp_dictoffset;\ninitproc tp_init;\nallocfunc tp_alloc;\nnewfunc tp_new;\nfreefunc tp_free; /* 层级的释放内存例程 */\ninquiry tp_is_gc; /* 用于 PyObject_IS_GC */\nPyObject *tp_bases;\nPyObject *tp_mro; /* 方法解析顺序 */\nPyObject *tp_cache; /* 不再被使用 */\nvoid *tp_subclasses; /* 对于静态内置类型这将是一个索引 */\nPyObject *tp_weaklist; /* 不被用于静态内置类型 */\ndestructor tp_del;\n/* 类型属性缓存版本标签。 在 2.6 版中添加。\n* 如果为零，则缓存无效并且必须被初始化。\n*/\nunsigned int tp_version_tag;\ndestructor tp_finalize;\nvectorcallfunc tp_vectorcall;\n/* 类型监视器针对此类型的位设置 */\nunsigned char tp_watched;\n/* 使用的 tp_version_tag 值数量。\n* 如果针对此类型的属性缓存被禁用则设为 _Py_ATTR_CACHE_UNUSED\n* （例如由于自定义的 MRO 条目而被禁用）。\n* 在其他情况下，将被限制为 MAX_VERSIONS_PER_CLASS (在其他地方定义)。\n*/\nuint16_t tp_versions_used;\n} PyTypeObject; |  |\n| --- | --- | --- |\n|  | 这里有 很多 方法。但是不要太担心，如果你要定义一个类型，通常只需要实现少量的方法。\n正如你猜到的一样，我们正要一步一步详细介绍各种处理程序。因为有大量的历史包袱影响字段的\n排序，所以我们不会根据它们在结构体里定义的顺序讲解。通常非常容易找到一个包含你需要的字\n段的例子，然后改变值去适应你新的类型。 |  |\n|  | const char *tp_name; /* 用于打印 */ |  |\n|  |  |  |\n\n类型的名字 - 上一章提到过的，会出现在很多地方，几乎全部都是为了诊断目的。尝试选择一个好\n名字，对于诊断很有帮助。\nPy_ssize_t tp_basicsize, tp_itemsize; /* 用于分配 */\n这些字段告诉运行时在创造这个类型的新对象时需要分配多少内存。Python为了可变长度的结构\n（想下：字符串，元组）有些内置支持，这是 tp_itemsize 字段存在的原由。这部分稍后解释。\nconst char *tp_doc;\n这里你可以放置一段字符串（或者它的地址），当你想在Python脚本引用 obj.__doc__ 时返回这段\n文档字符串。\n现在我们来看一下基本类型方法 - 大多数扩展类型将实现的方法。\n3.1. 终结和内存释放\ndestructor tp_dealloc;\n当您的类型实例的引用计数减少为零并且Python解释器想要回收它时，将调用此函数。如果你的类\n型有内存可供释放或执行其他清理，你可以把它放在这里。 对象本身也需要在这里释放。 以下是此\n函数的示例：\nstatic void\nnewdatatype_dealloc(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nfree(self->obj_UnderlyingDatatypePtr);\nPy_TYPE(self)->tp_free(self);\n}\n如果你的类型支持垃圾回收，则析构器应当在清理任何成员字段之前调用 PyObject_GC_UnTrack():\nstatic void\nnewdatatype_dealloc(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nPyObject_GC_UnTrack(op);\nPy_CLEAR(self->other_obj);\n...\nPy_TYPE(self)->tp_free(self);\n}\n一个重要的释放器函数实现要求是把所有未决异常放着不动。这很重要是因为释放器会被解释器频\n繁的调用，当栈异常退出时(而非正常返回)，不会有任何办法保护释放器看到一个异常尚未被设置。\n此事释放器的任何行为都会导致额外增加的Python代码来检查异常是否被设置。这可能导致解释器\n的误导性错误。正确的保护方法是，在任何不安全的操作前，保存未决异常，然后在其完成后恢\n复。者可以通过 PyErr_Fetch() 和 PyErr_Restore() 函数来实现:\n\n|  | 类型的名字 - 上一章提到过的，会出现在很多地方，几乎全部都是为了诊断目的。尝试选择一个好\n名字，对于诊断很有帮助。 |  |\n| --- | --- | --- |\n|  | Py_ssize_t tp_basicsize, tp_itemsize; /* 用于分配 */ |  |\n|  | 这些字段告诉运行时在创造这个类型的新对象时需要分配多少内存。Python为了可变长度的结构\n（想下：字符串，元组）有些内置支持，这是 tp_itemsize 字段存在的原由。这部分稍后解释。 |  |\n|  | const char *tp_doc; |  |\n|  | 这里你可以放置一段字符串（或者它的地址），当你想在Python脚本引用 obj.__doc__ 时返回这段\n文档字符串。\n现在我们来看一下基本类型方法 - 大多数扩展类型将实现的方法。\n3.1. 终结和内存释放 |  |\n|  | destructor tp_dealloc; |  |\n|  | 当您的类型实例的引用计数减少为零并且Python解释器想要回收它时，将调用此函数。如果你的类\n型有内存可供释放或执行其他清理，你可以把它放在这里。 对象本身也需要在这里释放。 以下是此\n函数的示例： |  |\n|  | static void\nnewdatatype_dealloc(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nfree(self->obj_UnderlyingDatatypePtr);\nPy_TYPE(self)->tp_free(self);\n} |  |\n|  | 如果你的类型支持垃圾回收，则析构器应当在清理任何成员字段之前调用 PyObject_GC_UnTrack(): |  |\n|  | static void\nnewdatatype_dealloc(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nPyObject_GC_UnTrack(op);\nPy_CLEAR(self->other_obj);\n...\nPy_TYPE(self)->tp_free(self);\n} |  |\n|  | 一个重要的释放器函数实现要求是把所有未决异常放着不动。这很重要是因为释放器会被解释器频\n繁的调用，当栈异常退出时(而非正常返回)，不会有任何办法保护释放器看到一个异常尚未被设置。\n此事释放器的任何行为都会导致额外增加的Python代码来检查异常是否被设置。这可能导致解释器\n的误导性错误。正确的保护方法是，在任何不安全的操作前，保存未决异常，然后在其完成后恢\n复。者可以通过 PyErr_Fetch() 和 PyErr_Restore() 函数来实现: |  |\n\nstatic void\nmy_dealloc(PyObject *obj)\n{\nMyObject *self = (MyObject *) obj;\nPyObject *cbresult;\nif (self->my_callback != NULL) {\nPyObject *err_type, *err_value, *err_traceback;\n/* 这里保存当前异常状态 */\nPyErr_Fetch(&err_type, &err_value, &err_traceback);\ncbresult = PyObject_CallNoArgs(self->my_callback);\nif (cbresult == NULL) {\nPyErr_WriteUnraisable(self->my_callback);\n}\nelse {\nPy_DECREF(cbresult);\n}\n/* 这里恢复被保存的异常状态 */\nPyErr_Restore(err_type, err_value, err_traceback);\nPy_DECREF(self->my_callback);\n}\nPy_TYPE(self)->tp_free(self);\n}\n备注: 你能在释放器函数中安全执行的操作是有限的。 首先，如果你的类型支持垃圾回收 (使用\ntp_traverse 和/或 tp_clear)，对象的部分成员可以在调用 tp_dealloc 时被清空或终结。 其\n次，在 tp_dealloc 中，你的对象将处于不稳定状态：它的引用计数等于零。 任何对非琐碎对象\n或 API 的调用 (如上面的示例所做的) 最终都可能会再次调用 tp_dealloc，导致双重释放并发生\n崩溃。\n从 Python 3.4 开始，推荐不要在 tp_dealloc 放复杂的终结代码，而是使用新的 tp_finalize\n类型方法。\n参见: PEP 442 解释了新的终结方案。\n3.2. 对象展示\n在 Python 中，有两种方式可以生成对象的文本表示: repr() 函数和 str() 函数。 (print() 函数会\n直接调用 str()。) 这些处理程序都是可选的。\nreprfunc tp_repr;\nreprfunc tp_str;\ntp_repr 处理程序应该返回一个字符串对象，其中包含调用它的实例的表示形式。 下面是一个简单\n的例子:\nstatic PyObject *\nnewdatatype_repr(PyObject *op)\n\n|  | static void\nmy_dealloc(PyObject *obj)\n{\nMyObject *self = (MyObject *) obj;\nPyObject *cbresult;\nif (self->my_callback != NULL) {\nPyObject *err_type, *err_value, *err_traceback;\n/* 这里保存当前异常状态 */\nPyErr_Fetch(&err_type, &err_value, &err_traceback);\ncbresult = PyObject_CallNoArgs(self->my_callback);\nif (cbresult == NULL) {\nPyErr_WriteUnraisable(self->my_callback);\n}\nelse {\nPy_DECREF(cbresult);\n}\n/* 这里恢复被保存的异常状态 */\nPyErr_Restore(err_type, err_value, err_traceback);\nPy_DECREF(self->my_callback);\n}\nPy_TYPE(self)->tp_free(self);\n} |  |\n| --- | --- | --- |\n|  |  |  |\n|  | 备注: 你能在释放器函数中安全执行的操作是有限的。 首先，如果你的类型支持垃圾回收 (使用\ntp_traverse 和/或 tp_clear)，对象的部分成员可以在调用 tp_dealloc 时被清空或终结。 其\n次，在 tp_dealloc 中，你的对象将处于不稳定状态：它的引用计数等于零。 任何对非琐碎对象\n或 API 的调用 (如上面的示例所做的) 最终都可能会再次调用 tp_dealloc，导致双重释放并发生\n崩溃。\n从 Python 3.4 开始，推荐不要在 tp_dealloc 放复杂的终结代码，而是使用新的 tp_finalize\n类型方法。\n参见: PEP 442 解释了新的终结方案。 |  |\n|  | 3.2. 对象展示\n在 Python 中，有两种方式可以生成对象的文本表示: repr() 函数和 str() 函数。 (print() 函数会\n直接调用 str()。) 这些处理程序都是可选的。 |  |\n|  | reprfunc tp_repr;\nreprfunc tp_str; |  |\n|  | tp_repr 处理程序应该返回一个字符串对象，其中包含调用它的实例的表示形式。 下面是一个简单\n的例子: |  |\n|  | static PyObject *\nnewdatatype_repr(PyObject *op) |  |\n\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nreturn PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\nself->obj_UnderlyingDatatypePtr->size);\n}\n如果没有指定 tp_repr 处理器，解释器将提供一个使用类型的 tp_name 的表示形式以及对象的唯一\n标识值。\ntp_str 处理器对于 str() 就如上述的 tp_repr 处理器对于 repr() 一样；也就是说，它会在当\nPython 代码在你的对象的某个实例上调用 str() 时被调用。 它的实现与 tp_repr 函数非常相似，\n但其结果字符串是供人类查看的。 如果未指定 tp_str，则会使用 tp_repr 处理器来代替。\n下面是一个简单的例子:\nstatic PyObject *\nnewdatatype_str(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nreturn PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\nself->obj_UnderlyingDatatypePtr->size);\n}\n3.3. 属性管理\n对于每个可支持属性操作的对象，相应的类型必须提供用于控制属性获取方式的函数。 需要有一个\n能够检索属性的函数（如果定义了任何属性）还要有另一个函数负责设置属性（如果允许设置属\n性）。 移除属性是一种特殊情况，在此情况下要传给处理器的新值为 NULL。\nPython 支持两对属性处理器；一个支持属性操作的类型只需要实现其中一对的函数。 两者的差别在\n于一对接受 char* 作为属性名称，而另一对则接受 PyObject*。 每种类型都可以选择使用对于实现\n的便利性来说更有意义的那一对。\ngetattrfunc tp_getattr; /* char * 版本 */\nsetattrfunc tp_setattr;\n/* ... */\ngetattrofunc tp_getattro; /* PyObject * 版本 */\nsetattrofunc tp_setattro;\n如果访问一个对象的属性总是为简单操作（这将在下文进行解释），则有一些泛用实现可被用来提\n供 PyObject* 版本的属性管理函数。 从 Python 2.2 开始对于类型专属的属性处理器的实际需要几\n乎已完全消失，尽管还存在着许多尚未理新为使用某种新的可选泛用机制的例子。\n3.3.1. 泛型属性管理\n大多数扩展类型只使用 简单 属性，那么，是什么让属性变得“简单”呢？只需要满足下面几个条件：\n1. 当调用 PyType_Ready() 时，必须知道属性的名称。\n2. 不需要特殊的处理来记录属性是否被查找或设置，也不需要根据值采取操作。\n请注意，此列表不对属性的值、值的计算时间或相关数据的存储方式施加任何限制。\n\n|  | {\nnewdatatypeobject *self = (newdatatypeobject *) op;\nreturn PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\nself->obj_UnderlyingDatatypePtr->size);\n} |  |\n| --- | --- | --- |\n|  | 如果没有指定 tp_repr 处理器，解释器将提供一个使用类型的 tp_name 的表示形式以及对象的唯一\n标识值。\ntp_str 处理器对于 str() 就如上述的 tp_repr 处理器对于 repr() 一样；也就是说，它会在当\nPython 代码在你的对象的某个实例上调用 str() 时被调用。 它的实现与 tp_repr 函数非常相似，\n但其结果字符串是供人类查看的。 如果未指定 tp_str，则会使用 tp_repr 处理器来代替。\n下面是一个简单的例子: |  |\n|  | static PyObject *\nnewdatatype_str(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nreturn PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\nself->obj_UnderlyingDatatypePtr->size);\n} |  |\n|  | 3.3. 属性管理\n对于每个可支持属性操作的对象，相应的类型必须提供用于控制属性获取方式的函数。 需要有一个\n能够检索属性的函数（如果定义了任何属性）还要有另一个函数负责设置属性（如果允许设置属\n性）。 移除属性是一种特殊情况，在此情况下要传给处理器的新值为 NULL。\nPython 支持两对属性处理器；一个支持属性操作的类型只需要实现其中一对的函数。 两者的差别在\n于一对接受 char* 作为属性名称，而另一对则接受 PyObject*。 每种类型都可以选择使用对于实现\n的便利性来说更有意义的那一对。 |  |\n|  | getattrfunc tp_getattr; /* char * 版本 */\nsetattrfunc tp_setattr;\n/* ... */\ngetattrofunc tp_getattro; /* PyObject * 版本 */\nsetattrofunc tp_setattro; |  |\n|  | 如果访问一个对象的属性总是为简单操作（这将在下文进行解释），则有一些泛用实现可被用来提\n供 PyObject* 版本的属性管理函数。 从 Python 2.2 开始对于类型专属的属性处理器的实际需要几\n乎已完全消失，尽管还存在着许多尚未理新为使用某种新的可选泛用机制的例子。\n3.3.1. 泛型属性管理\n大多数扩展类型只使用 简单 属性，那么，是什么让属性变得“简单”呢？只需要满足下面几个条件：\n1. 当调用 PyType_Ready() 时，必须知道属性的名称。\n2. 不需要特殊的处理来记录属性是否被查找或设置，也不需要根据值采取操作。\n请注意，此列表不对属性的值、值的计算时间或相关数据的存储方式施加任何限制。 |  |\n\n当 PyType_Ready() 被调用时，它会使用由类型对象所引用的三个表来创建要放置到类型对象的字\n典中的 descriptor。 每个描述器控制对实例对象的一个属性的访问。 每个表都是可选的；如果三个\n表全都为 NULL，则该类型的实例将只有从它们的基础类型继承来的属性，并且还应当让\ntp_getattro 和 tp_setattro 字段保持为 NULL，以允许由基础类型处理这些属性。\n表被声明为object::类型的三个字段:\nstruct PyMethodDef *tp_methods;\nstruct PyMemberDef *tp_members;\nstruct PyGetSetDef *tp_getset;\n如果 tp_methods 不为 NULL，则它必须指向一个由 PyMethodDef 结构体组成的数组。 表中的每个\n条目都是该结构体的一个实例:\ntypedef struct PyMethodDef {\nconst char *ml_name; /* 方法名称 */\nPyCFunction ml_meth; /* 实现函数 */\nint ml_flags; /* 旗标 */\nconst char *ml_doc; /* 文档字符串 */\n} PyMethodDef;\n应当为该类型所提供的每个方法都应定义一个条目；从基类型继承来的方法无需定义条目。 还需要\n在末尾加一个额外的条目；它是一个标记数组结束的哨兵条目。 该哨兵条目的 ml_name 字段必须为\nNULL。\n第二个表被用来定义要直接映射到实例中的数据的属性。 各种原始 C 类型均受到支持，并且访问方\n式可以为只读或读写。 表中的结构体被定义为:\ntypedef struct PyMemberDef {\nconst char *name;\nint type;\nint offset;\nint flags;\nconst char *doc;\n} PyMemberDef;\n对于表中的每个条目，都将构建一个 descriptor 并添加到类型中使其能够从实例结构体中提取值。\ntype 字段应包含一个类型代码如 Py_T_INT 或 Py_T_DOUBLE；该值将用于确定如何将 Python 值转\n换为 C 值或反之。 flags 字段用于保存控制属性要如何被访问的旗标：你可以将其设为\nPy_READONLY 以防止 Python 代码设置它。\n使用 tp_members 表来构建用于运行时的描述器还有一个有趣的优点是任何以这种方式定义的属性\n都可以简单地通过在表中提供文本来设置一个相关联的文档字符串。 一个应用程序可以使用自省\nAPI 从类对象获取描述器，并使用其 __doc__ 属性来获取文档字符串。\n与 tp_methods 表一样，需要有一个值为 NULL 的 ml_name 哨兵条目。\n3.3.2. 类型专属的属性管理\n\n|  | 当 PyType_Ready() 被调用时，它会使用由类型对象所引用的三个表来创建要放置到类型对象的字\n典中的 descriptor。 每个描述器控制对实例对象的一个属性的访问。 每个表都是可选的；如果三个\n表全都为 NULL，则该类型的实例将只有从它们的基础类型继承来的属性，并且还应当让\ntp_getattro 和 tp_setattro 字段保持为 NULL，以允许由基础类型处理这些属性。\n表被声明为object::类型的三个字段: |  |\n| --- | --- | --- |\n|  | struct PyMethodDef *tp_methods;\nstruct PyMemberDef *tp_members;\nstruct PyGetSetDef *tp_getset; |  |\n|  | 如果 tp_methods 不为 NULL，则它必须指向一个由 PyMethodDef 结构体组成的数组。 表中的每个\n条目都是该结构体的一个实例: |  |\n|  | typedef struct PyMethodDef {\nconst char *ml_name; /* 方法名称 */\nPyCFunction ml_meth; /* 实现函数 */\nint ml_flags; /* 旗标 */\nconst char *ml_doc; /* 文档字符串 */\n} PyMethodDef; |  |\n|  | 应当为该类型所提供的每个方法都应定义一个条目；从基类型继承来的方法无需定义条目。 还需要\n在末尾加一个额外的条目；它是一个标记数组结束的哨兵条目。 该哨兵条目的 ml_name 字段必须为\nNULL。\n第二个表被用来定义要直接映射到实例中的数据的属性。 各种原始 C 类型均受到支持，并且访问方\n式可以为只读或读写。 表中的结构体被定义为: |  |\n|  | typedef struct PyMemberDef {\nconst char *name;\nint type;\nint offset;\nint flags;\nconst char *doc;\n} PyMemberDef; |  |\n|  | 对于表中的每个条目，都将构建一个 descriptor 并添加到类型中使其能够从实例结构体中提取值。\ntype 字段应包含一个类型代码如 Py_T_INT 或 Py_T_DOUBLE；该值将用于确定如何将 Python 值转\n换为 C 值或反之。 flags 字段用于保存控制属性要如何被访问的旗标：你可以将其设为\nPy_READONLY 以防止 Python 代码设置它。\n使用 tp_members 表来构建用于运行时的描述器还有一个有趣的优点是任何以这种方式定义的属性\n都可以简单地通过在表中提供文本来设置一个相关联的文档字符串。 一个应用程序可以使用自省\nAPI 从类对象获取描述器，并使用其 __doc__ 属性来获取文档字符串。\n与 tp_methods 表一样，需要有一个值为 NULL 的 ml_name 哨兵条目。\n3.3.2. 类型专属的属性管理 |  |\n\n为了简单起见，这里只演示 char* 版本； name 形参的类型是 char* 和 PyObject* 风格接口之间\n的唯一区别。 这个示例实际上做了与上面的泛用示例相同的事情，但没有使用在 Python 2.2 中增加\n的泛用支持。 它解释了处理器函数是如何被调用的，因此如果你确实需要扩展它们的功能，你就会\n明白有什么是需要做的。\ntp_getattr 处理器会在对象需要进行属性查找时被调用。 它被调用的场合与一个类的\n__getattr__() 方法要被调用的场合相同。\n例如：\nstatic PyObject *\nnewdatatype_getattr(PyObject *op, char *name)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nif (strcmp(name, \"data\") == 0) {\nreturn PyLong_FromLong(self->data);\n}\nPyErr_Format(PyExc_AttributeError,\n\"'%.100s' object has no attribute '%.400s'\",\nPy_TYPE(self)->tp_name, name);\nreturn NULL;\n}\n当调用类实例的 __setattr__() 或 __delattr__() 方法时会调用 tp_setattr 处理器。 当需要删\n除一个属性时，第三个形参将为 NULL。 下面是一个简单地引发异常的例子；如果这确实是你想要\n的，则 tp_setattr 处理器应当被设为 NULL。\nstatic int\nnewdatatype_setattr(PyObject *op, char *name, PyObject *v)\n{\nPyErr_Format(PyExc_RuntimeError, \"Read-only attribute: %s\", name);\nreturn -1;\n}\n3.4. 对象比较\nrichcmpfunc tp_richcompare;\ntp_richcompare 处理器会在需要进行比较时被调用。 它类似于 富比较方法，例如 __lt__()，并\n会被 PyObject_RichCompare() 和 PyObject_RichCompareBool() 调用。\n此函数被调用时将传入两个 Python 对象和运算符作为参数，其中运算符为 Py_EQ, Py_NE, Py_LE,\nPy_GE, Py_LT 或 Py_GT 之一。 它应当使用指定的运算符来比较两个对象并在比较操作成功时返回\nPy_True 或 Py_False，如果比较操作未被实现并应尝试其他对象比较方法时则返回\nPy_NotImplemented，或者如果设置了异常则返回 NULL。\n下面是一个示例实现，该数据类型如果内部指针的大小相等就认为是相等的:\nstatic PyObject *\nnewdatatype_richcmp(PyObject *lhs, PyObject *rhs, int op)\n\n|  | 为了简单起见，这里只演示 char* 版本； name 形参的类型是 char* 和 PyObject* 风格接口之间\n的唯一区别。 这个示例实际上做了与上面的泛用示例相同的事情，但没有使用在 Python 2.2 中增加\n的泛用支持。 它解释了处理器函数是如何被调用的，因此如果你确实需要扩展它们的功能，你就会\n明白有什么是需要做的。\ntp_getattr 处理器会在对象需要进行属性查找时被调用。 它被调用的场合与一个类的\n__getattr__() 方法要被调用的场合相同。\n例如： |  |\n| --- | --- | --- |\n|  | static PyObject *\nnewdatatype_getattr(PyObject *op, char *name)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nif (strcmp(name, \"data\") == 0) {\nreturn PyLong_FromLong(self->data);\n}\nPyErr_Format(PyExc_AttributeError,\n\"'%.100s' object has no attribute '%.400s'\",\nPy_TYPE(self)->tp_name, name);\nreturn NULL;\n} |  |\n|  | 当调用类实例的 __setattr__() 或 __delattr__() 方法时会调用 tp_setattr 处理器。 当需要删\n除一个属性时，第三个形参将为 NULL。 下面是一个简单地引发异常的例子；如果这确实是你想要\n的，则 tp_setattr 处理器应当被设为 NULL。 |  |\n|  | static int\nnewdatatype_setattr(PyObject *op, char *name, PyObject *v)\n{\nPyErr_Format(PyExc_RuntimeError, \"Read-only attribute: %s\", name);\nreturn -1;\n} |  |\n|  | 3.4. 对象比较 |  |\n|  | richcmpfunc tp_richcompare; |  |\n|  | tp_richcompare 处理器会在需要进行比较时被调用。 它类似于 富比较方法，例如 __lt__()，并\n会被 PyObject_RichCompare() 和 PyObject_RichCompareBool() 调用。\n此函数被调用时将传入两个 Python 对象和运算符作为参数，其中运算符为 Py_EQ, Py_NE, Py_LE,\nPy_GE, Py_LT 或 Py_GT 之一。 它应当使用指定的运算符来比较两个对象并在比较操作成功时返回\nPy_True 或 Py_False，如果比较操作未被实现并应尝试其他对象比较方法时则返回\nPy_NotImplemented，或者如果设置了异常则返回 NULL。\n下面是一个示例实现，该数据类型如果内部指针的大小相等就认为是相等的: |  |\n|  | static PyObject *\nnewdatatype_richcmp(PyObject *lhs, PyObject *rhs, int op) |  |\n\n{\nnewdatatypeobject *obj1 = (newdatatypeobject *) lhs;\nnewdatatypeobject *obj2 = (newdatatypeobject *) rhs;\nPyObject *result;\nint c, size1, size2;\n/* 省略了确保两个参数均为\nnewdatatype 类型的代码 */\nsize1 = obj1->obj_UnderlyingDatatypePtr->size;\nsize2 = obj2->obj_UnderlyingDatatypePtr->size;\nswitch (op) {\ncase Py_LT: c = size1 < size2; break;\ncase Py_LE: c = size1 <= size2; break;\ncase Py_EQ: c = size1 == size2; break;\ncase Py_NE: c = size1 != size2; break;\ncase Py_GT: c = size1 > size2; break;\ncase Py_GE: c = size1 >= size2; break;\n}\nresult = c ? Py_True : Py_False;\nreturn Py_NewRef(result);\n}\n3.5. 抽象协议支持\nPython 支持多种 抽象 '协议'；被提供来使用这些接口的专门接口说明请在 抽象对象层 中查看。\n这些抽象接口很多都是在 Python 实现开发的早期被定义的。 特别地，数字、映射和序列协议从一\n开始就已经是 Python 的组成部分。 其他协议则是后来添加的。 对于依赖某些来自类型实现的处理\n器例程的协议来说，较旧的协议被定义为类型对象所引用的处理器的可选块。 对于较新的协议来说\n在主类型对象中还有额外的槽位，并带有一个预设旗标位来指明存在该槽位并应当由解释器来检\n查。 （此旗标位并不会指明槽位值非 NULL 的情况，可以设置该旗标来指明一个槽位的存在，但此\n本位仍可能保持未填充的状态。）\nPyNumberMethods *tp_as_number;\nPySequenceMethods *tp_as_sequence;\nPyMappingMethods *tp_as_mapping;\n如果你希望你的对象的行为类似一个数字、序列或映射对象，那么你就要分别放置一个实现了 C 类\n型 PyNumberMethods, PySequenceMethods 或 PyMappingMethods, 的结构体的地址。 你要负责将\n适当的值填入这些结构体。 你可以在 Python 源代码发布版的 Objects 目录中找到这些对象各自的\n用法示例。\nhashfunc tp_hash;\n如果你选择提供此函数，则它应当为你的数据类型的实例返回一个哈希数值。 下面是一个简单的示\n例:\nstatic Py_hash_t\nnewdatatype_hash(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\n\n|  | {\nnewdatatypeobject *obj1 = (newdatatypeobject *) lhs;\nnewdatatypeobject *obj2 = (newdatatypeobject *) rhs;\nPyObject *result;\nint c, size1, size2;\n/* 省略了确保两个参数均为\nnewdatatype 类型的代码 */\nsize1 = obj1->obj_UnderlyingDatatypePtr->size;\nsize2 = obj2->obj_UnderlyingDatatypePtr->size;\nswitch (op) {\ncase Py_LT: c = size1 < size2; break;\ncase Py_LE: c = size1 <= size2; break;\ncase Py_EQ: c = size1 == size2; break;\ncase Py_NE: c = size1 != size2; break;\ncase Py_GT: c = size1 > size2; break;\ncase Py_GE: c = size1 >= size2; break;\n}\nresult = c ? Py_True : Py_False;\nreturn Py_NewRef(result);\n} |  |\n| --- | --- | --- |\n|  | 3.5. 抽象协议支持\nPython 支持多种 抽象 '协议'；被提供来使用这些接口的专门接口说明请在 抽象对象层 中查看。\n这些抽象接口很多都是在 Python 实现开发的早期被定义的。 特别地，数字、映射和序列协议从一\n开始就已经是 Python 的组成部分。 其他协议则是后来添加的。 对于依赖某些来自类型实现的处理\n器例程的协议来说，较旧的协议被定义为类型对象所引用的处理器的可选块。 对于较新的协议来说\n在主类型对象中还有额外的槽位，并带有一个预设旗标位来指明存在该槽位并应当由解释器来检\n查。 （此旗标位并不会指明槽位值非 NULL 的情况，可以设置该旗标来指明一个槽位的存在，但此\n本位仍可能保持未填充的状态。） |  |\n|  | PyNumberMethods *tp_as_number;\nPySequenceMethods *tp_as_sequence;\nPyMappingMethods *tp_as_mapping; |  |\n|  | 如果你希望你的对象的行为类似一个数字、序列或映射对象，那么你就要分别放置一个实现了 C 类\n型 PyNumberMethods, PySequenceMethods 或 PyMappingMethods, 的结构体的地址。 你要负责将\n适当的值填入这些结构体。 你可以在 Python 源代码发布版的 Objects 目录中找到这些对象各自的\n用法示例。 |  |\n|  | hashfunc tp_hash; |  |\n|  | 如果你选择提供此函数，则它应当为你的数据类型的实例返回一个哈希数值。 下面是一个简单的示\n例: |  |\n|  | static Py_hash_t\nnewdatatype_hash(PyObject *op)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op; |  |\n\nPy_hash_t result;\nresult = self->some_size + 32767 * self->some_number;\nif (result == -1) {\nresult = -2;\n}\nreturn result;\n}\nPy_hash_t 是一个在宽度取决于具体平台的有符号整数类型。 从 tp_hash 返回 -1 表示发生了错\n误，这就是为什么你应当注意避免在哈希运算成功时返回它，如上面所演示的。\nternaryfunc tp_call;\n此函数会在“调用”你的数据类型实例时被调用，举例来说，如果 obj1 是你的数据类型的实例而\nPython 脚本包含了 obj1('hello')，则将唤起 tp_call 处理器。\n此函数接受三个参数:\n1. self 是作为调用目标的数据类型实例。 如果调用是 obj1('hello')，则 self 为 obj1。\n2. args 是包含调用参数的元组。 你可以使用 PyArg_ParseTuple() 来提取参数。\n3. kwds 是由传入的关键字参数组成的字典。 如果它不为 NULL 且你支持关键字参数，则可使用\nPyArg_ParseTupleAndKeywords() 来提取参数。 如果你不想支持关键字参数而它为非 NULL\n值，则会引发 TypeError 并附带一个提示不支持关键字参数的消息。\n下面是一个演示性的 tp_call 实现:\nstatic PyObject *\nnewdatatype_call(PyObject *op, PyObject *args, PyObject *kwds)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nPyObject *result;\nconst char *arg1;\nconst char *arg2;\nconst char *arg3;\nif (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\nreturn NULL;\n}\nresult = PyUnicode_FromFormat(\n\"Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\",\nself->obj_UnderlyingDatatypePtr->size,\narg1, arg2, arg3);\nreturn result;\n}\n/* Iterators */\ngetiterfunc tp_iter;\niternextfunc tp_iternext;\n这些函数提供了对迭代器协议的支持。 这两个处理器都只接受一个形参，即它们被调用时所使用的\n实例，并返回一个新的引用。 当发生错误时，它们应设置一个异常并返回 NULL。 tp_iter 对应于\nPython __iter__() 方法，而 tp_iternext 对应于 Python __next__() 方法。\n\n|  | Py_hash_t result;\nresult = self->some_size + 32767 * self->some_number;\nif (result == -1) {\nresult = -2;\n}\nreturn result;\n} |  |\n| --- | --- | --- |\n|  | Py_hash_t 是一个在宽度取决于具体平台的有符号整数类型。 从 tp_hash 返回 -1 表示发生了错\n误，这就是为什么你应当注意避免在哈希运算成功时返回它，如上面所演示的。 |  |\n|  | ternaryfunc tp_call; |  |\n|  | 此函数会在“调用”你的数据类型实例时被调用，举例来说，如果 obj1 是你的数据类型的实例而\nPython 脚本包含了 obj1('hello')，则将唤起 tp_call 处理器。\n此函数接受三个参数:\n1. self 是作为调用目标的数据类型实例。 如果调用是 obj1('hello')，则 self 为 obj1。\n2. args 是包含调用参数的元组。 你可以使用 PyArg_ParseTuple() 来提取参数。\n3. kwds 是由传入的关键字参数组成的字典。 如果它不为 NULL 且你支持关键字参数，则可使用\nPyArg_ParseTupleAndKeywords() 来提取参数。 如果你不想支持关键字参数而它为非 NULL\n值，则会引发 TypeError 并附带一个提示不支持关键字参数的消息。\n下面是一个演示性的 tp_call 实现: |  |\n|  | static PyObject *\nnewdatatype_call(PyObject *op, PyObject *args, PyObject *kwds)\n{\nnewdatatypeobject *self = (newdatatypeobject *) op;\nPyObject *result;\nconst char *arg1;\nconst char *arg2;\nconst char *arg3;\nif (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\nreturn NULL;\n}\nresult = PyUnicode_FromFormat(\n\"Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\",\nself->obj_UnderlyingDatatypePtr->size,\narg1, arg2, arg3);\nreturn result;\n} |  |\n|  |  |  |\n|  | /* Iterators */\ngetiterfunc tp_iter;\niternextfunc tp_iternext; |  |\n|  | 这些函数提供了对迭代器协议的支持。 这两个处理器都只接受一个形参，即它们被调用时所使用的\n实例，并返回一个新的引用。 当发生错误时，它们应设置一个异常并返回 NULL。 tp_iter 对应于\nPython __iter__() 方法，而 tp_iternext 对应于 Python __next__() 方法。 |  |\n\n任何 iterable 对象都必须实现 tp_iter 处理器，该处理器必须返回一个 iterator 对象。 下面是与\nPython 类所应用的同一个指导原则:\n对于可以支持多个独立迭代器的多项集（如列表和元组），则应当在每次调用 tp_iter 时创建并\n返回一个新的迭代器。\n只能被迭代一次的对象（通常是由于迭代操作的附带影响，例如文件对象）可以通过返回一个指\n向自身的新引用来实现 tp_iter -- 并且为此还应当实现 tp_iternext 处理器。\n任何 iterator 对象都应当同时实现 tp_iter 和 tp_iternext。 一个迭代器的 tp_iter 处理器应当\n返回一个指向该迭代器的新引用。 它的 tp_iternext 处理器应当返回一个指向迭代操作的下一个对\n象的新引用，如果还有下一个对象的话。 如果迭代已到达末尾，则 tp_iternext 可以返回 NULL 而\n不设置异常，或者也可以在返回 NULL 的基础上 额外 设置 StopIteration；避免异常可以产生更好\n的性能。 如果发生了实际的错误，则 tp_iternext 应当总是设置一个异常并返回 NULL。\n3.6. 弱引用支持\nOne of the goals of Python 弱引用实现的目标之一是允许任意类型参与弱引用机制而不会在重视性\n能的对象（例如数字）上产生额外开销。\n参见: weakref 模块的文档。\n对于可被弱引用的对象，扩展类型必须设置 tp_flags 字段的 Py_TPFLAGS_MANAGED_WEAKREF 比特\n位。 旧式的 tp_weaklistoffset 字段应当保持为零。\n具体地说，以下就是静态声明的类型对象的样子:\nstatic PyTypeObject TrivialType = {\nPyVarObject_HEAD_INIT(NULL, 0)\n/* ... 省略了其他成员以使代码简短 ... */\n.tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n};\n唯一的额外补充是 tp_dealloc 需要清除任何弱引用 (通过调用 PyObject_ClearWeakRefs()):\nstatic void\nTrivial_dealloc(PyObject *op)\n{\n/* 在调用任何析构器之前先清除弱引用 */\nPyObject_ClearWeakRefs(op);\n/* ... 省略了析构代码的其余部分以保持简短 ... */\nPy_TYPE(op)->tp_free(op);\n}\n3.7. 更多建议\n为了学习如何为你的新数据类型实现任何特定方法，请获取 CPython 源代码。 进入 Objects 目\n录，然后在 C 源文件中搜索 tp_ 加上你想要的函数 (例如，tp_richcompare)。 你将找到你想要实\n现的函数的例子。\n\n|  | 任何 iterable 对象都必须实现 tp_iter 处理器，该处理器必须返回一个 iterator 对象。 下面是与\nPython 类所应用的同一个指导原则:\n对于可以支持多个独立迭代器的多项集（如列表和元组），则应当在每次调用 tp_iter 时创建并\n返回一个新的迭代器。\n只能被迭代一次的对象（通常是由于迭代操作的附带影响，例如文件对象）可以通过返回一个指\n向自身的新引用来实现 tp_iter -- 并且为此还应当实现 tp_iternext 处理器。\n任何 iterator 对象都应当同时实现 tp_iter 和 tp_iternext。 一个迭代器的 tp_iter 处理器应当\n返回一个指向该迭代器的新引用。 它的 tp_iternext 处理器应当返回一个指向迭代操作的下一个对\n象的新引用，如果还有下一个对象的话。 如果迭代已到达末尾，则 tp_iternext 可以返回 NULL 而\n不设置异常，或者也可以在返回 NULL 的基础上 额外 设置 StopIteration；避免异常可以产生更好\n的性能。 如果发生了实际的错误，则 tp_iternext 应当总是设置一个异常并返回 NULL。\n3.6. 弱引用支持\nOne of the goals of Python 弱引用实现的目标之一是允许任意类型参与弱引用机制而不会在重视性\n能的对象（例如数字）上产生额外开销。 |  |\n| --- | --- | --- |\n|  | 参见: weakref 模块的文档。 |  |\n|  | 对于可被弱引用的对象，扩展类型必须设置 tp_flags 字段的 Py_TPFLAGS_MANAGED_WEAKREF 比特\n位。 旧式的 tp_weaklistoffset 字段应当保持为零。\n具体地说，以下就是静态声明的类型对象的样子: |  |\n|  | static PyTypeObject TrivialType = {\nPyVarObject_HEAD_INIT(NULL, 0)\n/* ... 省略了其他成员以使代码简短 ... */\n.tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n}; |  |\n|  | 唯一的额外补充是 tp_dealloc 需要清除任何弱引用 (通过调用 PyObject_ClearWeakRefs()): |  |\n|  | static void\nTrivial_dealloc(PyObject *op)\n{\n/* 在调用任何析构器之前先清除弱引用 */\nPyObject_ClearWeakRefs(op);\n/* ... 省略了析构代码的其余部分以保持简短 ... */\nPy_TYPE(op)->tp_free(op);\n} |  |\n|  | 3.7. 更多建议\n为了学习如何为你的新数据类型实现任何特定方法，请获取 CPython 源代码。 进入 Objects 目\n录，然后在 C 源文件中搜索 tp_ 加上你想要的函数 (例如，tp_richcompare)。 你将找到你想要实\n现的函数的例子。 |  |\n\n当你需要验证一个对象是否为你实现的类型的具体实例时，请使用 PyObject_TypeCheck() 函数。\n它的一个用法示例如下:\nif (!PyObject_TypeCheck(some_object, &MyType)) {\nPyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");\nreturn NULL;\n}\n参见:\n下载CPython源代码版本。\nhttps://www.python.org/downloads/source/\nGitHub上开发CPython源代码的CPython项目。\nhttps://github.com/python/cpython\n\n| 当你需要验证一个对象是否为你实现的类型的具体实例时，请使用 PyObject_TypeCheck() 函数。\n它的一个用法示例如下: |\n| --- |\n| if (!PyObject_TypeCheck(some_object, &MyType)) {\nPyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");\nreturn NULL;\n} |\n|  |\n| 参见:\n下载CPython源代码版本。\nhttps://www.python.org/downloads/source/\nGitHub上开发CPython源代码的CPython项目。\nhttps://github.com/python/cpython |", "metadata": {"title": "03_定义扩展类型：已分类主题", "source": "md_docs\\python_extending_md\\03_定义扩展类型：已分类主题.md", "doc_type": "扩展和嵌入", "language": "中文", "doc_id": "b5a517ca"}}
{"doc_id": "d6f9c66a", "content": "4. 构建 C/C++ 扩展\n一个 CPython 的 C 扩展是一个共享库 (例如 Linux上的 .so，或者 Windows 上的 .pyd)，它会导出\n一个 初始化函数。\n请参阅 定义扩展模块 来了解详情。\n4.1. 使用 setuptools 构建 C 和 C++ 扩展\n构建、打包和分发扩展模块最好使用第三方工具完成，并且超出了本文的范围。一个合适的工具是\nSetuptools，其文档可以在 https://setuptools.pypa.io/en/latest/setuptools.html 上找到。\ndistutils 模块在 Python 3.12 之前一直包含在标准库中，现在作为 Setuptools 的一部分进行维\n护。", "metadata": {"title": "04_构建_CC++_扩展", "source": "md_docs\\python_extending_md\\04_构建_CC++_扩展.md", "doc_type": "扩展和嵌入", "language": "中文", "doc_id": "d6f9c66a"}}
{"doc_id": "3b2b9114", "content": "5. 在 Windows 上构建 C 和 C++ 扩展\n这一章简要介绍了如何使用 Microsoft Visual C++ 创建 Python 的 Windows 扩展模块，然后再提供\n有关其工作机理的详细背景信息。 这些说明材料同时适用于 Windows 程序员学习构建 Python 扩展\n以及 Unix 程序员学习如何生成在 Unix 和 Windows 上均能成功构建的软件。\n鼓励模块作者使用 distutils 方式来构建扩展模块，而不使用本节所描述的方式。 你仍将需要使用 C\n编译器来构建 Python；通常为 Microsoft Visual C++。\n备注: 这一章提及了多个包括已编码 Python 版本号的文件名。 这些文件名以显示为 XY 的版本\n号来代表；在实践中，'X' 将为你所使用的 Python 发布版的主版本号而 'Y' 将为次版本号。 例\n如，如果你所使用的是 Python 2.2.1，XY 将为 22。\n5.1. 菜谱式说明\n与在 Unix 上一样，在 Windows 上构造扩展模块也有两种方式：使用 setuptools 包来控制构建过\n程，或者全手动操作。 setuptools 方式适用于大多数扩展；使用 setuptools 构建和打包扩展模块\n的文档见 使用 setuptools 构建 C 和 C++ 扩展。 如果你发现你真的需要手动操作，那么研究一下\nwinsound 标准库模块的项目文件可能会很有帮助。standard library module.\n5.2. Unix 和 Windows 之间的差异\nUnix 和 Windows 对于代码的运行时加载使用了完全不同的范式。 在你尝试构建可动态加载的模块\n之前，要先了解你所用系统是如何工作的。\n在 Unix 中，一个共享对象 (.so) 文件中包含将由程序来使用的代码，也包含在程序中可被找到的函\n数名称和数据。 当文件被合并到程序中时，对在文件代码中这些函数和数据的全部引用都会被改为\n指向程序中函数和数据在内存中所放置的实际位置。 这基本上是一个链接操作。\n在 Windows 中，一个动态链接库 (.dll) 文件中没有悬挂的引用。 而是通过一个查找表执行对函数\n或数据的访问。 因此在运行时 DLL 代码不必在运行时进行修改；相反地，代码已经使用了 DLL 的查\n找表，并且在运行时查找表会被修改以指向特定的函数和数据。\n在 Unix 中，只存在一种库文件 (.a)，它包含来自多个对象文件 (.o) 的代码。 在创建共享对象文件\n(.so) 的链接阶段，链接器可能会发现它不知道某个标识符是在哪里定义的。 链接器将在各个库的\n对象文件中查找它；如果找到了它，链接器将会包括来自该对象文件的所有代码。\n在 Windows 中，存在两种库类型，静态库和导入库 (扩展名都是 .lib)。 静态库类似于 Unix 的 .a\n文件；它包含在必要时可被包括的代码。 导入库基本上仅用于让链接器能确保特定标识符是合法\n的，并且将在 DLL 被加载时出现于程序中。 这样链接器可使用来自导入库的信息构建查找表以便使\n用未包括在 DLL 中的标识符。 当一个应用程序或 DLL 被链接时，可能会生成一个导入库，它将需要\n被用于应用程序或 DLL 中未来所有依赖于这些符号的 DLL。\n\n| 5. 在 Windows 上构建 C 和 C++ 扩展\n这一章简要介绍了如何使用 Microsoft Visual C++ 创建 Python 的 Windows 扩展模块，然后再提供\n有关其工作机理的详细背景信息。 这些说明材料同时适用于 Windows 程序员学习构建 Python 扩展\n以及 Unix 程序员学习如何生成在 Unix 和 Windows 上均能成功构建的软件。\n鼓励模块作者使用 distutils 方式来构建扩展模块，而不使用本节所描述的方式。 你仍将需要使用 C\n编译器来构建 Python；通常为 Microsoft Visual C++。 |\n| --- |\n| 备注: 这一章提及了多个包括已编码 Python 版本号的文件名。 这些文件名以显示为 XY 的版本\n号来代表；在实践中，'X' 将为你所使用的 Python 发布版的主版本号而 'Y' 将为次版本号。 例\n如，如果你所使用的是 Python 2.2.1，XY 将为 22。 |\n| 5.1. 菜谱式说明\n与在 Unix 上一样，在 Windows 上构造扩展模块也有两种方式：使用 setuptools 包来控制构建过\n程，或者全手动操作。 setuptools 方式适用于大多数扩展；使用 setuptools 构建和打包扩展模块\n的文档见 使用 setuptools 构建 C 和 C++ 扩展。 如果你发现你真的需要手动操作，那么研究一下\nwinsound 标准库模块的项目文件可能会很有帮助。standard library module.\n5.2. Unix 和 Windows 之间的差异\nUnix 和 Windows 对于代码的运行时加载使用了完全不同的范式。 在你尝试构建可动态加载的模块\n之前，要先了解你所用系统是如何工作的。\n在 Unix 中，一个共享对象 (.so) 文件中包含将由程序来使用的代码，也包含在程序中可被找到的函\n数名称和数据。 当文件被合并到程序中时，对在文件代码中这些函数和数据的全部引用都会被改为\n指向程序中函数和数据在内存中所放置的实际位置。 这基本上是一个链接操作。\n在 Windows 中，一个动态链接库 (.dll) 文件中没有悬挂的引用。 而是通过一个查找表执行对函数\n或数据的访问。 因此在运行时 DLL 代码不必在运行时进行修改；相反地，代码已经使用了 DLL 的查\n找表，并且在运行时查找表会被修改以指向特定的函数和数据。\n在 Unix 中，只存在一种库文件 (.a)，它包含来自多个对象文件 (.o) 的代码。 在创建共享对象文件\n(.so) 的链接阶段，链接器可能会发现它不知道某个标识符是在哪里定义的。 链接器将在各个库的\n对象文件中查找它；如果找到了它，链接器将会包括来自该对象文件的所有代码。\n在 Windows 中，存在两种库类型，静态库和导入库 (扩展名都是 .lib)。 静态库类似于 Unix 的 .a\n文件；它包含在必要时可被包括的代码。 导入库基本上仅用于让链接器能确保特定标识符是合法\n的，并且将在 DLL 被加载时出现于程序中。 这样链接器可使用来自导入库的信息构建查找表以便使\n用未包括在 DLL 中的标识符。 当一个应用程序或 DLL 被链接时，可能会生成一个导入库，它将需要\n被用于应用程序或 DLL 中未来所有依赖于这些符号的 DLL。 |\n\n假设你正在编译两个动态加载模块 B 和 C，它们应当共享另一个代码块 A。 在 Unix 上，你 不应 将\nA.a 传给链接器作为 B.so 和 C.so；那会导致它被包括两次，这样 B 和 C 将分别拥有它们自己的副\n本。 在 Windows 上，编译 A.dll 将同时编译 A.lib。 你 应当 将 A.lib 传给链接器用于 B 和 C。\nA.lib 并不包含代码；它只包含将在运行时被用于访问 A 的代码的信息。\n在 Windows 上，使用导入库有点像是使用 import spam；它让你可以访问 spam 中的名称，但并不\n会创建一个单独副本。 在 Unix 上，链接到一个库更像是 from spam import *；它会创建一个单独\n副本。\nPy_NO_LINK_LIB\n关闭在CPython头文件中执行的基于``#pragma``的与Python库的隐式链接。\nAdded in version 3.14.\n5.3. DLL 的实际使用\nWindows Python 是在 Microsoft Visual C++ 中构建的；使用其他编译器可能会也可能不会工作。本\n节的其余部分是针对 MSVC++ 的。\n在Windows中创建DLL时，你可以通过两种方式使用CPython库：\n1. 默认情况下，直接包含 PC/pyconfig.h 或通过 Python.h 会触发与库的隐式、配置感知型的\n链接。 头文件选择 pythonXY_d.lib 用于调试，pythonXY.lib 用于发布，以及\npythonX.lib 用于启用了 受限 API 的发布。\n要构建两个 DLL，spam 和 ni (使用 spam 中找到的 C 函数)，你应当使用以下命令:\ncl /LD /I/python/include spam.c\ncl /LD /I/python/include ni.c spam.lib\n第一条命令创建了三个文件: spam.obj, spam.dll 和 spam.lib。 Spam.dll 不包含任何\nPython 函数 (如 PyArg_ParseTuple())，但因为有隐式链接的 pythonXY.lib 所以它知道如\n何找到 Python 代码。\n第二条命令创建了 ni.dll (以及 .obj 和 .lib)，它知道如何从 spam 以及 Python 可执行文\n件中找到所需的函数。\n2. 在包含 Python.h 之前，手动定义 Py_NO_LINK_LIB 宏。 必须将 pythonXY.lib 传递给链接\n器。\n要构建两个 DLL，spam 和 ni (使用 spam 中找到的 C 函数)，你应当使用以下命令:\ncl /LD /DPy_NO_LINK_LIB /I/python/include spam.c ../libs/pythonXY.lib\ncl /LD /DPy_NO_LINK_LIB /I/python/include ni.c spam.lib ../libs/pythonXY.lib\n第一条命令创建了三个文件: spam.obj, spam.dll 和 spam.lib。 Spam.dll 不包含任何\nPython 函数 (例如 PyArg_ParseTuple())，但它通过 pythonXY.lib 可以知道如何找到所需\n的 Python 代码。\n\n|  | 假设你正在编译两个动态加载模块 B 和 C，它们应当共享另一个代码块 A。 在 Unix 上，你 不应 将\nA.a 传给链接器作为 B.so 和 C.so；那会导致它被包括两次，这样 B 和 C 将分别拥有它们自己的副\n本。 在 Windows 上，编译 A.dll 将同时编译 A.lib。 你 应当 将 A.lib 传给链接器用于 B 和 C。\nA.lib 并不包含代码；它只包含将在运行时被用于访问 A 的代码的信息。\n在 Windows 上，使用导入库有点像是使用 import spam；它让你可以访问 spam 中的名称，但并不\n会创建一个单独副本。 在 Unix 上，链接到一个库更像是 from spam import *；它会创建一个单独\n副本。\nPy_NO_LINK_LIB\n关闭在CPython头文件中执行的基于``#pragma``的与Python库的隐式链接。\nAdded in version 3.14.\n5.3. DLL 的实际使用\nWindows Python 是在 Microsoft Visual C++ 中构建的；使用其他编译器可能会也可能不会工作。本\n节的其余部分是针对 MSVC++ 的。\n在Windows中创建DLL时，你可以通过两种方式使用CPython库：\n1. 默认情况下，直接包含 PC/pyconfig.h 或通过 Python.h 会触发与库的隐式、配置感知型的\n链接。 头文件选择 pythonXY_d.lib 用于调试，pythonXY.lib 用于发布，以及\npythonX.lib 用于启用了 受限 API 的发布。\n要构建两个 DLL，spam 和 ni (使用 spam 中找到的 C 函数)，你应当使用以下命令:\ncl /LD /I/python/include spam.c\ncl /LD /I/python/include ni.c spam.lib\n第一条命令创建了三个文件: spam.obj, spam.dll 和 spam.lib。 Spam.dll 不包含任何\nPython 函数 (如 PyArg_ParseTuple())，但因为有隐式链接的 pythonXY.lib 所以它知道如\n何找到 Python 代码。\n第二条命令创建了 ni.dll (以及 .obj 和 .lib)，它知道如何从 spam 以及 Python 可执行文\n件中找到所需的函数。\n2. 在包含 Python.h 之前，手动定义 Py_NO_LINK_LIB 宏。 必须将 pythonXY.lib 传递给链接\n器。\n要构建两个 DLL，spam 和 ni (使用 spam 中找到的 C 函数)，你应当使用以下命令:\ncl /LD /DPy_NO_LINK_LIB /I/python/include spam.c ../libs/pythonXY.lib\ncl /LD /DPy_NO_LINK_LIB /I/python/include ni.c spam.lib ../libs/pythonXY.lib\n第一条命令创建了三个文件: spam.obj, spam.dll 和 spam.lib。 Spam.dll 不包含任何\nPython 函数 (例如 PyArg_ParseTuple())，但它通过 pythonXY.lib 可以知道如何找到所需\n的 Python 代码。 |  |\n| --- | --- | --- |\n\n第二条命令创建了 ni.dll (以及 .obj 和 .lib)，它知道如何从 spam 以及 Python 可执行文\n件中找到所需的函数。\n不是每个标识符都会被导出到查找表。 如果你想要任何其他模块（包括 Python）都能看到你的标识\n符，你必须写上 _declspec(dllexport)，就如在 void _declspec(dllexport) initspam(void)\n或 PyObject _declspec(dllexport) *NiGetSpamData(void) 中一样。\nDeveloper Studio 会添加很多你并不真正需要的导入库，命名你的可执行文件大小增加约 100K。 要\n摆脱它们，请使用项目设置对话框中的链接选项卡指定 忽略默认库。 将正确的 msvcrtxx.lib 添加\n到库列表中。", "metadata": {"title": "05_在_Windows_上构建_C_和_C++_扩展", "source": "md_docs\\python_extending_md\\05_在_Windows_上构建_C_和_C++_扩展.md", "doc_type": "扩展和嵌入", "language": "中文", "doc_id": "3b2b9114"}}
