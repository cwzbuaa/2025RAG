{"doc_id": "7d52d117", "content": "API 和 ABI 版本管理\n构建时版本常量\nCPython 在下列宏中公开其版本号。 请注意这对应于 构建 所用的版本代码。 请查看 Py_Version\n获取在 运行时 所用的版本。\n请参阅 C API 的稳定性 查看跨版本的 API 和 ABI 稳定情。\nPY_MAJOR_VERSION\n3 (3.4.1a2 中的第一段)。\nPY_MINOR_VERSION\n4 (3.4.1a2 中的第二段)。\nPY_MICRO_VERSION\n1 (3.4.1a2 中第三段的数字)。\nPY_RELEASE_LEVEL\na (3.4.1a2 中第3段的字母)。 可能为 0xA 即 alpha, 0xB 即 beta, 0xC 即 release candidate 或\n0xF 即 final。\nPY_RELEASE_SERIAL\n2 (3.4.1a2 中的末尾数字)。 零代表最终发布版。\nPY_VERSION_HEX\nPython 版本号被编码为一个整数。 请查看 Py_PACK_FULL_VERSION() 了解编码细节。\n可将其用于数字比较，例如 #if PY_VERSION_HEX >= ...。\n运行时版本\nconst unsigned long Py_Version\n属于 稳定 ABI 自 3.11 版起.\nPython 运行时版本号被编码为一个整数常量。 请查看 Py_PACK_FULL_VERSION() 了解编码细\n节。 这包含了在运行时使用的 Python 版本。\n可将其用于数字比较，例如 if (Py_Version >= ...)。\nAdded in version 3.11.\n比特位打包宏\n\nuint32_t Py_PACK_FULL_VERSION(int major, int minor, int micro, int\nrelease_level, int release_serial)\n属于 稳定 ABI 自 3.14 版起.\n返回给定的版本，编码为一个具有如下结构的 32 位整数：\n示例值\n参数 位编号 位掩码 位移\n3.4.1a2 3.10.0\nmajor 8 0xFF000000 24 0x03 0x03\nminor 8 0x00FF0000 16 0x04 0x0A\nmicro 8 0x0000FF00 8 0x01 0x00\nrelease_level 4 0x000000F0 4 0xA 0xF\nrelease_serial 4 0x0000000F 0 0x2 0x0\n例如:\n版本 Py_PACK_FULL_VERSION 参数 已编码版本\n3.4.1a2 (3, 4, 1, 0xA, 2) 0x030401a2\n3.10.0 (3, 10, 0, 0xF, 0) 0x030a00f0\n参数中超范围的比特位将被忽略。 也就是说，该宏可以被定义为：\n#ifndef Py_PACK_FULL_VERSION\n#define Py_PACK_FULL_VERSION(X, Y, Z, LEVEL, SERIAL) ( \\\n(((X) & 0xff) << 24) | \\\n(((Y) & 0xff) << 16) | \\\n(((Z) & 0xff) << 8) | \\\n(((LEVEL) & 0xf) << 4) | \\\n(((SERIAL) & 0xf) << 0))\n#endif\nPy_PACK_FULL_VERSION 本质上是一个宏，主要在 #if 指令中使用，但也可作为导出的函数使\n用。\nAdded in version 3.14.\nuint32_t Py_PACK_VERSION(int major, int minor)\n属于 稳定 ABI 自 3.14 版起.\n等价于 Py_PACK_FULL_VERSION(major, minor, 0, 0, 0)。 其结果不与任何 Python 发布版\n对应，但在数字比较中很有用处。\nAdded in version 3.14.\n\n| 参数 | 位编号 | 位掩码 | 位移 | 示例值 |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  |  | 3.4.1a2 | 3.10.0 |\n| major | 8 | 0xFF000000 | 24 | 0x03 | 0x03 |\n| minor | 8 | 0x00FF0000 | 16 | 0x04 | 0x0A |\n| micro | 8 | 0x0000FF00 | 8 | 0x01 | 0x00 |\n| release_level | 4 | 0x000000F0 | 4 | 0xA | 0xF |\n| release_serial | 4 | 0x0000000F | 0 | 0x2 | 0x0 |\n\n| 版本 | Py_PACK_FULL_VERSION 参数 | 已编码版本 |\n| --- | --- | --- |\n| 3.4.1a2 | (3, 4, 1, 0xA, 2) | 0x030401a2 |\n| 3.10.0 | (3, 10, 0, 0xF, 0) | 0x030a00f0 |", "metadata": {"title": "00_API_和_ABI_版本管理", "source": "md_docs\\python_c-api_md\\00_API_和_ABI_版本管理.md", "doc_type": "C API", "language": "中文", "doc_id": "7d52d117"}}
{"doc_id": "809eb27d", "content": "C API 的稳定性\n除非另有文档说明，Python 的 C API 将遵循 PEP 387 所描述的向下兼容策略。 对它的大部分改变\n都是源代码级兼容的（通常只会增加新的 new API）。 改变现有 API 或移除 API 只会在弃用期结束\n之后或需修复严重问题时才会发生。\nCPython 的应用程序二进制接口（ABI）可以跨微版本向上和向下兼容（在以相同方式编译的情况\n下，参见下文 平台的考虑 一节）。 因此，针对 Python 3.10.0 编译的代码将适用于 3.10.8，反之亦\n然，但对于 3.9.x 和 3.11.x 则需要单独编译。\n存在具有不同稳定性预期的两个 C API 层次：\n不稳定 API，可能在次要版本中发生改变而没有弃用期。 它的名称会以 PyUnstable 前缀来标\n记。\n受限 API，将会在多个次要版本间保持兼容。 当定义了 Py_LIMITED_API 时，将只有这个子集会\n从 Python.h 对外公开。\n这些将在下文中更详细地讨论。\n带有一个下划线前缀的名称，如 _Py_InternalState，是可能不经通知就改变甚至是在补丁发布版\n中改变的私有 API。 如果你需要使用这样的 API，请考虑联系 CPython 开发团队 来讨论为你的应用\n场景添加公有 API。\n不稳定 C API\n任何名称带有 PyUnstable 前缀的 API 都将对外公开 CPython 的实现细节，并可能不加弃用警告即\n在次要版本中发生改变（例如从 3.9 到 3.10）。 但是，它不会在问题修正发布版中改变（例如从\n3.10.0 到 3.10.1）。\n它通常是针对专门的，低层级的工具如调试器等。\n使用此 API 的项目需要跟随 CPython 开发进程并花费额外的努力来适应改变。\n应用程序二进制接口的稳定版\n简单起见，本文档只讨论了 扩展，但受限 API 和稳定 ABI 对于 API 的所有用法都能发挥相同的作用\n– 例如嵌入版的 Python 等。\n受限 C API\nPython 3.2 引入了 受限 API，它是 Python 的 C API 的子集。 只使用受限 API 的扩展可以一次编译即\n可在多个 Python 版本上加载。 受限 API 内容 如下所示。\nPy_LIMITED_API\n\n请在包括 Python.h 之前定义这个宏以选择只使用受限 API，并选择受限 API 的版本。\n将 Py_LIMITED_API 定义为对应于你的扩展所支持的最低 Python 版本的 PY_VERSION_HEX\n值。 扩展将与从指定版本开始的所有 Python 3 发布版保持 ABI 兼容，并可使用到该版本为止\n所引入的受限 API。\n不直接使用 PY_VERSION_HEX 宏，而是碍编码一个最小的次要版本（例如 0x030A0000 表示\nPython 3.10）以便在使用未来的 Python 版本进行编译时保持稳定。\n你还可以将 Py_LIMITED_API 定义为 3。 其效果与 0x03020000 相同（即 Python 3.2，引入受\n限 API 的版本）。\n稳定 ABI\n为启用此特性，Python 提供了一个 稳定 ABI:即一组将跨 Python 3.x 各个版本保持 ABI 兼容的符号集\n合。\n备注: 稳定 ABI 将防止多种 ABI 问题，如由于缺失符号导致的链接器错误或由于结构体布局或函\n数签名中的变化导致的数据损坏。 不过，Python 中的其他修改可能改变扩展的 行为。 请参阅\nPython 的向下兼容策略 (PEP 387) 了解详情。\n稳定 ABI 包含在 受限 API 中对外公开的符号，但还包含其他符号 – 例如，为支持旧版本受限 API 所\n需的函数。\n在 Windows 上，使用稳定 ABI 的扩展应当被链接到 python3.dll 而不是版本专属的库如\npython39.dll。\n在某些平台上，Python 将查找并载入名称中带有 abi3 标签的共享库文件 (例如\nmymodule.abi3.so)。 它不会检查这样的扩展是否兼容稳定 ABI。 使用方 (或其打包工具) 需要确保\n这一些，例如，基于 3.10+ 受限 API 编译的扩展不可被安装于更低版本的 Python 中。\n稳定 ABI 中的所有函数都会作为 Python 的共享库中的函数存在，而不仅是作为宏。 这使得它们可\n以在不使用 C 预处理器的语言中使用。\n受限 API 的作用域和性能\n受限 API 的目标是允许使用在完整 C API 中可用的任何东西，但可能会有性能上的损失。\n例如，虽然 PyList_GetItem() 是可用的，但其 “不安全的” 宏版本 PyList_GET_ITEM() 则是不可\n用的。 这个宏的运行速度更快因为它可以利用版本专属的列表对象实现细节。\n在未定义 Py_LIMITED_API 的情况下，某些 C API 函数将由宏来执行内联或替换。 定义\nPy_LIMITED_API 会禁用这样的内联，允许提升 Python 的数据结构稳定性，但有可能降低性能。\n通过省略 Py_LIMITED_API 定义，可以使基于版本专属的 ABI 来编译受限 API 扩展成为可能。 这能\n提升其在相应 Python 版本上的性能，但也将限制其兼容性。 基于 Py_LIMITED_API 进行编译将产\n生一个可在版本专属扩展不可用的场合分发的扩展 – 例如，针对即将发布的 Python 版本的预发布\n包。\n\n|  | 请在包括 Python.h 之前定义这个宏以选择只使用受限 API，并选择受限 API 的版本。\n将 Py_LIMITED_API 定义为对应于你的扩展所支持的最低 Python 版本的 PY_VERSION_HEX\n值。 扩展将与从指定版本开始的所有 Python 3 发布版保持 ABI 兼容，并可使用到该版本为止\n所引入的受限 API。\n不直接使用 PY_VERSION_HEX 宏，而是碍编码一个最小的次要版本（例如 0x030A0000 表示\nPython 3.10）以便在使用未来的 Python 版本进行编译时保持稳定。\n你还可以将 Py_LIMITED_API 定义为 3。 其效果与 0x03020000 相同（即 Python 3.2，引入受\n限 API 的版本）。\n稳定 ABI\n为启用此特性，Python 提供了一个 稳定 ABI:即一组将跨 Python 3.x 各个版本保持 ABI 兼容的符号集\n合。 |  |\n| --- | --- | --- |\n|  | 备注: 稳定 ABI 将防止多种 ABI 问题，如由于缺失符号导致的链接器错误或由于结构体布局或函\n数签名中的变化导致的数据损坏。 不过，Python 中的其他修改可能改变扩展的 行为。 请参阅\nPython 的向下兼容策略 (PEP 387) 了解详情。 |  |\n|  | 稳定 ABI 包含在 受限 API 中对外公开的符号，但还包含其他符号 – 例如，为支持旧版本受限 API 所\n需的函数。\n在 Windows 上，使用稳定 ABI 的扩展应当被链接到 python3.dll 而不是版本专属的库如\npython39.dll。\n在某些平台上，Python 将查找并载入名称中带有 abi3 标签的共享库文件 (例如\nmymodule.abi3.so)。 它不会检查这样的扩展是否兼容稳定 ABI。 使用方 (或其打包工具) 需要确保\n这一些，例如，基于 3.10+ 受限 API 编译的扩展不可被安装于更低版本的 Python 中。\n稳定 ABI 中的所有函数都会作为 Python 的共享库中的函数存在，而不仅是作为宏。 这使得它们可\n以在不使用 C 预处理器的语言中使用。\n受限 API 的作用域和性能\n受限 API 的目标是允许使用在完整 C API 中可用的任何东西，但可能会有性能上的损失。\n例如，虽然 PyList_GetItem() 是可用的，但其 “不安全的” 宏版本 PyList_GET_ITEM() 则是不可\n用的。 这个宏的运行速度更快因为它可以利用版本专属的列表对象实现细节。\n在未定义 Py_LIMITED_API 的情况下，某些 C API 函数将由宏来执行内联或替换。 定义\nPy_LIMITED_API 会禁用这样的内联，允许提升 Python 的数据结构稳定性，但有可能降低性能。\n通过省略 Py_LIMITED_API 定义，可以使基于版本专属的 ABI 来编译受限 API 扩展成为可能。 这能\n提升其在相应 Python 版本上的性能，但也将限制其兼容性。 基于 Py_LIMITED_API 进行编译将产\n生一个可在版本专属扩展不可用的场合分发的扩展 – 例如，针对即将发布的 Python 版本的预发布\n包。 |  |\n\n受限 API 警示\n请注意使用 Py_LIMITED_API 进行编译 无法 完全保证代码能够兼容 受限 API 或 稳定 ABI。\nPy_LIMITED_API 仅仅涵盖定义部分，但一个 API 还包括其他因素，如预期的语义等。\nPy_LIMITED_API 不能处理的一个问题是附带在较低 Python 版本中无效的参数调用某个函数。 例\n如，考虑一个接受 NULL 作为参数的函数。 在 Python 3.9 中，NULL 现在会选择一个默认行为，但在\nPython 3.8 中，该参数将被直接使用，导致一个 NULL 引用被崩溃。 类似的参数也适用于结构体的\n字段。\n另一个问题是当定义了 Py_LIMITED_API 时某些结构体字段目前不会被隐藏，即使它们是受限 API\n的一部分。\n出于这些原因，我们建议用要支持的 所有 Python 小版本号来测试一个扩展，并最好是用其中 最低\n的版本来编译它。\n我们还建议查看所使用 API 的全部文档以检查其是否显式指明为受限 API 的一部分。 即使定义了\nPy_LIMITED_API，少数私有声明还是会出于技术原因（或者甚至是作为程序缺陷在无意中）被暴露\n出来。\n还要注意受限 API 并不必然是稳定的：在 Python 3.8 上用 Py_LIMITED_API 编译扩展意味着该扩展\n能在 Python 3.12 上运行，但它将不一定能用 Python 3.12 编译。 特别地，在稳定 ABI 保持稳定的情\n况下，部分受限 API 可能会被弃用并被移除。\n平台的考虑\nABI 的稳定性不仅取决于 Python，取决于所使用的编译器、低层级库和编译器选项等。 对于 稳定\nABI 的目标来说，这些细节定义了一个 “平台”。 它们通常会依赖于 OS 类型和处理器架构等。\n确保在特定平台上的所有 Python 版本都以不破坏稳定 ABI 的方式构建是每个特定 Python 分发方的\n责任。 来自 python.org 以及许多第三方分发商的 Windows 和 macOS 发布版都必于这种情况。\n受限 API 的内容\n目前 受限 API 包括下面这些项:\nPY_VECTORCALL_ARGUMENTS_OFFSET\nPyAIter_Check()\nPyArg_Parse()\nPyArg_ParseTuple()\nPyArg_ParseTupleAndKeywords()\nPyArg_UnpackTuple()\nPyArg_VaParse()\nPyArg_VaParseTupleAndKeywords()\nPyArg_ValidateKeywordArguments()\nPyBaseObject_Type\n\n|  | 受限 API 警示\n请注意使用 Py_LIMITED_API 进行编译 无法 完全保证代码能够兼容 受限 API 或 稳定 ABI。\nPy_LIMITED_API 仅仅涵盖定义部分，但一个 API 还包括其他因素，如预期的语义等。\nPy_LIMITED_API 不能处理的一个问题是附带在较低 Python 版本中无效的参数调用某个函数。 例\n如，考虑一个接受 NULL 作为参数的函数。 在 Python 3.9 中，NULL 现在会选择一个默认行为，但在\nPython 3.8 中，该参数将被直接使用，导致一个 NULL 引用被崩溃。 类似的参数也适用于结构体的\n字段。\n另一个问题是当定义了 Py_LIMITED_API 时某些结构体字段目前不会被隐藏，即使它们是受限 API\n的一部分。\n出于这些原因，我们建议用要支持的 所有 Python 小版本号来测试一个扩展，并最好是用其中 最低\n的版本来编译它。\n我们还建议查看所使用 API 的全部文档以检查其是否显式指明为受限 API 的一部分。 即使定义了\nPy_LIMITED_API，少数私有声明还是会出于技术原因（或者甚至是作为程序缺陷在无意中）被暴露\n出来。\n还要注意受限 API 并不必然是稳定的：在 Python 3.8 上用 Py_LIMITED_API 编译扩展意味着该扩展\n能在 Python 3.12 上运行，但它将不一定能用 Python 3.12 编译。 特别地，在稳定 ABI 保持稳定的情\n况下，部分受限 API 可能会被弃用并被移除。\n平台的考虑\nABI 的稳定性不仅取决于 Python，取决于所使用的编译器、低层级库和编译器选项等。 对于 稳定\nABI 的目标来说，这些细节定义了一个 “平台”。 它们通常会依赖于 OS 类型和处理器架构等。\n确保在特定平台上的所有 Python 版本都以不破坏稳定 ABI 的方式构建是每个特定 Python 分发方的\n责任。 来自 python.org 以及许多第三方分发商的 Windows 和 macOS 发布版都必于这种情况。\n受限 API 的内容\n目前 受限 API 包括下面这些项:\nPY_VECTORCALL_ARGUMENTS_OFFSET\nPyAIter_Check()\nPyArg_Parse()\nPyArg_ParseTuple()\nPyArg_ParseTupleAndKeywords()\nPyArg_UnpackTuple()\nPyArg_VaParse()\nPyArg_VaParseTupleAndKeywords()\nPyArg_ValidateKeywordArguments()\nPyBaseObject_Type |  |\n| --- | --- | --- |\n\nPyBool_FromLong()\nPyBool_Type\nPyBuffer_FillContiguousStrides()\nPyBuffer_FillInfo()\nPyBuffer_FromContiguous()\nPyBuffer_GetPointer()\nPyBuffer_IsContiguous()\nPyBuffer_Release()\nPyBuffer_SizeFromFormat()\nPyBuffer_ToContiguous()\nPyByteArrayIter_Type\nPyByteArray_AsString()\nPyByteArray_Concat()\nPyByteArray_FromObject()\nPyByteArray_FromStringAndSize()\nPyByteArray_Resize()\nPyByteArray_Size()\nPyByteArray_Type\nPyBytesIter_Type\nPyBytes_AsString()\nPyBytes_AsStringAndSize()\nPyBytes_Concat()\nPyBytes_ConcatAndDel()\nPyBytes_DecodeEscape()\nPyBytes_FromFormat()\nPyBytes_FromFormatV()\nPyBytes_FromObject()\nPyBytes_FromString()\nPyBytes_FromStringAndSize()\nPyBytes_Repr()\nPyBytes_Size()\nPyBytes_Type\nPyCFunction\nPyCFunctionFast\nPyCFunctionFastWithKeywords\nPyCFunctionWithKeywords\nPyCFunction_GetFlags()\nPyCFunction_GetFunction()\nPyCFunction_GetSelf()\nPyCFunction_New()\nPyCFunction_NewEx()\nPyCFunction_Type\nPyCMethod_New()\n\n|  | PyBool_FromLong()\nPyBool_Type\nPyBuffer_FillContiguousStrides()\nPyBuffer_FillInfo()\nPyBuffer_FromContiguous()\nPyBuffer_GetPointer()\nPyBuffer_IsContiguous()\nPyBuffer_Release()\nPyBuffer_SizeFromFormat()\nPyBuffer_ToContiguous()\nPyByteArrayIter_Type\nPyByteArray_AsString()\nPyByteArray_Concat()\nPyByteArray_FromObject()\nPyByteArray_FromStringAndSize()\nPyByteArray_Resize()\nPyByteArray_Size()\nPyByteArray_Type\nPyBytesIter_Type\nPyBytes_AsString()\nPyBytes_AsStringAndSize()\nPyBytes_Concat()\nPyBytes_ConcatAndDel()\nPyBytes_DecodeEscape()\nPyBytes_FromFormat()\nPyBytes_FromFormatV()\nPyBytes_FromObject()\nPyBytes_FromString()\nPyBytes_FromStringAndSize()\nPyBytes_Repr()\nPyBytes_Size()\nPyBytes_Type\nPyCFunction\nPyCFunctionFast\nPyCFunctionFastWithKeywords\nPyCFunctionWithKeywords\nPyCFunction_GetFlags()\nPyCFunction_GetFunction()\nPyCFunction_GetSelf()\nPyCFunction_New()\nPyCFunction_NewEx()\nPyCFunction_Type\nPyCMethod_New() |  |\n| --- | --- | --- |\n\nPyCallIter_New()\nPyCallIter_Type\nPyCallable_Check()\nPyCapsule_Destructor\nPyCapsule_GetContext()\nPyCapsule_GetDestructor()\nPyCapsule_GetName()\nPyCapsule_GetPointer()\nPyCapsule_Import()\nPyCapsule_IsValid()\nPyCapsule_New()\nPyCapsule_SetContext()\nPyCapsule_SetDestructor()\nPyCapsule_SetName()\nPyCapsule_SetPointer()\nPyCapsule_Type\nPyClassMethodDescr_Type\nPyCodec_BackslashReplaceErrors()\nPyCodec_Decode()\nPyCodec_Decoder()\nPyCodec_Encode()\nPyCodec_Encoder()\nPyCodec_IgnoreErrors()\nPyCodec_IncrementalDecoder()\nPyCodec_IncrementalEncoder()\nPyCodec_KnownEncoding()\nPyCodec_LookupError()\nPyCodec_NameReplaceErrors()\nPyCodec_Register()\nPyCodec_RegisterError()\nPyCodec_ReplaceErrors()\nPyCodec_StreamReader()\nPyCodec_StreamWriter()\nPyCodec_StrictErrors()\nPyCodec_Unregister()\nPyCodec_XMLCharRefReplaceErrors()\nPyComplex_FromDoubles()\nPyComplex_ImagAsDouble()\nPyComplex_RealAsDouble()\nPyComplex_Type\nPyDescr_NewClassMethod()\nPyDescr_NewGetSet()\nPyDescr_NewMember()\n\n|  | PyCallIter_New()\nPyCallIter_Type\nPyCallable_Check()\nPyCapsule_Destructor\nPyCapsule_GetContext()\nPyCapsule_GetDestructor()\nPyCapsule_GetName()\nPyCapsule_GetPointer()\nPyCapsule_Import()\nPyCapsule_IsValid()\nPyCapsule_New()\nPyCapsule_SetContext()\nPyCapsule_SetDestructor()\nPyCapsule_SetName()\nPyCapsule_SetPointer()\nPyCapsule_Type\nPyClassMethodDescr_Type\nPyCodec_BackslashReplaceErrors()\nPyCodec_Decode()\nPyCodec_Decoder()\nPyCodec_Encode()\nPyCodec_Encoder()\nPyCodec_IgnoreErrors()\nPyCodec_IncrementalDecoder()\nPyCodec_IncrementalEncoder()\nPyCodec_KnownEncoding()\nPyCodec_LookupError()\nPyCodec_NameReplaceErrors()\nPyCodec_Register()\nPyCodec_RegisterError()\nPyCodec_ReplaceErrors()\nPyCodec_StreamReader()\nPyCodec_StreamWriter()\nPyCodec_StrictErrors()\nPyCodec_Unregister()\nPyCodec_XMLCharRefReplaceErrors()\nPyComplex_FromDoubles()\nPyComplex_ImagAsDouble()\nPyComplex_RealAsDouble()\nPyComplex_Type\nPyDescr_NewClassMethod()\nPyDescr_NewGetSet()\nPyDescr_NewMember() |  |\n| --- | --- | --- |\n\nPyDescr_NewMethod()\nPyDictItems_Type\nPyDictIterItem_Type\nPyDictIterKey_Type\nPyDictIterValue_Type\nPyDictKeys_Type\nPyDictProxy_New()\nPyDictProxy_Type\nPyDictRevIterItem_Type\nPyDictRevIterKey_Type\nPyDictRevIterValue_Type\nPyDictValues_Type\nPyDict_Clear()\nPyDict_Contains()\nPyDict_Copy()\nPyDict_DelItem()\nPyDict_DelItemString()\nPyDict_GetItem()\nPyDict_GetItemRef()\nPyDict_GetItemString()\nPyDict_GetItemStringRef()\nPyDict_GetItemWithError()\nPyDict_Items()\nPyDict_Keys()\nPyDict_Merge()\nPyDict_MergeFromSeq2()\nPyDict_New()\nPyDict_Next()\nPyDict_SetItem()\nPyDict_SetItemString()\nPyDict_Size()\nPyDict_Type\nPyDict_Update()\nPyDict_Values()\nPyEllipsis_Type\nPyEnum_Type\nPyErr_BadArgument()\nPyErr_BadInternalCall()\nPyErr_CheckSignals()\nPyErr_Clear()\nPyErr_Display()\nPyErr_DisplayException()\nPyErr_ExceptionMatches()\n\n|  | PyDescr_NewMethod()\nPyDictItems_Type\nPyDictIterItem_Type\nPyDictIterKey_Type\nPyDictIterValue_Type\nPyDictKeys_Type\nPyDictProxy_New()\nPyDictProxy_Type\nPyDictRevIterItem_Type\nPyDictRevIterKey_Type\nPyDictRevIterValue_Type\nPyDictValues_Type\nPyDict_Clear()\nPyDict_Contains()\nPyDict_Copy()\nPyDict_DelItem()\nPyDict_DelItemString()\nPyDict_GetItem()\nPyDict_GetItemRef()\nPyDict_GetItemString()\nPyDict_GetItemStringRef()\nPyDict_GetItemWithError()\nPyDict_Items()\nPyDict_Keys()\nPyDict_Merge()\nPyDict_MergeFromSeq2()\nPyDict_New()\nPyDict_Next()\nPyDict_SetItem()\nPyDict_SetItemString()\nPyDict_Size()\nPyDict_Type\nPyDict_Update()\nPyDict_Values()\nPyEllipsis_Type\nPyEnum_Type\nPyErr_BadArgument()\nPyErr_BadInternalCall()\nPyErr_CheckSignals()\nPyErr_Clear()\nPyErr_Display()\nPyErr_DisplayException()\nPyErr_ExceptionMatches() |  |\n| --- | --- | --- |\n\nPyErr_Fetch()\nPyErr_Format()\nPyErr_FormatV()\nPyErr_GetExcInfo()\nPyErr_GetHandledException()\nPyErr_GetRaisedException()\nPyErr_GivenExceptionMatches()\nPyErr_NewException()\nPyErr_NewExceptionWithDoc()\nPyErr_NoMemory()\nPyErr_NormalizeException()\nPyErr_Occurred()\nPyErr_Print()\nPyErr_PrintEx()\nPyErr_ProgramText()\nPyErr_ResourceWarning()\nPyErr_Restore()\nPyErr_SetExcFromWindowsErr()\nPyErr_SetExcFromWindowsErrWithFilename()\nPyErr_SetExcFromWindowsErrWithFilenameObject()\nPyErr_SetExcFromWindowsErrWithFilenameObjects()\nPyErr_SetExcInfo()\nPyErr_SetFromErrno()\nPyErr_SetFromErrnoWithFilename()\nPyErr_SetFromErrnoWithFilenameObject()\nPyErr_SetFromErrnoWithFilenameObjects()\nPyErr_SetFromWindowsErr()\nPyErr_SetFromWindowsErrWithFilename()\nPyErr_SetHandledException()\nPyErr_SetImportError()\nPyErr_SetImportErrorSubclass()\nPyErr_SetInterrupt()\nPyErr_SetInterruptEx()\nPyErr_SetNone()\nPyErr_SetObject()\nPyErr_SetRaisedException()\nPyErr_SetString()\nPyErr_SyntaxLocation()\nPyErr_SyntaxLocationEx()\nPyErr_WarnEx()\nPyErr_WarnExplicit()\nPyErr_WarnFormat()\nPyErr_WriteUnraisable()\n\n|  | PyErr_Fetch()\nPyErr_Format()\nPyErr_FormatV()\nPyErr_GetExcInfo()\nPyErr_GetHandledException()\nPyErr_GetRaisedException()\nPyErr_GivenExceptionMatches()\nPyErr_NewException()\nPyErr_NewExceptionWithDoc()\nPyErr_NoMemory()\nPyErr_NormalizeException()\nPyErr_Occurred()\nPyErr_Print()\nPyErr_PrintEx()\nPyErr_ProgramText()\nPyErr_ResourceWarning()\nPyErr_Restore()\nPyErr_SetExcFromWindowsErr()\nPyErr_SetExcFromWindowsErrWithFilename()\nPyErr_SetExcFromWindowsErrWithFilenameObject()\nPyErr_SetExcFromWindowsErrWithFilenameObjects()\nPyErr_SetExcInfo()\nPyErr_SetFromErrno()\nPyErr_SetFromErrnoWithFilename()\nPyErr_SetFromErrnoWithFilenameObject()\nPyErr_SetFromErrnoWithFilenameObjects()\nPyErr_SetFromWindowsErr()\nPyErr_SetFromWindowsErrWithFilename()\nPyErr_SetHandledException()\nPyErr_SetImportError()\nPyErr_SetImportErrorSubclass()\nPyErr_SetInterrupt()\nPyErr_SetInterruptEx()\nPyErr_SetNone()\nPyErr_SetObject()\nPyErr_SetRaisedException()\nPyErr_SetString()\nPyErr_SyntaxLocation()\nPyErr_SyntaxLocationEx()\nPyErr_WarnEx()\nPyErr_WarnExplicit()\nPyErr_WarnFormat()\nPyErr_WriteUnraisable() |  |\n| --- | --- | --- |\n\nPyEval_AcquireThread()\nPyEval_EvalCode()\nPyEval_EvalCodeEx()\nPyEval_EvalFrame()\nPyEval_EvalFrameEx()\nPyEval_GetBuiltins()\nPyEval_GetFrame()\nPyEval_GetFrameBuiltins()\nPyEval_GetFrameGlobals()\nPyEval_GetFrameLocals()\nPyEval_GetFuncDesc()\nPyEval_GetFuncName()\nPyEval_GetGlobals()\nPyEval_GetLocals()\nPyEval_InitThreads()\nPyEval_ReleaseThread()\nPyEval_RestoreThread()\nPyEval_SaveThread()\nPyExc_ArithmeticError\nPyExc_AssertionError\nPyExc_AttributeError\nPyExc_BaseException\nPyExc_BaseExceptionGroup\nPyExc_BlockingIOError\nPyExc_BrokenPipeError\nPyExc_BufferError\nPyExc_BytesWarning\nPyExc_ChildProcessError\nPyExc_ConnectionAbortedError\nPyExc_ConnectionError\nPyExc_ConnectionRefusedError\nPyExc_ConnectionResetError\nPyExc_DeprecationWarning\nPyExc_EOFError\nPyExc_EncodingWarning\nPyExc_EnvironmentError\nPyExc_Exception\nPyExc_FileExistsError\nPyExc_FileNotFoundError\nPyExc_FloatingPointError\nPyExc_FutureWarning\nPyExc_GeneratorExit\nPyExc_IOError\n\n|  | PyEval_AcquireThread()\nPyEval_EvalCode()\nPyEval_EvalCodeEx()\nPyEval_EvalFrame()\nPyEval_EvalFrameEx()\nPyEval_GetBuiltins()\nPyEval_GetFrame()\nPyEval_GetFrameBuiltins()\nPyEval_GetFrameGlobals()\nPyEval_GetFrameLocals()\nPyEval_GetFuncDesc()\nPyEval_GetFuncName()\nPyEval_GetGlobals()\nPyEval_GetLocals()\nPyEval_InitThreads()\nPyEval_ReleaseThread()\nPyEval_RestoreThread()\nPyEval_SaveThread()\nPyExc_ArithmeticError\nPyExc_AssertionError\nPyExc_AttributeError\nPyExc_BaseException\nPyExc_BaseExceptionGroup\nPyExc_BlockingIOError\nPyExc_BrokenPipeError\nPyExc_BufferError\nPyExc_BytesWarning\nPyExc_ChildProcessError\nPyExc_ConnectionAbortedError\nPyExc_ConnectionError\nPyExc_ConnectionRefusedError\nPyExc_ConnectionResetError\nPyExc_DeprecationWarning\nPyExc_EOFError\nPyExc_EncodingWarning\nPyExc_EnvironmentError\nPyExc_Exception\nPyExc_FileExistsError\nPyExc_FileNotFoundError\nPyExc_FloatingPointError\nPyExc_FutureWarning\nPyExc_GeneratorExit\nPyExc_IOError |  |\n| --- | --- | --- |\n\nPyExc_ImportError\nPyExc_ImportWarning\nPyExc_IndentationError\nPyExc_IndexError\nPyExc_InterruptedError\nPyExc_IsADirectoryError\nPyExc_KeyError\nPyExc_KeyboardInterrupt\nPyExc_LookupError\nPyExc_MemoryError\nPyExc_ModuleNotFoundError\nPyExc_NameError\nPyExc_NotADirectoryError\nPyExc_NotImplementedError\nPyExc_OSError\nPyExc_OverflowError\nPyExc_PendingDeprecationWarning\nPyExc_PermissionError\nPyExc_ProcessLookupError\nPyExc_RecursionError\nPyExc_ReferenceError\nPyExc_ResourceWarning\nPyExc_RuntimeError\nPyExc_RuntimeWarning\nPyExc_StopAsyncIteration\nPyExc_StopIteration\nPyExc_SyntaxError\nPyExc_SyntaxWarning\nPyExc_SystemError\nPyExc_SystemExit\nPyExc_TabError\nPyExc_TimeoutError\nPyExc_TypeError\nPyExc_UnboundLocalError\nPyExc_UnicodeDecodeError\nPyExc_UnicodeEncodeError\nPyExc_UnicodeError\nPyExc_UnicodeTranslateError\nPyExc_UnicodeWarning\nPyExc_UserWarning\nPyExc_ValueError\nPyExc_Warning\nPyExc_WindowsError\n\n|  | PyExc_ImportError\nPyExc_ImportWarning\nPyExc_IndentationError\nPyExc_IndexError\nPyExc_InterruptedError\nPyExc_IsADirectoryError\nPyExc_KeyError\nPyExc_KeyboardInterrupt\nPyExc_LookupError\nPyExc_MemoryError\nPyExc_ModuleNotFoundError\nPyExc_NameError\nPyExc_NotADirectoryError\nPyExc_NotImplementedError\nPyExc_OSError\nPyExc_OverflowError\nPyExc_PendingDeprecationWarning\nPyExc_PermissionError\nPyExc_ProcessLookupError\nPyExc_RecursionError\nPyExc_ReferenceError\nPyExc_ResourceWarning\nPyExc_RuntimeError\nPyExc_RuntimeWarning\nPyExc_StopAsyncIteration\nPyExc_StopIteration\nPyExc_SyntaxError\nPyExc_SyntaxWarning\nPyExc_SystemError\nPyExc_SystemExit\nPyExc_TabError\nPyExc_TimeoutError\nPyExc_TypeError\nPyExc_UnboundLocalError\nPyExc_UnicodeDecodeError\nPyExc_UnicodeEncodeError\nPyExc_UnicodeError\nPyExc_UnicodeTranslateError\nPyExc_UnicodeWarning\nPyExc_UserWarning\nPyExc_ValueError\nPyExc_Warning\nPyExc_WindowsError |  |\n| --- | --- | --- |\n\nPyExc_ZeroDivisionError\nPyExceptionClass_Name()\nPyException_GetArgs()\nPyException_GetCause()\nPyException_GetContext()\nPyException_GetTraceback()\nPyException_SetArgs()\nPyException_SetCause()\nPyException_SetContext()\nPyException_SetTraceback()\nPyFile_FromFd()\nPyFile_GetLine()\nPyFile_WriteObject()\nPyFile_WriteString()\nPyFilter_Type\nPyFloat_AsDouble()\nPyFloat_FromDouble()\nPyFloat_FromString()\nPyFloat_GetInfo()\nPyFloat_GetMax()\nPyFloat_GetMin()\nPyFloat_Type\nPyFrameObject\nPyFrame_GetCode()\nPyFrame_GetLineNumber()\nPyFrozenSet_New()\nPyFrozenSet_Type\nPyGC_Collect()\nPyGC_Disable()\nPyGC_Enable()\nPyGC_IsEnabled()\nPyGILState_Ensure()\nPyGILState_GetThisThreadState()\nPyGILState_Release()\nPyGILState_STATE\nPyGetSetDef\nPyGetSetDescr_Type\nPyImport_AddModule()\nPyImport_AddModuleObject()\nPyImport_AddModuleRef()\nPyImport_AppendInittab()\nPyImport_ExecCodeModule()\nPyImport_ExecCodeModuleEx()\n\n|  | PyExc_ZeroDivisionError\nPyExceptionClass_Name()\nPyException_GetArgs()\nPyException_GetCause()\nPyException_GetContext()\nPyException_GetTraceback()\nPyException_SetArgs()\nPyException_SetCause()\nPyException_SetContext()\nPyException_SetTraceback()\nPyFile_FromFd()\nPyFile_GetLine()\nPyFile_WriteObject()\nPyFile_WriteString()\nPyFilter_Type\nPyFloat_AsDouble()\nPyFloat_FromDouble()\nPyFloat_FromString()\nPyFloat_GetInfo()\nPyFloat_GetMax()\nPyFloat_GetMin()\nPyFloat_Type\nPyFrameObject\nPyFrame_GetCode()\nPyFrame_GetLineNumber()\nPyFrozenSet_New()\nPyFrozenSet_Type\nPyGC_Collect()\nPyGC_Disable()\nPyGC_Enable()\nPyGC_IsEnabled()\nPyGILState_Ensure()\nPyGILState_GetThisThreadState()\nPyGILState_Release()\nPyGILState_STATE\nPyGetSetDef\nPyGetSetDescr_Type\nPyImport_AddModule()\nPyImport_AddModuleObject()\nPyImport_AddModuleRef()\nPyImport_AppendInittab()\nPyImport_ExecCodeModule()\nPyImport_ExecCodeModuleEx() |  |\n| --- | --- | --- |\n\nPyImport_ExecCodeModuleObject()\nPyImport_ExecCodeModuleWithPathnames()\nPyImport_GetImporter()\nPyImport_GetMagicNumber()\nPyImport_GetMagicTag()\nPyImport_GetModule()\nPyImport_GetModuleDict()\nPyImport_Import()\nPyImport_ImportFrozenModule()\nPyImport_ImportFrozenModuleObject()\nPyImport_ImportModule()\nPyImport_ImportModuleLevel()\nPyImport_ImportModuleLevelObject()\nPyImport_ImportModuleNoBlock()\nPyImport_ReloadModule()\nPyIndex_Check()\nPyInterpreterState\nPyInterpreterState_Clear()\nPyInterpreterState_Delete()\nPyInterpreterState_Get()\nPyInterpreterState_GetDict()\nPyInterpreterState_GetID()\nPyInterpreterState_New()\nPyIter_Check()\nPyIter_Next()\nPyIter_NextItem()\nPyIter_Send()\nPyListIter_Type\nPyListRevIter_Type\nPyList_Append()\nPyList_AsTuple()\nPyList_GetItem()\nPyList_GetItemRef()\nPyList_GetSlice()\nPyList_Insert()\nPyList_New()\nPyList_Reverse()\nPyList_SetItem()\nPyList_SetSlice()\nPyList_Size()\nPyList_Sort()\nPyList_Type\nPyLongObject\n\n|  | PyImport_ExecCodeModuleObject()\nPyImport_ExecCodeModuleWithPathnames()\nPyImport_GetImporter()\nPyImport_GetMagicNumber()\nPyImport_GetMagicTag()\nPyImport_GetModule()\nPyImport_GetModuleDict()\nPyImport_Import()\nPyImport_ImportFrozenModule()\nPyImport_ImportFrozenModuleObject()\nPyImport_ImportModule()\nPyImport_ImportModuleLevel()\nPyImport_ImportModuleLevelObject()\nPyImport_ImportModuleNoBlock()\nPyImport_ReloadModule()\nPyIndex_Check()\nPyInterpreterState\nPyInterpreterState_Clear()\nPyInterpreterState_Delete()\nPyInterpreterState_Get()\nPyInterpreterState_GetDict()\nPyInterpreterState_GetID()\nPyInterpreterState_New()\nPyIter_Check()\nPyIter_Next()\nPyIter_NextItem()\nPyIter_Send()\nPyListIter_Type\nPyListRevIter_Type\nPyList_Append()\nPyList_AsTuple()\nPyList_GetItem()\nPyList_GetItemRef()\nPyList_GetSlice()\nPyList_Insert()\nPyList_New()\nPyList_Reverse()\nPyList_SetItem()\nPyList_SetSlice()\nPyList_Size()\nPyList_Sort()\nPyList_Type\nPyLongObject |  |\n| --- | --- | --- |\n\nPyLongRangeIter_Type\nPyLong_AsDouble()\nPyLong_AsInt()\nPyLong_AsInt32()\nPyLong_AsInt64()\nPyLong_AsLong()\nPyLong_AsLongAndOverflow()\nPyLong_AsLongLong()\nPyLong_AsLongLongAndOverflow()\nPyLong_AsNativeBytes()\nPyLong_AsSize_t()\nPyLong_AsSsize_t()\nPyLong_AsUInt32()\nPyLong_AsUInt64()\nPyLong_AsUnsignedLong()\nPyLong_AsUnsignedLongLong()\nPyLong_AsUnsignedLongLongMask()\nPyLong_AsUnsignedLongMask()\nPyLong_AsVoidPtr()\nPyLong_FromDouble()\nPyLong_FromInt32()\nPyLong_FromInt64()\nPyLong_FromLong()\nPyLong_FromLongLong()\nPyLong_FromNativeBytes()\nPyLong_FromSize_t()\nPyLong_FromSsize_t()\nPyLong_FromString()\nPyLong_FromUInt32()\nPyLong_FromUInt64()\nPyLong_FromUnsignedLong()\nPyLong_FromUnsignedLongLong()\nPyLong_FromUnsignedNativeBytes()\nPyLong_FromVoidPtr()\nPyLong_GetInfo()\nPyLong_Type\nPyMap_Type\nPyMapping_Check()\nPyMapping_GetItemString()\nPyMapping_GetOptionalItem()\nPyMapping_GetOptionalItemString()\nPyMapping_HasKey()\nPyMapping_HasKeyString()\n\n|  | PyLongRangeIter_Type\nPyLong_AsDouble()\nPyLong_AsInt()\nPyLong_AsInt32()\nPyLong_AsInt64()\nPyLong_AsLong()\nPyLong_AsLongAndOverflow()\nPyLong_AsLongLong()\nPyLong_AsLongLongAndOverflow()\nPyLong_AsNativeBytes()\nPyLong_AsSize_t()\nPyLong_AsSsize_t()\nPyLong_AsUInt32()\nPyLong_AsUInt64()\nPyLong_AsUnsignedLong()\nPyLong_AsUnsignedLongLong()\nPyLong_AsUnsignedLongLongMask()\nPyLong_AsUnsignedLongMask()\nPyLong_AsVoidPtr()\nPyLong_FromDouble()\nPyLong_FromInt32()\nPyLong_FromInt64()\nPyLong_FromLong()\nPyLong_FromLongLong()\nPyLong_FromNativeBytes()\nPyLong_FromSize_t()\nPyLong_FromSsize_t()\nPyLong_FromString()\nPyLong_FromUInt32()\nPyLong_FromUInt64()\nPyLong_FromUnsignedLong()\nPyLong_FromUnsignedLongLong()\nPyLong_FromUnsignedNativeBytes()\nPyLong_FromVoidPtr()\nPyLong_GetInfo()\nPyLong_Type\nPyMap_Type\nPyMapping_Check()\nPyMapping_GetItemString()\nPyMapping_GetOptionalItem()\nPyMapping_GetOptionalItemString()\nPyMapping_HasKey()\nPyMapping_HasKeyString() |  |\n| --- | --- | --- |\n\nPyMapping_HasKeyStringWithError()\nPyMapping_HasKeyWithError()\nPyMapping_Items()\nPyMapping_Keys()\nPyMapping_Length()\nPyMapping_SetItemString()\nPyMapping_Size()\nPyMapping_Values()\nPyMem_Calloc()\nPyMem_Free()\nPyMem_Malloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\nPyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_Realloc()\nPyMemberDef\nPyMemberDescr_Type\nPyMember_GetOne()\nPyMember_SetOne()\nPyMemoryView_FromBuffer()\nPyMemoryView_FromMemory()\nPyMemoryView_FromObject()\nPyMemoryView_GetContiguous()\nPyMemoryView_Type\nPyMethodDef\nPyMethodDescr_Type\nPyModuleDef\nPyModuleDef_Base\nPyModuleDef_Init()\nPyModuleDef_Type\nPyModule_Add()\nPyModule_AddFunctions()\nPyModule_AddIntConstant()\nPyModule_AddObject()\nPyModule_AddObjectRef()\nPyModule_AddStringConstant()\nPyModule_AddType()\nPyModule_Create2()\nPyModule_ExecDef()\nPyModule_FromDefAndSpec2()\nPyModule_GetDef()\nPyModule_GetDict()\n\n|  | PyMapping_HasKeyStringWithError()\nPyMapping_HasKeyWithError()\nPyMapping_Items()\nPyMapping_Keys()\nPyMapping_Length()\nPyMapping_SetItemString()\nPyMapping_Size()\nPyMapping_Values()\nPyMem_Calloc()\nPyMem_Free()\nPyMem_Malloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\nPyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_Realloc()\nPyMemberDef\nPyMemberDescr_Type\nPyMember_GetOne()\nPyMember_SetOne()\nPyMemoryView_FromBuffer()\nPyMemoryView_FromMemory()\nPyMemoryView_FromObject()\nPyMemoryView_GetContiguous()\nPyMemoryView_Type\nPyMethodDef\nPyMethodDescr_Type\nPyModuleDef\nPyModuleDef_Base\nPyModuleDef_Init()\nPyModuleDef_Type\nPyModule_Add()\nPyModule_AddFunctions()\nPyModule_AddIntConstant()\nPyModule_AddObject()\nPyModule_AddObjectRef()\nPyModule_AddStringConstant()\nPyModule_AddType()\nPyModule_Create2()\nPyModule_ExecDef()\nPyModule_FromDefAndSpec2()\nPyModule_GetDef()\nPyModule_GetDict() |  |\n| --- | --- | --- |\n\nPyModule_GetFilename()\nPyModule_GetFilenameObject()\nPyModule_GetName()\nPyModule_GetNameObject()\nPyModule_GetState()\nPyModule_New()\nPyModule_NewObject()\nPyModule_SetDocString()\nPyModule_Type\nPyNumber_Absolute()\nPyNumber_Add()\nPyNumber_And()\nPyNumber_AsSsize_t()\nPyNumber_Check()\nPyNumber_Divmod()\nPyNumber_Float()\nPyNumber_FloorDivide()\nPyNumber_InPlaceAdd()\nPyNumber_InPlaceAnd()\nPyNumber_InPlaceFloorDivide()\nPyNumber_InPlaceLshift()\nPyNumber_InPlaceMatrixMultiply()\nPyNumber_InPlaceMultiply()\nPyNumber_InPlaceOr()\nPyNumber_InPlacePower()\nPyNumber_InPlaceRemainder()\nPyNumber_InPlaceRshift()\nPyNumber_InPlaceSubtract()\nPyNumber_InPlaceTrueDivide()\nPyNumber_InPlaceXor()\nPyNumber_Index()\nPyNumber_Invert()\nPyNumber_Long()\nPyNumber_Lshift()\nPyNumber_MatrixMultiply()\nPyNumber_Multiply()\nPyNumber_Negative()\nPyNumber_Or()\nPyNumber_Positive()\nPyNumber_Power()\nPyNumber_Remainder()\nPyNumber_Rshift()\nPyNumber_Subtract()\n\n|  | PyModule_GetFilename()\nPyModule_GetFilenameObject()\nPyModule_GetName()\nPyModule_GetNameObject()\nPyModule_GetState()\nPyModule_New()\nPyModule_NewObject()\nPyModule_SetDocString()\nPyModule_Type\nPyNumber_Absolute()\nPyNumber_Add()\nPyNumber_And()\nPyNumber_AsSsize_t()\nPyNumber_Check()\nPyNumber_Divmod()\nPyNumber_Float()\nPyNumber_FloorDivide()\nPyNumber_InPlaceAdd()\nPyNumber_InPlaceAnd()\nPyNumber_InPlaceFloorDivide()\nPyNumber_InPlaceLshift()\nPyNumber_InPlaceMatrixMultiply()\nPyNumber_InPlaceMultiply()\nPyNumber_InPlaceOr()\nPyNumber_InPlacePower()\nPyNumber_InPlaceRemainder()\nPyNumber_InPlaceRshift()\nPyNumber_InPlaceSubtract()\nPyNumber_InPlaceTrueDivide()\nPyNumber_InPlaceXor()\nPyNumber_Index()\nPyNumber_Invert()\nPyNumber_Long()\nPyNumber_Lshift()\nPyNumber_MatrixMultiply()\nPyNumber_Multiply()\nPyNumber_Negative()\nPyNumber_Or()\nPyNumber_Positive()\nPyNumber_Power()\nPyNumber_Remainder()\nPyNumber_Rshift()\nPyNumber_Subtract() |  |\n| --- | --- | --- |\n\nPyNumber_ToBase()\nPyNumber_TrueDivide()\nPyNumber_Xor()\nPyOS_AfterFork()\nPyOS_AfterFork_Child()\nPyOS_AfterFork_Parent()\nPyOS_BeforeFork()\nPyOS_CheckStack()\nPyOS_FSPath()\nPyOS_InputHook\nPyOS_InterruptOccurred()\nPyOS_double_to_string()\nPyOS_getsig()\nPyOS_mystricmp()\nPyOS_mystrnicmp()\nPyOS_setsig()\nPyOS_sighandler_t\nPyOS_snprintf()\nPyOS_string_to_double()\nPyOS_strtol()\nPyOS_strtoul()\nPyOS_vsnprintf()\nPyObject\nPyObject.ob_refcnt\nPyObject.ob_type\nPyObject_ASCII()\nPyObject_AsFileDescriptor()\nPyObject_Bytes()\nPyObject_Call()\nPyObject_CallFunction()\nPyObject_CallFunctionObjArgs()\nPyObject_CallMethod()\nPyObject_CallMethodObjArgs()\nPyObject_CallNoArgs()\nPyObject_CallObject()\nPyObject_Calloc()\nPyObject_CheckBuffer()\nPyObject_ClearWeakRefs()\nPyObject_CopyData()\nPyObject_DelAttr()\nPyObject_DelAttrString()\nPyObject_DelItem()\nPyObject_DelItemString()\n\n|  | PyNumber_ToBase()\nPyNumber_TrueDivide()\nPyNumber_Xor()\nPyOS_AfterFork()\nPyOS_AfterFork_Child()\nPyOS_AfterFork_Parent()\nPyOS_BeforeFork()\nPyOS_CheckStack()\nPyOS_FSPath()\nPyOS_InputHook\nPyOS_InterruptOccurred()\nPyOS_double_to_string()\nPyOS_getsig()\nPyOS_mystricmp()\nPyOS_mystrnicmp()\nPyOS_setsig()\nPyOS_sighandler_t\nPyOS_snprintf()\nPyOS_string_to_double()\nPyOS_strtol()\nPyOS_strtoul()\nPyOS_vsnprintf()\nPyObject\nPyObject.ob_refcnt\nPyObject.ob_type\nPyObject_ASCII()\nPyObject_AsFileDescriptor()\nPyObject_Bytes()\nPyObject_Call()\nPyObject_CallFunction()\nPyObject_CallFunctionObjArgs()\nPyObject_CallMethod()\nPyObject_CallMethodObjArgs()\nPyObject_CallNoArgs()\nPyObject_CallObject()\nPyObject_Calloc()\nPyObject_CheckBuffer()\nPyObject_ClearWeakRefs()\nPyObject_CopyData()\nPyObject_DelAttr()\nPyObject_DelAttrString()\nPyObject_DelItem()\nPyObject_DelItemString() |  |\n| --- | --- | --- |\n\nPyObject_Dir()\nPyObject_Format()\nPyObject_Free()\nPyObject_GC_Del()\nPyObject_GC_IsFinalized()\nPyObject_GC_IsTracked()\nPyObject_GC_Track()\nPyObject_GC_UnTrack()\nPyObject_GenericGetAttr()\nPyObject_GenericGetDict()\nPyObject_GenericSetAttr()\nPyObject_GenericSetDict()\nPyObject_GetAIter()\nPyObject_GetAttr()\nPyObject_GetAttrString()\nPyObject_GetBuffer()\nPyObject_GetItem()\nPyObject_GetIter()\nPyObject_GetOptionalAttr()\nPyObject_GetOptionalAttrString()\nPyObject_GetTypeData()\nPyObject_HasAttr()\nPyObject_HasAttrString()\nPyObject_HasAttrStringWithError()\nPyObject_HasAttrWithError()\nPyObject_Hash()\nPyObject_HashNotImplemented()\nPyObject_Init()\nPyObject_InitVar()\nPyObject_IsInstance()\nPyObject_IsSubclass()\nPyObject_IsTrue()\nPyObject_Length()\nPyObject_Malloc()\nPyObject_Not()\nPyObject_Realloc()\nPyObject_Repr()\nPyObject_RichCompare()\nPyObject_RichCompareBool()\nPyObject_SelfIter()\nPyObject_SetAttr()\nPyObject_SetAttrString()\nPyObject_SetItem()\n\n|  | PyObject_Dir()\nPyObject_Format()\nPyObject_Free()\nPyObject_GC_Del()\nPyObject_GC_IsFinalized()\nPyObject_GC_IsTracked()\nPyObject_GC_Track()\nPyObject_GC_UnTrack()\nPyObject_GenericGetAttr()\nPyObject_GenericGetDict()\nPyObject_GenericSetAttr()\nPyObject_GenericSetDict()\nPyObject_GetAIter()\nPyObject_GetAttr()\nPyObject_GetAttrString()\nPyObject_GetBuffer()\nPyObject_GetItem()\nPyObject_GetIter()\nPyObject_GetOptionalAttr()\nPyObject_GetOptionalAttrString()\nPyObject_GetTypeData()\nPyObject_HasAttr()\nPyObject_HasAttrString()\nPyObject_HasAttrStringWithError()\nPyObject_HasAttrWithError()\nPyObject_Hash()\nPyObject_HashNotImplemented()\nPyObject_Init()\nPyObject_InitVar()\nPyObject_IsInstance()\nPyObject_IsSubclass()\nPyObject_IsTrue()\nPyObject_Length()\nPyObject_Malloc()\nPyObject_Not()\nPyObject_Realloc()\nPyObject_Repr()\nPyObject_RichCompare()\nPyObject_RichCompareBool()\nPyObject_SelfIter()\nPyObject_SetAttr()\nPyObject_SetAttrString()\nPyObject_SetItem() |  |\n| --- | --- | --- |\n\nPyObject_Size()\nPyObject_Str()\nPyObject_Type()\nPyObject_Vectorcall()\nPyObject_VectorcallMethod()\nPyProperty_Type\nPyRangeIter_Type\nPyRange_Type\nPyReversed_Type\nPySeqIter_New()\nPySeqIter_Type\nPySequence_Check()\nPySequence_Concat()\nPySequence_Contains()\nPySequence_Count()\nPySequence_DelItem()\nPySequence_DelSlice()\nPySequence_Fast()\nPySequence_GetItem()\nPySequence_GetSlice()\nPySequence_In()\nPySequence_InPlaceConcat()\nPySequence_InPlaceRepeat()\nPySequence_Index()\nPySequence_Length()\nPySequence_List()\nPySequence_Repeat()\nPySequence_SetItem()\nPySequence_SetSlice()\nPySequence_Size()\nPySequence_Tuple()\nPySetIter_Type\nPySet_Add()\nPySet_Clear()\nPySet_Contains()\nPySet_Discard()\nPySet_New()\nPySet_Pop()\nPySet_Size()\nPySet_Type\nPySlice_AdjustIndices()\nPySlice_GetIndices()\nPySlice_GetIndicesEx()\n\n|  | PyObject_Size()\nPyObject_Str()\nPyObject_Type()\nPyObject_Vectorcall()\nPyObject_VectorcallMethod()\nPyProperty_Type\nPyRangeIter_Type\nPyRange_Type\nPyReversed_Type\nPySeqIter_New()\nPySeqIter_Type\nPySequence_Check()\nPySequence_Concat()\nPySequence_Contains()\nPySequence_Count()\nPySequence_DelItem()\nPySequence_DelSlice()\nPySequence_Fast()\nPySequence_GetItem()\nPySequence_GetSlice()\nPySequence_In()\nPySequence_InPlaceConcat()\nPySequence_InPlaceRepeat()\nPySequence_Index()\nPySequence_Length()\nPySequence_List()\nPySequence_Repeat()\nPySequence_SetItem()\nPySequence_SetSlice()\nPySequence_Size()\nPySequence_Tuple()\nPySetIter_Type\nPySet_Add()\nPySet_Clear()\nPySet_Contains()\nPySet_Discard()\nPySet_New()\nPySet_Pop()\nPySet_Size()\nPySet_Type\nPySlice_AdjustIndices()\nPySlice_GetIndices()\nPySlice_GetIndicesEx() |  |\n| --- | --- | --- |\n\nPySlice_New()\nPySlice_Type\nPySlice_Unpack()\nPyState_AddModule()\nPyState_FindModule()\nPyState_RemoveModule()\nPyStructSequence_Desc\nPyStructSequence_Field\nPyStructSequence_GetItem()\nPyStructSequence_New()\nPyStructSequence_NewType()\nPyStructSequence_SetItem()\nPyStructSequence_UnnamedField\nPySuper_Type\nPySys_Audit()\nPySys_AuditTuple()\nPySys_FormatStderr()\nPySys_FormatStdout()\nPySys_GetObject()\nPySys_GetXOptions()\nPySys_ResetWarnOptions()\nPySys_SetArgv()\nPySys_SetArgvEx()\nPySys_SetObject()\nPySys_WriteStderr()\nPySys_WriteStdout()\nPyThreadState\nPyThreadState_Clear()\nPyThreadState_Delete()\nPyThreadState_Get()\nPyThreadState_GetDict()\nPyThreadState_GetFrame()\nPyThreadState_GetID()\nPyThreadState_GetInterpreter()\nPyThreadState_New()\nPyThreadState_SetAsyncExc()\nPyThreadState_Swap()\nPyThread_GetInfo()\nPyThread_ReInitTLS()\nPyThread_acquire_lock()\nPyThread_acquire_lock_timed()\nPyThread_allocate_lock()\nPyThread_create_key()\n\n|  | PySlice_New()\nPySlice_Type\nPySlice_Unpack()\nPyState_AddModule()\nPyState_FindModule()\nPyState_RemoveModule()\nPyStructSequence_Desc\nPyStructSequence_Field\nPyStructSequence_GetItem()\nPyStructSequence_New()\nPyStructSequence_NewType()\nPyStructSequence_SetItem()\nPyStructSequence_UnnamedField\nPySuper_Type\nPySys_Audit()\nPySys_AuditTuple()\nPySys_FormatStderr()\nPySys_FormatStdout()\nPySys_GetObject()\nPySys_GetXOptions()\nPySys_ResetWarnOptions()\nPySys_SetArgv()\nPySys_SetArgvEx()\nPySys_SetObject()\nPySys_WriteStderr()\nPySys_WriteStdout()\nPyThreadState\nPyThreadState_Clear()\nPyThreadState_Delete()\nPyThreadState_Get()\nPyThreadState_GetDict()\nPyThreadState_GetFrame()\nPyThreadState_GetID()\nPyThreadState_GetInterpreter()\nPyThreadState_New()\nPyThreadState_SetAsyncExc()\nPyThreadState_Swap()\nPyThread_GetInfo()\nPyThread_ReInitTLS()\nPyThread_acquire_lock()\nPyThread_acquire_lock_timed()\nPyThread_allocate_lock()\nPyThread_create_key() |  |\n| --- | --- | --- |\n\nPyThread_delete_key()\nPyThread_delete_key_value()\nPyThread_exit_thread()\nPyThread_free_lock()\nPyThread_get_key_value()\nPyThread_get_stacksize()\nPyThread_get_thread_ident()\nPyThread_get_thread_native_id()\nPyThread_init_thread()\nPyThread_release_lock()\nPyThread_set_key_value()\nPyThread_set_stacksize()\nPyThread_start_new_thread()\nPyThread_tss_alloc()\nPyThread_tss_create()\nPyThread_tss_delete()\nPyThread_tss_free()\nPyThread_tss_get()\nPyThread_tss_is_created()\nPyThread_tss_set()\nPyTraceBack_Here()\nPyTraceBack_Print()\nPyTraceBack_Type\nPyTupleIter_Type\nPyTuple_GetItem()\nPyTuple_GetSlice()\nPyTuple_New()\nPyTuple_Pack()\nPyTuple_SetItem()\nPyTuple_Size()\nPyTuple_Type\nPyTypeObject\nPyType_ClearCache()\nPyType_Freeze()\nPyType_FromMetaclass()\nPyType_FromModuleAndSpec()\nPyType_FromSpec()\nPyType_FromSpecWithBases()\nPyType_GenericAlloc()\nPyType_GenericNew()\nPyType_GetBaseByToken()\nPyType_GetFlags()\nPyType_GetFullyQualifiedName()\n\n|  | PyThread_delete_key()\nPyThread_delete_key_value()\nPyThread_exit_thread()\nPyThread_free_lock()\nPyThread_get_key_value()\nPyThread_get_stacksize()\nPyThread_get_thread_ident()\nPyThread_get_thread_native_id()\nPyThread_init_thread()\nPyThread_release_lock()\nPyThread_set_key_value()\nPyThread_set_stacksize()\nPyThread_start_new_thread()\nPyThread_tss_alloc()\nPyThread_tss_create()\nPyThread_tss_delete()\nPyThread_tss_free()\nPyThread_tss_get()\nPyThread_tss_is_created()\nPyThread_tss_set()\nPyTraceBack_Here()\nPyTraceBack_Print()\nPyTraceBack_Type\nPyTupleIter_Type\nPyTuple_GetItem()\nPyTuple_GetSlice()\nPyTuple_New()\nPyTuple_Pack()\nPyTuple_SetItem()\nPyTuple_Size()\nPyTuple_Type\nPyTypeObject\nPyType_ClearCache()\nPyType_Freeze()\nPyType_FromMetaclass()\nPyType_FromModuleAndSpec()\nPyType_FromSpec()\nPyType_FromSpecWithBases()\nPyType_GenericAlloc()\nPyType_GenericNew()\nPyType_GetBaseByToken()\nPyType_GetFlags()\nPyType_GetFullyQualifiedName() |  |\n| --- | --- | --- |\n\nPyType_GetModule()\nPyType_GetModuleByDef()\nPyType_GetModuleName()\nPyType_GetModuleState()\nPyType_GetName()\nPyType_GetQualName()\nPyType_GetSlot()\nPyType_GetTypeDataSize()\nPyType_IsSubtype()\nPyType_Modified()\nPyType_Ready()\nPyType_Slot\nPyType_Spec\nPyType_Type\nPyUnicodeDecodeError_Create()\nPyUnicodeDecodeError_GetEncoding()\nPyUnicodeDecodeError_GetEnd()\nPyUnicodeDecodeError_GetObject()\nPyUnicodeDecodeError_GetReason()\nPyUnicodeDecodeError_GetStart()\nPyUnicodeDecodeError_SetEnd()\nPyUnicodeDecodeError_SetReason()\nPyUnicodeDecodeError_SetStart()\nPyUnicodeEncodeError_GetEncoding()\nPyUnicodeEncodeError_GetEnd()\nPyUnicodeEncodeError_GetObject()\nPyUnicodeEncodeError_GetReason()\nPyUnicodeEncodeError_GetStart()\nPyUnicodeEncodeError_SetEnd()\nPyUnicodeEncodeError_SetReason()\nPyUnicodeEncodeError_SetStart()\nPyUnicodeIter_Type\nPyUnicodeTranslateError_GetEnd()\nPyUnicodeTranslateError_GetObject()\nPyUnicodeTranslateError_GetReason()\nPyUnicodeTranslateError_GetStart()\nPyUnicodeTranslateError_SetEnd()\nPyUnicodeTranslateError_SetReason()\nPyUnicodeTranslateError_SetStart()\nPyUnicode_Append()\nPyUnicode_AppendAndDel()\nPyUnicode_AsASCIIString()\nPyUnicode_AsCharmapString()\n\n|  | PyType_GetModule()\nPyType_GetModuleByDef()\nPyType_GetModuleName()\nPyType_GetModuleState()\nPyType_GetName()\nPyType_GetQualName()\nPyType_GetSlot()\nPyType_GetTypeDataSize()\nPyType_IsSubtype()\nPyType_Modified()\nPyType_Ready()\nPyType_Slot\nPyType_Spec\nPyType_Type\nPyUnicodeDecodeError_Create()\nPyUnicodeDecodeError_GetEncoding()\nPyUnicodeDecodeError_GetEnd()\nPyUnicodeDecodeError_GetObject()\nPyUnicodeDecodeError_GetReason()\nPyUnicodeDecodeError_GetStart()\nPyUnicodeDecodeError_SetEnd()\nPyUnicodeDecodeError_SetReason()\nPyUnicodeDecodeError_SetStart()\nPyUnicodeEncodeError_GetEncoding()\nPyUnicodeEncodeError_GetEnd()\nPyUnicodeEncodeError_GetObject()\nPyUnicodeEncodeError_GetReason()\nPyUnicodeEncodeError_GetStart()\nPyUnicodeEncodeError_SetEnd()\nPyUnicodeEncodeError_SetReason()\nPyUnicodeEncodeError_SetStart()\nPyUnicodeIter_Type\nPyUnicodeTranslateError_GetEnd()\nPyUnicodeTranslateError_GetObject()\nPyUnicodeTranslateError_GetReason()\nPyUnicodeTranslateError_GetStart()\nPyUnicodeTranslateError_SetEnd()\nPyUnicodeTranslateError_SetReason()\nPyUnicodeTranslateError_SetStart()\nPyUnicode_Append()\nPyUnicode_AppendAndDel()\nPyUnicode_AsASCIIString()\nPyUnicode_AsCharmapString() |  |\n| --- | --- | --- |\n\nPyUnicode_AsDecodedObject()\nPyUnicode_AsDecodedUnicode()\nPyUnicode_AsEncodedObject()\nPyUnicode_AsEncodedString()\nPyUnicode_AsEncodedUnicode()\nPyUnicode_AsLatin1String()\nPyUnicode_AsMBCSString()\nPyUnicode_AsRawUnicodeEscapeString()\nPyUnicode_AsUCS4()\nPyUnicode_AsUCS4Copy()\nPyUnicode_AsUTF16String()\nPyUnicode_AsUTF32String()\nPyUnicode_AsUTF8AndSize()\nPyUnicode_AsUTF8String()\nPyUnicode_AsUnicodeEscapeString()\nPyUnicode_AsWideChar()\nPyUnicode_AsWideCharString()\nPyUnicode_BuildEncodingMap()\nPyUnicode_Compare()\nPyUnicode_CompareWithASCIIString()\nPyUnicode_Concat()\nPyUnicode_Contains()\nPyUnicode_Count()\nPyUnicode_Decode()\nPyUnicode_DecodeASCII()\nPyUnicode_DecodeCharmap()\nPyUnicode_DecodeCodePageStateful()\nPyUnicode_DecodeFSDefault()\nPyUnicode_DecodeFSDefaultAndSize()\nPyUnicode_DecodeLatin1()\nPyUnicode_DecodeLocale()\nPyUnicode_DecodeLocaleAndSize()\nPyUnicode_DecodeMBCS()\nPyUnicode_DecodeMBCSStateful()\nPyUnicode_DecodeRawUnicodeEscape()\nPyUnicode_DecodeUTF16()\nPyUnicode_DecodeUTF16Stateful()\nPyUnicode_DecodeUTF32()\nPyUnicode_DecodeUTF32Stateful()\nPyUnicode_DecodeUTF7()\nPyUnicode_DecodeUTF7Stateful()\nPyUnicode_DecodeUTF8()\nPyUnicode_DecodeUTF8Stateful()\n\n|  | PyUnicode_AsDecodedObject()\nPyUnicode_AsDecodedUnicode()\nPyUnicode_AsEncodedObject()\nPyUnicode_AsEncodedString()\nPyUnicode_AsEncodedUnicode()\nPyUnicode_AsLatin1String()\nPyUnicode_AsMBCSString()\nPyUnicode_AsRawUnicodeEscapeString()\nPyUnicode_AsUCS4()\nPyUnicode_AsUCS4Copy()\nPyUnicode_AsUTF16String()\nPyUnicode_AsUTF32String()\nPyUnicode_AsUTF8AndSize()\nPyUnicode_AsUTF8String()\nPyUnicode_AsUnicodeEscapeString()\nPyUnicode_AsWideChar()\nPyUnicode_AsWideCharString()\nPyUnicode_BuildEncodingMap()\nPyUnicode_Compare()\nPyUnicode_CompareWithASCIIString()\nPyUnicode_Concat()\nPyUnicode_Contains()\nPyUnicode_Count()\nPyUnicode_Decode()\nPyUnicode_DecodeASCII()\nPyUnicode_DecodeCharmap()\nPyUnicode_DecodeCodePageStateful()\nPyUnicode_DecodeFSDefault()\nPyUnicode_DecodeFSDefaultAndSize()\nPyUnicode_DecodeLatin1()\nPyUnicode_DecodeLocale()\nPyUnicode_DecodeLocaleAndSize()\nPyUnicode_DecodeMBCS()\nPyUnicode_DecodeMBCSStateful()\nPyUnicode_DecodeRawUnicodeEscape()\nPyUnicode_DecodeUTF16()\nPyUnicode_DecodeUTF16Stateful()\nPyUnicode_DecodeUTF32()\nPyUnicode_DecodeUTF32Stateful()\nPyUnicode_DecodeUTF7()\nPyUnicode_DecodeUTF7Stateful()\nPyUnicode_DecodeUTF8()\nPyUnicode_DecodeUTF8Stateful() |  |\n| --- | --- | --- |\n\nPyUnicode_DecodeUnicodeEscape()\nPyUnicode_EncodeCodePage()\nPyUnicode_EncodeFSDefault()\nPyUnicode_EncodeLocale()\nPyUnicode_Equal()\nPyUnicode_EqualToUTF8()\nPyUnicode_EqualToUTF8AndSize()\nPyUnicode_FSConverter()\nPyUnicode_FSDecoder()\nPyUnicode_Find()\nPyUnicode_FindChar()\nPyUnicode_Format()\nPyUnicode_FromEncodedObject()\nPyUnicode_FromFormat()\nPyUnicode_FromFormatV()\nPyUnicode_FromObject()\nPyUnicode_FromOrdinal()\nPyUnicode_FromString()\nPyUnicode_FromStringAndSize()\nPyUnicode_FromWideChar()\nPyUnicode_GetDefaultEncoding()\nPyUnicode_GetLength()\nPyUnicode_InternFromString()\nPyUnicode_InternInPlace()\nPyUnicode_IsIdentifier()\nPyUnicode_Join()\nPyUnicode_Partition()\nPyUnicode_RPartition()\nPyUnicode_RSplit()\nPyUnicode_ReadChar()\nPyUnicode_Replace()\nPyUnicode_Resize()\nPyUnicode_RichCompare()\nPyUnicode_Split()\nPyUnicode_Splitlines()\nPyUnicode_Substring()\nPyUnicode_Tailmatch()\nPyUnicode_Translate()\nPyUnicode_Type\nPyUnicode_WriteChar()\nPyVarObject\nPyVarObject.ob_base\nPyVarObject.ob_size\n\n|  | PyUnicode_DecodeUnicodeEscape()\nPyUnicode_EncodeCodePage()\nPyUnicode_EncodeFSDefault()\nPyUnicode_EncodeLocale()\nPyUnicode_Equal()\nPyUnicode_EqualToUTF8()\nPyUnicode_EqualToUTF8AndSize()\nPyUnicode_FSConverter()\nPyUnicode_FSDecoder()\nPyUnicode_Find()\nPyUnicode_FindChar()\nPyUnicode_Format()\nPyUnicode_FromEncodedObject()\nPyUnicode_FromFormat()\nPyUnicode_FromFormatV()\nPyUnicode_FromObject()\nPyUnicode_FromOrdinal()\nPyUnicode_FromString()\nPyUnicode_FromStringAndSize()\nPyUnicode_FromWideChar()\nPyUnicode_GetDefaultEncoding()\nPyUnicode_GetLength()\nPyUnicode_InternFromString()\nPyUnicode_InternInPlace()\nPyUnicode_IsIdentifier()\nPyUnicode_Join()\nPyUnicode_Partition()\nPyUnicode_RPartition()\nPyUnicode_RSplit()\nPyUnicode_ReadChar()\nPyUnicode_Replace()\nPyUnicode_Resize()\nPyUnicode_RichCompare()\nPyUnicode_Split()\nPyUnicode_Splitlines()\nPyUnicode_Substring()\nPyUnicode_Tailmatch()\nPyUnicode_Translate()\nPyUnicode_Type\nPyUnicode_WriteChar()\nPyVarObject\nPyVarObject.ob_base\nPyVarObject.ob_size |  |\n| --- | --- | --- |\n\nPyVectorcall_Call()\nPyVectorcall_NARGS()\nPyWeakReference\nPyWeakref_GetObject()\nPyWeakref_GetRef()\nPyWeakref_NewProxy()\nPyWeakref_NewRef()\nPyWrapperDescr_Type\nPyWrapper_New()\nPyZip_Type\nPy_AddPendingCall()\nPy_AtExit()\nPy_BEGIN_ALLOW_THREADS\nPy_BLOCK_THREADS\nPy_BuildValue()\nPy_BytesMain()\nPy_CompileString()\nPy_DecRef()\nPy_DecodeLocale()\nPy_END_ALLOW_THREADS\nPy_EncodeLocale()\nPy_EndInterpreter()\nPy_EnterRecursiveCall()\nPy_Exit()\nPy_FatalError()\nPy_FileSystemDefaultEncodeErrors\nPy_FileSystemDefaultEncoding\nPy_Finalize()\nPy_FinalizeEx()\nPy_GenericAlias()\nPy_GenericAliasType\nPy_GetBuildInfo()\nPy_GetCompiler()\nPy_GetConstant()\nPy_GetConstantBorrowed()\nPy_GetCopyright()\nPy_GetExecPrefix()\nPy_GetPath()\nPy_GetPlatform()\nPy_GetPrefix()\nPy_GetProgramFullPath()\nPy_GetProgramName()\nPy_GetPythonHome()\n\n|  | PyVectorcall_Call()\nPyVectorcall_NARGS()\nPyWeakReference\nPyWeakref_GetObject()\nPyWeakref_GetRef()\nPyWeakref_NewProxy()\nPyWeakref_NewRef()\nPyWrapperDescr_Type\nPyWrapper_New()\nPyZip_Type\nPy_AddPendingCall()\nPy_AtExit()\nPy_BEGIN_ALLOW_THREADS\nPy_BLOCK_THREADS\nPy_BuildValue()\nPy_BytesMain()\nPy_CompileString()\nPy_DecRef()\nPy_DecodeLocale()\nPy_END_ALLOW_THREADS\nPy_EncodeLocale()\nPy_EndInterpreter()\nPy_EnterRecursiveCall()\nPy_Exit()\nPy_FatalError()\nPy_FileSystemDefaultEncodeErrors\nPy_FileSystemDefaultEncoding\nPy_Finalize()\nPy_FinalizeEx()\nPy_GenericAlias()\nPy_GenericAliasType\nPy_GetBuildInfo()\nPy_GetCompiler()\nPy_GetConstant()\nPy_GetConstantBorrowed()\nPy_GetCopyright()\nPy_GetExecPrefix()\nPy_GetPath()\nPy_GetPlatform()\nPy_GetPrefix()\nPy_GetProgramFullPath()\nPy_GetProgramName()\nPy_GetPythonHome() |  |\n| --- | --- | --- |\n\nPy_GetRecursionLimit()\nPy_GetVersion()\nPy_HasFileSystemDefaultEncoding\nPy_IncRef()\nPy_Initialize()\nPy_InitializeEx()\nPy_Is()\nPy_IsFalse()\nPy_IsFinalizing()\nPy_IsInitialized()\nPy_IsNone()\nPy_IsTrue()\nPy_LeaveRecursiveCall()\nPy_Main()\nPy_MakePendingCalls()\nPy_NewInterpreter()\nPy_NewRef()\nPy_PACK_FULL_VERSION()\nPy_PACK_VERSION()\nPy_REFCNT()\nPy_ReprEnter()\nPy_ReprLeave()\nPy_SetProgramName()\nPy_SetPythonHome()\nPy_SetRecursionLimit()\nPy_TYPE()\nPy_UCS4\nPy_UNBLOCK_THREADS\nPy_UTF8Mode\nPy_VaBuildValue()\nPy_Version\nPy_XNewRef()\nPy_buffer\nPy_intptr_t\nPy_ssize_t\nPy_uintptr_t\nallocfunc\nbinaryfunc\ndescrgetfunc\ndescrsetfunc\ndestructor\ngetattrfunc\ngetattrofunc\n\n|  | Py_GetRecursionLimit()\nPy_GetVersion()\nPy_HasFileSystemDefaultEncoding\nPy_IncRef()\nPy_Initialize()\nPy_InitializeEx()\nPy_Is()\nPy_IsFalse()\nPy_IsFinalizing()\nPy_IsInitialized()\nPy_IsNone()\nPy_IsTrue()\nPy_LeaveRecursiveCall()\nPy_Main()\nPy_MakePendingCalls()\nPy_NewInterpreter()\nPy_NewRef()\nPy_PACK_FULL_VERSION()\nPy_PACK_VERSION()\nPy_REFCNT()\nPy_ReprEnter()\nPy_ReprLeave()\nPy_SetProgramName()\nPy_SetPythonHome()\nPy_SetRecursionLimit()\nPy_TYPE()\nPy_UCS4\nPy_UNBLOCK_THREADS\nPy_UTF8Mode\nPy_VaBuildValue()\nPy_Version\nPy_XNewRef()\nPy_buffer\nPy_intptr_t\nPy_ssize_t\nPy_uintptr_t\nallocfunc\nbinaryfunc\ndescrgetfunc\ndescrsetfunc\ndestructor\ngetattrfunc\ngetattrofunc |  |\n| --- | --- | --- |\n\ngetbufferproc\ngetiterfunc\ngetter\nhashfunc\ninitproc\ninquiry\niternextfunc\nlenfunc\nnewfunc\nobjobjargproc\nobjobjproc\nreleasebufferproc\nreprfunc\nrichcmpfunc\nsetattrfunc\nsetattrofunc\nsetter\nssizeargfunc\nssizeobjargproc\nssizessizeargfunc\nssizessizeobjargproc\nsymtable\nternaryfunc\ntraverseproc\nunaryfunc\nvectorcallfunc\nvisitproc", "metadata": {"title": "00_C_API_的稳定性", "source": "md_docs\\python_c-api_md\\00_C_API_的稳定性.md", "doc_type": "C API", "language": "中文", "doc_id": "809eb27d"}}
{"doc_id": "4cce2aee", "content": "Python 初始化配置\nPyInitConfig C API\nAdded in version 3.14.\nPython 可以用 Py_InitializeFromInitConfig() 来初始化。\nPy_RunMain() 函数可被用来编写定制的 Python 程序。\n另请参阅 初始化、最终化与线程。\n参见: PEP 741 \"Python 配置 C API\"。\n示例\n运行时始终启用 Python 开发模式 的定制版 Python 的例子；出错时将返回 -1:\nint init_python(void)\n{\nPyInitConfig *config = PyInitConfig_Create();\nif (config == NULL) {\nprintf(\"PYTHON INIT ERROR: memory allocation failed\\n\");\nreturn -1;\n}\n// 启用 Python 开发模式\nif (PyInitConfig_SetInt(config, \"dev_mode\", 1) < 0) {\ngoto error;\n}\n// 使用配置初始化 Python\nif (Py_InitializeFromInitConfig(config) < 0) {\ngoto error;\n}\nPyInitConfig_Free(config);\nreturn 0;\nerror:\n{\n// 显示错误消息\n//\n// 使用这种不常见的花括号风格，因为你不能\n// 将跳转目标指向变量声明。\nconst char *err_msg;\n(void)PyInitConfig_GetError(config, &err_msg);\nprintf(\"PYTHON INIT ERROR: %s\\n\", err_msg);\nPyInitConfig_Free(config);\nreturn -1;\n}\n}\n\n| Python 初始化配置\nPyInitConfig C API\nAdded in version 3.14.\nPython 可以用 Py_InitializeFromInitConfig() 来初始化。\nPy_RunMain() 函数可被用来编写定制的 Python 程序。\n另请参阅 初始化、最终化与线程。 |\n| --- |\n| 参见: PEP 741 \"Python 配置 C API\"。 |\n| 示例\n运行时始终启用 Python 开发模式 的定制版 Python 的例子；出错时将返回 -1: |\n| int init_python(void)\n{\nPyInitConfig *config = PyInitConfig_Create();\nif (config == NULL) {\nprintf(\"PYTHON INIT ERROR: memory allocation failed\\n\");\nreturn -1;\n}\n// 启用 Python 开发模式\nif (PyInitConfig_SetInt(config, \"dev_mode\", 1) < 0) {\ngoto error;\n}\n// 使用配置初始化 Python\nif (Py_InitializeFromInitConfig(config) < 0) {\ngoto error;\n}\nPyInitConfig_Free(config);\nreturn 0;\nerror:\n{\n// 显示错误消息\n//\n// 使用这种不常见的花括号风格，因为你不能\n// 将跳转目标指向变量声明。\nconst char *err_msg;\n(void)PyInitConfig_GetError(config, &err_msg);\nprintf(\"PYTHON INIT ERROR: %s\\n\", err_msg);\nPyInitConfig_Free(config);\nreturn -1;\n}\n} |\n|  |\n\n创建配置\nstruct PyInitConfig\n用于配置 Python 初始化的不透明结构体。\nPyInitConfig *PyInitConfig_Create(void)\n使用 隔离配置 的默认值新建一个初始化配置。\n它必须由 PyInitConfig_Free() 来释放。\n内存分配失败时返回 NULL。\nvoid PyInitConfig_Free(PyInitConfig *config)\n释放初始化配置 config 的内存。\n如果 config 为 NULL，则不执行任何操作。\n错误处理\nint PyInitConfig_GetError(PyInitConfig *config, const char **err_msg)\n获取 config 错误消息。\n如果设置了一个错误则设置 *err_msg 并返回 1。\n在其他情况下将 *err_msg 设为 NULL 并返回 0。\n错误消息是一个 UTF-8 编码的字符串。\n如果 config 具有一个退出码，则将退出码格式化为错误消息。\n错误消息将保持无效直到调用另一个 PyInitConfig 并附带 config。 调用方不必释放错误消\n息。\nint PyInitConfig_GetExitCode(PyInitConfig *config, int *exitcode)\n获取 config 退出码。\n如果 config 设置了一个退出码则设置 *exitcode 并返回 1。\n如果 config 没有设置退出码则返回 0。\n如果 parse_argv 选项为非零值则只有 Py_InitializeFromInitConfig() 函数能设置退出\n码。\n退出码的设置可以在解析命令行失败时 (退出码 2) 或是在命令行选项请求显示命令行帮助时 (退\n出码 0) 进行。\n获取选项\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\nint PyInitConfig_HasOption(PyInitConfig *config, const char *name)\n\n|  | 创建配置\nstruct PyInitConfig\n用于配置 Python 初始化的不透明结构体。\nPyInitConfig *PyInitConfig_Create(void)\n使用 隔离配置 的默认值新建一个初始化配置。\n它必须由 PyInitConfig_Free() 来释放。\n内存分配失败时返回 NULL。\nvoid PyInitConfig_Free(PyInitConfig *config)\n释放初始化配置 config 的内存。\n如果 config 为 NULL，则不执行任何操作。\n错误处理\nint PyInitConfig_GetError(PyInitConfig *config, const char **err_msg)\n获取 config 错误消息。\n如果设置了一个错误则设置 *err_msg 并返回 1。\n在其他情况下将 *err_msg 设为 NULL 并返回 0。\n错误消息是一个 UTF-8 编码的字符串。\n如果 config 具有一个退出码，则将退出码格式化为错误消息。\n错误消息将保持无效直到调用另一个 PyInitConfig 并附带 config。 调用方不必释放错误消\n息。\nint PyInitConfig_GetExitCode(PyInitConfig *config, int *exitcode)\n获取 config 退出码。\n如果 config 设置了一个退出码则设置 *exitcode 并返回 1。\n如果 config 没有设置退出码则返回 0。\n如果 parse_argv 选项为非零值则只有 Py_InitializeFromInitConfig() 函数能设置退出\n码。\n退出码的设置可以在解析命令行失败时 (退出码 2) 或是在命令行选项请求显示命令行帮助时 (退\n出码 0) 进行。\n获取选项\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\nint PyInitConfig_HasOption(PyInitConfig *config, const char *name) |  |\n| --- | --- | --- |\n\n检测配置是否具有一个名为 name 的选项。\n如果选项存在则返回 1，否则返回 0。\nint PyInitConfig_GetInt(PyInitConfig *config, const char *name, int64_t\n*value)\n获取一个整数形式的配置选项。\n在成功时设置 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\nint PyInitConfig_GetStr(PyInitConfig *config, const char *name, char\n**value)\n获取一个以空值结束的 UTF-8 编码字符串形式的字符串配置选项。\n在成功时设置 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果选项是一个可选字符串并且选项被取消设置则 *value 可被设为 NULL。\n在成功时，字符串如果不为 NULL 则必须用 free(value) 来释放它。\nint PyInitConfig_GetStrList(PyInitConfig *config, const char *name, size_t\n*length, char ***items)\n获取一个由以空值结束的 UTF-8 编码字符串组成的数组形式的字符串列表配置选项。\n在成功时设置 *length 和 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n在成功时，字符串列表必须用 PyInitConfig_FreeStrList(length, items) 来释放。\nvoid PyInitConfig_FreeStrList(size_t length, char **items)\n释放由 PyInitConfig_GetStrList() 创建的字符串列表的内存。\n设置选项\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\n某些配置选项具有对其他选项的附带影响。 这种逻辑仅限于调用了\nPy_InitializeFromInitConfig() 的时候，而不被下面的“设置”函数所实现。 例如，将 dev_mode\n设为 1 并不会将 faulthandler 设为 1。\nint PyInitConfig_SetInt(PyInitConfig *config, const char *name, int64_t\nvalue)\n设置一个整数形式的配置选项。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n\n|  | 检测配置是否具有一个名为 name 的选项。\n如果选项存在则返回 1，否则返回 0。\nint PyInitConfig_GetInt(PyInitConfig *config, const char *name, int64_t\n*value)\n获取一个整数形式的配置选项。\n在成功时设置 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\nint PyInitConfig_GetStr(PyInitConfig *config, const char *name, char\n**value)\n获取一个以空值结束的 UTF-8 编码字符串形式的字符串配置选项。\n在成功时设置 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果选项是一个可选字符串并且选项被取消设置则 *value 可被设为 NULL。\n在成功时，字符串如果不为 NULL 则必须用 free(value) 来释放它。\nint PyInitConfig_GetStrList(PyInitConfig *config, const char *name, size_t\n*length, char ***items)\n获取一个由以空值结束的 UTF-8 编码字符串组成的数组形式的字符串列表配置选项。\n在成功时设置 *length 和 *value，并返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n在成功时，字符串列表必须用 PyInitConfig_FreeStrList(length, items) 来释放。\nvoid PyInitConfig_FreeStrList(size_t length, char **items)\n释放由 PyInitConfig_GetStrList() 创建的字符串列表的内存。\n设置选项\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\n某些配置选项具有对其他选项的附带影响。 这种逻辑仅限于调用了\nPy_InitializeFromInitConfig() 的时候，而不被下面的“设置”函数所实现。 例如，将 dev_mode\n设为 1 并不会将 faulthandler 设为 1。\nint PyInitConfig_SetInt(PyInitConfig *config, const char *name, int64_t\nvalue)\n设置一个整数形式的配置选项。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。 |  |\n| --- | --- | --- |\n\nint PyInitConfig_SetStr(PyInitConfig *config, const char *name, const char\n*value)\n设置一个以空值结束的 UTF-8 编码字符串形式的字符串配置选项。 该字符串将被拷贝。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\nint PyInitConfig_SetStrList(PyInitConfig *config, const char *name, size_t\nlength, char *const *items)\n设置一个由以空值结束的 UTF-8 编码字符串组成的数组形式的字符串列表配置选项。 该字符串\n列表将被拷贝。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n模块\nint PyInitConfig_AddModule(PyInitConfig *config, const char *name, PyObject *\n(*initfunc)(void))\n将一个内置扩展模块添加到内置模块表。\n这个新模块可按名称 name 导入，并使用函数 initfunc 作为在首次尝试导入时要调用的初始化\n函数。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果 Python 要被多次初始化，则 PyInitConfig_AddModule() 必须在每次 Python 初始化时\n被调用。\n类似于 PyImport_AppendInittab() 函数。\n初始化 Python\nint Py_InitializeFromInitConfig(PyInitConfig *config)\n根据初始化配置来初始化 Python。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果 Python 想要退出则在 config 中设置一个退出码并返回 -1。\n请参阅 PyInitConfig_GetExitcode() 了解退出码用例。\n配置选项\n可见\n属性 PyConfig/PyPreConfig 成员 类型\n性\n\"allocator\" allocator int 只读\n\n|  | int PyInitConfig_SetStr(PyInitConfig *config, const char *name, const char\n*value)\n设置一个以空值结束的 UTF-8 编码字符串形式的字符串配置选项。 该字符串将被拷贝。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\nint PyInitConfig_SetStrList(PyInitConfig *config, const char *name, size_t\nlength, char *const *items)\n设置一个由以空值结束的 UTF-8 编码字符串组成的数组形式的字符串列表配置选项。 该字符串\n列表将被拷贝。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n模块\nint PyInitConfig_AddModule(PyInitConfig *config, const char *name, PyObject *\n(*initfunc)(void))\n将一个内置扩展模块添加到内置模块表。\n这个新模块可按名称 name 导入，并使用函数 initfunc 作为在首次尝试导入时要调用的初始化\n函数。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果 Python 要被多次初始化，则 PyInitConfig_AddModule() 必须在每次 Python 初始化时\n被调用。\n类似于 PyImport_AppendInittab() 函数。\n初始化 Python\nint Py_InitializeFromInitConfig(PyInitConfig *config)\n根据初始化配置来初始化 Python。\n成功时返回 0。\n在出错时在 config 中设置一个错误并返回 -1。\n如果 Python 想要退出则在 config 中设置一个退出码并返回 -1。\n请参阅 PyInitConfig_GetExitcode() 了解退出码用例。\n配置选项 |  |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  | 属性 | PyConfig/PyPreConfig 成员 | 类型 | 可见\n性 |  |\n|  | \"allocator\" | allocator | int | 只读 |  |\n|  |  |  |  |  |  |\n\n可见\n属性 PyConfig/PyPreConfig 成员 类型\n性\n\"argv\" argv list[str] 公有\n\"base_exec_prefix\" base_exec_prefix str 公有\n\"base_executable\" base_executable str 公有\n\"base_prefix\" base_prefix str 公有\n\"buffered_stdio\" buffered_stdio bool 只读\n\"bytes_warning\" bytes_warning int 公有\n\"check_hash_pycs_mode\" check_hash_pycs_mode str 只读\n\"code_debug_ranges\" code_debug_ranges bool 只读\n\"coerce_c_locale\" coerce_c_locale bool 只读\n\"coerce_c_locale_warn\" coerce_c_locale_warn bool 只读\n\"configure_c_stdio\" configure_c_stdio bool 只读\n\"configure_locale\" configure_locale bool 只读\n\"cpu_count\" cpu_count int 公有\n\"dev_mode\" dev_mode bool 只读\n\"dump_refs\" dump_refs bool 只读\n\"dump_refs_file\" dump_refs_file str 只读\n\"exec_prefix\" exec_prefix str 公有\n\"executable\" executable str 公有\n\"faulthandler\" faulthandler bool 只读\n\"filesystem_encoding\" filesystem_encoding str 只读\n\"filesystem_errors\" filesystem_errors str 只读\n\"hash_seed\" hash_seed int 只读\n\"home\" home str 只读\n\"import_time\" import_time int 只读\n\"inspect\" inspect bool 公有\n\"install_signal_handlers\" install_signal_handlers bool 只读\n\"int_max_str_digits\" int_max_str_digits int 公有\n\"interactive\" interactive bool 公有\n\n|  | 属性 | PyConfig/PyPreConfig 成员 | 类型 | 可见\n性 |  |\n| --- | --- | --- | --- | --- | --- |\n|  | \"argv\" | argv | list[str] | 公有 |  |\n|  | \"base_exec_prefix\" | base_exec_prefix | str | 公有 |  |\n|  | \"base_executable\" | base_executable | str | 公有 |  |\n|  | \"base_prefix\" | base_prefix | str | 公有 |  |\n|  | \"buffered_stdio\" | buffered_stdio | bool | 只读 |  |\n|  | \"bytes_warning\" | bytes_warning | int | 公有 |  |\n|  | \"check_hash_pycs_mode\" | check_hash_pycs_mode | str | 只读 |  |\n|  | \"code_debug_ranges\" | code_debug_ranges | bool | 只读 |  |\n|  | \"coerce_c_locale\" | coerce_c_locale | bool | 只读 |  |\n|  | \"coerce_c_locale_warn\" | coerce_c_locale_warn | bool | 只读 |  |\n|  | \"configure_c_stdio\" | configure_c_stdio | bool | 只读 |  |\n|  | \"configure_locale\" | configure_locale | bool | 只读 |  |\n|  | \"cpu_count\" | cpu_count | int | 公有 |  |\n|  | \"dev_mode\" | dev_mode | bool | 只读 |  |\n|  | \"dump_refs\" | dump_refs | bool | 只读 |  |\n|  | \"dump_refs_file\" | dump_refs_file | str | 只读 |  |\n|  | \"exec_prefix\" | exec_prefix | str | 公有 |  |\n|  | \"executable\" | executable | str | 公有 |  |\n|  | \"faulthandler\" | faulthandler | bool | 只读 |  |\n|  | \"filesystem_encoding\" | filesystem_encoding | str | 只读 |  |\n|  | \"filesystem_errors\" | filesystem_errors | str | 只读 |  |\n|  | \"hash_seed\" | hash_seed | int | 只读 |  |\n|  | \"home\" | home | str | 只读 |  |\n|  | \"import_time\" | import_time | int | 只读 |  |\n|  | \"inspect\" | inspect | bool | 公有 |  |\n|  | \"install_signal_handlers\" | install_signal_handlers | bool | 只读 |  |\n|  | \"int_max_str_digits\" | int_max_str_digits | int | 公有 |  |\n|  | \"interactive\" | interactive | bool | 公有 |  |\n|  |  |  |  |  |  |\n\n可见\n属性 PyConfig/PyPreConfig 成员 类型\n性\n\"isolated\" isolated bool 只读\n\"legacy_windows_fs_encoding\" legacy_windows_fs_encoding bool 只读\n\"legacy_windows_stdio\" legacy_windows_stdio bool 只读\n\"malloc_stats\" malloc_stats bool 只读\n\"module_search_paths\" module_search_paths list[str] 公有\n\"optimization_level\" optimization_level int 公有\n\"orig_argv\" orig_argv list[str] 只读\n\"parse_argv\" parse_argv bool 只读\n\"parser_debug\" parser_debug bool 公有\n\"pathconfig_warnings\" pathconfig_warnings bool 只读\n\"perf_profiling\" perf_profiling bool 只读\n\"platlibdir\" platlibdir str 公有\n\"prefix\" prefix str 公有\n\"program_name\" program_name str 只读\n\"pycache_prefix\" pycache_prefix str 公有\n\"quiet\" quiet bool 公有\n\"run_command\" run_command str 只读\n\"run_filename\" run_filename str 只读\n\"run_module\" run_module str 只读\n\"run_presite\" run_presite str 只读\n\"safe_path\" safe_path bool 只读\n\"show_ref_count\" show_ref_count bool 只读\n\"site_import\" site_import bool 只读\n\"skip_source_first_line\" skip_source_first_line bool 只读\n\"stdio_encoding\" stdio_encoding str 只读\n\"stdio_errors\" stdio_errors str 只读\n\"stdlib_dir\" stdlib_dir str 公有\n\"tracemalloc\" tracemalloc int 只读\n\n|  | 属性 | PyConfig/PyPreConfig 成员 | 类型 | 可见\n性 |  |\n| --- | --- | --- | --- | --- | --- |\n|  | \"isolated\" | isolated | bool | 只读 |  |\n|  | \"legacy_windows_fs_encoding\" | legacy_windows_fs_encoding | bool | 只读 |  |\n|  | \"legacy_windows_stdio\" | legacy_windows_stdio | bool | 只读 |  |\n|  | \"malloc_stats\" | malloc_stats | bool | 只读 |  |\n|  | \"module_search_paths\" | module_search_paths | list[str] | 公有 |  |\n|  | \"optimization_level\" | optimization_level | int | 公有 |  |\n|  | \"orig_argv\" | orig_argv | list[str] | 只读 |  |\n|  | \"parse_argv\" | parse_argv | bool | 只读 |  |\n|  | \"parser_debug\" | parser_debug | bool | 公有 |  |\n|  | \"pathconfig_warnings\" | pathconfig_warnings | bool | 只读 |  |\n|  | \"perf_profiling\" | perf_profiling | bool | 只读 |  |\n|  | \"platlibdir\" | platlibdir | str | 公有 |  |\n|  | \"prefix\" | prefix | str | 公有 |  |\n|  | \"program_name\" | program_name | str | 只读 |  |\n|  | \"pycache_prefix\" | pycache_prefix | str | 公有 |  |\n|  | \"quiet\" | quiet | bool | 公有 |  |\n|  | \"run_command\" | run_command | str | 只读 |  |\n|  | \"run_filename\" | run_filename | str | 只读 |  |\n|  | \"run_module\" | run_module | str | 只读 |  |\n|  | \"run_presite\" | run_presite | str | 只读 |  |\n|  | \"safe_path\" | safe_path | bool | 只读 |  |\n|  | \"show_ref_count\" | show_ref_count | bool | 只读 |  |\n|  | \"site_import\" | site_import | bool | 只读 |  |\n|  | \"skip_source_first_line\" | skip_source_first_line | bool | 只读 |  |\n|  | \"stdio_encoding\" | stdio_encoding | str | 只读 |  |\n|  | \"stdio_errors\" | stdio_errors | str | 只读 |  |\n|  | \"stdlib_dir\" | stdlib_dir | str | 公有 |  |\n|  | \"tracemalloc\" | tracemalloc | int | 只读 |  |\n|  |  |  |  |  |  |\n\n可见\n属性 PyConfig/PyPreConfig 成员 类型\n性\n\"use_environment\" use_environment bool 公有\n\"use_frozen_modules\" use_frozen_modules bool 只读\n\"use_hash_seed\" use_hash_seed bool 只读\n\"use_system_logger\" use_system_logger bool 只读\n\"user_site_directory\" user_site_directory bool 只读\n\"utf8_mode\" utf8_mode bool 只读\n\"verbose\" verbose int 公有\n\"warn_default_encoding\" warn_default_encoding bool 只读\n\"warnoptions\" warnoptions list[str] 公有\n\"write_bytecode\" write_bytecode bool 公有\ndict[str,\n\"xoptions\" xoptions 公有\nstr]\n\"_pystats\" _pystats bool 只读\n可见性：\n公有：可由 PyConfig_Get() 获取并由 PyConfig_Set() 设置。\n只读：可由 PyConfig_Get() 获取，但不可由 PyConfig_Set() 设置。\n运行时 Python 配置 API\n在运行时，有可能使用 PyConfig_Get() 和 PyConfig_Set() 函数来获取和设置配置选项。\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\n有些选项是从 sys 的属性读取的。 例如，选项 \"argv\" 是从 sys.argv 读取的。\nPyObject *PyConfig_Get(const char *name)\n获取一个配置选项的以 Python 对象表示的当前运行时值。\n成功时返回一个新的引用。\n出错时设置一个异常并返回 NULL。\n对象类型取决于具体的配置选项。 它可以是：\nbool\nint\nstr\nlist[str]\n\n|  | 属性 | PyConfig/PyPreConfig 成员 | 类型 | 可见\n性 |  |\n| --- | --- | --- | --- | --- | --- |\n|  | \"use_environment\" | use_environment | bool | 公有 |  |\n|  | \"use_frozen_modules\" | use_frozen_modules | bool | 只读 |  |\n|  | \"use_hash_seed\" | use_hash_seed | bool | 只读 |  |\n|  | \"use_system_logger\" | use_system_logger | bool | 只读 |  |\n|  | \"user_site_directory\" | user_site_directory | bool | 只读 |  |\n|  | \"utf8_mode\" | utf8_mode | bool | 只读 |  |\n|  | \"verbose\" | verbose | int | 公有 |  |\n|  | \"warn_default_encoding\" | warn_default_encoding | bool | 只读 |  |\n|  | \"warnoptions\" | warnoptions | list[str] | 公有 |  |\n|  | \"write_bytecode\" | write_bytecode | bool | 公有 |  |\n|  | \"xoptions\" | xoptions | dict[str,\nstr] | 公有 |  |\n|  | \"_pystats\" | _pystats | bool | 只读 |  |\n|  | 可见性：\n公有：可由 PyConfig_Get() 获取并由 PyConfig_Set() 设置。\n只读：可由 PyConfig_Get() 获取，但不可由 PyConfig_Set() 设置。\n运行时 Python 配置 API\n在运行时，有可能使用 PyConfig_Get() 和 PyConfig_Set() 函数来获取和设置配置选项。\n配置选项的 name 形参必须是一个非 NULL 的以空值结束的 UTF-8 编码字符串。 参见 配置选项。\n有些选项是从 sys 的属性读取的。 例如，选项 \"argv\" 是从 sys.argv 读取的。\nPyObject *PyConfig_Get(const char *name)\n获取一个配置选项的以 Python 对象表示的当前运行时值。\n成功时返回一个新的引用。\n出错时设置一个异常并返回 NULL。\n对象类型取决于具体的配置选项。 它可以是：\nbool\nint\nstr\nlist[str] |  |  |  |  |\n\n|  | str] |\n| --- | --- |\n\ndict[str, str]\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\nAdded in version 3.14.\nint PyConfig_GetInt(const char *name, int *value)\n类似于 PyConfig_Get()，但会获取 C int 形式的值。\n成功时返回 0。\n出错时设置一个异常并返回 -1。\nAdded in version 3.14.\nPyObject *PyConfig_Names(void)\n获取以一个 frozenset 表示的全部配置选项名称。\n成功时返回一个新的引用。\n出错时设置一个异常并返回 NULL。\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\nAdded in version 3.14.\nint PyConfig_Set(const char *name, PyObject *value)\n设置一个配置选项的当前运行时值。\n如果没有选项 name 则会引发 ValueError。\n如果 value 是一个无效的值则会引发 ValueError。\n如果选项是只读的（无法被设置）则会引发 ValueError。\n如果 value 的类型不正确则会引发 TypeError。\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\n引发一个 审计事件 cpython.PyConfig_Set 并附带参数 name, value。\nAdded in version 3.14.\nPyConfig C API\nAdded in version 3.8.\nPython 可以使用 Py_InitializeFromConfig() 和 PyConfig 结构体来初始化。 它可以使用\nPy_PreInitialize() 和 PyPreConfig 结构体来预初始化。\n有两种配置方式：\n\n|  | dict[str, str]\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\nAdded in version 3.14.\nint PyConfig_GetInt(const char *name, int *value)\n类似于 PyConfig_Get()，但会获取 C int 形式的值。\n成功时返回 0。\n出错时设置一个异常并返回 -1。\nAdded in version 3.14.\nPyObject *PyConfig_Names(void)\n获取以一个 frozenset 表示的全部配置选项名称。\n成功时返回一个新的引用。\n出错时设置一个异常并返回 NULL。\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\nAdded in version 3.14.\nint PyConfig_Set(const char *name, PyObject *value)\n设置一个配置选项的当前运行时值。\n如果没有选项 name 则会引发 ValueError。\n如果 value 是一个无效的值则会引发 ValueError。\n如果选项是只读的（无法被设置）则会引发 ValueError。\n如果 value 的类型不正确则会引发 TypeError。\n调用方必须拥有一个 attached thread state。 这个函数不能在 Python 初始化之前或 Python 最\n终后之后被调用。\n引发一个 审计事件 cpython.PyConfig_Set 并附带参数 name, value。\nAdded in version 3.14.\nPyConfig C API\nAdded in version 3.8.\nPython 可以使用 Py_InitializeFromConfig() 和 PyConfig 结构体来初始化。 它可以使用\nPy_PreInitialize() 和 PyPreConfig 结构体来预初始化。\n有两种配置方式： |  |\n| --- | --- | --- |\n\nPython 配置 可被用于构建一个定制的 Python，其行为与常规 Python 类似。 例如，环境变量和\n命令行参数可被用于配置 Python。\n隔离配置 可被用于将 Python 嵌入到应用程序。 它将 Python 与系统隔离开来。 例如，环境变量\n将被忽略，LC_CTYPE 语言区域设置保持不变并且不会注册任何信号处理器。\nPy_RunMain() 函数可被用来编写定制的 Python 程序。\n另请参阅 初始化、最终化与线程。\n参见: PEP 587 \"Python 初始化配置\".\n示例\n定制的 Python 的示例总是会以隔离模式运行:\nint main(int argc, char **argv)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\nconfig.isolated = 1;\n/* 解码命令行参数。\n隐式地预初始化 Python (隔离模式)。 */\nstatus = PyConfig_SetBytesArgv(&config, argc, argv);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config);\nreturn Py_RunMain();\nexception:\nPyConfig_Clear(&config);\nif (PyStatus_IsExit(status)) {\nreturn status.exitcode;\n}\n/* 显示错误消息然后退出进程\n并设置非零值退出码 */\nPy_ExitStatusException(status);\n}\nPyWideStringList\ntype PyWideStringList\n由 wchar_t* 字符串组成的列表。\n\n|  | Python 配置 可被用于构建一个定制的 Python，其行为与常规 Python 类似。 例如，环境变量和\n命令行参数可被用于配置 Python。\n隔离配置 可被用于将 Python 嵌入到应用程序。 它将 Python 与系统隔离开来。 例如，环境变量\n将被忽略，LC_CTYPE 语言区域设置保持不变并且不会注册任何信号处理器。\nPy_RunMain() 函数可被用来编写定制的 Python 程序。\n另请参阅 初始化、最终化与线程。 |  |\n| --- | --- | --- |\n|  | 参见: PEP 587 \"Python 初始化配置\". |  |\n|  | 示例\n定制的 Python 的示例总是会以隔离模式运行: |  |\n|  | int main(int argc, char **argv)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\nconfig.isolated = 1;\n/* 解码命令行参数。\n隐式地预初始化 Python (隔离模式)。 */\nstatus = PyConfig_SetBytesArgv(&config, argc, argv);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config);\nreturn Py_RunMain();\nexception:\nPyConfig_Clear(&config);\nif (PyStatus_IsExit(status)) {\nreturn status.exitcode;\n}\n/* 显示错误消息然后退出进程\n并设置非零值退出码 */\nPy_ExitStatusException(status);\n} |  |\n|  | PyWideStringList\ntype PyWideStringList\n由 wchar_t* 字符串组成的列表。 |  |\n\n如果 length 为非零值，则 items 必须不为 NULL 并且所有字符串均必须不为 NULL。\n方法\nPyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t\n*item)\n将 item 添加到 list。\nPython 必须被预初始化以便调用此函数。\nPyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t\nindex, const wchar_t *item)\n将 item 插入到 list 的 index 位置上。\n如果 index 大于等于 list 的长度，则将 item 添加到 list。\nindex 必须大于等于 0。\nPython 必须被预初始化以便调用此函数。\n结构体字段:\nPy_ssize_t length\nList 长度。\nwchar_t **items\n列表项目。\nPyStatus\ntype PyStatus\n存储初始函数状态：成功、错误或退出的结构体。\n对于错误，它可以存储造成错误的 C 函数的名称。\n结构体字段:\nint exitcode\n退出码。 传给 exit() 的参数。\nconst char *err_msg\n错误信息\nconst char *func\n造成错误的函数的名称，可以为 NULL。\n创建状态的函数:\n\n|  | 如果 length 为非零值，则 items 必须不为 NULL 并且所有字符串均必须不为 NULL。\n方法\nPyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t\n*item)\n将 item 添加到 list。\nPython 必须被预初始化以便调用此函数。\nPyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t\nindex, const wchar_t *item)\n将 item 插入到 list 的 index 位置上。\n如果 index 大于等于 list 的长度，则将 item 添加到 list。\nindex 必须大于等于 0。\nPython 必须被预初始化以便调用此函数。\n结构体字段:\nPy_ssize_t length\nList 长度。\nwchar_t **items\n列表项目。\nPyStatus\ntype PyStatus\n存储初始函数状态：成功、错误或退出的结构体。\n对于错误，它可以存储造成错误的 C 函数的名称。\n结构体字段:\nint exitcode\n退出码。 传给 exit() 的参数。\nconst char *err_msg\n错误信息\nconst char *func\n造成错误的函数的名称，可以为 NULL。\n创建状态的函数: |  |\n| --- | --- | --- |\n\nPyStatus PyStatus_Ok(void)\n完成。\nPyStatus PyStatus_Error(const char *err_msg)\n带消息的初始化错误。\nerr_msg 不可为 NULL。\nPyStatus PyStatus_NoMemory(void)\n内存分配失败（内存不足）。\nPyStatus PyStatus_Exit(int exitcode)\n以指定的退出代码退出 Python。\n处理状态的函数:\nint PyStatus_Exception(PyStatus status)\n状态为错误还是退出？如为真值，则异常必须被处理；例如通过调用\nPy_ExitStatusException()。\nint PyStatus_IsError(PyStatus status)\n结果错误吗？\nint PyStatus_IsExit(PyStatus status)\n结果是否退出？\nvoid Py_ExitStatusException(PyStatus status)\n如果 status 是一个退出码则调用 exit(exitcode)。如果 status 是一个错误码则打印错误\n消息并设置一个非零退出码再退出。 必须在 PyStatus_Exception(status) 为非零值时\n才能被调用。\n备注: 在内部，Python 将使用设置 PyStatus.func 的宏，而创建状态的函数则会将 func 设为\nNULL。\n示例:\nPyStatus alloc(void **ptr, size_t size)\n{\n*ptr = PyMem_RawMalloc(size);\nif (*ptr == NULL) {\nreturn PyStatus_NoMemory();\n}\nreturn PyStatus_Ok();\n}\nint main(int argc, char **argv)\n\n|  | PyStatus PyStatus_Ok(void)\n完成。\nPyStatus PyStatus_Error(const char *err_msg)\n带消息的初始化错误。\nerr_msg 不可为 NULL。\nPyStatus PyStatus_NoMemory(void)\n内存分配失败（内存不足）。\nPyStatus PyStatus_Exit(int exitcode)\n以指定的退出代码退出 Python。\n处理状态的函数:\nint PyStatus_Exception(PyStatus status)\n状态为错误还是退出？如为真值，则异常必须被处理；例如通过调用\nPy_ExitStatusException()。\nint PyStatus_IsError(PyStatus status)\n结果错误吗？\nint PyStatus_IsExit(PyStatus status)\n结果是否退出？\nvoid Py_ExitStatusException(PyStatus status)\n如果 status 是一个退出码则调用 exit(exitcode)。如果 status 是一个错误码则打印错误\n消息并设置一个非零退出码再退出。 必须在 PyStatus_Exception(status) 为非零值时\n才能被调用。 |  |\n| --- | --- | --- |\n|  | 备注: 在内部，Python 将使用设置 PyStatus.func 的宏，而创建状态的函数则会将 func 设为\nNULL。 |  |\n|  | 示例: |  |\n|  | PyStatus alloc(void **ptr, size_t size)\n{\n*ptr = PyMem_RawMalloc(size);\nif (*ptr == NULL) {\nreturn PyStatus_NoMemory();\n}\nreturn PyStatus_Ok();\n}\nint main(int argc, char **argv) |  |\n\n{\nvoid *ptr;\nPyStatus status = alloc(&ptr, 16);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\nPyMem_Free(ptr);\nreturn 0;\n}\nPyPreConfig\ntype PyPreConfig\n用于预初始化 Python 的结构体。\n用于初始化预先配置的函数:\nvoid PyPreConfig_InitPythonConfig(PyPreConfig *preconfig)\n通过 Python 配置 来初始化预先配置。\nvoid PyPreConfig_InitIsolatedConfig(PyPreConfig *preconfig)\n通过 隔离配置 来初始化预先配置。\n结构体字段:\nint allocator\nPython 内存分配器名称:\nPYMEM_ALLOCATOR_NOT_SET (0): 不改变内存分配器 (使用默认)。\nPYMEM_ALLOCATOR_DEFAULT (1): 默认内存分配器。\nPYMEM_ALLOCATOR_DEBUG (2): 默认内存分配器 附带 调试钩子。\nPYMEM_ALLOCATOR_MALLOC (3): 使用 C 库的 malloc()。\nPYMEM_ALLOCATOR_MALLOC_DEBUG (4): 强制使用 malloc() 附带 调试钩子。\nPYMEM_ALLOCATOR_PYMALLOC (5): Python pymalloc 内存分配器。\nPYMEM_ALLOCATOR_PYMALLOC_DEBUG (6): Python pymalloc 内存分配器 附带 调试钩子。\nPYMEM_ALLOCATOR_MIMALLOC (6): 使用 mimalloc，一个快速的 malloc 替代。\nPYMEM_ALLOCATOR_MIMALLOC_DEBUG (7): 使用 mimalloc，一个快速的 malloc 替代，它\n带有 调试钩子。\n如果 Python 是 使用 --without-pymalloc 进行配置 则 PYMEM_ALLOCATOR_PYMALLOC 和\nPYMEM_ALLOCATOR_PYMALLOC_DEBUG 将不被支持。\n如果 Python 是 使用 --without-mimalloc 进行配置 或者如果下层的原子化支持不可用\n则 PYMEM_ALLOCATOR_MIMALLOC 和 PYMEM_ALLOCATOR_MIMALLOC_DEBUG 将不被支持。\n参见 Memory Management.\n默认值: PYMEM_ALLOCATOR_NOT_SET。\n\n|  | {\nvoid *ptr;\nPyStatus status = alloc(&ptr, 16);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\nPyMem_Free(ptr);\nreturn 0;\n} |  |\n| --- | --- | --- |\n|  | PyPreConfig\ntype PyPreConfig\n用于预初始化 Python 的结构体。\n用于初始化预先配置的函数:\nvoid PyPreConfig_InitPythonConfig(PyPreConfig *preconfig)\n通过 Python 配置 来初始化预先配置。\nvoid PyPreConfig_InitIsolatedConfig(PyPreConfig *preconfig)\n通过 隔离配置 来初始化预先配置。\n结构体字段:\nint allocator\nPython 内存分配器名称:\nPYMEM_ALLOCATOR_NOT_SET (0): 不改变内存分配器 (使用默认)。\nPYMEM_ALLOCATOR_DEFAULT (1): 默认内存分配器。\nPYMEM_ALLOCATOR_DEBUG (2): 默认内存分配器 附带 调试钩子。\nPYMEM_ALLOCATOR_MALLOC (3): 使用 C 库的 malloc()。\nPYMEM_ALLOCATOR_MALLOC_DEBUG (4): 强制使用 malloc() 附带 调试钩子。\nPYMEM_ALLOCATOR_PYMALLOC (5): Python pymalloc 内存分配器。\nPYMEM_ALLOCATOR_PYMALLOC_DEBUG (6): Python pymalloc 内存分配器 附带 调试钩子。\nPYMEM_ALLOCATOR_MIMALLOC (6): 使用 mimalloc，一个快速的 malloc 替代。\nPYMEM_ALLOCATOR_MIMALLOC_DEBUG (7): 使用 mimalloc，一个快速的 malloc 替代，它\n带有 调试钩子。\n如果 Python 是 使用 --without-pymalloc 进行配置 则 PYMEM_ALLOCATOR_PYMALLOC 和\nPYMEM_ALLOCATOR_PYMALLOC_DEBUG 将不被支持。\n如果 Python 是 使用 --without-mimalloc 进行配置 或者如果下层的原子化支持不可用\n则 PYMEM_ALLOCATOR_MIMALLOC 和 PYMEM_ALLOCATOR_MIMALLOC_DEBUG 将不被支持。\n参见 Memory Management.\n默认值: PYMEM_ALLOCATOR_NOT_SET。 |  |\n\nint configure_locale\n将 LC_CTYPE 语言区域设为用户选择的语言区域。\n如果等于 0，则将 coerce_c_locale 和 coerce_c_locale_warn 的成员设为 0。\n参见 locale encoding。\n默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint coerce_c_locale\n如果等于 2，强制转换 C 语言区域。\n如果等于 1，则读取 LC_CTYPE 语言区域来确定其是否应当被强制转换。\n参见 locale encoding。\n默认值: 在 Python 配置中为 -1，在隔离配置中为 0。\nint coerce_c_locale_warn\n如为非零值，则会在 C 语言区域被强制转换时发出警告。\n默认值: 在 Python 配置中为 -1，在隔离配置中为 0。\nint dev_mode\nPython 开发模式: 参见 PyConfig.dev_mode。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nint isolated\n隔离模式：参见 PyConfig.isolated。\n默认值: 在 Python 模式中为 0，在隔离模式中为 1。\nint legacy_windows_fs_encoding\n如为非零值:\n设置 PyPreConfig.utf8_mode 为 0,\n设置 PyConfig.filesystem_encoding 为 \"mbcs\",\n设置 PyConfig.filesystem_errors 为 \"replace\".\n基于 PYTHONLEGACYWINDOWSFSENCODING 环境变量值完成初始化。\n仅在 Windows 上可用。 #ifdef MS_WINDOWS 宏可被用于 Windows 专属的代码。\n默认值: 0.\nint parse_argv\n\n|  | int configure_locale\n将 LC_CTYPE 语言区域设为用户选择的语言区域。\n如果等于 0，则将 coerce_c_locale 和 coerce_c_locale_warn 的成员设为 0。\n参见 locale encoding。\n默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint coerce_c_locale\n如果等于 2，强制转换 C 语言区域。\n如果等于 1，则读取 LC_CTYPE 语言区域来确定其是否应当被强制转换。\n参见 locale encoding。\n默认值: 在 Python 配置中为 -1，在隔离配置中为 0。\nint coerce_c_locale_warn\n如为非零值，则会在 C 语言区域被强制转换时发出警告。\n默认值: 在 Python 配置中为 -1，在隔离配置中为 0。\nint dev_mode\nPython 开发模式: 参见 PyConfig.dev_mode。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nint isolated\n隔离模式：参见 PyConfig.isolated。\n默认值: 在 Python 模式中为 0，在隔离模式中为 1。\nint legacy_windows_fs_encoding\n如为非零值:\n设置 PyPreConfig.utf8_mode 为 0,\n设置 PyConfig.filesystem_encoding 为 \"mbcs\",\n设置 PyConfig.filesystem_errors 为 \"replace\".\n基于 PYTHONLEGACYWINDOWSFSENCODING 环境变量值完成初始化。\n仅在 Windows 上可用。 #ifdef MS_WINDOWS 宏可被用于 Windows 专属的代码。\n默认值: 0.\nint parse_argv |  |\n| --- | --- | --- |\n\n如为非零值，Py_PreInitializeFromArgs() 和 Py_PreInitializeFromBytesArgs() 将\n以与常规 Python 解析命令行参数的相同方式解析其 argv 参数：参见 命令行参数。\n默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint use_environment\n使用 环境变量? 参见 PyConfig.use_environment。\n默认值: 在 Python 配置中为 1 而在隔离配置中为 0。\nint utf8_mode\n如为非零值，则启用 Python UTF-8 模式。\n通过 -X utf8 命令行选项和 PYTHONUTF8 环境变量设为 0 或 1。\n如果 LC_CTYPE 语言区域为 C 或 POSIX 也会被设为 1。\n默认值: 在 Python 配置中为 -1 而在隔离配置中为 0。\n使用 PyPreConfig 预初始化 Python\nPython 的预初始化:\n设置 Python 内存分配器 (PyPreConfig.allocator)\n配置 LC_CTYPE 语言区域 (locale encoding)\n设置 Python UTF-8 模式 (PyPreConfig.utf8_mode)\n当前的预配置 (PyPreConfig 类型) 保存在 _PyRuntime.preconfig 中。\n用于预初始化 Python 的函数：\nPyStatus Py_PreInitialize(const PyPreConfig *preconfig)\n根据 preconfig 预配置来预初始化 Python。\npreconfig 不可为 NULL。\nPyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *preconfig, int\nargc, char *const *argv)\n根据 preconfig 预配置来预初始化 Python。\n如果 preconfig 的 parse_argv 为非零值则解析 argv 命令行参数（字节串）。\npreconfig 不可为 NULL。\nPyStatus Py_PreInitializeFromArgs(const PyPreConfig *preconfig, int argc,\nwchar_t *const *argv)\n根据 preconfig 预配置来预初始化 Python。\n如果 preconfig 的 parse_argv 为非零值则解析 argv 命令行参数（宽字符串）。\n\n|  | 如为非零值，Py_PreInitializeFromArgs() 和 Py_PreInitializeFromBytesArgs() 将\n以与常规 Python 解析命令行参数的相同方式解析其 argv 参数：参见 命令行参数。\n默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint use_environment\n使用 环境变量? 参见 PyConfig.use_environment。\n默认值: 在 Python 配置中为 1 而在隔离配置中为 0。\nint utf8_mode\n如为非零值，则启用 Python UTF-8 模式。\n通过 -X utf8 命令行选项和 PYTHONUTF8 环境变量设为 0 或 1。\n如果 LC_CTYPE 语言区域为 C 或 POSIX 也会被设为 1。\n默认值: 在 Python 配置中为 -1 而在隔离配置中为 0。\n使用 PyPreConfig 预初始化 Python\nPython 的预初始化:\n设置 Python 内存分配器 (PyPreConfig.allocator)\n配置 LC_CTYPE 语言区域 (locale encoding)\n设置 Python UTF-8 模式 (PyPreConfig.utf8_mode)\n当前的预配置 (PyPreConfig 类型) 保存在 _PyRuntime.preconfig 中。\n用于预初始化 Python 的函数：\nPyStatus Py_PreInitialize(const PyPreConfig *preconfig)\n根据 preconfig 预配置来预初始化 Python。\npreconfig 不可为 NULL。\nPyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *preconfig, int\nargc, char *const *argv)\n根据 preconfig 预配置来预初始化 Python。\n如果 preconfig 的 parse_argv 为非零值则解析 argv 命令行参数（字节串）。\npreconfig 不可为 NULL。\nPyStatus Py_PreInitializeFromArgs(const PyPreConfig *preconfig, int argc,\nwchar_t *const *argv)\n根据 preconfig 预配置来预初始化 Python。\n如果 preconfig 的 parse_argv 为非零值则解析 argv 命令行参数（宽字符串）。 |  |\n| --- | --- | --- |\n\npreconfig 不可为 NULL。\n调用方要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处理异常（错误或退\n出）。\n对于 Python 配置 (PyPreConfig_InitPythonConfig())，如果 Python 是用命令行参数初始化的，\n那么在预初始化 Python 时也必须传递命令行参数，因为它们会对编码格式等预配置产生影响。 例\n如，-X utf8 命令行选项将启用 Python UTF-8 模式。\nPyMem_SetAllocator() 可在 Py_PreInitialize() 之后、Py_InitializeFromConfig() 之前被\n调用以安装自定义的内存分配器。 如果 PyPreConfig.allocator 被设为\nPYMEM_ALLOCATOR_NOT_SET 则可在 Py_PreInitialize() 之前被调用。\n像 PyMem_RawMalloc() 这样的 Python 内存分配函数不能在 Python 预初始化之前使用，而直接调\n用 malloc() 和 free() 则始终会是安全的。 Py_DecodeLocale() 不能在 Python 预初始化之前被\n调用。\n使用预初始化来启用 Python UTF-8 模式 的例子:\nPyStatus status;\nPyPreConfig preconfig;\nPyPreConfig_InitPythonConfig(&preconfig);\npreconfig.utf8_mode = 1;\nstatus = Py_PreInitialize(&preconfig);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\n/* 此时，Python 将使用 UTF-8 */\nPy_Initialize();\n/* ... 在此使用 Python API ... */\nPy_Finalize();\nPyConfig\ntype PyConfig\n包含了大部分用于配置 Python 的形参的结构体。\n在完成后，必须使用 PyConfig_Clear() 函数来释放配置内存。\n结构体方法:\nvoid PyConfig_InitPythonConfig(PyConfig *config)\n通过 Python 配置 来初始化配置。\nvoid PyConfig_InitIsolatedConfig(PyConfig *config)\n通过 隔离配置 来初始化配置。\n\n|  | preconfig 不可为 NULL。\n调用方要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处理异常（错误或退\n出）。\n对于 Python 配置 (PyPreConfig_InitPythonConfig())，如果 Python 是用命令行参数初始化的，\n那么在预初始化 Python 时也必须传递命令行参数，因为它们会对编码格式等预配置产生影响。 例\n如，-X utf8 命令行选项将启用 Python UTF-8 模式。\nPyMem_SetAllocator() 可在 Py_PreInitialize() 之后、Py_InitializeFromConfig() 之前被\n调用以安装自定义的内存分配器。 如果 PyPreConfig.allocator 被设为\nPYMEM_ALLOCATOR_NOT_SET 则可在 Py_PreInitialize() 之前被调用。\n像 PyMem_RawMalloc() 这样的 Python 内存分配函数不能在 Python 预初始化之前使用，而直接调\n用 malloc() 和 free() 则始终会是安全的。 Py_DecodeLocale() 不能在 Python 预初始化之前被\n调用。\n使用预初始化来启用 Python UTF-8 模式 的例子: |  |\n| --- | --- | --- |\n|  | PyStatus status;\nPyPreConfig preconfig;\nPyPreConfig_InitPythonConfig(&preconfig);\npreconfig.utf8_mode = 1;\nstatus = Py_PreInitialize(&preconfig);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\n/* 此时，Python 将使用 UTF-8 */\nPy_Initialize();\n/* ... 在此使用 Python API ... */\nPy_Finalize(); |  |\n|  | PyConfig\ntype PyConfig\n包含了大部分用于配置 Python 的形参的结构体。\n在完成后，必须使用 PyConfig_Clear() 函数来释放配置内存。\n结构体方法:\nvoid PyConfig_InitPythonConfig(PyConfig *config)\n通过 Python 配置 来初始化配置。\nvoid PyConfig_InitIsolatedConfig(PyConfig *config)\n通过 隔离配置 来初始化配置。 |  |\n\nPyStatus PyConfig_SetString(PyConfig *config, wchar_t *const *config_str,\nconst wchar_t *str)\n将宽字符串 str 拷贝至 *config_str。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t *const\n*config_str, const char *str)\n使用 Py_DecodeLocale() 对 str 进行解码并将结果设置到 *config_str。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetArgv(PyConfig *config, int argc, wchar_t *const\n*argv)\n根据宽字符串列表 argv 设置命令行参数 (config 的 argv 成员)。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetBytesArgv(PyConfig *config, int argc, char *const\n*argv)\n根据字节串列表 argv 设置命令行参数 (config 的 argv 成员)。 使用 Py_DecodeLocale()\n对字节串进行解码。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList\n*list, Py_ssize_t length, wchar_t **items)\n将宽字符串列表 list 设置为 length 和 items。\n在必要时 预初始化 Python。\nPyStatus PyConfig_Read(PyConfig *config)\n读取所有 Python 配置。\n已经初始化的字段会保持不变。\n调用此函数时不再计算或修改用于 路径配置 的字段，如 Python 3.11 那样。\nPyConfig_Read() 函数对 PyConfig.argv 参数只会解析一次：在参数解析完成后\nPyConfig.parse_argv 将被设为 2。 由于 Python 参数是从 PyConfig.argv 提取的，因\n此解析参数两次会将应用程序选项解析为 Python 选项。\n在必要时 预初始化 Python。\n\n|  | PyStatus PyConfig_SetString(PyConfig *config, wchar_t *const *config_str,\nconst wchar_t *str)\n将宽字符串 str 拷贝至 *config_str。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t *const\n*config_str, const char *str)\n使用 Py_DecodeLocale() 对 str 进行解码并将结果设置到 *config_str。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetArgv(PyConfig *config, int argc, wchar_t *const\n*argv)\n根据宽字符串列表 argv 设置命令行参数 (config 的 argv 成员)。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetBytesArgv(PyConfig *config, int argc, char *const\n*argv)\n根据字节串列表 argv 设置命令行参数 (config 的 argv 成员)。 使用 Py_DecodeLocale()\n对字节串进行解码。\n在必要时 预初始化 Python。\nPyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList\n*list, Py_ssize_t length, wchar_t **items)\n将宽字符串列表 list 设置为 length 和 items。\n在必要时 预初始化 Python。\nPyStatus PyConfig_Read(PyConfig *config)\n读取所有 Python 配置。\n已经初始化的字段会保持不变。\n调用此函数时不再计算或修改用于 路径配置 的字段，如 Python 3.11 那样。\nPyConfig_Read() 函数对 PyConfig.argv 参数只会解析一次：在参数解析完成后\nPyConfig.parse_argv 将被设为 2。 由于 Python 参数是从 PyConfig.argv 提取的，因\n此解析参数两次会将应用程序选项解析为 Python 选项。\n在必要时 预初始化 Python。 |  |\n| --- | --- | --- |\n\n在 3.10 版本发生变更: PyConfig.argv 参数现在只会被解析一次，在参数解析完成\n后，PyConfig.parse_argv 将被设为 2，只有当 PyConfig.parse_argv 等于 1 时\n才会解析参数。\n在 3.11 版本发生变更: PyConfig_Read() 不会再计算所有路径，因此在 Python 路径\n配置 下列出的字段可能不会再更新直到 Py_InitializeFromConfig() 被调用。\nvoid PyConfig_Clear(PyConfig *config)\n释放配置内存\n如有必要大多数 PyConfig 方法将会 预初始化 Python。 在这种情况下，Python 预初始化配置\n(PyPreConfig) 将以 PyConfig 为基础。 如果要调整与 PyPreConfig 相同的配置字段，它们必\n须在调用 PyConfig 方法之前被设置：\nPyConfig.dev_mode\nPyConfig.isolated\nPyConfig.parse_argv\nPyConfig.use_environment\n此外，如果使用了 PyConfig_SetArgv() 或 PyConfig_SetBytesArgv()，则必须在调用其他\n方法之前调用该方法，因为预初始化配置取决于命令行参数（如果 parse_argv 为非零值）。\n这些方法的调用者要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处\n理异常（错误或退出）。\n结构体字段:\nPyWideStringList argv\n根据 argv 设置 sys.argv 命令行参数。 这些形参与传给程序的 main() 函数的类似，区\n别在于其中第一项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。\n如果没有要运行的脚本，而 argv 中的第一项可以为空字符串。\n将 parse_argv 设为 1 将以与普通 Python 解析 Python 命令行参数相同的方式解析 argv\n再从 argv 中剥离 Python 参数。\n如果 argv 为空，则会添加一个空字符串以确保 sys.argv 始终存在并且永远不为空。\n默认值: NULL.\n另请参阅 orig_argv 成员。\nint safe_path\n如果等于零，Py_RunMain() 会在启动时向 sys.path 开头添加一个可能不安全的路径:\n如果 argv[0] 等于 L\"-m\" (python -m module)，则添加当前工作目录。\n如果是运行脚本 (python script.py)，则添加脚本的目录。 如果是符号链接，则会解\n析符号链接。\n\n|  | 在 3.10 版本发生变更: PyConfig.argv 参数现在只会被解析一次，在参数解析完成\n后，PyConfig.parse_argv 将被设为 2，只有当 PyConfig.parse_argv 等于 1 时\n才会解析参数。\n在 3.11 版本发生变更: PyConfig_Read() 不会再计算所有路径，因此在 Python 路径\n配置 下列出的字段可能不会再更新直到 Py_InitializeFromConfig() 被调用。\nvoid PyConfig_Clear(PyConfig *config)\n释放配置内存\n如有必要大多数 PyConfig 方法将会 预初始化 Python。 在这种情况下，Python 预初始化配置\n(PyPreConfig) 将以 PyConfig 为基础。 如果要调整与 PyPreConfig 相同的配置字段，它们必\n须在调用 PyConfig 方法之前被设置：\nPyConfig.dev_mode\nPyConfig.isolated\nPyConfig.parse_argv\nPyConfig.use_environment\n此外，如果使用了 PyConfig_SetArgv() 或 PyConfig_SetBytesArgv()，则必须在调用其他\n方法之前调用该方法，因为预初始化配置取决于命令行参数（如果 parse_argv 为非零值）。\n这些方法的调用者要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处\n理异常（错误或退出）。\n结构体字段:\nPyWideStringList argv\n根据 argv 设置 sys.argv 命令行参数。 这些形参与传给程序的 main() 函数的类似，区\n别在于其中第一项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。\n如果没有要运行的脚本，而 argv 中的第一项可以为空字符串。\n将 parse_argv 设为 1 将以与普通 Python 解析 Python 命令行参数相同的方式解析 argv\n再从 argv 中剥离 Python 参数。\n如果 argv 为空，则会添加一个空字符串以确保 sys.argv 始终存在并且永远不为空。\n默认值: NULL.\n另请参阅 orig_argv 成员。\nint safe_path\n如果等于零，Py_RunMain() 会在启动时向 sys.path 开头添加一个可能不安全的路径:\n如果 argv[0] 等于 L\"-m\" (python -m module)，则添加当前工作目录。\n如果是运行脚本 (python script.py)，则添加脚本的目录。 如果是符号链接，则会解\n析符号链接。 |  |\n| --- | --- | --- |\n\n在其他情况下 (python -c code 和 python)，将添加一个空字符串，这表示当前工作目\n录。\n通过 -P 命令行选项和 PYTHONSAFEPATH 环境变量设置为 1。\n默认值：Python 配置中为 0，隔离配置中为 1。\nAdded in version 3.11.\nwchar_t *base_exec_prefix\nsys.base_exec_prefix.\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.exec_prefix。\nwchar_t *base_executable\nPython 基础可执行文件: sys._base_executable。\n由 __PYVENV_LAUNCHER__ 环境变量设置。\n如为 NULL 则从 PyConfig.executable 设置。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.executable。\nwchar_t *base_prefix\nsys.base_prefix.\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.prefix。\nint buffered_stdio\n如果等于 0 且 configure_c_stdio 为非零值，则禁用 C 数据流 stdout 和 stderr 的缓\n冲。\n通过 -u 命令行选项和 PYTHONUNBUFFERED 环境变量设置为 0。\nstdin 始终以缓冲模式打开。\n默认值: 1.\n\n|  | 在其他情况下 (python -c code 和 python)，将添加一个空字符串，这表示当前工作目\n录。\n通过 -P 命令行选项和 PYTHONSAFEPATH 环境变量设置为 1。\n默认值：Python 配置中为 0，隔离配置中为 1。\nAdded in version 3.11.\nwchar_t *base_exec_prefix\nsys.base_exec_prefix.\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.exec_prefix。\nwchar_t *base_executable\nPython 基础可执行文件: sys._base_executable。\n由 __PYVENV_LAUNCHER__ 环境变量设置。\n如为 NULL 则从 PyConfig.executable 设置。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.executable。\nwchar_t *base_prefix\nsys.base_prefix.\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.prefix。\nint buffered_stdio\n如果等于 0 且 configure_c_stdio 为非零值，则禁用 C 数据流 stdout 和 stderr 的缓\n冲。\n通过 -u 命令行选项和 PYTHONUNBUFFERED 环境变量设置为 0。\nstdin 始终以缓冲模式打开。\n默认值: 1. |  |\n| --- | --- | --- |\n\nint bytes_warning\n如果等于 1，则在将 bytes 或 bytearray 与 str 进行比较，或将 bytes 与 int 进行比\n较时发出警告。\n如果大于等于 2，则在这些情况下引发 BytesWarning 异常。\n由 -b 命令行选项执行递增。\n默认值: 0.\nint warn_default_encoding\n如为非零值，则在 io.TextIOWrapper 使用默认编码格式时发出 EncodingWarning 警\n告。 详情请参阅 选择性的 EncodingWarning。\n默认值: 0.\nAdded in version 3.10.\nint code_debug_ranges\n如果等于 0，则禁用在代码对象中包括末尾行和列映射。 并且禁用在特定错误位置打印回\n溯标记。\n通过 PYTHONNODEBUGRANGES 环境变量和 -X no_debug_ranges 命令行选项设置为 0。\n默认值: 1.\nAdded in version 3.11.\nwchar_t *check_hash_pycs_mode\n控制基于哈希值的 .pyc 文件的验证行为: --check-hash-based-pycs 命令行选项的值。\n有效的值：\nL\"always\": 无论 'check_source' 旗标的值是什么都会对源文件进行哈希验证。\nL\"never\": 假定基于哈希值的 pyc 始终是有效的。\nL\"default\": 基于哈希值的 pyc 中的 'check_source' 旗标确定是否验证无效。\n默认值： L\"default\"。\n参见 PEP 552 \"Deterministic pycs\"。\nint configure_c_stdio\n如为非零值，则配置 C 标准流:\n在 Windows 中，在 stdin, stdout 和 stderr 上设置二进制模式 (O_BINARY)。\n如果 buffered_stdio 等于零，则禁用 stdin, stdout 和 stderr 流的缓冲。\n如果 interactive 为非零值，则启用 stdin 和 stdout 上的流缓冲（Windows 中仅限\nstdout）。\n\n|  | int bytes_warning\n如果等于 1，则在将 bytes 或 bytearray 与 str 进行比较，或将 bytes 与 int 进行比\n较时发出警告。\n如果大于等于 2，则在这些情况下引发 BytesWarning 异常。\n由 -b 命令行选项执行递增。\n默认值: 0.\nint warn_default_encoding\n如为非零值，则在 io.TextIOWrapper 使用默认编码格式时发出 EncodingWarning 警\n告。 详情请参阅 选择性的 EncodingWarning。\n默认值: 0.\nAdded in version 3.10.\nint code_debug_ranges\n如果等于 0，则禁用在代码对象中包括末尾行和列映射。 并且禁用在特定错误位置打印回\n溯标记。\n通过 PYTHONNODEBUGRANGES 环境变量和 -X no_debug_ranges 命令行选项设置为 0。\n默认值: 1.\nAdded in version 3.11.\nwchar_t *check_hash_pycs_mode\n控制基于哈希值的 .pyc 文件的验证行为: --check-hash-based-pycs 命令行选项的值。\n有效的值：\nL\"always\": 无论 'check_source' 旗标的值是什么都会对源文件进行哈希验证。\nL\"never\": 假定基于哈希值的 pyc 始终是有效的。\nL\"default\": 基于哈希值的 pyc 中的 'check_source' 旗标确定是否验证无效。\n默认值： L\"default\"。\n参见 PEP 552 \"Deterministic pycs\"。\nint configure_c_stdio\n如为非零值，则配置 C 标准流:\n在 Windows 中，在 stdin, stdout 和 stderr 上设置二进制模式 (O_BINARY)。\n如果 buffered_stdio 等于零，则禁用 stdin, stdout 和 stderr 流的缓冲。\n如果 interactive 为非零值，则启用 stdin 和 stdout 上的流缓冲（Windows 中仅限\nstdout）。 |  |\n| --- | --- | --- |\n\n默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint dev_mode\n如果为非零值，则启用 Python 开发模式。\n通过 -X dev 选项和 PYTHONDEVMODE 环境变量设置为 1。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nint dump_refs\n转储 Python 引用？\n如果为非零值，则转储所有在退出时仍存活的对象。\n由 PYTHONDUMPREFS 环境变量设置为 1。\n需要定义了 Py_TRACE_REFS 宏的特殊 Python 编译版：参见 configure --with-trace-\nrefs 选项。\n默认值: 0.\nwchar_t *dump_refs_file\n转储 Python 引用的目标文件名。\n由 PYTHONDUMPREFSFILE 环境变量设置。\n默认值: NULL.\nAdded in version 3.11.\nwchar_t *exec_prefix\n安装依赖于平台的 Python 文件的站点专属目录前缀: sys.exec_prefix。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_exec_prefix。\nwchar_t *executable\nPython 解释器可执行二进制文件的绝对路径: sys.executable。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_executable。\nint faulthandler\n\n|  | 默认值: 在 Python 配置中为 1，在隔离配置中为 0。\nint dev_mode\n如果为非零值，则启用 Python 开发模式。\n通过 -X dev 选项和 PYTHONDEVMODE 环境变量设置为 1。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nint dump_refs\n转储 Python 引用？\n如果为非零值，则转储所有在退出时仍存活的对象。\n由 PYTHONDUMPREFS 环境变量设置为 1。\n需要定义了 Py_TRACE_REFS 宏的特殊 Python 编译版：参见 configure --with-trace-\nrefs 选项。\n默认值: 0.\nwchar_t *dump_refs_file\n转储 Python 引用的目标文件名。\n由 PYTHONDUMPREFSFILE 环境变量设置。\n默认值: NULL.\nAdded in version 3.11.\nwchar_t *exec_prefix\n安装依赖于平台的 Python 文件的站点专属目录前缀: sys.exec_prefix。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_exec_prefix。\nwchar_t *executable\nPython 解释器可执行二进制文件的绝对路径: sys.executable。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_executable。\nint faulthandler |  |\n| --- | --- | --- |\n\n启用 faulthandler？\n如果为非零值，则在启动时调用 faulthandler.enable()。\n通过 -X faulthandler 和 PYTHONFAULTHANDLER 环境变量设为 1。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nwchar_t *filesystem_encoding\n文件系统编码格式: sys.getfilesystemencoding()。\n在 macOS, Android 和 VxWorks 上：默认使用 \"utf-8\"。\n在 Windows 上：默认使用 \"utf-8\"，或者如果 PyPreConfig 的\nlegacy_windows_fs_encoding 为非零值则使用 \"mbcs\"。\n在其他平台上的默认编码格式：\n如果 PyPreConfig.utf8_mode 为非零值则使用 \"utf-8\"。\n如果 Python 检测到 nl_langinfo(CODESET) 声明为 ASCII 编码格式，而 mbstowcs()\n是从其他的编码格式解码（通常为 Latin1）则使用 \"ascii\"。\n如果 nl_langinfo(CODESET) 返回空字符串则使用 \"utf-8\"。\n在其他情况下，使用 locale encoding: nl_langinfo(CODESET) 的结果。\n在 Python 启动时，编码格式名称会规范化为 Python 编解码器名称。 例如，\"ANSI_X3.4-\n1968\" 将被替换为 \"ascii\"。\n参见 filesystem_errors 的成员。\nwchar_t *filesystem_errors\n文件系统错误处理器: sys.getfilesystemencodeerrors()。\n在 Windows 上：默认使用 \"surrogatepass\"，或者如果 PyPreConfig 的\nlegacy_windows_fs_encoding 为非零值则使用 \"replace\"。\n在其他平台上：默认使用 \"surrogateescape\"。\n支持的错误处理器：\n\"strict\"\n\"surrogateescape\"\n\"surrogatepass\" (仅支持 UTF-8 编码格式)\n参见 filesystem_encoding 的成员。\nint use_frozen_modules\n如为非零值，则使用冻结模块。\n由 PYTHON_FROZEN_MODULES 环境变量设置。\n\n|  |  | 启用 faulthandler？\n如果为非零值，则在启动时调用 faulthandler.enable()。\n通过 -X faulthandler 和 PYTHONFAULTHANDLER 环境变量设为 1。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\nwchar_t *filesystem_encoding\n文件系统编码格式: sys.getfilesystemencoding()。\n在 macOS, Android 和 VxWorks 上：默认使用 \"utf-8\"。\n在 Windows 上：默认使用 \"utf-8\"，或者如果 PyPreConfig 的\nlegacy_windows_fs_encoding 为非零值则使用 \"mbcs\"。\n在其他平台上的默认编码格式：\n如果 PyPreConfig.utf8_mode 为非零值则使用 \"utf-8\"。\n如果 Python 检测到 nl_langinfo(CODESET) 声明为 ASCII 编码格式，而 mbstowcs()\n是从其他的编码格式解码（通常为 Latin1）则使用 \"ascii\"。\n如果 nl_langinfo(CODESET) 返回空字符串则使用 \"utf-8\"。\n在其他情况下，使用 locale encoding: nl_langinfo(CODESET) 的结果。\n在 Python 启动时，编码格式名称会规范化为 Python 编解码器名称。 例如，\"ANSI_X3.4-\n1968\" 将被替换为 \"ascii\"。\n参见 filesystem_errors 的成员。\nwchar_t *filesystem_errors\n文件系统错误处理器: sys.getfilesystemencodeerrors()。\n在 Windows 上：默认使用 \"surrogatepass\"，或者如果 PyPreConfig 的\nlegacy_windows_fs_encoding 为非零值则使用 \"replace\"。\n在其他平台上：默认使用 \"surrogateescape\"。\n支持的错误处理器：\n\"strict\"\n\"surrogateescape\"\n\"surrogatepass\" (仅支持 UTF-8 编码格式)\n参见 filesystem_encoding 的成员。\nint use_frozen_modules\n如为非零值，则使用冻结模块。\n由 PYTHON_FROZEN_MODULES 环境变量设置。 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | \"ANSI_X3.4- |  |  |\n|  |  |  |  |  |  |\n|  |  | 1968\" |  |  |  |\n|  |  |  |  |  |  |\n\n默认值：在发布构建版中为 1，而在 调试构建版 中为 0。\nunsigned long hash_seed\nint use_hash_seed\n随机化的哈希函数种子。\n如果 use_hash_seed 为零，则在 Python 启动时随机选择一个种子，并忽略 hash_seed。\n由 PYTHONHASHSEED 环境变量设置。\n默认的 use_hash_seed 值：在 Python 模式下为 -1，在隔离模式下为 0。\nwchar_t *home\n设置默认的 Python \"home\" 目录，即标准 Python 库所在的位置 (参见 PYTHONHOME)。\n由 PYTHONHOME 环境变量设置。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nint import_time\n如为 1，则会针对导入时间进行性能分析。 如为 2，则会包括提示当被导入模块已被加\n载的额外输出。\n通过 -X importtime 选项和 PYTHONPROFILEIMPORTTIME 环境变量设置。\n默认值: 0.\n在 3.14 版本发生变更: 添加了对 import_time = 2 的支持\nint inspect\n在执行脚本或命令之后进入交互模式。\n如果大于 0 ，则启用检查：当脚本作为第一个参数传入或使用了 -c 选项时，在执行脚本\n或命令后进入交互模式，即使在 sys.stdin 看来并非一个终端时也是如此。\n通过 -i 命令行选项执行递增。 如果 PYTHONINSPECT 环境变量为非空值则设为 1。\n默认值: 0.\nint install_signal_handlers\n安装 Python 信号处理器？\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\nint interactive\n\n|  | 默认值：在发布构建版中为 1，而在 调试构建版 中为 0。\nunsigned long hash_seed\nint use_hash_seed\n随机化的哈希函数种子。\n如果 use_hash_seed 为零，则在 Python 启动时随机选择一个种子，并忽略 hash_seed。\n由 PYTHONHASHSEED 环境变量设置。\n默认的 use_hash_seed 值：在 Python 模式下为 -1，在隔离模式下为 0。\nwchar_t *home\n设置默认的 Python \"home\" 目录，即标准 Python 库所在的位置 (参见 PYTHONHOME)。\n由 PYTHONHOME 环境变量设置。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nint import_time\n如为 1，则会针对导入时间进行性能分析。 如为 2，则会包括提示当被导入模块已被加\n载的额外输出。\n通过 -X importtime 选项和 PYTHONPROFILEIMPORTTIME 环境变量设置。\n默认值: 0.\n在 3.14 版本发生变更: 添加了对 import_time = 2 的支持\nint inspect\n在执行脚本或命令之后进入交互模式。\n如果大于 0 ，则启用检查：当脚本作为第一个参数传入或使用了 -c 选项时，在执行脚本\n或命令后进入交互模式，即使在 sys.stdin 看来并非一个终端时也是如此。\n通过 -i 命令行选项执行递增。 如果 PYTHONINSPECT 环境变量为非空值则设为 1。\n默认值: 0.\nint install_signal_handlers\n安装 Python 信号处理器？\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\nint interactive |  |\n| --- | --- | --- |\n\n如果大于 0，则启用交互模式（REPL）。\n由 -i 命令行选项执行递增。\n默认值: 0.\nint int_max_str_digits\n配置 整数字符串转换长度限制。 初始值为 -1 表示该值将从命令行或环境获取否则默认为\n4300 (sys.int_info.default_max_str_digits)。 值为 0 表示禁用限制。 大于 0 但小\n于 640 (sys.int_info.str_digits_check_threshold) 的值将不被支持并会产生错误。\n通过 -X int_max_str_digits 命令行旗标或 PYTHONINTMAXSTRDIGITS 环境变量配置。\n默认值：在 Python 模式下为 -1 。 在孤立模式下为 4300\n(sys.int_info.default_max_str_digits)。\nAdded in version 3.12.\nint cpu_count\n如果 cpu_count 的值不为 -1 则它将覆盖 os.cpu_count(), os.process_cpu_count()\n和 multiprocessing.cpu_count() 的返回值。\n通过 -X cpu_count=n|default 命令行旗标或 PYTHON_CPU_COUNT 环境变量来配置。\n默认值: -1。\nAdded in version 3.13.\nint isolated\n如果大于 0 ，则启用隔离模式：\n将 safe_path 设为 1: 在 Python 启动时将不在 sys.path 前添加有潜在不安全性的路\n径，如当前目录、脚本所在目录或空字符串。\n将 use_environment 设为 0: 忽略 PYTHON 环境变量。\n将 user_site_directory 设为 0: 不要将用户级站点目录添加到 sys.path。\nPython REPL 将不导入 readline 也不在交互提示符中启用默认的 readline 配置。\n通过 -I 命令行选项设置为 1。\n默认值: 在 Python 模式中为 0，在隔离模式中为 1。\n另请参阅 隔离配置 和 PyPreConfig.isolated。\nint legacy_windows_stdio\n如为非零值，则使用 io.FileIO 代替 io._WindowsConsoleIO 作为 sys.stdin、\nsys.stdout 和 sys.stderr。\n如果 PYTHONLEGACYWINDOWSSTDIO 环境变量被设为非空字符串则设为 1。\n\n|  | 如果大于 0，则启用交互模式（REPL）。\n由 -i 命令行选项执行递增。\n默认值: 0.\nint int_max_str_digits\n配置 整数字符串转换长度限制。 初始值为 -1 表示该值将从命令行或环境获取否则默认为\n4300 (sys.int_info.default_max_str_digits)。 值为 0 表示禁用限制。 大于 0 但小\n于 640 (sys.int_info.str_digits_check_threshold) 的值将不被支持并会产生错误。\n通过 -X int_max_str_digits 命令行旗标或 PYTHONINTMAXSTRDIGITS 环境变量配置。\n默认值：在 Python 模式下为 -1 。 在孤立模式下为 4300\n(sys.int_info.default_max_str_digits)。\nAdded in version 3.12.\nint cpu_count\n如果 cpu_count 的值不为 -1 则它将覆盖 os.cpu_count(), os.process_cpu_count()\n和 multiprocessing.cpu_count() 的返回值。\n通过 -X cpu_count=n|default 命令行旗标或 PYTHON_CPU_COUNT 环境变量来配置。\n默认值: -1。\nAdded in version 3.13.\nint isolated\n如果大于 0 ，则启用隔离模式：\n将 safe_path 设为 1: 在 Python 启动时将不在 sys.path 前添加有潜在不安全性的路\n径，如当前目录、脚本所在目录或空字符串。\n将 use_environment 设为 0: 忽略 PYTHON 环境变量。\n将 user_site_directory 设为 0: 不要将用户级站点目录添加到 sys.path。\nPython REPL 将不导入 readline 也不在交互提示符中启用默认的 readline 配置。\n通过 -I 命令行选项设置为 1。\n默认值: 在 Python 模式中为 0，在隔离模式中为 1。\n另请参阅 隔离配置 和 PyPreConfig.isolated。\nint legacy_windows_stdio\n如为非零值，则使用 io.FileIO 代替 io._WindowsConsoleIO 作为 sys.stdin、\nsys.stdout 和 sys.stderr。\n如果 PYTHONLEGACYWINDOWSSTDIO 环境变量被设为非空字符串则设为 1。 |  |\n| --- | --- | --- |\n\n仅在 Windows 上可用。 #ifdef MS_WINDOWS 宏可被用于 Windows 专属的代码。\n默认值: 0.\n另请参阅 PEP 528 (将 Windows 控制台编码格式更改为 UTF-8)。\nint malloc_stats\n如为非零值，则在退出时转储 Python pymalloc 内存分配器 的统计数据。\n由 PYTHONMALLOCSTATS 环境变量设置为 1。\n如果 Python 是 使用 --without-pymalloc 选项进行配置 则该选项将被忽略。\n默认值: 0.\nwchar_t *platlibdir\n平台库目录名称: sys.platlibdir。\n由 PYTHONPLATLIBDIR 环境变量设置。\n默认值：由 configure --with-platlibdir 选项 设置的 PLATLIBDIR 宏的值 (默认值:\n\"lib\"，在 Windows 上则为 \"DLLs\")。\nPython 路径配置 输入的一部分。\nAdded in version 3.9.\n在 3.11 版本发生变更: 目前在 Windows 系统中该宏被用于定位标准库扩展模块，通\n常位于 DLLs 下。 不过，出于兼容性考虑，请注意在任何非标准布局包括树内构建\n和虚拟环境中，该值都将被忽略。\nwchar_t *pythonpath_env\n模块搜索路径 (sys.path) 为一个用 DELIM (os.pathsep) 分隔的字符串。\n由 PYTHONPATH 环境变量设置。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nPyWideStringList module_search_paths\nint module_search_paths_set\n模块搜索路径: sys.path。\n如果 module_search_paths_set 等于 0，Py_InitializeFromConfig() 将替代\nmodule_search_paths 并将 module_search_paths_set 设为 1。\n默认值：空列表 (module_search_paths) 和 0 (module_search_paths_set)。\n\n|  | 仅在 Windows 上可用。 #ifdef MS_WINDOWS 宏可被用于 Windows 专属的代码。\n默认值: 0.\n另请参阅 PEP 528 (将 Windows 控制台编码格式更改为 UTF-8)。\nint malloc_stats\n如为非零值，则在退出时转储 Python pymalloc 内存分配器 的统计数据。\n由 PYTHONMALLOCSTATS 环境变量设置为 1。\n如果 Python 是 使用 --without-pymalloc 选项进行配置 则该选项将被忽略。\n默认值: 0.\nwchar_t *platlibdir\n平台库目录名称: sys.platlibdir。\n由 PYTHONPLATLIBDIR 环境变量设置。\n默认值：由 configure --with-platlibdir 选项 设置的 PLATLIBDIR 宏的值 (默认值:\n\"lib\"，在 Windows 上则为 \"DLLs\")。\nPython 路径配置 输入的一部分。\nAdded in version 3.9.\n在 3.11 版本发生变更: 目前在 Windows 系统中该宏被用于定位标准库扩展模块，通\n常位于 DLLs 下。 不过，出于兼容性考虑，请注意在任何非标准布局包括树内构建\n和虚拟环境中，该值都将被忽略。\nwchar_t *pythonpath_env\n模块搜索路径 (sys.path) 为一个用 DELIM (os.pathsep) 分隔的字符串。\n由 PYTHONPATH 环境变量设置。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nPyWideStringList module_search_paths\nint module_search_paths_set\n模块搜索路径: sys.path。\n如果 module_search_paths_set 等于 0，Py_InitializeFromConfig() 将替代\nmodule_search_paths 并将 module_search_paths_set 设为 1。\n默认值：空列表 (module_search_paths) 和 0 (module_search_paths_set)。 |  |\n| --- | --- | --- |\n\nPython 路径配置 的一部分。\nint optimization_level\n编译优化级别：\n0: Peephole 优化器，将 __debug__ 设为 True。\n1: 0 级，移除断言，将 __debug__ 设为 False。\n2: 1 级，去除文档字符串。\n通过 -O 命令行选项递增。 设置为 PYTHONOPTIMIZE 环境变量值。\n默认值: 0.\nPyWideStringList orig_argv\n传给 Python 可执行程序的原始命令行参数列表: sys.orig_argv。\n如果 orig_argv 列表为空并且 argv 不是一个只包含空字符串的列表，PyConfig_Read()\n将在修改 argv 之前把 argv 拷贝至 orig_argv (如果 parse_argv 不为空)。\n另请参阅 argv 成员和 Py_GetArgcArgv() 函数。\n默认值：空列表。\nAdded in version 3.10.\nint parse_argv\n解析命令行参数？\n如果等于 1，则以与常规 Python 解析 命令行参数 相同的方式解析 argv，并从 argv 中剥\n离 Python 参数。\nPyConfig_Read() 函数对 PyConfig.argv 参数只会解析一次：在参数解析完成后\nPyConfig.parse_argv 将被设为 2。 由于 Python 参数是从 PyConfig.argv 提取的，因\n此解析参数两次会将应用程序选项解析为 Python 选项。\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\n在 3.10 版本发生变更: 现在只有当 PyConfig.parse_argv 等于 1 时才会解析\nPyConfig.argv 参数。\nint parser_debug\n解析器调试模式。 如果大于 0，则打开解析器调试输出（仅针对专家，取决于编译选\n项）。\n通过 -d 命令行选项递增。 设置为 PYTHONDEBUG 环境变量值。\n需要 Python 调试编译版 (必须已定义 Py_DEBUG 宏)。\n\n|  | Python 路径配置 的一部分。\nint optimization_level\n编译优化级别：\n0: Peephole 优化器，将 __debug__ 设为 True。\n1: 0 级，移除断言，将 __debug__ 设为 False。\n2: 1 级，去除文档字符串。\n通过 -O 命令行选项递增。 设置为 PYTHONOPTIMIZE 环境变量值。\n默认值: 0.\nPyWideStringList orig_argv\n传给 Python 可执行程序的原始命令行参数列表: sys.orig_argv。\n如果 orig_argv 列表为空并且 argv 不是一个只包含空字符串的列表，PyConfig_Read()\n将在修改 argv 之前把 argv 拷贝至 orig_argv (如果 parse_argv 不为空)。\n另请参阅 argv 成员和 Py_GetArgcArgv() 函数。\n默认值：空列表。\nAdded in version 3.10.\nint parse_argv\n解析命令行参数？\n如果等于 1，则以与常规 Python 解析 命令行参数 相同的方式解析 argv，并从 argv 中剥\n离 Python 参数。\nPyConfig_Read() 函数对 PyConfig.argv 参数只会解析一次：在参数解析完成后\nPyConfig.parse_argv 将被设为 2。 由于 Python 参数是从 PyConfig.argv 提取的，因\n此解析参数两次会将应用程序选项解析为 Python 选项。\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\n在 3.10 版本发生变更: 现在只有当 PyConfig.parse_argv 等于 1 时才会解析\nPyConfig.argv 参数。\nint parser_debug\n解析器调试模式。 如果大于 0，则打开解析器调试输出（仅针对专家，取决于编译选\n项）。\n通过 -d 命令行选项递增。 设置为 PYTHONDEBUG 环境变量值。\n需要 Python 调试编译版 (必须已定义 Py_DEBUG 宏)。 |  |\n| --- | --- | --- |\n\n默认值: 0.\nint pathconfig_warnings\n如为非零值，则允许计算路径配置以将警告记录到 stderr 中。 如果等于 0，则抑制这些\n警告。\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\nPython 路径配置 输入的一部分。\n在 3.11 版本发生变更: 现在也适用于 Windows。\nwchar_t *prefix\n安装依赖于平台的 Python 文件的站点专属目录前缀: sys.prefix。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_prefix。\nwchar_t *program_name\n用于初始化 executable 和在 Python 初始化期间早期错误消息中使用的程序名称。\n在 macOS 上，如果设置了 PYTHONEXECUTABLE 环境变量则会使用它。\n如果定义了 WITH_NEXT_FRAMEWORK 宏，当设置了 __PYVENV_LAUNCHER__ 环境变量时\n将会使用它。\n如果 argv 的 argv[0] 可用并且不为空值则会使用它。\n否则，在 Windows 上将使用 L\"python\"，在其他平台上将使用 L\"python3\"。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nwchar_t *pycache_prefix\n缓存 .pyc 文件被写入到的目录: sys.pycache_prefix。\n通过 -X pycache_prefix=PATH 命令行选项和 PYTHONPYCACHEPREFIX 环境变量设置。 命\n令行选项优先级更高。\n如果为 NULL，则 sys.pycache_prefix 将被设为 None。\n默认值: NULL.\nint quiet\n安静模式。 如果大于 0，则在交互模式下启动 Python 时不显示版权和版本。\n由 -q 命令行选项执行递增。\n\n|  | 默认值: 0.\nint pathconfig_warnings\n如为非零值，则允许计算路径配置以将警告记录到 stderr 中。 如果等于 0，则抑制这些\n警告。\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\nPython 路径配置 输入的一部分。\n在 3.11 版本发生变更: 现在也适用于 Windows。\nwchar_t *prefix\n安装依赖于平台的 Python 文件的站点专属目录前缀: sys.prefix。\n默认值: NULL.\nPython 路径配置 的一部分。\n另请参阅 PyConfig.base_prefix。\nwchar_t *program_name\n用于初始化 executable 和在 Python 初始化期间早期错误消息中使用的程序名称。\n在 macOS 上，如果设置了 PYTHONEXECUTABLE 环境变量则会使用它。\n如果定义了 WITH_NEXT_FRAMEWORK 宏，当设置了 __PYVENV_LAUNCHER__ 环境变量时\n将会使用它。\n如果 argv 的 argv[0] 可用并且不为空值则会使用它。\n否则，在 Windows 上将使用 L\"python\"，在其他平台上将使用 L\"python3\"。\n默认值: NULL.\nPython 路径配置 输入的一部分。\nwchar_t *pycache_prefix\n缓存 .pyc 文件被写入到的目录: sys.pycache_prefix。\n通过 -X pycache_prefix=PATH 命令行选项和 PYTHONPYCACHEPREFIX 环境变量设置。 命\n令行选项优先级更高。\n如果为 NULL，则 sys.pycache_prefix 将被设为 None。\n默认值: NULL.\nint quiet\n安静模式。 如果大于 0，则在交互模式下启动 Python 时不显示版权和版本。\n由 -q 命令行选项执行递增。 |  |\n| --- | --- | --- |\n\n默认值: 0.\nwchar_t *run_command\n-c 命令行选项的值。\n由 Py_RunMain() 使用。\n默认值: NULL.\nwchar_t *run_filename\n通过命令行传入的文件名：不包含 -c 或 -m 的附加命令行参数。 它会被 Py_RunMain()\n函数使用。\n例如，对于命令行 python3 script.py arg 它将被设为 script.py。\n另请参阅 PyConfig.skip_source_first_line 选项。\n默认值: NULL.\nwchar_t *run_module\n-m 命令行选项的值。\n由 Py_RunMain() 使用。\n默认值: NULL.\nwchar_t *run_presite\npackage.module 模块路径，它应当在运行 site.py 之前被导入。\n通过 -X presite=package.module 命令行选项和 PYTHON_PRESITE 环境变量设置。 命令\n行选项优先级更高。\n需要 Python 调试编译版 (必须已定义 Py_DEBUG 宏)。\n默认值: NULL.\nint show_ref_count\n是否要在退出时显示总引用计数 (不包括 immortal 对象)？\n通过 -X showrefcount 命令行选项设置为 1。\n需要 Python 调试编译版 (必须已定义 Py_REF_DEBUG 宏)。\n默认值: 0.\nint site_import\n在启动时导入 site 模块？\n如果等于零，则禁用模块站点的导入以及由此产生的与站点相关的 sys.path 操作。\n\n|  | 默认值: 0.\nwchar_t *run_command\n-c 命令行选项的值。\n由 Py_RunMain() 使用。\n默认值: NULL.\nwchar_t *run_filename\n通过命令行传入的文件名：不包含 -c 或 -m 的附加命令行参数。 它会被 Py_RunMain()\n函数使用。\n例如，对于命令行 python3 script.py arg 它将被设为 script.py。\n另请参阅 PyConfig.skip_source_first_line 选项。\n默认值: NULL.\nwchar_t *run_module\n-m 命令行选项的值。\n由 Py_RunMain() 使用。\n默认值: NULL.\nwchar_t *run_presite\npackage.module 模块路径，它应当在运行 site.py 之前被导入。\n通过 -X presite=package.module 命令行选项和 PYTHON_PRESITE 环境变量设置。 命令\n行选项优先级更高。\n需要 Python 调试编译版 (必须已定义 Py_DEBUG 宏)。\n默认值: NULL.\nint show_ref_count\n是否要在退出时显示总引用计数 (不包括 immortal 对象)？\n通过 -X showrefcount 命令行选项设置为 1。\n需要 Python 调试编译版 (必须已定义 Py_REF_DEBUG 宏)。\n默认值: 0.\nint site_import\n在启动时导入 site 模块？\n如果等于零，则禁用模块站点的导入以及由此产生的与站点相关的 sys.path 操作。 |  |\n| --- | --- | --- |\n\n如果以后显式地导入 site 模块也要禁用这些操作（如果你希望触发这些操作，请调用\nsite.main() 函数）。\n通过 -S 命令行选项设置为 0。\nsys.flags.no_site 会被设为 site_import 取反后的值。\n默认值: 1.\nint skip_source_first_line\n如为非零值，则跳过 PyConfig.run_filename 源的第一行。\n它将允许使用非 Unix 形式的 #!cmd。 这是针对 DOS 专属的破解操作。\n通过 -x 命令行选项设置为 1。\n默认值: 0.\nwchar_t *stdio_encoding\nwchar_t *stdio_errors\nsys.stdin、sys.stdout 和 sys.stderr 的编码格式和编码格式错误（但 sys.stderr\n将始终使用 \"backslashreplace\" 错误处理器）。\n如果 PYTHONIOENCODING 环境变量非空则会使用它。\n默认编码格式：\n如果 PyPreConfig.utf8_mode 为非零值则使用 \"UTF-8\"。\n在其他情况下，使用 locale encoding。\n默认错误处理器：\n在 Windows 上：使用 \"surrogateescape\"。\n如果 PyPreConfig.utf8_mode 为非零值，或者如果 LC_CTYPE 语言区域为 \"C\" 或\n\"POSIX\" 则使用 \"surrogateescape\"。\n在其他情况下则使用 \"strict\"。\n另请参阅 PyConfig.legacy_windows_stdio。\nint tracemalloc\n启用 tracemalloc？\n如果为非零值，则在启动时调用 tracemalloc.start()。\n通过 -X tracemalloc=N 命令行选项和 PYTHONTRACEMALLOC 环境变量设置。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。\n\n|  | 如果以后显式地导入 site 模块也要禁用这些操作（如果你希望触发这些操作，请调用\nsite.main() 函数）。\n通过 -S 命令行选项设置为 0。\nsys.flags.no_site 会被设为 site_import 取反后的值。\n默认值: 1.\nint skip_source_first_line\n如为非零值，则跳过 PyConfig.run_filename 源的第一行。\n它将允许使用非 Unix 形式的 #!cmd。 这是针对 DOS 专属的破解操作。\n通过 -x 命令行选项设置为 1。\n默认值: 0.\nwchar_t *stdio_encoding\nwchar_t *stdio_errors\nsys.stdin、sys.stdout 和 sys.stderr 的编码格式和编码格式错误（但 sys.stderr\n将始终使用 \"backslashreplace\" 错误处理器）。\n如果 PYTHONIOENCODING 环境变量非空则会使用它。\n默认编码格式：\n如果 PyPreConfig.utf8_mode 为非零值则使用 \"UTF-8\"。\n在其他情况下，使用 locale encoding。\n默认错误处理器：\n在 Windows 上：使用 \"surrogateescape\"。\n如果 PyPreConfig.utf8_mode 为非零值，或者如果 LC_CTYPE 语言区域为 \"C\" 或\n\"POSIX\" 则使用 \"surrogateescape\"。\n在其他情况下则使用 \"strict\"。\n另请参阅 PyConfig.legacy_windows_stdio。\nint tracemalloc\n启用 tracemalloc？\n如果为非零值，则在启动时调用 tracemalloc.start()。\n通过 -X tracemalloc=N 命令行选项和 PYTHONTRACEMALLOC 环境变量设置。\n默认值: 在 Python 模式中为 -1，在隔离模式中为 0。 |  |\n| --- | --- | --- |\n\nint perf_profiling\n是否启用 Linux perf 性能分析器支持？\n如果等于 1，则启用对 Linux perf 性能分析器的支持。\n如果等于 2，则启用对带有 DWARF JIT 支持的 Linux perf 性能分析器的支持。\n通过 -X perf 命令行选项和 PYTHONPERFSUPPORT 环境变量设置为 1。\n通过 -X perf_jit 命令行选项和 PYTHON_PERF_JIT_SUPPORT 环境变量设置为 2。\n默认值: -1。\n参见: 请参阅 Python 对 Linux perf 性能分析器的支持 了解详情。\nAdded in version 3.12.\nwchar_t *stdlib_dir\nPython 标准库的目录。\n默认值: NULL.\nAdded in version 3.11.\nint use_environment\n使用 环境变量？\n如果等于零，则忽略 环境变量。\n由 -E 环境变量设置为 0。\n默认值: 在 Python 配置中为 1 而在隔离配置中为 0。\nint use_system_logger\n如为非零值，则 stdout 和 stderr 将被重定向到系统日志。\n仅在 macOS 10.12 和更新版本，以及 iOS 上可用。\n默认值: 在 macOS 上为 0 (不使用系统日志); 在 iOS 上为 1 (使用系统日志)。\nAdded in version 3.14.\nint user_site_directory\n如果为非零值，则将用户站点目录添加到 sys.path。\n通过 -s 和 -I 命令行选项设置为 0。\n由 PYTHONNOUSERSITE 环境变量设置为 0。\n\n|  | int perf_profiling\n是否启用 Linux perf 性能分析器支持？\n如果等于 1，则启用对 Linux perf 性能分析器的支持。\n如果等于 2，则启用对带有 DWARF JIT 支持的 Linux perf 性能分析器的支持。\n通过 -X perf 命令行选项和 PYTHONPERFSUPPORT 环境变量设置为 1。\n通过 -X perf_jit 命令行选项和 PYTHON_PERF_JIT_SUPPORT 环境变量设置为 2。\n默认值: -1。\n参见: 请参阅 Python 对 Linux perf 性能分析器的支持 了解详情。\nAdded in version 3.12.\nwchar_t *stdlib_dir\nPython 标准库的目录。\n默认值: NULL.\nAdded in version 3.11.\nint use_environment\n使用 环境变量？\n如果等于零，则忽略 环境变量。\n由 -E 环境变量设置为 0。\n默认值: 在 Python 配置中为 1 而在隔离配置中为 0。\nint use_system_logger\n如为非零值，则 stdout 和 stderr 将被重定向到系统日志。\n仅在 macOS 10.12 和更新版本，以及 iOS 上可用。\n默认值: 在 macOS 上为 0 (不使用系统日志); 在 iOS 上为 1 (使用系统日志)。\nAdded in version 3.14.\nint user_site_directory\n如果为非零值，则将用户站点目录添加到 sys.path。\n通过 -s 和 -I 命令行选项设置为 0。\n由 PYTHONNOUSERSITE 环境变量设置为 0。 |  |\n| --- | --- | --- |\n\n默认值：在 Python 模式下为 1，在隔离模式下为 0。\nint verbose\n详细模式。 如果大于 0，则每次导入模块时都会打印一条消息，显示加载模块的位置（文\n件名或内置模块）。\n如果大于等于 2，则为搜索模块时每个被检查的文件打印一条消息。 还在退出时提供关于\n模块清理的信息。\n由 -v 命令行选项执行递增。\n通过 PYTHONVERBOSE 环境变量值设置。\n默认值: 0.\nPyWideStringList warnoptions\nwarnings 模块用于构建警告过滤器的选项，优先级从低到高: sys.warnoptions。\nwarnings 模块以相反的顺序添加 sys.warnoptions: 最后一个 PyConfig.warnoptions\n条目将成为 warnings.filters 的第一个条目并将最先被检查（最高优先级）。\n-W 命令行选项会将其值添加到 warnoptions 中，它可以被多次使用。\nPYTHONWARNINGS 环境变量也可被用于添加警告选项。 可以指定多个选项，并以逗号 (,)\n分隔。\n默认值：空列表。\nint write_bytecode\n如果等于 0，Python 将不会尝试在导入源模块时写入 .pyc 文件。\n通过 -B 命令行选项和 PYTHONDONTWRITEBYTECODE 环境变量设置为 0。\nsys.dont_write_bytecode 会被初始化为 write_bytecode 取反后的值。\n默认值: 1.\nPyWideStringList xoptions\n-X 命令行选项的值: sys._xoptions。\n默认值：空列表。\nint _pystats\n如为非零值，则在 Python 退出时写入性能统计数据。\n需要带有 Py_STATS 宏的特殊构建版：参见 --enable-pystats。\n默认值: 0.\n\n|  | 默认值：在 Python 模式下为 1，在隔离模式下为 0。\nint verbose\n详细模式。 如果大于 0，则每次导入模块时都会打印一条消息，显示加载模块的位置（文\n件名或内置模块）。\n如果大于等于 2，则为搜索模块时每个被检查的文件打印一条消息。 还在退出时提供关于\n模块清理的信息。\n由 -v 命令行选项执行递增。\n通过 PYTHONVERBOSE 环境变量值设置。\n默认值: 0.\nPyWideStringList warnoptions\nwarnings 模块用于构建警告过滤器的选项，优先级从低到高: sys.warnoptions。\nwarnings 模块以相反的顺序添加 sys.warnoptions: 最后一个 PyConfig.warnoptions\n条目将成为 warnings.filters 的第一个条目并将最先被检查（最高优先级）。\n-W 命令行选项会将其值添加到 warnoptions 中，它可以被多次使用。\nPYTHONWARNINGS 环境变量也可被用于添加警告选项。 可以指定多个选项，并以逗号 (,)\n分隔。\n默认值：空列表。\nint write_bytecode\n如果等于 0，Python 将不会尝试在导入源模块时写入 .pyc 文件。\n通过 -B 命令行选项和 PYTHONDONTWRITEBYTECODE 环境变量设置为 0。\nsys.dont_write_bytecode 会被初始化为 write_bytecode 取反后的值。\n默认值: 1.\nPyWideStringList xoptions\n-X 命令行选项的值: sys._xoptions。\n默认值：空列表。\nint _pystats\n如为非零值，则在 Python 退出时写入性能统计数据。\n需要带有 Py_STATS 宏的特殊构建版：参见 --enable-pystats。\n默认值: 0. |  |\n| --- | --- | --- |\n\n如果 parse_argv 为非零值，则 argv 参数将以与常规 Python 解析 命令行参数 相同的方式被解\n析，并从 argv 中剥离 Python 参数。\nxoptions 选项将会被解析以设置其他选项：参见 -X 命令行选项。\n在 3.9 版本发生变更: show_alloc_count 字段已被移除。\n使用 PyConfig 初始化\n基于一个已填充内容的配置结构体初始化解释器是通过调用 Py_InitializeFromConfig() 来处理\n的。\n调用方要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处理异常（错误或退\n出）。\n如果使用了 PyImport_FrozenModules()、PyImport_AppendInittab() 或\nPyImport_ExtendInittab()，则必须在 Python 预初始化之后、Python 初始化之前设置或调用它\n们。 如果 Python 被多次初始化，则必须在每次初始化 Python 之前调用\nPyImport_AppendInittab() 或 PyImport_ExtendInittab()。\n当前的配置 (PyConfig 类型) 保存在 PyInterpreterState.config 中。\n设置程序名称的示例:\nvoid init_python(void)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 设置程序名称。 隐式地预初始化 Python。 */\nstatus = PyConfig_SetString(&config, &config.program_name,\nL\"/path/to/my_program\");\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config);\nreturn;\nexception:\nPyConfig_Clear(&config);\nPy_ExitStatusException(status);\n}\n更完整的示例会修改默认配置，读取配置，然后覆盖某些参数。 请注意自 3.11 版开始，许多参数在\n初始化之前不会被计算，因此无法从配置结构体中读取值。在调用初始化之前设置的任何值都将不\n会被初始化操作改变:\n\n|  | 如果 parse_argv 为非零值，则 argv 参数将以与常规 Python 解析 命令行参数 相同的方式被解\n析，并从 argv 中剥离 Python 参数。\nxoptions 选项将会被解析以设置其他选项：参见 -X 命令行选项。\n在 3.9 版本发生变更: show_alloc_count 字段已被移除。\n使用 PyConfig 初始化\n基于一个已填充内容的配置结构体初始化解释器是通过调用 Py_InitializeFromConfig() 来处理\n的。\n调用方要负责使用 PyStatus_Exception() 和 Py_ExitStatusException() 来处理异常（错误或退\n出）。\n如果使用了 PyImport_FrozenModules()、PyImport_AppendInittab() 或\nPyImport_ExtendInittab()，则必须在 Python 预初始化之后、Python 初始化之前设置或调用它\n们。 如果 Python 被多次初始化，则必须在每次初始化 Python 之前调用\nPyImport_AppendInittab() 或 PyImport_ExtendInittab()。\n当前的配置 (PyConfig 类型) 保存在 PyInterpreterState.config 中。\n设置程序名称的示例: |  |\n| --- | --- | --- |\n|  | void init_python(void)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 设置程序名称。 隐式地预初始化 Python。 */\nstatus = PyConfig_SetString(&config, &config.program_name,\nL\"/path/to/my_program\");\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nstatus = Py_InitializeFromConfig(&config);\nif (PyStatus_Exception(status)) {\ngoto exception;\n}\nPyConfig_Clear(&config);\nreturn;\nexception:\nPyConfig_Clear(&config);\nPy_ExitStatusException(status);\n} |  |\n|  | 更完整的示例会修改默认配置，读取配置，然后覆盖某些参数。 请注意自 3.11 版开始，许多参数在\n初始化之前不会被计算，因此无法从配置结构体中读取值。在调用初始化之前设置的任何值都将不\n会被初始化操作改变: |  |\n\nPyStatus init_python(const char *program_name)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 在读取配置之前设置程序名称\n(基于语言区域的编码格式来解码字节串)。\nImplicitly preinitialize Python. */\nstatus = PyConfig_SetBytesString(&config, &config.program_name,\nprogram_name);\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* 一次性读取所有配置 */\nstatus = PyConfig_Read(&config);\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* 显式地指定 sys.path */\n/* 如果你希望修改默认的路径集合，\n可先完成初始化再使用 PySys_GetObject(\"path\") */\nconfig.module_search_paths_set = 1;\nstatus = PyWideStringList_Append(&config.module_search_paths,\nL\"/path/to/stdlib\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\nstatus = PyWideStringList_Append(&config.module_search_paths,\nL\"/path/to/more/modules\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* Override executable computed by PyConfig_Read() */\nstatus = PyConfig_SetString(&config, &config.executable,\nL\"/path/to/my_executable\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\nstatus = Py_InitializeFromConfig(&config);\ndone:\nPyConfig_Clear(&config);\nreturn status;\n}\n隔离配置\nPyPreConfig_InitIsolatedConfig() 和 PyConfig_InitIsolatedConfig() 函数会创建一个配置\n来将 Python 与系统隔离开来。 例如，将 Python 嵌入到某个应用程序。\n\n|  | PyStatus init_python(const char *program_name)\n{\nPyStatus status;\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\n/* 在读取配置之前设置程序名称\n(基于语言区域的编码格式来解码字节串)。\nImplicitly preinitialize Python. */\nstatus = PyConfig_SetBytesString(&config, &config.program_name,\nprogram_name);\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* 一次性读取所有配置 */\nstatus = PyConfig_Read(&config);\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* 显式地指定 sys.path */\n/* 如果你希望修改默认的路径集合，\n可先完成初始化再使用 PySys_GetObject(\"path\") */\nconfig.module_search_paths_set = 1;\nstatus = PyWideStringList_Append(&config.module_search_paths,\nL\"/path/to/stdlib\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\nstatus = PyWideStringList_Append(&config.module_search_paths,\nL\"/path/to/more/modules\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\n/* Override executable computed by PyConfig_Read() */\nstatus = PyConfig_SetString(&config, &config.executable,\nL\"/path/to/my_executable\");\nif (PyStatus_Exception(status)) {\ngoto done;\n}\nstatus = Py_InitializeFromConfig(&config);\ndone:\nPyConfig_Clear(&config);\nreturn status;\n} |  |\n| --- | --- | --- |\n|  | 隔离配置\nPyPreConfig_InitIsolatedConfig() 和 PyConfig_InitIsolatedConfig() 函数会创建一个配置\n来将 Python 与系统隔离开来。 例如，将 Python 嵌入到某个应用程序。 |  |\n\n该配置将忽略全局配置变量、环境变量、命令行参数 (PyConfig.argv 将不会被解析) 和用户站点目\n录。 C 标准流 (例如 stdout) 和 LC_CTYPE 语言区域将保持不变。 信号处理器将不会被安装。\n该配置仍然会使用配置文件来确定未被指明的路径。 请确保指定了 PyConfig.home 以避免计算默\n认的路径配置。\nPython 配置\nPyPreConfig_InitPythonConfig() 和 PyConfig_InitPythonConfig() 函数会创建一个配置来构\n建一个行为与常规 Python 相同的自定义 Python。\n环境变量和命令行参数将被用于配置 Python，而全局配置变量将被忽略。\n此函数将根据 LC_CTYPE 语言区域、PYTHONUTF8 和 PYTHONCOERCECLOCALE 环境变量启用 C 语言区\n域强制转换 (PEP 538) 和 Python UTF-8 模式 (PEP 540)。\nPython 路径配置\nPyConfig 包含多个用于路径配置的字段：\n路径配置输入：\nPyConfig.home\nPyConfig.platlibdir\nPyConfig.pathconfig_warnings\nPyConfig.program_name\nPyConfig.pythonpath_env\n当前工作目录：用于获取绝对路径\nPATH 环境变量用于获取程序的完整路径 (来自 PyConfig.program_name)\n__PYVENV_LAUNCHER__ 环境变量\n（仅限 Windows only） 注册表 HKEY_CURRENT_USER 和 HKEY_LOCAL_MACHINE 的\n\"SoftwarePythonPythonCoreX.YPythonPath\" 项下的应用程序目录（其中 X.Y 为 Python 版\n本）。\n路径配置输出字段：\nPyConfig.base_exec_prefix\nPyConfig.base_executable\nPyConfig.base_prefix\nPyConfig.exec_prefix\nPyConfig.executable\nPyConfig.module_search_paths_set, PyConfig.module_search_paths\nPyConfig.prefix\n如果至少有一个“输出字段”未被设置，Python 就会计算路径配置来填充未设置的字段。 如果\nmodule_search_paths_set 等于 0，则 module_search_paths 将被覆盖并且\nmodule_search_paths_set 将被设置为 1。\n\n|  | 该配置将忽略全局配置变量、环境变量、命令行参数 (PyConfig.argv 将不会被解析) 和用户站点目\n录。 C 标准流 (例如 stdout) 和 LC_CTYPE 语言区域将保持不变。 信号处理器将不会被安装。\n该配置仍然会使用配置文件来确定未被指明的路径。 请确保指定了 PyConfig.home 以避免计算默\n认的路径配置。\nPython 配置\nPyPreConfig_InitPythonConfig() 和 PyConfig_InitPythonConfig() 函数会创建一个配置来构\n建一个行为与常规 Python 相同的自定义 Python。\n环境变量和命令行参数将被用于配置 Python，而全局配置变量将被忽略。\n此函数将根据 LC_CTYPE 语言区域、PYTHONUTF8 和 PYTHONCOERCECLOCALE 环境变量启用 C 语言区\n域强制转换 (PEP 538) 和 Python UTF-8 模式 (PEP 540)。\nPython 路径配置\nPyConfig 包含多个用于路径配置的字段：\n路径配置输入：\nPyConfig.home\nPyConfig.platlibdir\nPyConfig.pathconfig_warnings\nPyConfig.program_name\nPyConfig.pythonpath_env\n当前工作目录：用于获取绝对路径\nPATH 环境变量用于获取程序的完整路径 (来自 PyConfig.program_name)\n__PYVENV_LAUNCHER__ 环境变量\n（仅限 Windows only） 注册表 HKEY_CURRENT_USER 和 HKEY_LOCAL_MACHINE 的\n\"SoftwarePythonPythonCoreX.YPythonPath\" 项下的应用程序目录（其中 X.Y 为 Python 版\n本）。\n路径配置输出字段：\nPyConfig.base_exec_prefix\nPyConfig.base_executable\nPyConfig.base_prefix\nPyConfig.exec_prefix\nPyConfig.executable\nPyConfig.module_search_paths_set, PyConfig.module_search_paths\nPyConfig.prefix\n如果至少有一个“输出字段”未被设置，Python 就会计算路径配置来填充未设置的字段。 如果\nmodule_search_paths_set 等于 0，则 module_search_paths 将被覆盖并且\nmodule_search_paths_set 将被设置为 1。 |  |\n| --- | --- | --- |\n\n通过显式地设置上述所有路径配置输出字段可以完全忽略计算默认路径配置的函数。 即使字符串不\n为空也会被视为已设置。 如果 module_search_paths_set 被设为 1 则 module_search_paths 会\n被视为已设置。 在这种情况下，module_search_paths 将不加修改地被使用。\n将 pathconfig_warnings 设为 0 以便在计算路径配置时抑制警告（仅限 Unix，Windows 不会记录\n任何警告）。\n如果 base_prefix 或 base_exec_prefix 字段未设置，它们将分别从 prefix 和 exec_prefix 继\n承其值。\nPy_RunMain() 和 Py_Main() 将修改 sys.path:\n如果 run_filename 已设置并且是一个包含 __main__.py 脚本的目录，则会将 run_filename 添\n加到 sys.path 的开头。\n如果 isolated 为零：\n如果设置了 run_module，则将当前目录添加到 sys.path 的开头。 如果无法读取当前目录则\n不执行任何操作。\n如果设置了 run_filename，则将文件名的目录添加到 sys.path 的开头。\n在其他情况下，则将一个空字符串添加到 sys.path 的开头。\n如果 site_import 为非零值，则 sys.path 可通过 site 模块修改。 如果 user_site_directory\n为非零值且用户的 site-package 目录存在，则 site 模块会将用户的 site-package 目录附加到\nsys.path。\n路径配置会使用以下配置文件：\npyvenv.cfg\n._pth 文件 (例如: python._pth)\npybuilddir.txt (仅Unix)\n如果存在 ._pth 文件:\n将 isolated 设为 1。\n将 use_environment 设为 0。\n将 site_import 设为 0。\n将 safe_path 设为 1。\n如果未设置 home 并且 executable 的目录或其父目录下存在 pyvenv.cfg 文件，则 prefix 和\nexec_prefix 将被设为该目录，base_prefix 和 base_exec_prefix 仍会保持其原值，即指向基础\n安装目录。 请参阅 虚拟环境 了解详情。\n使用 __PYVENV_LAUNCHER__ 环境变量来设置 PyConfig.base_executable。\n在 3.14 版本发生变更: 现在 prefix 和 exec_prefix 会被设为 pyvenv.cfg 目录。 在之前版\n本中这是由 site 完成的，因而会受 -S 影响。\nPy_GetArgcArgv()\n\n|  | 通过显式地设置上述所有路径配置输出字段可以完全忽略计算默认路径配置的函数。 即使字符串不\n为空也会被视为已设置。 如果 module_search_paths_set 被设为 1 则 module_search_paths 会\n被视为已设置。 在这种情况下，module_search_paths 将不加修改地被使用。\n将 pathconfig_warnings 设为 0 以便在计算路径配置时抑制警告（仅限 Unix，Windows 不会记录\n任何警告）。\n如果 base_prefix 或 base_exec_prefix 字段未设置，它们将分别从 prefix 和 exec_prefix 继\n承其值。\nPy_RunMain() 和 Py_Main() 将修改 sys.path:\n如果 run_filename 已设置并且是一个包含 __main__.py 脚本的目录，则会将 run_filename 添\n加到 sys.path 的开头。\n如果 isolated 为零：\n如果设置了 run_module，则将当前目录添加到 sys.path 的开头。 如果无法读取当前目录则\n不执行任何操作。\n如果设置了 run_filename，则将文件名的目录添加到 sys.path 的开头。\n在其他情况下，则将一个空字符串添加到 sys.path 的开头。\n如果 site_import 为非零值，则 sys.path 可通过 site 模块修改。 如果 user_site_directory\n为非零值且用户的 site-package 目录存在，则 site 模块会将用户的 site-package 目录附加到\nsys.path。\n路径配置会使用以下配置文件：\npyvenv.cfg\n._pth 文件 (例如: python._pth)\npybuilddir.txt (仅Unix)\n如果存在 ._pth 文件:\n将 isolated 设为 1。\n将 use_environment 设为 0。\n将 site_import 设为 0。\n将 safe_path 设为 1。\n如果未设置 home 并且 executable 的目录或其父目录下存在 pyvenv.cfg 文件，则 prefix 和\nexec_prefix 将被设为该目录，base_prefix 和 base_exec_prefix 仍会保持其原值，即指向基础\n安装目录。 请参阅 虚拟环境 了解详情。\n使用 __PYVENV_LAUNCHER__ 环境变量来设置 PyConfig.base_executable。\n在 3.14 版本发生变更: 现在 prefix 和 exec_prefix 会被设为 pyvenv.cfg 目录。 在之前版\n本中这是由 site 完成的，因而会受 -S 影响。\nPy_GetArgcArgv() |  |\n| --- | --- | --- |\n\nvoid Py_GetArgcArgv(int *argc, wchar_t ***argv)\n在 Python 修改原始命令行参数之前，获取这些参数。\n另请参阅 PyConfig.orig_argv 成员。\n延迟主模块的执行\n在某些嵌入式用例中，可能会需要将解释器初始化和主模块的执行分隔开来。\n这种分隔可通过在初始化期间将 PyConfig.run_command 设为空字符串来达成（以避免解释器进入\n交互提示符），然后再使用 __main__.__dict__ 作为全局命名空间来执行所需的主模块代码。", "metadata": {"title": "00_Python_初始化配置", "source": "md_docs\\python_c-api_md\\00_Python_初始化配置.md", "doc_type": "C API", "language": "中文", "doc_id": "4cce2aee"}}
{"doc_id": "50910d00", "content": "具体的对象层\n本章中的函数特定于某些 Python 对象类型。 将错误类型的对象传递给它们并不是一个好主意；如\n果您从 Python 程序接收到一个对象，但不确定它是否具有正确的类型，则必须首先执行类型检查；\n例如，要检查对象是否为字典，请使用 PyDict_Check()。 本章的结构类似于 Python 对象类型的\n“家族树”。\n警告: 虽然本章所描述的函数会仔细检查传入对象的类型，但是其中许多函数不会检查传入的对\n象是否为 NULL。 允许传入 NULL 可能导致内存访问冲突和解释器的立即终止。\n基本对象\n本节描述Python类型对象和单一实例对象 象None。\n类型对象\n创建堆分配类型\nNone 对象\n数值对象\n整数型对象\n导出API\nPyLongWriter API\n布尔对象\n浮点数对象\n打包与解包函数\n打包函数\n解包函数\n复数对象\n表示复数的C结构体\n表示复数的Python对象\n序列对象\n序列对象的一般操作在前一章中讨论过;本节介绍Python语言固有的特定类型的序列对象。\nbytes 对象\n字节数组对象\n类型检查宏\n直接 API 函数\n宏\n\n| 具体的对象层\n本章中的函数特定于某些 Python 对象类型。 将错误类型的对象传递给它们并不是一个好主意；如\n果您从 Python 程序接收到一个对象，但不确定它是否具有正确的类型，则必须首先执行类型检查；\n例如，要检查对象是否为字典，请使用 PyDict_Check()。 本章的结构类似于 Python 对象类型的\n“家族树”。 |\n| --- |\n| 警告: 虽然本章所描述的函数会仔细检查传入对象的类型，但是其中许多函数不会检查传入的对\n象是否为 NULL。 允许传入 NULL 可能导致内存访问冲突和解释器的立即终止。 |\n| 基本对象\n本节描述Python类型对象和单一实例对象 象None。\n类型对象\n创建堆分配类型\nNone 对象\n数值对象\n整数型对象\n导出API\nPyLongWriter API\n布尔对象\n浮点数对象\n打包与解包函数\n打包函数\n解包函数\n复数对象\n表示复数的C结构体\n表示复数的Python对象\n序列对象\n序列对象的一般操作在前一章中讨论过;本节介绍Python语言固有的特定类型的序列对象。\nbytes 对象\n字节数组对象\n类型检查宏\n直接 API 函数\n宏 |\n\nUnicode对象和编解码器\nUnicode对象\nUnicode类型\nUnicode字符属性\n创建和访问 Unicode 字符串\n语言区域编码格式\n文件系统编码格式\nwchar_t 支持\n内置编解码器\n泛型编解码器\nUTF-8 编解码器\nUTF-32 编解码器\nUTF-16 编解码器\nUTF-7 编解码器\nUnicode-Escape 编解码器\nRaw-Unicode-Escape 编解码器\nLatin-1 编解码器\nASCII 编解码器\n字符映射编解码器\nWindows 中的 MBCS 编解码器\n方法与槽位函数\nPyUnicodeWriter\n已弃用的 API\n元组对象\n结构序列对象\n列表对象\n容器对象\n字典对象\n集合对象\nFunction 对象\nFunction 对象\n实例方法对象\n方法对象\nCell 对象\n代码对象\n代码对象标志\n附加信息\n其他对象\n\n|  | Unicode对象和编解码器\nUnicode对象\nUnicode类型\nUnicode字符属性\n创建和访问 Unicode 字符串\n语言区域编码格式\n文件系统编码格式\nwchar_t 支持\n内置编解码器\n泛型编解码器\nUTF-8 编解码器\nUTF-32 编解码器\nUTF-16 编解码器\nUTF-7 编解码器\nUnicode-Escape 编解码器\nRaw-Unicode-Escape 编解码器\nLatin-1 编解码器\nASCII 编解码器\n字符映射编解码器\nWindows 中的 MBCS 编解码器\n方法与槽位函数\nPyUnicodeWriter\n已弃用的 API\n元组对象\n结构序列对象\n列表对象\n容器对象\n字典对象\n集合对象\nFunction 对象\nFunction 对象\n实例方法对象\n方法对象\nCell 对象\n代码对象\n代码对象标志\n附加信息\n其他对象 |  |\n| --- | --- | --- |\n\n文件对象\n模块对象\n模块定义\n模块槽位\n动态创建扩展模块\n支持函数\n模块查找（单阶段初始化）\n迭代器对象\n描述符对象\n切片对象\nEllipsis 对象\nMemoryView 对象\n弱引用对象\nCapsule 对象\n帧对象\n帧 locals 代理\n内部帧\n生成器对象\n协程对象\n上下文变量对象\nDateTime 对象\n类型注解对象", "metadata": {"title": "00_具体的对象层", "source": "md_docs\\python_c-api_md\\00_具体的对象层.md", "doc_type": "C API", "language": "中文", "doc_id": "50910d00"}}
{"doc_id": "8517ed68", "content": "内存管理\n概述\n在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有\n堆的管理由内部的 Python 内存管理器（Python memory manager） 保证。Python 内存管理器有不\n同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。\n在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来\n存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运\n行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同\n于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管\n理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。\nPython 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块\n的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存\n管理器按需通过本文档中列出的 Python/C API 函数进行的。\n为了避免内存破坏，扩展的作者永远不应该试图用 C 库函数导出的函数来对 Python 对象进行操作，\n这些函数包括： malloc(), calloc(), realloc() 和 free()。这将导致 C 分配器和 Python 内存管\n理器之间的混用，引发严重后果，这是由于它们实现了不同的算法，并在不同的堆上操作。但是，\n我们可以安全地使用 C 库分配器为单独的目的分配和释放内存块，如下例所示：\nPyObject *res;\nchar *buf = (char *) malloc(BUFSIZ); /* for I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n...执行一些涉及 buf 的 I/O 操作...\nres = PyBytes_FromString(buf);\nfree(buf); /* 已分配的 */\nreturn res;\n在这个例子中，I/O 缓冲区的内存请求是由 C 库分配器处理的。Python 内存管理器只参与了分配作\n为结果返回的字节对象。\n然而，在大多数情况下，都建议专门基于 Python 堆来分配内存，因为后者是由 Python 内存管理器\n控制的。 例如，当解释器使用 C 编写的新对象类型进行扩展时就必须这样做。 使用 Python 堆的另\n一个理由是需要能 通知 Python 内存管理器有关扩展模块的内存需求。 即使所请求的内存全部只用\n于内部的、高度特定的目的，将所有的内存请求交给 Python 内存管理器能让解释器对其内存占用的\n整体情况有更准确的了解。 因此，在特定情况下，Python 内存管理器可能会触发或不触发适当的操\n作，如垃圾回收、内存压缩或其他的预防性操作。 请注意通过使用前面例子所演示的 C 库分配器，\n为 I/O 缓冲区分配的内存将完全不受 Python 内存管理器的控制。\n参见: 环境变量 PYTHONMALLOC 可被用来配置 Python 所使用的内存分配器。\n\n| 内存管理\n概述\n在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有\n堆的管理由内部的 Python 内存管理器（Python memory manager） 保证。Python 内存管理器有不\n同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。\n在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来\n存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运\n行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同\n于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管\n理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。\nPython 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块\n的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存\n管理器按需通过本文档中列出的 Python/C API 函数进行的。\n为了避免内存破坏，扩展的作者永远不应该试图用 C 库函数导出的函数来对 Python 对象进行操作，\n这些函数包括： malloc(), calloc(), realloc() 和 free()。这将导致 C 分配器和 Python 内存管\n理器之间的混用，引发严重后果，这是由于它们实现了不同的算法，并在不同的堆上操作。但是，\n我们可以安全地使用 C 库分配器为单独的目的分配和释放内存块，如下例所示： |\n| --- |\n| PyObject *res;\nchar *buf = (char *) malloc(BUFSIZ); /* for I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n...执行一些涉及 buf 的 I/O 操作...\nres = PyBytes_FromString(buf);\nfree(buf); /* 已分配的 */\nreturn res; |\n| 在这个例子中，I/O 缓冲区的内存请求是由 C 库分配器处理的。Python 内存管理器只参与了分配作\n为结果返回的字节对象。\n然而，在大多数情况下，都建议专门基于 Python 堆来分配内存，因为后者是由 Python 内存管理器\n控制的。 例如，当解释器使用 C 编写的新对象类型进行扩展时就必须这样做。 使用 Python 堆的另\n一个理由是需要能 通知 Python 内存管理器有关扩展模块的内存需求。 即使所请求的内存全部只用\n于内部的、高度特定的目的，将所有的内存请求交给 Python 内存管理器能让解释器对其内存占用的\n整体情况有更准确的了解。 因此，在特定情况下，Python 内存管理器可能会触发或不触发适当的操\n作，如垃圾回收、内存压缩或其他的预防性操作。 请注意通过使用前面例子所演示的 C 库分配器，\n为 I/O 缓冲区分配的内存将完全不受 Python 内存管理器的控制。 |\n| 参见: 环境变量 PYTHONMALLOC 可被用来配置 Python 所使用的内存分配器。 |\n\n环境变量 PYTHONMALLOCSTATS 可以用来在每次创建和关闭新的 pymalloc 对象区域时打印\npymalloc 内存分配器 的统计数据。\n分配器域\n所有分配函数都归属于三个不同的“域”之一 (另请参阅 PyMemAllocatorDomain)。 这些域代表不同\n的分配策略并针对不同的目的进行了优化。 每个域如何分配内存及每个域会调用哪些内部函数的详\n情被认为是实现细节，但是出于调试目的可以在 这里 找到一张简化的表格。 用于分配和释放内存块\n的 API 必须来自同一个域。 例如，PyMem_Free() 必须被用来释放使用 PyMem_Malloc() 分配的内\n存。\n三个分配域分别是：\n原始域：用于为通用内存缓冲区分配内存，其分配 必须 转到系统分配器或者可在没有 attached\nthread state 的情况下使用的分配器。 内存将直接自系统请求。 参见 原始内存接口。\n“内存”域：用于为 Python 缓冲区和通用内存缓冲区分配内存，其分配必须在具有 attached thread\nstate 的情况下进行。 内存将从 Python 私有堆获取。 参见 内存接口。\n对象域：用于为 Python 对象分配内存。 内存将从 Python 私有堆获取。 参见 对象分配器。\n备注: 自由线程 构建版要求仅 Python 对象使用“对象”域来分配并且所有 Python 对象都使用该域\n来分配。 这不同于之前的 Python 版本，在之前版本中这只是最佳实践而非硬件要求。\n例如，缓冲区（非 Python 对象）的分配应当使用 PyMem_Malloc(), PyMem_RawMalloc() 或\nmalloc()，而不能用 PyObject_Malloc()。\n参见 内存分配 API。\n原始内存接口\n以下函数集是系统分配器的包装器。 这些函数是线程安全的，因此不需要 附加 thread state。\n默认原始内存分配器 使用以下函数: malloc(), calloc(), realloc() 和 free()；当请求零个字节\n时则调用 malloc(1) (或 calloc(1, 1))。\nAdded in version 3.4.\nvoid *PyMem_RawMalloc(size_t n)\n属于 稳定 ABI 自 3.13 版起.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_RawMalloc(1) 一样。但是\n内存不会以任何方式被初始化。\nvoid *PyMem_RawCalloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.13 版起.\n\n|  | 环境变量 PYTHONMALLOCSTATS 可以用来在每次创建和关闭新的 pymalloc 对象区域时打印\npymalloc 内存分配器 的统计数据。 |  |\n| --- | --- | --- |\n|  | 分配器域\n所有分配函数都归属于三个不同的“域”之一 (另请参阅 PyMemAllocatorDomain)。 这些域代表不同\n的分配策略并针对不同的目的进行了优化。 每个域如何分配内存及每个域会调用哪些内部函数的详\n情被认为是实现细节，但是出于调试目的可以在 这里 找到一张简化的表格。 用于分配和释放内存块\n的 API 必须来自同一个域。 例如，PyMem_Free() 必须被用来释放使用 PyMem_Malloc() 分配的内\n存。\n三个分配域分别是：\n原始域：用于为通用内存缓冲区分配内存，其分配 必须 转到系统分配器或者可在没有 attached\nthread state 的情况下使用的分配器。 内存将直接自系统请求。 参见 原始内存接口。\n“内存”域：用于为 Python 缓冲区和通用内存缓冲区分配内存，其分配必须在具有 attached thread\nstate 的情况下进行。 内存将从 Python 私有堆获取。 参见 内存接口。\n对象域：用于为 Python 对象分配内存。 内存将从 Python 私有堆获取。 参见 对象分配器。 |  |\n|  | 备注: 自由线程 构建版要求仅 Python 对象使用“对象”域来分配并且所有 Python 对象都使用该域\n来分配。 这不同于之前的 Python 版本，在之前版本中这只是最佳实践而非硬件要求。\n例如，缓冲区（非 Python 对象）的分配应当使用 PyMem_Malloc(), PyMem_RawMalloc() 或\nmalloc()，而不能用 PyObject_Malloc()。\n参见 内存分配 API。 |  |\n|  | 原始内存接口\n以下函数集是系统分配器的包装器。 这些函数是线程安全的，因此不需要 附加 thread state。\n默认原始内存分配器 使用以下函数: malloc(), calloc(), realloc() 和 free()；当请求零个字节\n时则调用 malloc(1) (或 calloc(1, 1))。\nAdded in version 3.4.\nvoid *PyMem_RawMalloc(size_t n)\n属于 稳定 ABI 自 3.13 版起.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_RawMalloc(1) 一样。但是\n内存不会以任何方式被初始化。\nvoid *PyMem_RawCalloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.13 版起. |  |\n\n分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_RawCalloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyMem_RawRealloc(void *p, size_t n)\n属于 稳定 ABI 自 3.13 版起.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变，\n如果 p 是 NULL ，则相当于调用 PyMem_RawMalloc(n) ；如果 n 等于 0，则内存块大小会被调\n整，但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyMem_RawMalloc() 、 PyMem_RawRealloc() 或\nPyMem_RawCalloc() 所返回的。\n如果请求失败，PyMem_RawRealloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyMem_RawFree(void *p)\n属于 稳定 ABI 自 3.13 版起.\n释放 p 指向的内存块。 p 必须是之前调用 PyMem_RawMalloc() 、 PyMem_RawRealloc() 或\nPyMem_RawCalloc() 所返回的指针。否则，或在 PyMem_RawFree(p) 之前已经调用过的情况\n下，未定义的行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n内存接口\n以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内\n存。\n默认内存分配器 使用了 pymalloc 内存分配器.\n警告: 在使用这些函数时必须有一个 attached thread state。\n在 3.6 版本发生变更: 现在默认的分配器是 pymalloc 而非系统的 malloc() 。\nvoid *PyMem_Malloc(size_t n)\n属于 稳定 ABI.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_Malloc(1) 一样。但是内存\n不会以任何方式被初始化。\n\n|  | 分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_RawCalloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyMem_RawRealloc(void *p, size_t n)\n属于 稳定 ABI 自 3.13 版起.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变，\n如果 p 是 NULL ，则相当于调用 PyMem_RawMalloc(n) ；如果 n 等于 0，则内存块大小会被调\n整，但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyMem_RawMalloc() 、 PyMem_RawRealloc() 或\nPyMem_RawCalloc() 所返回的。\n如果请求失败，PyMem_RawRealloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyMem_RawFree(void *p)\n属于 稳定 ABI 自 3.13 版起.\n释放 p 指向的内存块。 p 必须是之前调用 PyMem_RawMalloc() 、 PyMem_RawRealloc() 或\nPyMem_RawCalloc() 所返回的指针。否则，或在 PyMem_RawFree(p) 之前已经调用过的情况\n下，未定义的行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n内存接口\n以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内\n存。\n默认内存分配器 使用了 pymalloc 内存分配器. |  |\n| --- | --- | --- |\n|  | 警告: 在使用这些函数时必须有一个 attached thread state。 |  |\n|  | 在 3.6 版本发生变更: 现在默认的分配器是 pymalloc 而非系统的 malloc() 。\nvoid *PyMem_Malloc(size_t n)\n属于 稳定 ABI.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_Malloc(1) 一样。但是内存\n不会以任何方式被初始化。 |  |\n\nvoid *PyMem_Calloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.7 版起.\n分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_Calloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyMem_Realloc(void *p, size_t n)\n属于 稳定 ABI.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变，\n如果 p 是 NULL ，则相当于调用 PyMem_Malloc(n) ；如果 n 等于 0，则内存块大小会被调整，\n但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyMem_Malloc() 、 PyMem_Realloc() 或\nPyMem_Calloc() 所返回的。\n如果请求失败，PyMem_Realloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyMem_Free(void *p)\n属于 稳定 ABI.\n释放 p 指向的内存块。 p 必须是之前调用 PyMem_Malloc() 、 PyMem_Realloc() 或\nPyMem_Calloc() 所返回的指针。否则，或在 PyMem_Free(p) 之前已经调用过的情况下，未定\n义的行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n以下面向类型的宏为方便而提供。 注意 TYPE 可以指任何 C 类型。\nPyMem_New(TYPE, n)\n与 PyMem_Malloc() 相同，但会分配 (n * sizeof(TYPE)) 字节的内存。 返回一个转换为\nTYPE* 的指针。 内存不会以任何方式被初始化。\nPyMem_Resize(p, TYPE, n)\n与 PyMem_Realloc() 类似，但内存块的大小被调整为 (n * sizeof(TYPE)) 个字节。 返回一\n个转换为 TYPE* 的指针。 在返回时，p 将是一个指向新内存区域的指针，或者如果执行失败则\n为 NULL。\n这是一个 C 预处理宏， p 总是被重新赋值。请保存 p 的原始值，以避免在处理错误时丢失内\n存。\nvoid PyMem_Del(void *p)\n与 PyMem_Free() 相同\n\n|  | void *PyMem_Calloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.7 版起.\n分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyMem_Calloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyMem_Realloc(void *p, size_t n)\n属于 稳定 ABI.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变，\n如果 p 是 NULL ，则相当于调用 PyMem_Malloc(n) ；如果 n 等于 0，则内存块大小会被调整，\n但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyMem_Malloc() 、 PyMem_Realloc() 或\nPyMem_Calloc() 所返回的。\n如果请求失败，PyMem_Realloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyMem_Free(void *p)\n属于 稳定 ABI.\n释放 p 指向的内存块。 p 必须是之前调用 PyMem_Malloc() 、 PyMem_Realloc() 或\nPyMem_Calloc() 所返回的指针。否则，或在 PyMem_Free(p) 之前已经调用过的情况下，未定\n义的行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n以下面向类型的宏为方便而提供。 注意 TYPE 可以指任何 C 类型。\nPyMem_New(TYPE, n)\n与 PyMem_Malloc() 相同，但会分配 (n * sizeof(TYPE)) 字节的内存。 返回一个转换为\nTYPE* 的指针。 内存不会以任何方式被初始化。\nPyMem_Resize(p, TYPE, n)\n与 PyMem_Realloc() 类似，但内存块的大小被调整为 (n * sizeof(TYPE)) 个字节。 返回一\n个转换为 TYPE* 的指针。 在返回时，p 将是一个指向新内存区域的指针，或者如果执行失败则\n为 NULL。\n这是一个 C 预处理宏， p 总是被重新赋值。请保存 p 的原始值，以避免在处理错误时丢失内\n存。\nvoid PyMem_Del(void *p)\n与 PyMem_Free() 相同 |  |\n| --- | --- | --- |\n\n此外，我们还提供了以下宏集用于直接调用 Python 内存分配器，而不涉及上面列出的 C API 函数。\n但是请注意，使用它们并不能保证跨 Python 版本的二进制兼容性，因此在扩展模块被弃用。\nPyMem_MALLOC(size)\nPyMem_NEW(type, size)\nPyMem_REALLOC(ptr, size)\nPyMem_RESIZE(ptr, type, size)\nPyMem_FREE(ptr)\nPyMem_DEL(ptr)\n对象分配器\n以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内\n存。\n备注: 当通过 自定义内存分配器 部分描述的方法拦截该域中的分配函数时，无法保证这些分配\n器返回的内存可以被成功地转换成 Python 对象。\n默认对象分配器 使用 pymalloc 内存分配器.\n警告: 在使用这些函数时必须有一个 attached thread state。\nvoid *PyObject_Malloc(size_t n)\n属于 稳定 ABI.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyObject_Malloc(1) 一样。但是\n内存不会以任何方式被初始化。\nvoid *PyObject_Calloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.7 版起.\n分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyObject_Calloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyObject_Realloc(void *p, size_t n)\n属于 稳定 ABI.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变，\n\n|  | 此外，我们还提供了以下宏集用于直接调用 Python 内存分配器，而不涉及上面列出的 C API 函数。\n但是请注意，使用它们并不能保证跨 Python 版本的二进制兼容性，因此在扩展模块被弃用。\nPyMem_MALLOC(size)\nPyMem_NEW(type, size)\nPyMem_REALLOC(ptr, size)\nPyMem_RESIZE(ptr, type, size)\nPyMem_FREE(ptr)\nPyMem_DEL(ptr)\n对象分配器\n以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内\n存。 |  |\n| --- | --- | --- |\n|  | 备注: 当通过 自定义内存分配器 部分描述的方法拦截该域中的分配函数时，无法保证这些分配\n器返回的内存可以被成功地转换成 Python 对象。 |  |\n|  | 默认对象分配器 使用 pymalloc 内存分配器. |  |\n|  | 警告: 在使用这些函数时必须有一个 attached thread state。 |  |\n|  | void *PyObject_Malloc(size_t n)\n属于 稳定 ABI.\n分配 n 个字节并返回一个指向所分配内存的 void* 类型指针，如果请求失败则返回 NULL。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyObject_Malloc(1) 一样。但是\n内存不会以任何方式被初始化。\nvoid *PyObject_Calloc(size_t nelem, size_t elsize)\n属于 稳定 ABI 自 3.7 版起.\n分配 nelem 个元素，每个元素的大小为 elsize 个字节，并返回指向所分配的内存的 void* 类型\n指针，如果请求失败则返回 NULL。 内存会被初始化为零。\n请求零字节可能返回一个独特的非 NULL 指针，就像调用了 PyObject_Calloc(1, 1) 一样。\nAdded in version 3.5.\nvoid *PyObject_Realloc(void *p, size_t n)\n属于 稳定 ABI.\n将 p 指向的内存块大小调整为 n 字节。以新旧内存块大小中的最小值为准，其中内容保持不\n变， |  |\n\n如果*p*是 NULL，则相当于调用 PyObject_Malloc(n) ；如果 n 等于 0，则内存块大小会被调\n整，但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyObject_Malloc() 、 PyObject_Realloc() 或\nPyObject_Calloc() 所返回的。\n如果请求失败，PyObject_Realloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyObject_Free(void *p)\n属于 稳定 ABI.\n释放 p 指向的内存块。 p 必须是之前调用 PyObject_Malloc() 、 PyObject_Realloc() 或\nPyObject_Calloc() 所返回的指针。否则，或在 PyObject_Free(p) 之前已经调用过的情况\n下，未定义行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n请不要直接调用此函数来释放对象的内存；而应调用类型的 tp_free 槽位。\n请不要为 PyObject_GC_New 或 PyObject_GC_NewVar 所分配的内存使用此宏；而应改用\nPyObject_GC_Del()。\n参见:\nPyObject_GC_Del() 是该函数针对由支持垃圾回收的类型分配的内存的等价物。\nPyObject_Malloc()\nPyObject_Realloc()\nPyObject_Calloc()\nPyObject_New\nPyObject_NewVar\nPyType_GenericAlloc()\ntp_free\n默认内存分配器\n默认内存分配器：\n配置 名称 PyMem_RawMalloc PyMem_Malloc PyObject_Malloc\n发布版本 \"pymalloc\" malloc pymalloc pymalloc\npymalloc + pymalloc +\n调试构建 \"pymalloc_debug\" malloc + debug\ndebug debug\n没有 \"malloc\" malloc malloc malloc\npymalloc 的\n\n|  | 如果*p*是 NULL，则相当于调用 PyObject_Malloc(n) ；如果 n 等于 0，则内存块大小会被调\n整，但不会被释放，返回非 NULL 指针。\n除非 p 是 NULL ，否则它必须是之前调用 PyObject_Malloc() 、 PyObject_Realloc() 或\nPyObject_Calloc() 所返回的。\n如果请求失败，PyObject_Realloc() 返回 NULL ， p 仍然是指向先前内存区域的有效指针。\nvoid PyObject_Free(void *p)\n属于 稳定 ABI.\n释放 p 指向的内存块。 p 必须是之前调用 PyObject_Malloc() 、 PyObject_Realloc() 或\nPyObject_Calloc() 所返回的指针。否则，或在 PyObject_Free(p) 之前已经调用过的情况\n下，未定义行为会发生。\n如果 p 是 NULL, 那么什么操作也不会进行。\n请不要直接调用此函数来释放对象的内存；而应调用类型的 tp_free 槽位。\n请不要为 PyObject_GC_New 或 PyObject_GC_NewVar 所分配的内存使用此宏；而应改用\nPyObject_GC_Del()。\n参见:\nPyObject_GC_Del() 是该函数针对由支持垃圾回收的类型分配的内存的等价物。\nPyObject_Malloc()\nPyObject_Realloc()\nPyObject_Calloc()\nPyObject_New\nPyObject_NewVar\nPyType_GenericAlloc()\ntp_free\n默认内存分配器\n默认内存分配器： |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 配置 | 名称 | PyMem_RawMalloc | PyMem_Malloc | PyObject_Malloc |  |\n|  | 发布版本 | \"pymalloc\" | malloc | pymalloc | pymalloc |  |\n|  | 调试构建 | \"pymalloc_debug\" | malloc + debug | pymalloc +\ndebug | pymalloc +\ndebug |  |\n|  | 没有\npymalloc 的 | \"malloc\" | malloc | malloc | malloc |  |\n\n配置 名称 PyMem_RawMalloc PyMem_Malloc PyObject_Malloc\n发布版本\n没有\nmalloc +\npymalloc 的 \"malloc_debug\" malloc + debug malloc + debug\ndebug\n调试构建\n说明：\n名称: PYTHONMALLOC 环境变量的值。\nmalloc：来自 C 标准库的系统分配器，C 函数：malloc()、calloc()、realloc() 和\nfree()。\npymalloc：pymalloc 内存分配器.\nmimalloc: mimalloc 内存分配器。 如果 mimalloc 不受支持则将使用 pymalloc 分配器。\n\"+ debug\": 附带 Python 内存分配器的调试钩子.\n“调试构建”：调试模式下的 Python 构建。\n自定义内存分配器\nAdded in version 3.4.\ntype PyMemAllocatorEx\n用于描述内存块分配器的结构体。 该结构体下列字段:\n域 含意\n作为第一个参数传入的用户上\nvoid *ctx\n下文\nvoid* malloc(void *ctx, size_t size) 分配一个内存块\nvoid* calloc(void *ctx, size_t nelem, size_t\n分配一个初始化为 0 的内存块\nelsize)\nvoid* realloc(void *ctx, void *ptr, size_t\n分配一个内存块或调整其大小\nnew_size)\nvoid free(void *ctx, void *ptr) 释放一个内存块\n在 3.5 版本发生变更: PyMemAllocator 结构被重命名为 PyMemAllocatorEx 并新增了一\n个 calloc 字段。\ntype PyMemAllocatorDomain\n用来识别分配器域的枚举类。域有：\nPYMEM_DOMAIN_RAW\n函数\n\n|  |  |  | 配置 |  | 名称 | PyMem_RawMalloc | PyMem_Malloc | PyObject_Malloc |  |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | 发布版本 |  |  |  |  |  |  |\n|  |  |  | 没有\npymalloc 的\n调试构建 |  | \"malloc_debug\" | malloc + debug | malloc +\ndebug | malloc + debug |  |\n|  |  |  | 说明：\n名称: PYTHONMALLOC 环境变量的值。\nmalloc：来自 C 标准库的系统分配器，C 函数：malloc()、calloc()、realloc() 和\nfree()。\npymalloc：pymalloc 内存分配器.\nmimalloc: mimalloc 内存分配器。 如果 mimalloc 不受支持则将使用 pymalloc 分配器。\n\"+ debug\": 附带 Python 内存分配器的调试钩子.\n“调试构建”：调试模式下的 Python 构建。\n自定义内存分配器\nAdded in version 3.4.\ntype PyMemAllocatorEx\n用于描述内存块分配器的结构体。 该结构体下列字段:\n域 含意\n作为第一个参数传入的用户上\nvoid *ctx\n下文\nvoid* malloc(void *ctx, size_t size) 分配一个内存块\nvoid* calloc(void *ctx, size_t nelem, size_t\n分配一个初始化为 0 的内存块\nelsize)\nvoid* realloc(void *ctx, void *ptr, size_t\n分配一个内存块或调整其大小\nnew_size)\nvoid free(void *ctx, void *ptr) 释放一个内存块\n在 3.5 版本发生变更: PyMemAllocator 结构被重命名为 PyMemAllocatorEx 并新增了一\n个 calloc 字段。\ntype PyMemAllocatorDomain\n用来识别分配器域的枚举类。域有：\nPYMEM_DOMAIN_RAW\n函数 |  |  |  |  |  |  |\n|  |  |  |  | elsize) |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |  |\n|  |  |  |  | new_size) |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |  |\n\n| 域 | 含意 |\n| --- | --- |\n| void *ctx | 作为第一个参数传入的用户上\n下文 |\n| void* malloc(void *ctx, size_t size) | 分配一个内存块 |\n| void* calloc(void *ctx, size_t nelem, size_t\nelsize) | 分配一个初始化为 0 的内存块 |\n| void* realloc(void *ctx, void *ptr, size_t\nnew_size) | 分配一个内存块或调整其大小 |\n| void free(void *ctx, void *ptr) | 释放一个内存块 |\n\n| void* calloc(void *ctx, size_t nelem, size_t |  |\n| --- | --- |\n\n| void* realloc(void *ctx, void *ptr, size_t |  |\n| --- | --- |\n\nPyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\nPYMEM_DOMAIN_MEM\n函数\nPyMem_Malloc(),\nPyMem_Realloc()\nPyMem_Calloc()\nPyMem_Free()\nPYMEM_DOMAIN_OBJ\n函数\nPyObject_Malloc()\nPyObject_Realloc()\nPyObject_Calloc()\nPyObject_Free()\nvoid PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx\n*allocator)\n获取指定域的内存块分配器。\nvoid PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx\n*allocator)\n设置指定域的内存块分配器。\n当请求零字节时，新的分配器必须返回一个独特的非 NULL 指针。\n对于 PYMEM_DOMAIN_RAW 域，分配器必须是线程安全的：当分配器被调用时 thread state 是没\n有 附加的。\n对于其余的域，分配器也必须是线程安全的：分配器可以在不共享 GIL 的不同解释器中被调\n用。\n如果新的分配器不是钩子（不调用之前的分配器），必须调用 PyMem_SetupDebugHooks() 函\n数在新分配器上重新安装调试钩子。\n另请参阅 PyPreConfig.allocator 和 Preinitialize Python with PyPreConfig。\n警告: PyMem_SetAllocator() 没有以下合约:\n可以在 Py_PreInitialize() 之后和 Py_InitializeFromConfig() 之前调用它来安装自\n定义的内存分配器。 对于所安装的分配器除了域的规定以外没有任何其他限制（例如 Raw\n\n|  | PyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\nPYMEM_DOMAIN_MEM\n函数\nPyMem_Malloc(),\nPyMem_Realloc()\nPyMem_Calloc()\nPyMem_Free()\nPYMEM_DOMAIN_OBJ\n函数\nPyObject_Malloc()\nPyObject_Realloc()\nPyObject_Calloc()\nPyObject_Free()\nvoid PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx\n*allocator)\n获取指定域的内存块分配器。\nvoid PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx\n*allocator)\n设置指定域的内存块分配器。\n当请求零字节时，新的分配器必须返回一个独特的非 NULL 指针。\n对于 PYMEM_DOMAIN_RAW 域，分配器必须是线程安全的：当分配器被调用时 thread state 是没\n有 附加的。\n对于其余的域，分配器也必须是线程安全的：分配器可以在不共享 GIL 的不同解释器中被调\n用。\n如果新的分配器不是钩子（不调用之前的分配器），必须调用 PyMem_SetupDebugHooks() 函\n数在新分配器上重新安装调试钩子。\n另请参阅 PyPreConfig.allocator 和 Preinitialize Python with PyPreConfig。\n警告: PyMem_SetAllocator() 没有以下合约:\n可以在 Py_PreInitialize() 之后和 Py_InitializeFromConfig() 之前调用它来安装自\n定义的内存分配器。 对于所安装的分配器除了域的规定以外没有任何其他限制（例如 Raw |  |  |\n| --- | --- | --- | --- |\n|  |  | 警告: PyMem_SetAllocator() 没有以下合约:\n可以在 Py_PreInitialize() 之后和 Py_InitializeFromConfig() 之前调用它来安装自\n定义的内存分配器。 对于所安装的分配器除了域的规定以外没有任何其他限制（例如 Raw |  |\n\nDomain 允许分配器在没有 attached thread state 的情况下被调用）。 请参阅 有关分配器\n域的章节 来了解详情。\n如果在 Python 已完成初始化之后（即 Py_InitializeFromConfig() 被调用之后）被调\n用则自定义分配器 must 必须包装现有的分配器。 将现有分配器替换为任意的其他分配器\n是 不受支持的。\n在 3.12 版本发生变更: 所有分配器都必须是线程安全的。\nvoid PyMem_SetupDebugHooks(void)\n设置 Python 内存分配器的调试钩子 以检测内存错误。\nPython 内存分配器的调试钩子\n当 Python 在调试模式下构建，PyMem_SetupDebugHooks() 函数在 Python 预初始化 时被调用，以\n在 Python 内存分配器上设置调试钩子以检测内存错误。\nPYTHONMALLOC 环境变量可被用于在以发行模式下编译的 Python 上安装调试钩子 (例如:\nPYTHONMALLOC=debug)。\nPyMem_SetupDebugHooks() 函数可被用于在调用了 PyMem_SetAllocator() 之后设置调试钩子。\n这些调试钩子用特殊的、可辨认的位模式填充动态分配的内存块。新分配的内存用字节 0xCD\n（PYMEM_CLEANBYTE ）填充，释放的内存用字节 0xDD （PYMEM_DEADBYTE ）填充。内存块被填充\n了字节 0xFD （PYMEM_FORBIDDENBYTE ）的“禁止字节”包围。这些字节串不太可能是合法的地址、\n浮点数或ASCII字符串\n运行时检查：\n检测对 API 的违反。例如：检测对 PyMem_Malloc() 分配的内存块调用 PyObject_Free()。\n检测缓冲区起始位置前的写入（缓冲区下溢）。\n检测缓冲区终止位置后的写入（缓冲区溢出）。\n检测当调用 PYMEM_DOMAIN_OBJ (如: PyObject_Malloc()) 和 PYMEM_DOMAIN_MEM (如:\nPyMem_Malloc()) 域的分配器函数时是否持有 attached thread state。\n在出错时，调试钩子使用 tracemalloc 模块来回溯内存块被分配的位置。只有当 tracemalloc 正\n在追踪 Python 内存分配，并且内存块被追踪时，才会显示回溯。\n让 S = sizeof(size_t)。 将 2*S 个字节添加到每个被请求的 N 字节数据块的两端。 内存的布局像\n是这样，其中 p 代表由类似 malloc 或类似 realloc 的函数所返回的地址 (p[i:j] 表示从 *(p+i) 左\n侧开始到 *(p+j) 左侧止的字节数据切片；请注意对负索引号的处理与 Python 切片是不同的）:\np[-2*S:-S]\n最初所要求的字节数。 这是一个 size_t，为大端序（易于在内存转储中读取）。\np[-S]\nAPI 标识符（ASCII 字符）:\n'r' 表示 PYMEM_DOMAIN_RAW。\n\n|  | Domain 允许分配器在没有 attached thread state 的情况下被调用）。 请参阅 有关分配器\n域的章节 来了解详情。\n如果在 Python 已完成初始化之后（即 Py_InitializeFromConfig() 被调用之后）被调\n用则自定义分配器 must 必须包装现有的分配器。 将现有分配器替换为任意的其他分配器\n是 不受支持的。\n在 3.12 版本发生变更: 所有分配器都必须是线程安全的。\nvoid PyMem_SetupDebugHooks(void)\n设置 Python 内存分配器的调试钩子 以检测内存错误。\nPython 内存分配器的调试钩子\n当 Python 在调试模式下构建，PyMem_SetupDebugHooks() 函数在 Python 预初始化 时被调用，以\n在 Python 内存分配器上设置调试钩子以检测内存错误。\nPYTHONMALLOC 环境变量可被用于在以发行模式下编译的 Python 上安装调试钩子 (例如:\nPYTHONMALLOC=debug)。\nPyMem_SetupDebugHooks() 函数可被用于在调用了 PyMem_SetAllocator() 之后设置调试钩子。\n这些调试钩子用特殊的、可辨认的位模式填充动态分配的内存块。新分配的内存用字节 0xCD\n（PYMEM_CLEANBYTE ）填充，释放的内存用字节 0xDD （PYMEM_DEADBYTE ）填充。内存块被填充\n了字节 0xFD （PYMEM_FORBIDDENBYTE ）的“禁止字节”包围。这些字节串不太可能是合法的地址、\n浮点数或ASCII字符串\n运行时检查：\n检测对 API 的违反。例如：检测对 PyMem_Malloc() 分配的内存块调用 PyObject_Free()。\n检测缓冲区起始位置前的写入（缓冲区下溢）。\n检测缓冲区终止位置后的写入（缓冲区溢出）。\n检测当调用 PYMEM_DOMAIN_OBJ (如: PyObject_Malloc()) 和 PYMEM_DOMAIN_MEM (如:\nPyMem_Malloc()) 域的分配器函数时是否持有 attached thread state。\n在出错时，调试钩子使用 tracemalloc 模块来回溯内存块被分配的位置。只有当 tracemalloc 正\n在追踪 Python 内存分配，并且内存块被追踪时，才会显示回溯。\n让 S = sizeof(size_t)。 将 2*S 个字节添加到每个被请求的 N 字节数据块的两端。 内存的布局像\n是这样，其中 p 代表由类似 malloc 或类似 realloc 的函数所返回的地址 (p[i:j] 表示从 *(p+i) 左\n侧开始到 *(p+j) 左侧止的字节数据切片；请注意对负索引号的处理与 Python 切片是不同的）:\np[-2*S:-S]\n最初所要求的字节数。 这是一个 size_t，为大端序（易于在内存转储中读取）。\np[-S]\nAPI 标识符（ASCII 字符）:\n'r' 表示 PYMEM_DOMAIN_RAW。 | Domain 允许分配器在没有 attached thread state 的情况下被调用）。 请参阅 有关分配器\n域的章节 来了解详情。\n如果在 Python 已完成初始化之后（即 Py_InitializeFromConfig() 被调用之后）被调\n用则自定义分配器 must 必须包装现有的分配器。 将现有分配器替换为任意的其他分配器\n是 不受支持的。 |  |\n| --- | --- | --- | --- |\n\n'm' 表示 PYMEM_DOMAIN_MEM。\n'o' 表示 PYMEM_DOMAIN_OBJ。\np[-S+1:0]\nPYMEM_FORBIDDENBYTE 的副本。 用于捕获下层的写入和读取。\np[0:N]\n所请求的内存，用 PYMEM_CLEANBYTE 的副本填充，用于捕获对未初始化内存的引用。 当调\n用 realloc 之类的函数来请求更大的内存块时，额外新增的字节也会用 PYMEM_CLEANBYTE 来\n填充。 当调用 free 之类的函数时，这些字节会用 PYMEM_DEADBYTE 来重写，以捕获对已释放\n内存的引用。 当调用 realloc 之类的函数来请求更小的内存块时，多余的旧字节也会用\nPYMEM_DEADBYTE 来填充。\np[N:N+S]\nPYMEM_FORBIDDENBYTE 的副本。 用于捕获超限的写入和读取。\np[N+S:N+2*S]\n仅当定义了 PYMEM_DEBUG_SERIALNO 宏时会被使用（默认情况下将不定义）。\n一个序列号，每次调用 malloc 或 realloc 之类的函数时都会递增 1。 大端序的 size_t。 如果\n之后检测到了“被破坏的内存”，此序列号提供了一个很好的手段用来在下次运行时设置中断\n点，以捕获该内存块被破坏的瞬间。 obmalloc.c 中的静态函数 bumpserialno() 是唯一会递增序\n列号的函数，它的存在让你可以轻松地设置这样的中断点。\n一个 realloc 之类或 free 之类的函数会先检查两端的 PYMEM_FORBIDDENBYTE 字节是否完好。 如果\n它们被改变了，则会将诊断输出写入到 stderr，并且程序将通过 Py_FatalError() 中止。 另一种主要\n的失败模式是当程序读到某种特殊的比特模式并试图将其用作地址时触发内存错误。 如果你随即进\n入调试器并查看该对象，你很可能会看到它已完全被填充为 PYMEM_DEADBYTE (意味着已释放的内\n存被使用) 或 PYMEM_CLEANBYTE (意味着未初始货摊内存被使用)。\n在 3.6 版本发生变更: PyMem_SetupDebugHooks() 函数现在也能在使用发布模式编译的 Python\n上工作。 当发生错误时，调试钩子现在会使用 tracemalloc 来获取已分配内存块的回溯信\n息。 调试钩子现在还会在 PYMEM_DOMAIN_OBJ 和 PYMEM_DOMAIN_MEM 作用域的函数被调用时\n检查是否有 attached thread state。\n在 3.8 版本发生变更: 字节模式 0xCB (PYMEM_CLEANBYTE)、 0xDB (PYMEM_DEADBYTE) 和 0xFB\n(PYMEM_FORBIDDENBYTE) 已被 0xCD 、 0xDD 和 0xFD 替代以使用与 Windows CRT 调试\nmalloc() 和 free() 相同的值。\npymalloc 分配器\nPython 有一个针对短生命周期的小对象（小于或等于 512 字节）进行了优化的 pymalloc 分配器。\n它使用名为“arena”的内存映射，在 32 位平台上的固定大小为 256 KiB，在 64 位平台上的固定大小\n为 1 MiB。 对于大于 512 字节的分配，它会回退为 PyMem_RawMalloc() 和\nPyMem_RawRealloc()。\n\n|  | 'm' 表示 PYMEM_DOMAIN_MEM。\n'o' 表示 PYMEM_DOMAIN_OBJ。\np[-S+1:0]\nPYMEM_FORBIDDENBYTE 的副本。 用于捕获下层的写入和读取。\np[0:N]\n所请求的内存，用 PYMEM_CLEANBYTE 的副本填充，用于捕获对未初始化内存的引用。 当调\n用 realloc 之类的函数来请求更大的内存块时，额外新增的字节也会用 PYMEM_CLEANBYTE 来\n填充。 当调用 free 之类的函数时，这些字节会用 PYMEM_DEADBYTE 来重写，以捕获对已释放\n内存的引用。 当调用 realloc 之类的函数来请求更小的内存块时，多余的旧字节也会用\nPYMEM_DEADBYTE 来填充。\np[N:N+S]\nPYMEM_FORBIDDENBYTE 的副本。 用于捕获超限的写入和读取。\np[N+S:N+2*S]\n仅当定义了 PYMEM_DEBUG_SERIALNO 宏时会被使用（默认情况下将不定义）。\n一个序列号，每次调用 malloc 或 realloc 之类的函数时都会递增 1。 大端序的 size_t。 如果\n之后检测到了“被破坏的内存”，此序列号提供了一个很好的手段用来在下次运行时设置中断\n点，以捕获该内存块被破坏的瞬间。 obmalloc.c 中的静态函数 bumpserialno() 是唯一会递增序\n列号的函数，它的存在让你可以轻松地设置这样的中断点。\n一个 realloc 之类或 free 之类的函数会先检查两端的 PYMEM_FORBIDDENBYTE 字节是否完好。 如果\n它们被改变了，则会将诊断输出写入到 stderr，并且程序将通过 Py_FatalError() 中止。 另一种主要\n的失败模式是当程序读到某种特殊的比特模式并试图将其用作地址时触发内存错误。 如果你随即进\n入调试器并查看该对象，你很可能会看到它已完全被填充为 PYMEM_DEADBYTE (意味着已释放的内\n存被使用) 或 PYMEM_CLEANBYTE (意味着未初始货摊内存被使用)。\n在 3.6 版本发生变更: PyMem_SetupDebugHooks() 函数现在也能在使用发布模式编译的 Python\n上工作。 当发生错误时，调试钩子现在会使用 tracemalloc 来获取已分配内存块的回溯信\n息。 调试钩子现在还会在 PYMEM_DOMAIN_OBJ 和 PYMEM_DOMAIN_MEM 作用域的函数被调用时\n检查是否有 attached thread state。\n在 3.8 版本发生变更: 字节模式 0xCB (PYMEM_CLEANBYTE)、 0xDB (PYMEM_DEADBYTE) 和 0xFB\n(PYMEM_FORBIDDENBYTE) 已被 0xCD 、 0xDD 和 0xFD 替代以使用与 Windows CRT 调试\nmalloc() 和 free() 相同的值。\npymalloc 分配器\nPython 有一个针对短生命周期的小对象（小于或等于 512 字节）进行了优化的 pymalloc 分配器。\n它使用名为“arena”的内存映射，在 32 位平台上的固定大小为 256 KiB，在 64 位平台上的固定大小\n为 1 MiB。 对于大于 512 字节的分配，它会回退为 PyMem_RawMalloc() 和\nPyMem_RawRealloc()。 |  |\n| --- | --- | --- |\n\npymalloc 是 PYMEM_DOMAIN_MEM (例如: PyMem_Malloc()) 和 PYMEM_DOMAIN_OBJ (例如:\nPyObject_Malloc()) 域的 默认分配器。\narena 分配器使用以下函数：\nWindows 上的 VirtualAlloc() 和 VirtualFree()，\nmmap() 和 munmap()，如果可用的话，\n否则， malloc() 和 free() 。\n如果 Python 配置了 --without-pymalloc 选项，那么此分配器将被禁用。也可以在运行时使用\nPYTHONMALLOC (例如: PYTHONMALLOC=malloc) 环境变量来禁用它。\n通常，在使用 AddressSanitizer（通过 --with-address-sanitizer 选项）构建 Python 时，建议禁\n用 pymalloc 内存分配器，这有助于发现 C 代码中的底层错误。\n自定义 pymalloc Arena 分配器\nAdded in version 3.4.\ntype PyObjectArenaAllocator\n用来描述一个 arena 分配器的结构体。这个结构体有三个字段：\n域 含意\nvoid *ctx 作为第一个参数传入的用户上下文\nvoid* alloc(void *ctx, size_t size) 分配一块 size 字节的区域\nvoid free(void *ctx, void *ptr, size_t size) 释放一块区域\nvoid PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)\n获取 arena 分配器\nvoid PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)\n设置 arena 分配器\nmimalloc 分配器\nAdded in version 3.13.\nPython 会在下层平台提供支持的情况下支持 mimalloc 分配器。 mimalloc \"是一个具有优良运行效\n率特性的通用分配器。 它最初由 Daan Leijen 针对 Koka 和 Lean 语言运行时系统开发。\"\ntracemalloc C API\nAdded in version 3.7.\nint PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)\n\n|  | pymalloc 是 PYMEM_DOMAIN_MEM (例如: PyMem_Malloc()) 和 PYMEM_DOMAIN_OBJ (例如:\nPyObject_Malloc()) 域的 默认分配器。\narena 分配器使用以下函数：\nWindows 上的 VirtualAlloc() 和 VirtualFree()，\nmmap() 和 munmap()，如果可用的话，\n否则， malloc() 和 free() 。\n如果 Python 配置了 --without-pymalloc 选项，那么此分配器将被禁用。也可以在运行时使用\nPYTHONMALLOC (例如: PYTHONMALLOC=malloc) 环境变量来禁用它。\n通常，在使用 AddressSanitizer（通过 --with-address-sanitizer 选项）构建 Python 时，建议禁\n用 pymalloc 内存分配器，这有助于发现 C 代码中的底层错误。\n自定义 pymalloc Arena 分配器\nAdded in version 3.4.\ntype PyObjectArenaAllocator\n用来描述一个 arena 分配器的结构体。这个结构体有三个字段：\n域 含意\nvoid *ctx 作为第一个参数传入的用户上下文\nvoid* alloc(void *ctx, size_t size) 分配一块 size 字节的区域\nvoid free(void *ctx, void *ptr, size_t size) 释放一块区域\nvoid PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)\n获取 arena 分配器\nvoid PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)\n设置 arena 分配器\nmimalloc 分配器\nAdded in version 3.13.\nPython 会在下层平台提供支持的情况下支持 mimalloc 分配器。 mimalloc \"是一个具有优良运行效\n率特性的通用分配器。 它最初由 Daan Leijen 针对 Koka 和 Lean 语言运行时系统开发。\"\ntracemalloc C API\nAdded in version 3.7.\nint PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size) |  |\n| --- | --- | --- |\n\n| 域 | 含意 |\n| --- | --- |\n| void *ctx | 作为第一个参数传入的用户上下文 |\n| void* alloc(void *ctx, size_t size) | 分配一块 size 字节的区域 |\n| void free(void *ctx, void *ptr, size_t size) | 释放一块区域 |\n\n在 tracemalloc 模块中跟踪一个已分配的内存块。\n成功时返回 0，出错时返回 -1 (无法分配内存来保存跟踪信息)。 如果禁用了 tracemalloc 则返\n回 -2。\n如果内存块已被跟踪，则更新现有跟踪信息。\nint PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)\n在 tracemalloc 模块中取消跟踪一个已分配的内存块。 如果内存块未被跟踪则不执行任何操\n作。\n如果 tracemalloc 被禁用则返回 -2，否则返回 0。\n例子\n以下是来自 概述 小节的示例，经过重写以使 I/O 缓冲区是通过使用第一个函数集从 Python 堆中分\n配的:\nPyObject *res;\nchar *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n/* ...执行一些涉及 buf 的 I/O 操作... */\nres = PyBytes_FromString(buf);\nPyMem_Free(buf); /* 使用 PyMem_Malloc 分配的 */\nreturn res;\n使用面向类型函数集的相同代码:\nPyObject *res;\nchar *buf = PyMem_New(char, BUFSIZ); /* 用于 I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n/* ...执行一些涉及 buf 的 I/O 操作... */\nres = PyBytes_FromString(buf);\nPyMem_Free(buf); /* 使用 PyMem_New 分配的 */\nreturn res;\n请注意在以上两个示例中，缓冲区总是通过归属于相同集的函数来操纵的。 事实上，对于一个给定\n的内存块必须使用相同的内存 API 族，以便使得混合不同分配器的风险减至最低。 以下代码序列包\n含两处错误，其中一个被标记为 fatal 因为它混合了两种在不同堆上操作的不同分配器。\nchar *buf1 = PyMem_New(char, BUFSIZ);\nchar *buf2 = (char *) malloc(BUFSIZ);\nchar *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n...\nPyMem_Del(buf3); /* 错误 -- 应为 PyMem_Free() */\nfree(buf2); /* 正确 -- 通过 malloc() 分配的 */\nfree(buf1); /* 致命错误 -- 应为 PyMem_Free() */\n\n|  | 在 tracemalloc 模块中跟踪一个已分配的内存块。\n成功时返回 0，出错时返回 -1 (无法分配内存来保存跟踪信息)。 如果禁用了 tracemalloc 则返\n回 -2。\n如果内存块已被跟踪，则更新现有跟踪信息。\nint PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)\n在 tracemalloc 模块中取消跟踪一个已分配的内存块。 如果内存块未被跟踪则不执行任何操\n作。\n如果 tracemalloc 被禁用则返回 -2，否则返回 0。\n例子\n以下是来自 概述 小节的示例，经过重写以使 I/O 缓冲区是通过使用第一个函数集从 Python 堆中分\n配的: |  |\n| --- | --- | --- |\n|  | PyObject *res;\nchar *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n/* ...执行一些涉及 buf 的 I/O 操作... */\nres = PyBytes_FromString(buf);\nPyMem_Free(buf); /* 使用 PyMem_Malloc 分配的 */\nreturn res; |  |\n|  | 使用面向类型函数集的相同代码: |  |\n|  | PyObject *res;\nchar *buf = PyMem_New(char, BUFSIZ); /* 用于 I/O */\nif (buf == NULL)\nreturn PyErr_NoMemory();\n/* ...执行一些涉及 buf 的 I/O 操作... */\nres = PyBytes_FromString(buf);\nPyMem_Free(buf); /* 使用 PyMem_New 分配的 */\nreturn res; |  |\n|  | 请注意在以上两个示例中，缓冲区总是通过归属于相同集的函数来操纵的。 事实上，对于一个给定\n的内存块必须使用相同的内存 API 族，以便使得混合不同分配器的风险减至最低。 以下代码序列包\n含两处错误，其中一个被标记为 fatal 因为它混合了两种在不同堆上操作的不同分配器。 |  |\n|  | char *buf1 = PyMem_New(char, BUFSIZ);\nchar *buf2 = (char *) malloc(BUFSIZ);\nchar *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n...\nPyMem_Del(buf3); /* 错误 -- 应为 PyMem_Free() */\nfree(buf2); /* 正确 -- 通过 malloc() 分配的 */\nfree(buf1); /* 致命错误 -- 应为 PyMem_Free() */ |  |\n|  |  |  |\n\n除了用于处理来自 Python 堆的原始内存块的函数，Python 中的对象还通过 PyObject_New,\nPyObject_NewVar 和 PyObject_Free() 进行分配和释放。\n这些将在有关如何在 C 中定义和实现新对象类型的下一章中讲解。", "metadata": {"title": "00_内存管理", "source": "md_docs\\python_c-api_md\\00_内存管理.md", "doc_type": "C API", "language": "中文", "doc_id": "8517ed68"}}
{"doc_id": "3951a3f2", "content": "初始化，最终化和线程\n请参阅 Python 初始化配置 了解如何在初始化之前配置解释器的详情。\n在Python初始化之前\n在一个植入了 Python 的应用程序中，Py_Initialize() 函数必须在任何其他 Python/C API 函数之\n前被调用；例外的只有个别函数和 全局配置变量。\n在初始化Python之前，可以安全地调用以下函数：\n初始化解释器的函数：\nPy_Initialize()\nPy_InitializeEx()\nPy_InitializeFromConfig()\nPy_BytesMain()\nPy_Main()\n运行时预初始化相关函数在 Python 初始化配置 中介绍\n配置函数：\nPyImport_AppendInittab()\nPyImport_ExtendInittab()\nPyInitFrozenExtensions()\nPyMem_SetAllocator()\nPyMem_SetupDebugHooks()\nPyObject_SetArenaAllocator()\nPy_SetProgramName()\nPy_SetPythonHome()\nPySys_ResetWarnOptions()\n配置相关函数在 Python 初始化配置 中介绍\n信息函数：\nPy_IsInitialized()\nPyMem_GetAllocator()\nPyObject_GetArenaAllocator()\nPy_GetBuildInfo()\nPy_GetCompiler()\nPy_GetCopyright()\nPy_GetPlatform()\nPy_GetVersion()\nPy_IsInitialized()\n工具\nPy_DecodeLocale()\n\n状态报告和工具相关函数在 Python 初始化配置 中介绍\n内存分配器：\nPyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\n同步：\nPyMutex_Lock()\nPyMutex_Unlock()\n备注: 虽然它们看起来与上面列出的某些函数类似，但以下函数 不应 在解释器被初始化之前调\n用: Py_EncodeLocale(), Py_GetPath(), Py_GetPrefix(), Py_GetExecPrefix(),\nPy_GetProgramFullPath(), Py_GetPythonHome(), Py_GetProgramName(),\nPyEval_InitThreads() 和 Py_RunMain()。\n全局配置变量\nPython 有负责控制全局配置中不同特性和选项的变量。这些标志默认被 命令行选项。\n当一个选项设置一个旗标时，该旗标的值将是设置选项的次数。 例如，-b 会将\nPy_BytesWarningFlag 设为 1 而 -bb 会将 Py_BytesWarningFlag 设为 2.\nint Py_BytesWarningFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.bytes_warning，参见 Python 初始化\n配置。\n当将 bytes 或 bytearray 与 str 比较或者将 bytes 与 int 比较时发出警告。 如果大于等于\n2 则报错。\n由 -b 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_DebugFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.parser_debug，参见 Python 初始化配\n置。\n开启解析器调试输出（限专家使用，依赖于编译选项）。\n由 -d 选项和 PYTHONDEBUG 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_DontWriteBytecodeFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.write_bytecode，参见 Python 初始化\n配置。\n\n|  | 状态报告和工具相关函数在 Python 初始化配置 中介绍\n内存分配器：\nPyMem_RawMalloc()\nPyMem_RawRealloc()\nPyMem_RawCalloc()\nPyMem_RawFree()\n同步：\nPyMutex_Lock()\nPyMutex_Unlock() |  |\n| --- | --- | --- |\n|  | 备注: 虽然它们看起来与上面列出的某些函数类似，但以下函数 不应 在解释器被初始化之前调\n用: Py_EncodeLocale(), Py_GetPath(), Py_GetPrefix(), Py_GetExecPrefix(),\nPy_GetProgramFullPath(), Py_GetPythonHome(), Py_GetProgramName(),\nPyEval_InitThreads() 和 Py_RunMain()。 |  |\n|  | 全局配置变量\nPython 有负责控制全局配置中不同特性和选项的变量。这些标志默认被 命令行选项。\n当一个选项设置一个旗标时，该旗标的值将是设置选项的次数。 例如，-b 会将\nPy_BytesWarningFlag 设为 1 而 -bb 会将 Py_BytesWarningFlag 设为 2.\nint Py_BytesWarningFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.bytes_warning，参见 Python 初始化\n配置。\n当将 bytes 或 bytearray 与 str 比较或者将 bytes 与 int 比较时发出警告。 如果大于等于\n2 则报错。\n由 -b 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_DebugFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.parser_debug，参见 Python 初始化配\n置。\n开启解析器调试输出（限专家使用，依赖于编译选项）。\n由 -d 选项和 PYTHONDEBUG 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_DontWriteBytecodeFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.write_bytecode，参见 Python 初始化\n配置。 |  |\n\n如果设置为非零, Python 不会在导入源代码时尝试写入 .pyc 文件\n由 -B 选项和 PYTHONDONTWRITEBYTECODE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_FrozenFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.pathconfig_warnings，参见 Python\n初始化配置。\n当在 Py_GetPath() 中计算模块搜索路径时屏蔽错误消息。\n由 _freeze_importlib 和 frozenmain 程序使用的私有旗标。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_HashRandomizationFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.hash_seed 和\nPyConfig.use_hash_seed，参见 Python 初始化配置。\n如果 PYTHONHASHSEED 环境变量被设为非空字符串则设为 1。\n如果该旗标为非零值，则读取 PYTHONHASHSEED 环境变量来初始化加密哈希种子。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_IgnoreEnvironmentFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.use_environment，参见 Python 初始\n化配置。\n忽略所有 PYTHON* 环境变量，例如可能设置的 PYTHONPATH 和 PYTHONHOME。\n由 -E 和 -I 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_InspectFlag\n此 API 被保留用于向下兼容：应当改为采用设置 PyConfig.inspect，参见 Python 初始化配\n置。\n当将脚本作为第一个参数传入或是使用了 -c 选项时，则会在执行该脚本或命令后进入交互模\n式，即使在 sys.stdin 并非一个终端时也是如此。\n由 -i 选项和 PYTHONINSPECT 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_InteractiveFlag\n此 API 被保留用于向下兼容：应当改为采用设置 PyConfig.interactive，参见 Python 初始化\n配置。\n\n|  | 如果设置为非零, Python 不会在导入源代码时尝试写入 .pyc 文件\n由 -B 选项和 PYTHONDONTWRITEBYTECODE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_FrozenFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.pathconfig_warnings，参见 Python\n初始化配置。\n当在 Py_GetPath() 中计算模块搜索路径时屏蔽错误消息。\n由 _freeze_importlib 和 frozenmain 程序使用的私有旗标。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_HashRandomizationFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.hash_seed 和\nPyConfig.use_hash_seed，参见 Python 初始化配置。\n如果 PYTHONHASHSEED 环境变量被设为非空字符串则设为 1。\n如果该旗标为非零值，则读取 PYTHONHASHSEED 环境变量来初始化加密哈希种子。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_IgnoreEnvironmentFlag\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.use_environment，参见 Python 初始\n化配置。\n忽略所有 PYTHON* 环境变量，例如可能设置的 PYTHONPATH 和 PYTHONHOME。\n由 -E 和 -I 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_InspectFlag\n此 API 被保留用于向下兼容：应当改为采用设置 PyConfig.inspect，参见 Python 初始化配\n置。\n当将脚本作为第一个参数传入或是使用了 -c 选项时，则会在执行该脚本或命令后进入交互模\n式，即使在 sys.stdin 并非一个终端时也是如此。\n由 -i 选项和 PYTHONINSPECT 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_InteractiveFlag\n此 API 被保留用于向下兼容：应当改为采用设置 PyConfig.interactive，参见 Python 初始化\n配置。 |  |\n| --- | --- | --- |\n\n由 -i 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_IsolatedFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.isolated，参见 Python 初始化配置。\n以隔离模式运行 Python. 在隔离模式下 sys.path 将不包含脚本的目录或用户的 site-packages\n目录。\n由 -I 选项设置。\nAdded in version 3.4.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_LegacyWindowsFSEncodingFlag\n此 API 被保留用于向下兼容：应当改为设置 PyPreConfig.legacy_windows_fs_encoding，参\n见 Python 初始化配置。\n如果该旗标为非零值，则使用 mbcs 编码和 replace 错误处理器，而不是 UTF-8 编码和\nsurrogatepass 错误处理器作用 filesystem encoding and error handler。\n如果 PYTHONLEGACYWINDOWSFSENCODING 环境变量被设为非空字符串则设为 1。\n更多详情请参阅 PEP 529。\nAvailability: Windows.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_LegacyWindowsStdioFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.legacy_windows_stdio，参见 Python\n初始化配置。\n如果该旗标为非零值，则会使用 io.FileIO 而不是 io._WindowsConsoleIO 作为 sys 标准\n流。\n如果 PYTHONLEGACYWINDOWSSTDIO 环境变量被设为非空字符串则设为 1。\n有关更多详细信息，请参阅 PEP 528。\nAvailability: Windows.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_NoSiteFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.site_import，参见 Python 初始化配\n置。\n\n|  | 由 -i 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_IsolatedFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.isolated，参见 Python 初始化配置。\n以隔离模式运行 Python. 在隔离模式下 sys.path 将不包含脚本的目录或用户的 site-packages\n目录。\n由 -I 选项设置。\nAdded in version 3.4.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_LegacyWindowsFSEncodingFlag\n此 API 被保留用于向下兼容：应当改为设置 PyPreConfig.legacy_windows_fs_encoding，参\n见 Python 初始化配置。\n如果该旗标为非零值，则使用 mbcs 编码和 replace 错误处理器，而不是 UTF-8 编码和\nsurrogatepass 错误处理器作用 filesystem encoding and error handler。\n如果 PYTHONLEGACYWINDOWSFSENCODING 环境变量被设为非空字符串则设为 1。\n更多详情请参阅 PEP 529。\nAvailability: Windows.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_LegacyWindowsStdioFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.legacy_windows_stdio，参见 Python\n初始化配置。\n如果该旗标为非零值，则会使用 io.FileIO 而不是 io._WindowsConsoleIO 作为 sys 标准\n流。\n如果 PYTHONLEGACYWINDOWSSTDIO 环境变量被设为非空字符串则设为 1。\n有关更多详细信息，请参阅 PEP 528。\nAvailability: Windows.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_NoSiteFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.site_import，参见 Python 初始化配\n置。 |  |\n| --- | --- | --- |\n\n禁用 site 的导入及其所附带的基于站点对 sys.path 的操作。 如果 site 会在稍后被显式地\n导入也会禁用这些操作 (如果你希望触发它们则应调用 site.main())。\n由 -S 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_NoUserSiteDirectory\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.user_site_directory，参见 Python\n初始化配置。\n不要将 用户 site-packages 目录 添加到 sys.path。\n由 -s 和 -I 选项以及 PYTHONNOUSERSITE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_OptimizeFlag\n此 API 被保留用于向下兼容：应当改为 PyConfig.optimization_level，参见 Python 初始化\n配置。\n由 -O 选项和 PYTHONOPTIMIZE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_QuietFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.quiet，参见 Python 初始化配置。\n即使在交互模式下也不显示版权和版本信息。\n由 -q 选项设置。\nAdded in version 3.2.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_UnbufferedStdioFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.buffered_stdio，参见 Python 初始化\n配置。\n强制 stdout 和 stderr 流不带缓冲。\n由 -u 选项和 PYTHONUNBUFFERED 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_VerboseFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.verbose，参见 Python 初始化配置。\n\n|  | 禁用 site 的导入及其所附带的基于站点对 sys.path 的操作。 如果 site 会在稍后被显式地\n导入也会禁用这些操作 (如果你希望触发它们则应调用 site.main())。\n由 -S 选项设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_NoUserSiteDirectory\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.user_site_directory，参见 Python\n初始化配置。\n不要将 用户 site-packages 目录 添加到 sys.path。\n由 -s 和 -I 选项以及 PYTHONNOUSERSITE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_OptimizeFlag\n此 API 被保留用于向下兼容：应当改为 PyConfig.optimization_level，参见 Python 初始化\n配置。\n由 -O 选项和 PYTHONOPTIMIZE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_QuietFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.quiet，参见 Python 初始化配置。\n即使在交互模式下也不显示版权和版本信息。\n由 -q 选项设置。\nAdded in version 3.2.\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_UnbufferedStdioFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.buffered_stdio，参见 Python 初始化\n配置。\n强制 stdout 和 stderr 流不带缓冲。\n由 -u 选项和 PYTHONUNBUFFERED 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\nint Py_VerboseFlag\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.verbose，参见 Python 初始化配置。 |  |\n| --- | --- | --- |\n\n每次初始化模块时打印一条消息，显示加载模块的位置（文件名或内置模块）。 如果大于或等\n于 2，则为搜索模块时检查的每个文件打印一条消息。 此外还会在退出时提供模块清理信息。\n由 -v 选项和 PYTHONVERBOSE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\n初始化和最终化解释器\nvoid Py_Initialize()\n属于 稳定 ABI.\n初始化 Python 解释器。 在嵌入 Python 的应用程序中，它应当在使用任何其他 Python/C API\n函数之前被调用；请参阅 在 Python 初始化之前 了解少数的例外情况。\n这将初始化已加载的模块表 (sys.modules)，并创建基础模块 builtins, __main__ 和 sys。\n它还会初始化模块搜索路径 (sys.path)。 它不会设置 sys.argv；对于此设置请使用 Python\n初始化配置 API。 当第二次被调用时（在未先调用 Py_FinalizeEx() 的情况下）将不会执行任\n何操作。 它没有返回值；如果初始化失败则会发生致命错误。\n使用 Py_InitializeFromConfig() 来自定义 Python 初始化配置。\n备注: 在 Windows 上，将控制台模式从 O_TEXT 改为 O_BINARY，这还将影响使用 C 运行\n时的非 Python 的控制台使用。\nvoid Py_InitializeEx(int initsigs)\n属于 稳定 ABI.\n如果 initsigs 为 1 则此函数的工作方式与 Py_Initialize() 类似。 如果 initsigs 为 0，它将跳\n过信号处理器的初始化注册，这在将 CPython 作为更大应用程序的一部分嵌入时会很有用处。\n使用 Py_InitializeFromConfig() 来自定义 Python 初始化配置。\nPyStatus Py_InitializeFromConfig(const PyConfig *config)\n根据 config 配置来初始化 Python，如 使用 PyConfig 初始化 中所描述的。.\n请参阅 Python 初始化配置 一节了解有关预初始化解释器，填充运行时配置结构体，以及查询\n所返回的状态结构体的详情。\nint Py_IsInitialized()\n属于 稳定 ABI.\n如果 Python 解释器已初始化，则返回真值（非零）；否则返回假值（零）。 在调用\nPy_FinalizeEx() 之后，此函数将返回假值直到 Py_Initialize() 再次被调用。\nint Py_IsFinalizing()\n属于 稳定 ABI 自 3.13 版起.\n\n|  | 每次初始化模块时打印一条消息，显示加载模块的位置（文件名或内置模块）。 如果大于或等\n于 2，则为搜索模块时检查的每个文件打印一条消息。 此外还会在退出时提供模块清理信息。\n由 -v 选项和 PYTHONVERBOSE 环境变量设置。\nDeprecated since version 3.12, will be removed in version 3.15.\n初始化和最终化解释器\nvoid Py_Initialize()\n属于 稳定 ABI.\n初始化 Python 解释器。 在嵌入 Python 的应用程序中，它应当在使用任何其他 Python/C API\n函数之前被调用；请参阅 在 Python 初始化之前 了解少数的例外情况。\n这将初始化已加载的模块表 (sys.modules)，并创建基础模块 builtins, __main__ 和 sys。\n它还会初始化模块搜索路径 (sys.path)。 它不会设置 sys.argv；对于此设置请使用 Python\n初始化配置 API。 当第二次被调用时（在未先调用 Py_FinalizeEx() 的情况下）将不会执行任\n何操作。 它没有返回值；如果初始化失败则会发生致命错误。\n使用 Py_InitializeFromConfig() 来自定义 Python 初始化配置。\n备注: 在 Windows 上，将控制台模式从 O_TEXT 改为 O_BINARY，这还将影响使用 C 运行\n时的非 Python 的控制台使用。\nvoid Py_InitializeEx(int initsigs)\n属于 稳定 ABI.\n如果 initsigs 为 1 则此函数的工作方式与 Py_Initialize() 类似。 如果 initsigs 为 0，它将跳\n过信号处理器的初始化注册，这在将 CPython 作为更大应用程序的一部分嵌入时会很有用处。\n使用 Py_InitializeFromConfig() 来自定义 Python 初始化配置。\nPyStatus Py_InitializeFromConfig(const PyConfig *config)\n根据 config 配置来初始化 Python，如 使用 PyConfig 初始化 中所描述的。.\n请参阅 Python 初始化配置 一节了解有关预初始化解释器，填充运行时配置结构体，以及查询\n所返回的状态结构体的详情。\nint Py_IsInitialized()\n属于 稳定 ABI.\n如果 Python 解释器已初始化，则返回真值（非零）；否则返回假值（零）。 在调用\nPy_FinalizeEx() 之后，此函数将返回假值直到 Py_Initialize() 再次被调用。\nint Py_IsFinalizing()\n属于 稳定 ABI 自 3.13 版起. |  |\n| --- | --- | --- |\n\n如果主 Python 解释器 正在关闭 则返回真（非零）值。 在其他情况下返回假（零）值。\nAdded in version 3.13.\nint Py_FinalizeEx()\n属于 稳定 ABI 自 3.6 版起.\n撤销由 Py_Initialize() 完成的所有初始化操作及后续Python/C API函数调用，并销毁自上次\n调用 Py_Initialize() 以来创建但尚未销毁的所有子解释器（参见下文\nPy_NewInterpreter()）。若在未再次调用 Py_Initialize() 的情况下重复执行，该操作将\n无效。\n由于这是 Py_Initialize() 的逆向操作，因而它应当在激活同一解释器的同一线程中被调用。\n这意味着主线程和主解释器。 当 Py_RunMain() 仍然运行时则绝不应调用此函数。\n通常返回值为 0。 如果在最终化（刷新缓冲的数据）期间发生错误，则返回 -1。\n请注意，Python会尽最大努力释放解释器分配的所有内存。因此，任何C扩展模块都应确保在\n后续调用 Py_Initialize() 前，正确清理之前分配的所有PyObject对象。否则可能导致安全漏\n洞和异常行为。\n提供此函数的原因有很多。嵌入应用程序可能希望重新启动Python，而不必重新启动应用程序\n本身。从动态可加载库（或DLL）加载Python解释器的应用程序可能希望在卸载DLL之前释放\nPython分配的所有内存。在搜索应用程序内存泄漏的过程中，开发人员可能希望在退出应用程\n序之前释放Python分配的所有内存。\n已知问题与注意事项： 模块及模块内对象的销毁顺序是随机的，这可能导致析构函数\n（__del__() 方法）在依赖其他对象（甚至函数）或模块时执行失败； 由Python动态加载的扩\n展模块不会被卸载； Python解释器分配的少量内存可能无法释放（如发现内存泄漏请提交报\n告）； 对象间循环引用占用的内存不会被释放； 无论引用计数如何，所有驻留字符串\n（interned strings）都将被释放； 扩展模块分配的部分内存可能无法释放； 某些扩展在初始化\n例程被多次调用时可能出现异常行为（当应用程序多次调用 Py_Initialize() 和\nPy_FinalizeEx() 时会发生这种情况）； Py_FinalizeEx() 不可被自身递归调用，因此任何\n可能作为解释器关闭流程一部分的代码（如 atexit 处理器、对象终结器、或在刷新\nstdout/stderr文件时运行的代码）都不得调用该函数。\n引发一个不带参数的 审计事件 cpython._PySys_ClearAuditHooks。\nAdded in version 3.6.\nvoid Py_Finalize()\n属于 稳定 ABI.\n这是一个不考虑返回值的 Py_FinalizeEx() 的向下兼容版本。\nint Py_BytesMain(int argc, char **argv)\n属于 稳定 ABI 自 3.8 版起.\n\n|  | 如果主 Python 解释器 正在关闭 则返回真（非零）值。 在其他情况下返回假（零）值。\nAdded in version 3.13.\nint Py_FinalizeEx()\n属于 稳定 ABI 自 3.6 版起.\n撤销由 Py_Initialize() 完成的所有初始化操作及后续Python/C API函数调用，并销毁自上次\n调用 Py_Initialize() 以来创建但尚未销毁的所有子解释器（参见下文\nPy_NewInterpreter()）。若在未再次调用 Py_Initialize() 的情况下重复执行，该操作将\n无效。\n由于这是 Py_Initialize() 的逆向操作，因而它应当在激活同一解释器的同一线程中被调用。\n这意味着主线程和主解释器。 当 Py_RunMain() 仍然运行时则绝不应调用此函数。\n通常返回值为 0。 如果在最终化（刷新缓冲的数据）期间发生错误，则返回 -1。\n请注意，Python会尽最大努力释放解释器分配的所有内存。因此，任何C扩展模块都应确保在\n后续调用 Py_Initialize() 前，正确清理之前分配的所有PyObject对象。否则可能导致安全漏\n洞和异常行为。\n提供此函数的原因有很多。嵌入应用程序可能希望重新启动Python，而不必重新启动应用程序\n本身。从动态可加载库（或DLL）加载Python解释器的应用程序可能希望在卸载DLL之前释放\nPython分配的所有内存。在搜索应用程序内存泄漏的过程中，开发人员可能希望在退出应用程\n序之前释放Python分配的所有内存。\n已知问题与注意事项： 模块及模块内对象的销毁顺序是随机的，这可能导致析构函数\n（__del__() 方法）在依赖其他对象（甚至函数）或模块时执行失败； 由Python动态加载的扩\n展模块不会被卸载； Python解释器分配的少量内存可能无法释放（如发现内存泄漏请提交报\n告）； 对象间循环引用占用的内存不会被释放； 无论引用计数如何，所有驻留字符串\n（interned strings）都将被释放； 扩展模块分配的部分内存可能无法释放； 某些扩展在初始化\n例程被多次调用时可能出现异常行为（当应用程序多次调用 Py_Initialize() 和\nPy_FinalizeEx() 时会发生这种情况）； Py_FinalizeEx() 不可被自身递归调用，因此任何\n可能作为解释器关闭流程一部分的代码（如 atexit 处理器、对象终结器、或在刷新\nstdout/stderr文件时运行的代码）都不得调用该函数。\n引发一个不带参数的 审计事件 cpython._PySys_ClearAuditHooks。\nAdded in version 3.6.\nvoid Py_Finalize()\n属于 稳定 ABI.\n这是一个不考虑返回值的 Py_FinalizeEx() 的向下兼容版本。\nint Py_BytesMain(int argc, char **argv)\n属于 稳定 ABI 自 3.8 版起. |  |\n| --- | --- | --- |\n\n类似于 Py_Main() 但 argv 是一个字节串数组，允许调用方应用程序将文本编码步骤委托给\nCPython 运行时。\nAdded in version 3.8.\nint Py_Main(int argc, wchar_t **argv)\n属于 稳定 ABI.\n标准解释器的主程序，封装了完整的初始化/最终化循环，以及一些附加行为以实现从环境和命\n令行读取配置设置，然后按照 命令行 的规则执行 __main__。\n这适用于希望支持完整 CPython 命令行界面的程序，而不仅是在更大应用程序中嵌入 Python\n运行时。\nargc 和 argv 形参与传给 C 程序的 main() 函数的形参类似，不同之处在于 argv 的条目会先使\n用 Py_DecodeLocale() 转换为 wchar_t。 还有一个重要的注意事项是参数列表条目可能会被\n修改为指向并非被传入的字符串（不过，参数列表所指向的字符串内容不会被修改）。\n如果参数列表不是表示一个有效的 Python 命令行则返回值为 2，否则将与 Py_RunMain() 相\n同。\n在记录于 运行时配置 一节的 CPython 运行时配置 API 文档中（不考虑错误处理），Py_Main\n大致相当于:\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\nPyConfig_SetArgv(&config, argc, argv);\nPy_InitializeFromConfig(&config);\nPyConfig_Clear(&config);\nPy_RunMain();\n在正常使用中，嵌入式应用程序将调用此函数 而不是 直接调用 Py_Initialize(),\nPy_InitializeEx() 或 Py_InitializeFromConfig()，并且所有设置都将如本文档的其他部\n分所描述的那样被应用。 如果此函数改在某个先前的运行时初始化 API 调用 之后 被调用，那\n么到底那个环境和命令行配置会被更新将取决于具体的版本（因为它要依赖当运行时被初始化\n时究竟有哪些设置在它们已被设置一次之后是正确地支持被修改的）。\nint Py_RunMain(void)\n在完整配置的 CPython 运行时中执行主模块。\n执行在命令行或配置中指定的命令 (PyConfig.run_command)、脚本\n(PyConfig.run_filename) 或模块 (PyConfig.run_module)。 如果这些值均未设置，则使用\n__main__ 模块的全局命令空间来运行交互式 Python 提示符 (REPL)。\n如果 PyConfig.inspect 未设置（默认），则当解释器正常退出（也就是说未引发异常）时返\n回值将为 0，未处理的 SystemExit 的退出状态，或者对于任何其他未处理异常则为 1。\n\n|  | 类似于 Py_Main() 但 argv 是一个字节串数组，允许调用方应用程序将文本编码步骤委托给\nCPython 运行时。\nAdded in version 3.8.\nint Py_Main(int argc, wchar_t **argv)\n属于 稳定 ABI.\n标准解释器的主程序，封装了完整的初始化/最终化循环，以及一些附加行为以实现从环境和命\n令行读取配置设置，然后按照 命令行 的规则执行 __main__。\n这适用于希望支持完整 CPython 命令行界面的程序，而不仅是在更大应用程序中嵌入 Python\n运行时。\nargc 和 argv 形参与传给 C 程序的 main() 函数的形参类似，不同之处在于 argv 的条目会先使\n用 Py_DecodeLocale() 转换为 wchar_t。 还有一个重要的注意事项是参数列表条目可能会被\n修改为指向并非被传入的字符串（不过，参数列表所指向的字符串内容不会被修改）。\n如果参数列表不是表示一个有效的 Python 命令行则返回值为 2，否则将与 Py_RunMain() 相\n同。\n在记录于 运行时配置 一节的 CPython 运行时配置 API 文档中（不考虑错误处理），Py_Main\n大致相当于:\nPyConfig config;\nPyConfig_InitPythonConfig(&config);\nPyConfig_SetArgv(&config, argc, argv);\nPy_InitializeFromConfig(&config);\nPyConfig_Clear(&config);\nPy_RunMain();\n在正常使用中，嵌入式应用程序将调用此函数 而不是 直接调用 Py_Initialize(),\nPy_InitializeEx() 或 Py_InitializeFromConfig()，并且所有设置都将如本文档的其他部\n分所描述的那样被应用。 如果此函数改在某个先前的运行时初始化 API 调用 之后 被调用，那\n么到底那个环境和命令行配置会被更新将取决于具体的版本（因为它要依赖当运行时被初始化\n时究竟有哪些设置在它们已被设置一次之后是正确地支持被修改的）。\nint Py_RunMain(void)\n在完整配置的 CPython 运行时中执行主模块。\n执行在命令行或配置中指定的命令 (PyConfig.run_command)、脚本\n(PyConfig.run_filename) 或模块 (PyConfig.run_module)。 如果这些值均未设置，则使用\n__main__ 模块的全局命令空间来运行交互式 Python 提示符 (REPL)。\n如果 PyConfig.inspect 未设置（默认），则当解释器正常退出（也就是说未引发异常）时返\n回值将为 0，未处理的 SystemExit 的退出状态，或者对于任何其他未处理异常则为 1。 |  |\n| --- | --- | --- |\n\n如果 PyConfig.inspect 已设置（例如当使用了 -i 选项时），则当解释器退出时执行将不会\n返回，而是会使用 __main__ 模块的全局命名空间在交互式 Python 提示符 (REPL) 中恢复。 如\n果解释器附带异常退出，该异常将在 REPL 会话中被立即引发。 随后函数的返回值将由 REPL 会\n话 的终结方式来决定: 0, 1 或者 SystemExit 的状态，如上文所指明的。\n此函数总是会在它返回之前最终化 Python 解释器。\n请参阅 Python 配置 查看一个使用 Py_RunMain() 在隔离模式下始终运行定制的 Python 的示\n例。\nint PyUnstable_AtExit(PyInterpreterState *interp, void (*func)(void*), void\n*data)\n这是 不稳定 API。它可在次发布版中不经警告地改变。\n为目标解释器 interp 注册一个 atexit 回调。 这与 Py_AtExit() 类似，但它接受一个显式的\n解释器和用于回调的数据指针。\n必须有一个对应 interp 的 attached thread state。\nAdded in version 3.13.\n进程级参数\nvoid Py_SetProgramName(const wchar_t *name)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.program_name，参见 Python 初始化配\n置。\n如果要调用该函数，应当在首次调用 Py_Initialize() 之前调用它。 它将告诉解释器程序的\nmain() 函数的 argv[0] 参数的值（转换为宽字符）。 Py_GetPath() 和下面的某些其他函数\n会使用它在相对于解释器的位置上查找可执行文件的 Python 运行时库。 默认值是 'python'。\n参数应当指向静态存储中的一个以零值结束的宽字符串，其内容在程序执行期间不会发生改\n变。 Python 解释器中的任何代码都不会改变该存储的内容。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\nDeprecated since version 3.11, will be removed in version 3.15.\nwchar_t *Py_GetProgramName()\n属于 稳定 ABI.\n返回用 Py_SetProgramName() 设置的程序名称，或默认的名称。 返回的字符串指向静态存\n储；调用者不应修改其值。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\n\n|  | 如果 PyConfig.inspect 已设置（例如当使用了 -i 选项时），则当解释器退出时执行将不会\n返回，而是会使用 __main__ 模块的全局命名空间在交互式 Python 提示符 (REPL) 中恢复。 如\n果解释器附带异常退出，该异常将在 REPL 会话中被立即引发。 随后函数的返回值将由 REPL 会\n话 的终结方式来决定: 0, 1 或者 SystemExit 的状态，如上文所指明的。\n此函数总是会在它返回之前最终化 Python 解释器。\n请参阅 Python 配置 查看一个使用 Py_RunMain() 在隔离模式下始终运行定制的 Python 的示\n例。\nint PyUnstable_AtExit(PyInterpreterState *interp, void (*func)(void*), void\n*data)\n这是 不稳定 API。它可在次发布版中不经警告地改变。\n为目标解释器 interp 注册一个 atexit 回调。 这与 Py_AtExit() 类似，但它接受一个显式的\n解释器和用于回调的数据指针。\n必须有一个对应 interp 的 attached thread state。\nAdded in version 3.13.\n进程级参数\nvoid Py_SetProgramName(const wchar_t *name)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.program_name，参见 Python 初始化配\n置。\n如果要调用该函数，应当在首次调用 Py_Initialize() 之前调用它。 它将告诉解释器程序的\nmain() 函数的 argv[0] 参数的值（转换为宽字符）。 Py_GetPath() 和下面的某些其他函数\n会使用它在相对于解释器的位置上查找可执行文件的 Python 运行时库。 默认值是 'python'。\n参数应当指向静态存储中的一个以零值结束的宽字符串，其内容在程序执行期间不会发生改\n变。 Python 解释器中的任何代码都不会改变该存储的内容。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\nDeprecated since version 3.11, will be removed in version 3.15.\nwchar_t *Py_GetProgramName()\n属于 稳定 ABI.\n返回用 Py_SetProgramName() 设置的程序名称，或默认的名称。 返回的字符串指向静态存\n储；调用者不应修改其值。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。 |  |\n| --- | --- | --- |\n\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"executable\") (sys.executable)。\nwchar_t *Py_GetPrefix()\n属于 稳定 ABI.\n返回针对已安装的独立于平台文件的 prefix。 这是通过基于使用 PyConfig.program_name 设\n置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；举例来说，如果程序名称为\n'/usr/local/bin/python'，则 prefix 为 '/usr/local'。 返回的字符串将指向静态存储；调\n用方不应修改其值。 这对应于最高层级 Makefile 中的 prefix 变量以及在编译时传给\nconfigure 脚本的 --prefix 参数。 该值将作为 sys.base_prefix 供 Python 代码使用。 它仅\n适用于 Unix。 另请参见下一个函数。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"base_prefix\") (sys.base_prefix)。 如果需要处理 虚拟环境 则使用\nPyConfig_Get(\"prefix\") (sys.prefix)。\nwchar_t *Py_GetExecPrefix()\n属于 稳定 ABI.\n返回针对已安装的 依赖于 平台文件的 exec-prefix。 这是通过基于使用\nPyConfig.program_name 设置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；\n举例来说，如果程序名称为 '/usr/local/bin/python'，则 exec-prefix 为 '/usr/local'。\n返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 Makefile 中的\nexec_prefix 变量以及在编译时传给 configure 脚本的 --exec-prefix 参数。 该值将作为\nsys.base_exec_prefix 供 Python 代码使用。 它仅适用于 Unix。\n背景：当依赖于平台的文件（如可执行文件和共享库）是安装于不同的目录树中的时候 exec-\nprefix 将会不同于 prefix。 在典型的安装中，依赖于平台的文件可能安装于 the\n/usr/local/plat 子目录树而独立于平台的文件可能安装于 /usr/local。\n总而言之，平台是一组硬件和软件资源的组合，例如所有运行 Solaris 2.x 操作系统的 Sparc 机\n器会被视为相同平台，但运行 Solaris 2.x 的 Intel 机器是另一种平台，而运行 Linux 的 Intel 机\n器又是另一种平台。 相同操作系统的不同主要发布版通常也会构成不同的平台。 非 Unix 操作\n系统的情况又有所不同；这类系统上的安装策略差别巨大因此 prefix 和 exec-prefix 是没有意义\n的，并将被设为空字符串。 请注意已编译的 Python 字节码是独立于平台的（但并不独立于它\n们编译时所使用的 Python 版本！）\n系统管理员知道如何配置 mount 或 automount 程序以在平台间共享 /usr/local 而让\n/usr/local/plat 成为针对不同平台的不同文件系统。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n\n|  | Deprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"executable\") (sys.executable)。\nwchar_t *Py_GetPrefix()\n属于 稳定 ABI.\n返回针对已安装的独立于平台文件的 prefix。 这是通过基于使用 PyConfig.program_name 设\n置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；举例来说，如果程序名称为\n'/usr/local/bin/python'，则 prefix 为 '/usr/local'。 返回的字符串将指向静态存储；调\n用方不应修改其值。 这对应于最高层级 Makefile 中的 prefix 变量以及在编译时传给\nconfigure 脚本的 --prefix 参数。 该值将作为 sys.base_prefix 供 Python 代码使用。 它仅\n适用于 Unix。 另请参见下一个函数。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"base_prefix\") (sys.base_prefix)。 如果需要处理 虚拟环境 则使用\nPyConfig_Get(\"prefix\") (sys.prefix)。\nwchar_t *Py_GetExecPrefix()\n属于 稳定 ABI.\n返回针对已安装的 依赖于 平台文件的 exec-prefix。 这是通过基于使用\nPyConfig.program_name 设置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；\n举例来说，如果程序名称为 '/usr/local/bin/python'，则 exec-prefix 为 '/usr/local'。\n返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 Makefile 中的\nexec_prefix 变量以及在编译时传给 configure 脚本的 --exec-prefix 参数。 该值将作为\nsys.base_exec_prefix 供 Python 代码使用。 它仅适用于 Unix。\n背景：当依赖于平台的文件（如可执行文件和共享库）是安装于不同的目录树中的时候 exec-\nprefix 将会不同于 prefix。 在典型的安装中，依赖于平台的文件可能安装于 the\n/usr/local/plat 子目录树而独立于平台的文件可能安装于 /usr/local。\n总而言之，平台是一组硬件和软件资源的组合，例如所有运行 Solaris 2.x 操作系统的 Sparc 机\n器会被视为相同平台，但运行 Solaris 2.x 的 Intel 机器是另一种平台，而运行 Linux 的 Intel 机\n器又是另一种平台。 相同操作系统的不同主要发布版通常也会构成不同的平台。 非 Unix 操作\n系统的情况又有所不同；这类系统上的安装策略差别巨大因此 prefix 和 exec-prefix 是没有意义\n的，并将被设为空字符串。 请注意已编译的 Python 字节码是独立于平台的（但并不独立于它\n们编译时所使用的 Python 版本！）\n系统管理员知道如何配置 mount 或 automount 程序以在平台间共享 /usr/local 而让\n/usr/local/plat 成为针对不同平台的不同文件系统。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。 |  |\n| --- | --- | --- |\n\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"base_exec_prefix\") (sys.base_exec_prefix)。 如果需要处理 虚拟\n环境 则使用 PyConfig_Get(\"exec_prefix\") (sys.exec_prefix)。\nwchar_t *Py_GetProgramFullPath()\n属于 稳定 ABI.\n返回 Python 可执行文件的完整程序名称；这是作为基于程序名称（由\nPyConfig.program_name 设置）派生默认模块搜索路径的附带影响计算得出的。 返回的字符\n串将指向静态存储；调用方不应修改其值。 该值将以 sys.executable 的名称供 Python 代码\n访问。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"executable\") (sys.executable)。\nwchar_t *Py_GetPath()\n属于 稳定 ABI.\n返回默认模块搜索路径；这是基于程序名称（由 PyConfig.program_name 设置）和某些环境\n变量计算得出的。 返回的字符串由一系列以依赖于平台的分隔符分开的目录名称组成。 此分隔\n符在 Unix 和 macOS 上为 ':'，在 Windows 上为 ';'。 返回的字符串将指向静态存储；调用\n方不应修改其值。 列表 sys.path 将在解释器启动时使用该值来初始化；它可以在随后被修改\n（并且通常都会被修改）以变更用于加载模块的搜索路径。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"module_search_paths\") (sys.path)。\nconst char *Py_GetVersion()\n属于 稳定 ABI.\n返回 Python 解释器的版本。 这将为如下形式的字符串\n\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\"\n第一个单词（到第一个空格符为止）是当前的 Python 版本；前面的字符是以点号分隔的主要和\n次要版本号。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 sys.version\n的名称供 Python 代码使用。\n另请参阅 Py_Version 常量。\n\n|  | 在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"base_exec_prefix\") (sys.base_exec_prefix)。 如果需要处理 虚拟\n环境 则使用 PyConfig_Get(\"exec_prefix\") (sys.exec_prefix)。\nwchar_t *Py_GetProgramFullPath()\n属于 稳定 ABI.\n返回 Python 可执行文件的完整程序名称；这是作为基于程序名称（由\nPyConfig.program_name 设置）派生默认模块搜索路径的附带影响计算得出的。 返回的字符\n串将指向静态存储；调用方不应修改其值。 该值将以 sys.executable 的名称供 Python 代码\n访问。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"executable\") (sys.executable)。\nwchar_t *Py_GetPath()\n属于 稳定 ABI.\n返回默认模块搜索路径；这是基于程序名称（由 PyConfig.program_name 设置）和某些环境\n变量计算得出的。 返回的字符串由一系列以依赖于平台的分隔符分开的目录名称组成。 此分隔\n符在 Unix 和 macOS 上为 ':'，在 Windows 上为 ';'。 返回的字符串将指向静态存储；调用\n方不应修改其值。 列表 sys.path 将在解释器启动时使用该值来初始化；它可以在随后被修改\n（并且通常都会被修改）以变更用于加载模块的搜索路径。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"module_search_paths\") (sys.path)。\nconst char *Py_GetVersion()\n属于 稳定 ABI.\n返回 Python 解释器的版本。 这将为如下形式的字符串\n\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\"\n第一个单词（到第一个空格符为止）是当前的 Python 版本；前面的字符是以点号分隔的主要和\n次要版本号。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 sys.version\n的名称供 Python 代码使用。\n另请参阅 Py_Version 常量。 |  |\n| --- | --- | --- |\n\nconst char *Py_GetPlatform()\n属于 稳定 ABI.\n返回当前平台的平台标识符。 在 Unix 上，这将以操作系统的“官方”名称为基础，转换为小写形\n式，再加上主版本号；例如，对于 Solaris 2.x，或称 SunOS 5.x，该值将为 'sunos5'。 在\nmacOS 上，它将为 'darwin'。 在 Windows 上它将为 'win'。 返回的字符串指向静态存储；\n调用方不应修改其值。 Python 代码可通过 sys.platform 获取该值。\nconst char *Py_GetCopyright()\n属于 稳定 ABI.\n返回当前 Python 版本的官方版权字符串，例如\n'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可通过 sys.copyright 获取\n该值。\nconst char *Py_GetCompiler()\n属于 稳定 ABI.\n返回用于编译当前 Python 版本的编译器指令，为带方括号的形式，例如:\n\"[GCC 2.7.2.2]\"\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 sys.version 中\n获取该值。\nconst char *Py_GetBuildInfo()\n属于 稳定 ABI.\n返回有关当前Python解释器实例的序列号和构建日期和时间的信息，例如：\n\"#67, Aug 1 1997, 22:34:28\"\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 sys.version 中\n获取该值。\nvoid PySys_SetArgvEx(int argc, wchar_t **argv, int updatepath)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.argv, PyConfig.parse_argv 和\nPyConfig.safe_path，参见 Python 初始化配置。\n根据 argc 和 argv 设置 sys.argv。 这些形参与传给程序的 main() 函数的类似，区别在于第一\n项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。 如果没有要运行的脚\n本，则 argv 中的第一项可以为空字符串。 如果此函数无法初始化 sys.argv，则将使用\nPy_FatalError() 发出严重情况信号。\n\n|  | const char *Py_GetPlatform()\n属于 稳定 ABI.\n返回当前平台的平台标识符。 在 Unix 上，这将以操作系统的“官方”名称为基础，转换为小写形\n式，再加上主版本号；例如，对于 Solaris 2.x，或称 SunOS 5.x，该值将为 'sunos5'。 在\nmacOS 上，它将为 'darwin'。 在 Windows 上它将为 'win'。 返回的字符串指向静态存储；\n调用方不应修改其值。 Python 代码可通过 sys.platform 获取该值。\nconst char *Py_GetCopyright()\n属于 稳定 ABI.\n返回当前 Python 版本的官方版权字符串，例如\n'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可通过 sys.copyright 获取\n该值。\nconst char *Py_GetCompiler()\n属于 稳定 ABI.\n返回用于编译当前 Python 版本的编译器指令，为带方括号的形式，例如:\n\"[GCC 2.7.2.2]\"\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 sys.version 中\n获取该值。\nconst char *Py_GetBuildInfo()\n属于 稳定 ABI.\n返回有关当前Python解释器实例的序列号和构建日期和时间的信息，例如：\n\"#67, Aug 1 1997, 22:34:28\"\n返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 sys.version 中\n获取该值。\nvoid PySys_SetArgvEx(int argc, wchar_t **argv, int updatepath)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.argv, PyConfig.parse_argv 和\nPyConfig.safe_path，参见 Python 初始化配置。\n根据 argc 和 argv 设置 sys.argv。 这些形参与传给程序的 main() 函数的类似，区别在于第一\n项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。 如果没有要运行的脚\n本，则 argv 中的第一项可以为空字符串。 如果此函数无法初始化 sys.argv，则将使用\nPy_FatalError() 发出严重情况信号。 |  |\n| --- | --- | --- |\n\n如果 updatepath 为零，此函数将完成操作。 如果 updatepath 为非零值，则此函数还将根据以\n下算法修改 sys.path:\n如果在 argv[0] 中传入一个现有脚本，则脚本所在目录的绝对路径将被添加到 sys.path 的\n开头。\n在其他情况下 (也就是说，如果 argc 为 0 或 argv[0] 未指向现有文件名)，则将在\nsys.path 的开头添加一个空字符串，这等价于添加当前工作目录 (\".\")。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\n另请参阅 Python 初始化配置 的 PyConfig.orig_argv 和 PyConfig.argv 成员。\n备注: 建议在出于执行单个脚本以外的目的嵌入 Python 解释器的应用传入 0 作为\nupdatepath，并在需要时更新 sys.path 本身。 参见 CVE 2008-5983。\n在 3.1.3 之前的版本中，你可以通过在调用 PySys_SetArgv() 之后手动弹出第一个\nsys.path 元素，例如使用:\nPyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");\nAdded in version 3.1.3.\nDeprecated since version 3.11, will be removed in version 3.15.\nvoid PySys_SetArgv(int argc, wchar_t **argv)\n属于 稳定 ABI.\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.argv 并改用 PyConfig.parse_argv，\n参见 Python 初始化配置。\n此函数相当于 PySys_SetArgvEx() 设置了 updatepath 为 1 除非 python 解释器启动时附带了\n-I。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\n另请参阅 Python 初始化配置 的 PyConfig.orig_argv 和 PyConfig.argv 成员。\n在 3.4 版本发生变更: updatepath 值依赖于 -I。\nDeprecated since version 3.11, will be removed in version 3.15.\nvoid Py_SetPythonHome(const wchar_t *home)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.home，参见 Python 初始化配置。\n设置默认的 \"home\" 目录，也就是标准 Python 库所在的位置。 请参阅 PYTHONHOME 了解该参\n数字符串的含义。\n\n|  | 如果 updatepath 为零，此函数将完成操作。 如果 updatepath 为非零值，则此函数还将根据以\n下算法修改 sys.path:\n如果在 argv[0] 中传入一个现有脚本，则脚本所在目录的绝对路径将被添加到 sys.path 的\n开头。\n在其他情况下 (也就是说，如果 argc 为 0 或 argv[0] 未指向现有文件名)，则将在\nsys.path 的开头添加一个空字符串，这等价于添加当前工作目录 (\".\")。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\n另请参阅 Python 初始化配置 的 PyConfig.orig_argv 和 PyConfig.argv 成员。\n备注: 建议在出于执行单个脚本以外的目的嵌入 Python 解释器的应用传入 0 作为\nupdatepath，并在需要时更新 sys.path 本身。 参见 CVE 2008-5983。\n在 3.1.3 之前的版本中，你可以通过在调用 PySys_SetArgv() 之后手动弹出第一个\nsys.path 元素，例如使用:\nPyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");\nAdded in version 3.1.3.\nDeprecated since version 3.11, will be removed in version 3.15.\nvoid PySys_SetArgv(int argc, wchar_t **argv)\n属于 稳定 ABI.\n此 API 仅为向下兼容而保留：应当改为设置 PyConfig.argv 并改用 PyConfig.parse_argv，\n参见 Python 初始化配置。\n此函数相当于 PySys_SetArgvEx() 设置了 updatepath 为 1 除非 python 解释器启动时附带了\n-I。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\n另请参阅 Python 初始化配置 的 PyConfig.orig_argv 和 PyConfig.argv 成员。\n在 3.4 版本发生变更: updatepath 值依赖于 -I。\nDeprecated since version 3.11, will be removed in version 3.15.\nvoid Py_SetPythonHome(const wchar_t *home)\n属于 稳定 ABI.\n此 API 被保留用于向下兼容：应当改为设置 PyConfig.home，参见 Python 初始化配置。\n设置默认的 \"home\" 目录，也就是标准 Python 库所在的位置。 请参阅 PYTHONHOME 了解该参\n数字符串的含义。 |  |\n| --- | --- | --- |\n\n此参数应当指向静态存储中一个以零值结束的字符串，其内容在程序执行期间将保持不变。\nPython 解释器中的代码绝不会修改此存储中的内容。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\nDeprecated since version 3.11, will be removed in version 3.15.\nwchar_t *Py_GetPythonHome()\n属于 稳定 ABI.\n返回默认的 \"home\"，就是由 PyConfig.home 所设置的值，或者在设置了 PYTHONHOME 环境变\n量的情况下则为该变量的值。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"home\") 或 PYTHONHOME 环境变量。\n线程状态和全局解释器锁\n除非使用 自由线程 构建的 CPython 版本，否则 Python 解释器并非完全线程安全。 为支持多线程\nPython 程序，系统设置了名为 global interpreter lock 或 GIL 的全局锁 —— 当前线程必须获取该锁\n后才能安全操作Python对象。 若未持有此锁，即便是最简单的操作也可能引发多线程程序问题：例\n如当两个线程同时递增同一对象的引用计数时，最终引用计数可能只增加一次而非两次。\n因此，规则要求只有获得 GIL 的线程才能在 Python对象上执行操作或调用 Python/C API 函数。 为\n了模拟并发执行，解释器会定期尝试切换线程 (参见 sys.setswitchinterval())。 锁也会在读写文\n件等可能造成阻塞的 I/O 操作时释放，以便其他 Python 线程可以同时运行。\nPython解释器将线程特定的簿记信息存储在名为 PyThreadState 的数据结构中，该结构被称为\nthread state。 每个操作系统线程都拥有一个线程本地指针指向 PyThreadState，被该指针引用的\n线程状态被视为 已附加。\n一个线程同一时间只能拥有一个 attached thread state。 已附加线程状态通常等同于持有 GIL，但在\n自由线程 构建中例外。 在启用 GIL 的构建版本中，附加 线程状态会阻塞直至获取到 GIL。 但需注\n意，即使在禁用 GIL 的构建版本中，调用大多数 C API 仍需要已附加线程状态。\n通常情况下，使用 Python C API 时总会存在一个 attached thread state。 仅在某些特定情况下（例\n如处于 Py_BEGIN_ALLOW_THREADS 代码块中），线程才不会有已附加线程状态。 如不确定，可通过\n检查 PyThreadState_GetUnchecked() 是否返回 NULL 来确认。\n从扩展代码分离线程状态\n大多数操作 thread state 的扩展代码具有以下简单结构:\n将线程状态保存到一个局部变量中。\n... 执行某些阻塞式的 I/O 操作 ...\n\n|  | 此参数应当指向静态存储中一个以零值结束的字符串，其内容在程序执行期间将保持不变。\nPython 解释器中的代码绝不会修改此存储中的内容。\n使用 Py_DecodeLocale() 解码字节串以得到一个 wchar_t* 字符串。\nDeprecated since version 3.11, will be removed in version 3.15.\nwchar_t *Py_GetPythonHome()\n属于 稳定 ABI.\n返回默认的 \"home\"，就是由 PyConfig.home 所设置的值，或者在设置了 PYTHONHOME 环境变\n量的情况下则为该变量的值。\n此函数不应在 Py_Initialize() 之前被调用，否则将返回 NULL。\n在 3.10 版本发生变更: 现在如果它在 Py_Initialize() 之前被调用将返回 NULL。\nDeprecated since version 3.13, will be removed in version 3.15: 改用\nPyConfig_Get(\"home\") 或 PYTHONHOME 环境变量。\n线程状态和全局解释器锁\n除非使用 自由线程 构建的 CPython 版本，否则 Python 解释器并非完全线程安全。 为支持多线程\nPython 程序，系统设置了名为 global interpreter lock 或 GIL 的全局锁 —— 当前线程必须获取该锁\n后才能安全操作Python对象。 若未持有此锁，即便是最简单的操作也可能引发多线程程序问题：例\n如当两个线程同时递增同一对象的引用计数时，最终引用计数可能只增加一次而非两次。\n因此，规则要求只有获得 GIL 的线程才能在 Python对象上执行操作或调用 Python/C API 函数。 为\n了模拟并发执行，解释器会定期尝试切换线程 (参见 sys.setswitchinterval())。 锁也会在读写文\n件等可能造成阻塞的 I/O 操作时释放，以便其他 Python 线程可以同时运行。\nPython解释器将线程特定的簿记信息存储在名为 PyThreadState 的数据结构中，该结构被称为\nthread state。 每个操作系统线程都拥有一个线程本地指针指向 PyThreadState，被该指针引用的\n线程状态被视为 已附加。\n一个线程同一时间只能拥有一个 attached thread state。 已附加线程状态通常等同于持有 GIL，但在\n自由线程 构建中例外。 在启用 GIL 的构建版本中，附加 线程状态会阻塞直至获取到 GIL。 但需注\n意，即使在禁用 GIL 的构建版本中，调用大多数 C API 仍需要已附加线程状态。\n通常情况下，使用 Python C API 时总会存在一个 attached thread state。 仅在某些特定情况下（例\n如处于 Py_BEGIN_ALLOW_THREADS 代码块中），线程才不会有已附加线程状态。 如不确定，可通过\n检查 PyThreadState_GetUnchecked() 是否返回 NULL 来确认。\n从扩展代码分离线程状态\n大多数操作 thread state 的扩展代码具有以下简单结构: |  |\n| --- | --- | --- |\n|  | 将线程状态保存到一个局部变量中。\n... 执行某些阻塞式的 I/O 操作 ... |  |\n\n从局部变量中恢复线程状态。\n这是如此常用因此增加了一对宏来简化它:\nPy_BEGIN_ALLOW_THREADS\n... 执行某些阻塞式的 I/O 操作 ...\nPy_END_ALLOW_THREADS\nPy_BEGIN_ALLOW_THREADS 宏将打开一个新块并声明一个隐藏的局部变量；Py_END_ALLOW_THREADS\n宏将关闭这个块。\n上面的代码块可扩展为下面的代码:\nPyThreadState *_save;\n_save = PyEval_SaveThread();\n... 执行某些阻塞式的 I/O 操作 ...\nPyEval_RestoreThread(_save);\n下面介绍这些函数是如何运作的：\nattached thread state 持有整个解释器的 GIL。当分离 attached thread state 时，GIL 会被释放，允\n许其他线程将线程状态附加到自己的线程上，从而获取 GIL 并开始执行。先前 attached thread state\n的指针会被存储为局部变量。当执行到 Py_END_ALLOW_THREADS 时，先前 已附加 的线程状态会被传\n递给 PyEval_RestoreThread()。 该函数将阻塞直到其他线程释放其 线程状态，从而使旧的 线程\n状态 能够重新附加，并再次调用 C API。\n对于 自由线程 构建版本，通常无需考虑 GIL，但在阻塞I/O和长时操作中仍需分离 线程状态。不同\n之处在于，线程无需等待 GIL 释放即可附加其线程状态，从而实现真正的多核并行。\n备注: 调用系统I/O函数是分离 线程状态 的最常见场景，但在执行无需访问Python对象的长时计\n算（如针对内存缓冲区的压缩或加密运算）前，分离线程状态同样有益。例如标准库中的 zlib\n和 hashlib 模块在压缩或哈希数据时就会分离 线程状态。\n非Python创建的线程\n当线程通过 Python 专用 API（如 threading 模块）创建时，系统会自动为其关联线程状态，因此\n上述代码是正确的。 然而，当线程直接从 C 创建时（例如通过自带线程管理的第三方库），这些线\n程不会持有 GIL，因为它们没有 attached thread state。\n若需从这些线程调用 Python 代码（常见于前述第三方库提供的回调 API 中），必须首先创建\nattached thread state 向解释器注册线程，然后才能使用 Python/C API。 操作完成后，应当分离 线\n程状态 并最终释放该线程。\nPyGILState_Ensure() 和 PyGILState_Release() 函数会自动完成上述的所有操作。 从 C 线程调\n用到 Python 的典型方式如下:\nPyGILState_STATE gstate;\ngstate = PyGILState_Ensure();\n\n|  | 从局部变量中恢复线程状态。 |  |\n| --- | --- | --- |\n|  | 这是如此常用因此增加了一对宏来简化它: |  |\n|  | Py_BEGIN_ALLOW_THREADS\n... 执行某些阻塞式的 I/O 操作 ...\nPy_END_ALLOW_THREADS |  |\n|  | Py_BEGIN_ALLOW_THREADS 宏将打开一个新块并声明一个隐藏的局部变量；Py_END_ALLOW_THREADS\n宏将关闭这个块。\n上面的代码块可扩展为下面的代码: |  |\n|  | PyThreadState *_save;\n_save = PyEval_SaveThread();\n... 执行某些阻塞式的 I/O 操作 ...\nPyEval_RestoreThread(_save); |  |\n|  | 下面介绍这些函数是如何运作的：\nattached thread state 持有整个解释器的 GIL。当分离 attached thread state 时，GIL 会被释放，允\n许其他线程将线程状态附加到自己的线程上，从而获取 GIL 并开始执行。先前 attached thread state\n的指针会被存储为局部变量。当执行到 Py_END_ALLOW_THREADS 时，先前 已附加 的线程状态会被传\n递给 PyEval_RestoreThread()。 该函数将阻塞直到其他线程释放其 线程状态，从而使旧的 线程\n状态 能够重新附加，并再次调用 C API。\n对于 自由线程 构建版本，通常无需考虑 GIL，但在阻塞I/O和长时操作中仍需分离 线程状态。不同\n之处在于，线程无需等待 GIL 释放即可附加其线程状态，从而实现真正的多核并行。 |  |\n|  | 备注: 调用系统I/O函数是分离 线程状态 的最常见场景，但在执行无需访问Python对象的长时计\n算（如针对内存缓冲区的压缩或加密运算）前，分离线程状态同样有益。例如标准库中的 zlib\n和 hashlib 模块在压缩或哈希数据时就会分离 线程状态。 |  |\n|  | 非Python创建的线程\n当线程通过 Python 专用 API（如 threading 模块）创建时，系统会自动为其关联线程状态，因此\n上述代码是正确的。 然而，当线程直接从 C 创建时（例如通过自带线程管理的第三方库），这些线\n程不会持有 GIL，因为它们没有 attached thread state。\n若需从这些线程调用 Python 代码（常见于前述第三方库提供的回调 API 中），必须首先创建\nattached thread state 向解释器注册线程，然后才能使用 Python/C API。 操作完成后，应当分离 线\n程状态 并最终释放该线程。\nPyGILState_Ensure() 和 PyGILState_Release() 函数会自动完成上述的所有操作。 从 C 线程调\n用到 Python 的典型方式如下: |  |\n|  | PyGILState_STATE gstate;\ngstate = PyGILState_Ensure(); |  |\n\n/* 在此执行 Python 动作。 */\nresult = CallSomeFunction();\n/* 评估结果或处理异常 */\n/* 释放线程。 在此之后不再允许 Python API。 */\nPyGILState_Release(gstate);\n请注意 PyGILState_* 系列函数基于单全局解释器假设（由 Py_Initialize() 自动创建）。\nPython虽支持创建附加解释器（通过 Py_NewInterpreter()），但混合使用多解释器与\nPyGILState_* API 不受支持。这是因为 PyGILState_Ensure() 及类似函数默认将 thread state 附\n加 到主解释器，导致线程无法安全地与调用方的子解释器交互。\n在非Python线程中支持子解释器\n如需在非Python创建的线程中支持子解释器，必须改用 PyThreadState_* API 替代传统的\nPyGILState_* API。\n特别需要注意的是，必须从调用函数中保存解释器状态，并将其传递给 PyThreadState_New()，该\n函数会确保新建的 thread state 正确关联目标解释器:\n/* 创建该线程的函数中 PyInterpreterState_Get() 的返回值*/\nPyInterpreterState *interp = ThreadData->interp;\nPyThreadState *tstate = PyThreadState_New(interp);\nPyThreadState_Swap(tstate);\n/* 此时已持有子解释器的GIL，\n可在此执行Python操作。 */\nresult = CallSomeFunction();\n/* 评估结果或处理异常 */\n/* 销毁线程状态。此后禁止调用任何 Python API。*/\nPyThreadState_Clear(tstate);\nPyThreadState_DeleteCurrent();\n有关 fork() 的注意事项\n有关线程的另一个需要注意的重要问题是它们在面对 C fork() 调用时的行为。 在大多数支持\nfork() 的系统中，当一个进程执行 fork 之后将只有发出 fork 的线程存在。 这对需要如何处理锁以\n及CPython 的运行时内所有的存储状态都会有实质性的影响。\n只保留“当前”线程这一事实意味着任何由其他线程所持有的锁永远不会被释放。 Python 通过在 fork\n之前获取内部使用的锁，并随后释放它们的方式为 os.fork() 解决了这个问题。 此外，它还会重置\n子进程中的任何 Lock 对象。 在扩展或嵌入 Python 时，没有办法通知 Python 在 fork 之前或之后需\n要获取或重置的附加（非 Python）锁。 需要使用 OS 工具例如 pthread_atfork() 来完成同样的事\n情。 此外，在扩展或嵌入 Python 时，直接调用 fork() 而不是通过 os.fork() (并返回到或调用至\nPython 中) 调用可能会导致某个被 fork 之后失效的线程所持有的 Python 内部锁发生死锁。\nPyOS_AfterFork_Child() 会尝试重置必要的锁，但并不总是能够做到。\n所有其他线程都将结束这一事实也意味着 CPython 的运行时状态必须妥善清理，os.fork() 就是这\n样做的。 这意味着最终化归属于当前解释器的所有其他 PyThreadState 对象以及所有其他\n\n|  | /* 在此执行 Python 动作。 */\nresult = CallSomeFunction();\n/* 评估结果或处理异常 */\n/* 释放线程。 在此之后不再允许 Python API。 */\nPyGILState_Release(gstate); |  |\n| --- | --- | --- |\n|  | 请注意 PyGILState_* 系列函数基于单全局解释器假设（由 Py_Initialize() 自动创建）。\nPython虽支持创建附加解释器（通过 Py_NewInterpreter()），但混合使用多解释器与\nPyGILState_* API 不受支持。这是因为 PyGILState_Ensure() 及类似函数默认将 thread state 附\n加 到主解释器，导致线程无法安全地与调用方的子解释器交互。\n在非Python线程中支持子解释器\n如需在非Python创建的线程中支持子解释器，必须改用 PyThreadState_* API 替代传统的\nPyGILState_* API。\n特别需要注意的是，必须从调用函数中保存解释器状态，并将其传递给 PyThreadState_New()，该\n函数会确保新建的 thread state 正确关联目标解释器: |  |\n|  | /* 创建该线程的函数中 PyInterpreterState_Get() 的返回值*/\nPyInterpreterState *interp = ThreadData->interp;\nPyThreadState *tstate = PyThreadState_New(interp);\nPyThreadState_Swap(tstate);\n/* 此时已持有子解释器的GIL，\n可在此执行Python操作。 */\nresult = CallSomeFunction();\n/* 评估结果或处理异常 */\n/* 销毁线程状态。此后禁止调用任何 Python API。*/\nPyThreadState_Clear(tstate);\nPyThreadState_DeleteCurrent(); |  |\n|  | 有关 fork() 的注意事项\n有关线程的另一个需要注意的重要问题是它们在面对 C fork() 调用时的行为。 在大多数支持\nfork() 的系统中，当一个进程执行 fork 之后将只有发出 fork 的线程存在。 这对需要如何处理锁以\n及CPython 的运行时内所有的存储状态都会有实质性的影响。\n只保留“当前”线程这一事实意味着任何由其他线程所持有的锁永远不会被释放。 Python 通过在 fork\n之前获取内部使用的锁，并随后释放它们的方式为 os.fork() 解决了这个问题。 此外，它还会重置\n子进程中的任何 Lock 对象。 在扩展或嵌入 Python 时，没有办法通知 Python 在 fork 之前或之后需\n要获取或重置的附加（非 Python）锁。 需要使用 OS 工具例如 pthread_atfork() 来完成同样的事\n情。 此外，在扩展或嵌入 Python 时，直接调用 fork() 而不是通过 os.fork() (并返回到或调用至\nPython 中) 调用可能会导致某个被 fork 之后失效的线程所持有的 Python 内部锁发生死锁。\nPyOS_AfterFork_Child() 会尝试重置必要的锁，但并不总是能够做到。\n所有其他线程都将结束这一事实也意味着 CPython 的运行时状态必须妥善清理，os.fork() 就是这\n样做的。 这意味着最终化归属于当前解释器的所有其他 PyThreadState 对象以及所有其他 |  |\n\nPyInterpreterState 对象。 由于这一点以及 \"main\" 解释器 的特殊性质，fork() 应当只在该解释\n器 的 \"main\" 线程中被调用，而 CPython 全局运行时最初就是在该线程中初始化的。 只有当\nexec() 将随后立即被调用的情况是唯一的例外。\n有关运行时最终化的注意事项\n在 interpreter shutdown 的后期阶段，系统会先尝试等待非守护线程退出（此过程可能被\nKeyboardInterrupt 中断），并执行 atexit 注册的函数。 此时运行时状态会被标记为 正在终结:\nPy_IsFinalizing() 和 sys.is_finalizing() 均返回真值。 在此状态下，仅允许发起终结流程的\n终结线程 （通常为主线程）获取 GIL。\n如果非终结线程的其他线程在终结阶段尝试显式或隐式附加 thread state，该线程将进入 永久阻塞状\n态 ——直至程序退出前都无法恢复。 多数情况下这不会造成危害，但如果终结过程的后续阶段试图\n获取被阻塞线程持有的锁，或以其他方式等待该线程响应，则可能引发死锁。\n粗暴？确实如此。 但这样做能避免随机崩溃，以及当这些线程在 CPython 3.13 及更早版本中被强制\n退出时，调用栈上游可能出现的 C++ 资源未释放问题。 CPython 运行时的 thread state C API在设\n计之初就未考虑在 thread state 附加阶段提供错误报告或处理机制，因此无法优雅处理这种情况。\n若要改变现状，就需要新增稳定的 C API，并重写 CPython 生态中绝大多数 C 代码来适配这些带错\n误处理的新 API。\n高阶 API\n这些是在编写 C 扩展代码或在嵌入 Python 解释器时最常用的类型和函数：\ntype PyInterpreterState\n属于 受限 API （作为不透明的结构体）.\n该数据结构代表多个合作线程所共享的状态。 属于同一解释器的线程将共享其模块管理以及其\n他一些内部条目。 该结构体中不包含公有成员。\n最初归属于不同解释器的线程不会共享任何东西，但进程状态如可用内存、打开的文件描述符\n等等除外。 全局解释器锁也会被所有线程共享，无论它们归属于哪个解释器。\n在 3.12 版本发生变更: PEP 684 引入了 单解释器 GIL 的可能性。请参阅\nPy_NewInterpreterFromConfig()。\ntype PyThreadState\n属于 受限 API （作为不透明的结构体）.\n该数据结构代表单个线程的状态。 唯一的公有数据成员为：\nPyInterpreterState *interp\n该线程的解释器状态。\nvoid PyEval_InitThreads()\n属于 稳定 ABI.\n\n|  | PyInterpreterState 对象。 由于这一点以及 \"main\" 解释器 的特殊性质，fork() 应当只在该解释\n器 的 \"main\" 线程中被调用，而 CPython 全局运行时最初就是在该线程中初始化的。 只有当\nexec() 将随后立即被调用的情况是唯一的例外。\n有关运行时最终化的注意事项\n在 interpreter shutdown 的后期阶段，系统会先尝试等待非守护线程退出（此过程可能被\nKeyboardInterrupt 中断），并执行 atexit 注册的函数。 此时运行时状态会被标记为 正在终结:\nPy_IsFinalizing() 和 sys.is_finalizing() 均返回真值。 在此状态下，仅允许发起终结流程的\n终结线程 （通常为主线程）获取 GIL。\n如果非终结线程的其他线程在终结阶段尝试显式或隐式附加 thread state，该线程将进入 永久阻塞状\n态 ——直至程序退出前都无法恢复。 多数情况下这不会造成危害，但如果终结过程的后续阶段试图\n获取被阻塞线程持有的锁，或以其他方式等待该线程响应，则可能引发死锁。\n粗暴？确实如此。 但这样做能避免随机崩溃，以及当这些线程在 CPython 3.13 及更早版本中被强制\n退出时，调用栈上游可能出现的 C++ 资源未释放问题。 CPython 运行时的 thread state C API在设\n计之初就未考虑在 thread state 附加阶段提供错误报告或处理机制，因此无法优雅处理这种情况。\n若要改变现状，就需要新增稳定的 C API，并重写 CPython 生态中绝大多数 C 代码来适配这些带错\n误处理的新 API。\n高阶 API\n这些是在编写 C 扩展代码或在嵌入 Python 解释器时最常用的类型和函数：\ntype PyInterpreterState\n属于 受限 API （作为不透明的结构体）.\n该数据结构代表多个合作线程所共享的状态。 属于同一解释器的线程将共享其模块管理以及其\n他一些内部条目。 该结构体中不包含公有成员。\n最初归属于不同解释器的线程不会共享任何东西，但进程状态如可用内存、打开的文件描述符\n等等除外。 全局解释器锁也会被所有线程共享，无论它们归属于哪个解释器。\n在 3.12 版本发生变更: PEP 684 引入了 单解释器 GIL 的可能性。请参阅\nPy_NewInterpreterFromConfig()。\ntype PyThreadState\n属于 受限 API （作为不透明的结构体）.\n该数据结构代表单个线程的状态。 唯一的公有数据成员为：\nPyInterpreterState *interp\n该线程的解释器状态。\nvoid PyEval_InitThreads()\n属于 稳定 ABI. |  |\n| --- | --- | --- |\n\n不执行任何操作的已弃用函数。\n在 Python 3.6 及更老的版本中，此函数会在 GIL 不存在时创建它。\n在 3.9 版本发生变更: 此函数现在不执行任何操作。\n在 3.7 版本发生变更: 该函数现在由 Py_Initialize() 调用，因此你无需再自行调用它。\n在 3.2 版本发生变更: 此函数已不再被允许在 Py_Initialize() 之前调用。\n自 3.9 版本弃用.\nPyThreadState *PyEval_SaveThread()\n属于 稳定 ABI.\n分离当前线程的 attached thread state 并返回该状态对象。调 用此函数返回后，当前线程将不\n再关联任何 thread state。\nvoid PyEval_RestoreThread(PyThreadState *tstate)\n属于 稳定 ABI.\n将 attached thread state 设置为 tstate。传入的 thread state 不应 处于 已附加 状态，否则会导\n致死锁。 调用此函数返回后，tstate 将被附加到当前线程。\n备注: 当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退\n出，即便是由非 Python 创建的线程也不例外。更多详情请参考 有关运行时最终化的注意事\n项。\n在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nPyThreadState *PyThreadState_Get()\n属于 稳定 ABI.\n返回当前线程的 attached thread state。 如果线程没有已附加的线程状态（例如，当处于\nPy_BEGIN_ALLOW_THREADS 代码块内部时），则会触发致命错误 (因此调用者无需检查返回值是\n否为 NULL)。\n另请参阅 PyThreadState_GetUnchecked()。\nPyThreadState *PyThreadState_GetUnchecked()\n与 PyThreadState_Get() 类似，但如果其为 NULL 则不会杀死进程并设置致命错误。 调用方\n要负责检查结果是否为 NULL。\nAdded in version 3.13: 在 Python 3.5 到 3.12 中，此函数是私有的并且命名为\n_PyThreadState_UncheckedGet()。\nPyThreadState *PyThreadState_Swap(PyThreadState *tstate)\n\n|  | 不执行任何操作的已弃用函数。\n在 Python 3.6 及更老的版本中，此函数会在 GIL 不存在时创建它。\n在 3.9 版本发生变更: 此函数现在不执行任何操作。\n在 3.7 版本发生变更: 该函数现在由 Py_Initialize() 调用，因此你无需再自行调用它。\n在 3.2 版本发生变更: 此函数已不再被允许在 Py_Initialize() 之前调用。\n自 3.9 版本弃用.\nPyThreadState *PyEval_SaveThread()\n属于 稳定 ABI.\n分离当前线程的 attached thread state 并返回该状态对象。调 用此函数返回后，当前线程将不\n再关联任何 thread state。\nvoid PyEval_RestoreThread(PyThreadState *tstate)\n属于 稳定 ABI.\n将 attached thread state 设置为 tstate。传入的 thread state 不应 处于 已附加 状态，否则会导\n致死锁。 调用此函数返回后，tstate 将被附加到当前线程。\n备注: 当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退\n出，即便是由非 Python 创建的线程也不例外。更多详情请参考 有关运行时最终化的注意事\n项。\n在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nPyThreadState *PyThreadState_Get()\n属于 稳定 ABI.\n返回当前线程的 attached thread state。 如果线程没有已附加的线程状态（例如，当处于\nPy_BEGIN_ALLOW_THREADS 代码块内部时），则会触发致命错误 (因此调用者无需检查返回值是\n否为 NULL)。\n另请参阅 PyThreadState_GetUnchecked()。\nPyThreadState *PyThreadState_GetUnchecked()\n与 PyThreadState_Get() 类似，但如果其为 NULL 则不会杀死进程并设置致命错误。 调用方\n要负责检查结果是否为 NULL。\nAdded in version 3.13: 在 Python 3.5 到 3.12 中，此函数是私有的并且命名为\n_PyThreadState_UncheckedGet()。\nPyThreadState *PyThreadState_Swap(PyThreadState *tstate) |  |\n| --- | --- | --- |\n\n属于 稳定 ABI.\n将 attached thread state 设置为 tstate，并返回调用此函数前已附加的 thread state。\n此函数在没有 attached thread state 的情况下调用也是安全的；此时它会直接返回 NULL，表示\n之前不存在线程状态。\n参见: PyEval_ReleaseThread()\n备注: 与 PyGILState_Ensure() 类似，当运行时处于终结阶段时，调用此函数会导致线程\n挂起。\n下列函数使用线程级本地存储，并且不能兼容子解释器：\ntype PyGILState_STATE\n属于 稳定 ABI.\n由 PyGILState_Ensure() 返回并传递给 PyGILState_Release() 的值的类型。\nenumerator PyGILState_LOCKED\n当调用 PyGILState_Ensure() 时 GIL 已经被持有。\nenumerator PyGILState_UNLOCKED\n当调用 PyGILState_Ensure() 时 GIL 尚未被持有。\nPyGILState_STATE PyGILState_Ensure()\n属于 稳定 ABI.\n确保当前线程可以调用 Python C API，无论 Python 的当前状态或 attached thread state 如何。\n只要每个调用都与对 PyGILState_Release() 的调用相匹配，线程就可以根据需要多次调用此\n函数。通常，只要线程状态在调用 Release() 之前恢复到其先前状态，就可以在\nPyGILState_Ensure() 和 PyGILState_Release() 调用之间使用其他与线程相关的 API。例\n如，可以正常使用 Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS 宏。\n返回值是一个不透明的\"句柄\"，指向调用 PyGILState_Ensure() 时的 attached thread state，\n必须将其传递给 PyGILState_Release() 以确保 Python 恢复到相同状态。尽管允许递归调\n用，但这些句柄 不能 共享 — 每次对 PyGILState_Ensure() 的独立调用都必须保存其对应的\n句柄，用于后续调用 PyGILState_Release()。\n当此函数返回时，将存在一个 attached thread state，并且线程将能够调用任意 Python 代码。\n若操作失败则会引发致命错误。\n警告: 当运行时处于终结阶段时调用此函数是不安全的。这样做要么会使线程挂起直至程序\n结束，在极少数情况下还可能导致解释器完全崩溃。更多详情请参考 有关运行时最终化的注\n意事项。\n\n|  | 属于 稳定 ABI.\n将 attached thread state 设置为 tstate，并返回调用此函数前已附加的 thread state。\n此函数在没有 attached thread state 的情况下调用也是安全的；此时它会直接返回 NULL，表示\n之前不存在线程状态。\n参见: PyEval_ReleaseThread()\n备注: 与 PyGILState_Ensure() 类似，当运行时处于终结阶段时，调用此函数会导致线程\n挂起。\n下列函数使用线程级本地存储，并且不能兼容子解释器：\ntype PyGILState_STATE\n属于 稳定 ABI.\n由 PyGILState_Ensure() 返回并传递给 PyGILState_Release() 的值的类型。\nenumerator PyGILState_LOCKED\n当调用 PyGILState_Ensure() 时 GIL 已经被持有。\nenumerator PyGILState_UNLOCKED\n当调用 PyGILState_Ensure() 时 GIL 尚未被持有。\nPyGILState_STATE PyGILState_Ensure()\n属于 稳定 ABI.\n确保当前线程可以调用 Python C API，无论 Python 的当前状态或 attached thread state 如何。\n只要每个调用都与对 PyGILState_Release() 的调用相匹配，线程就可以根据需要多次调用此\n函数。通常，只要线程状态在调用 Release() 之前恢复到其先前状态，就可以在\nPyGILState_Ensure() 和 PyGILState_Release() 调用之间使用其他与线程相关的 API。例\n如，可以正常使用 Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS 宏。\n返回值是一个不透明的\"句柄\"，指向调用 PyGILState_Ensure() 时的 attached thread state，\n必须将其传递给 PyGILState_Release() 以确保 Python 恢复到相同状态。尽管允许递归调\n用，但这些句柄 不能 共享 — 每次对 PyGILState_Ensure() 的独立调用都必须保存其对应的\n句柄，用于后续调用 PyGILState_Release()。\n当此函数返回时，将存在一个 attached thread state，并且线程将能够调用任意 Python 代码。\n若操作失败则会引发致命错误。\n警告: 当运行时处于终结阶段时调用此函数是不安全的。这样做要么会使线程挂起直至程序\n结束，在极少数情况下还可能导致解释器完全崩溃。更多详情请参考 有关运行时最终化的注\n意事项。 |  |\n| --- | --- | --- |\n\n在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nvoid PyGILState_Release(PyGILState_STATE)\n属于 稳定 ABI.\n释放之前获取的任何资源。 在此调用之后，Python 的状态将与其在对相应\nPyGILState_Ensure() 调用之前的一样（但是通常此状态对调用方来说将是未知的，对\nGILState API 的使用也是如此）。\n对 PyGILState_Ensure() 的每次调用都必须与在同一线程上对 PyGILState_Release() 的调\n用相匹配。\nPyThreadState *PyGILState_GetThisThreadState()\n属于 稳定 ABI.\n获取当前线程的 attached thread state。如果当前线程尚未使用任何 GILState API，则可能返回\nNULL。 请注意，主线程始终拥有这样的线程状态，即使尚未在主线程上进行任何自动线程状态\n调用。此函数主要用作辅助/诊断工具。\n备注: This function may return non-NULL even when the thread state is detached. Prefer\nPyThreadState_Get() or PyThreadState_GetUnchecked() for most cases.\n参见: PyThreadState_Get()\nint PyGILState_Check()\n如果当前线程持有 GIL 则返回 1，否则返回 0。此函数可随时从任何线程调用。只有当线程的\n线程状态 通过 PyGILState_Ensure() 初始化后，它才会返回 1。此函数主要用作辅助/诊断工\n具。例如，在回调函数上下文或内存分配函数中，了解 GIL 是否被锁定可以让调用者执行敏感\n操作或以不同方式运行时，这个函数就会很有用。\n备注: 如果当前 Python 进程曾经创建过子解释器，则此函数 始终 返回 1。在大多数情况\n下，建议使用 PyThreadState_GetUnchecked()。\nAdded in version 3.4.\n以下的宏被使用时通常不带末尾分号；请在 Python 源代码发布包中查看示例用法。\nPy_BEGIN_ALLOW_THREADS\n属于 稳定 ABI.\n此宏会扩展为 { PyThreadState *_save; _save = PyEval_SaveThread();。 请注意它包含\n一个开头花括号；它必须与后面的 Py_END_ALLOW_THREADS 宏匹配。 有关此宏的进一步讨论请\n参阅上文。\nPy_END_ALLOW_THREADS\n\n|  | 在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nvoid PyGILState_Release(PyGILState_STATE)\n属于 稳定 ABI.\n释放之前获取的任何资源。 在此调用之后，Python 的状态将与其在对相应\nPyGILState_Ensure() 调用之前的一样（但是通常此状态对调用方来说将是未知的，对\nGILState API 的使用也是如此）。\n对 PyGILState_Ensure() 的每次调用都必须与在同一线程上对 PyGILState_Release() 的调\n用相匹配。\nPyThreadState *PyGILState_GetThisThreadState()\n属于 稳定 ABI.\n获取当前线程的 attached thread state。如果当前线程尚未使用任何 GILState API，则可能返回\nNULL。 请注意，主线程始终拥有这样的线程状态，即使尚未在主线程上进行任何自动线程状态\n调用。此函数主要用作辅助/诊断工具。\n备注: This function may return non-NULL even when the thread state is detached. Prefer\nPyThreadState_Get() or PyThreadState_GetUnchecked() for most cases.\n参见: PyThreadState_Get()\nint PyGILState_Check()\n如果当前线程持有 GIL 则返回 1，否则返回 0。此函数可随时从任何线程调用。只有当线程的\n线程状态 通过 PyGILState_Ensure() 初始化后，它才会返回 1。此函数主要用作辅助/诊断工\n具。例如，在回调函数上下文或内存分配函数中，了解 GIL 是否被锁定可以让调用者执行敏感\n操作或以不同方式运行时，这个函数就会很有用。\n备注: 如果当前 Python 进程曾经创建过子解释器，则此函数 始终 返回 1。在大多数情况\n下，建议使用 PyThreadState_GetUnchecked()。\nAdded in version 3.4.\n以下的宏被使用时通常不带末尾分号；请在 Python 源代码发布包中查看示例用法。\nPy_BEGIN_ALLOW_THREADS\n属于 稳定 ABI.\n此宏会扩展为 { PyThreadState *_save; _save = PyEval_SaveThread();。 请注意它包含\n一个开头花括号；它必须与后面的 Py_END_ALLOW_THREADS 宏匹配。 有关此宏的进一步讨论请\n参阅上文。\nPy_END_ALLOW_THREADS |  |\n| --- | --- | --- |\n\n属于 稳定 ABI.\n此宏扩展为 PyEval_RestoreThread(_save); }。 注意它包含一个右花括号；它必须与之前的\nPy_BEGIN_ALLOW_THREADS 宏匹配。 请参阅上文以进一步讨论此宏。\nPy_BLOCK_THREADS\n属于 稳定 ABI.\n这个宏扩展为 PyEval_RestoreThread(_save);: 它等价于没有关闭花括号的\nPy_END_ALLOW_THREADS。\nPy_UNBLOCK_THREADS\n属于 稳定 ABI.\n这个宏扩展为 _save = PyEval_SaveThread();: 它等价于没有开始花括号和变量声明的\nPy_BEGIN_ALLOW_THREADS。\n底层级 API\n下列所有函数都必须在 Py_Initialize() 之后被调用。\n在 3.7 版本发生变更: 现在 Py_Initialize() 会初始化 GIL 并设置一个 attached thread\nstate。\nPyInterpreterState *PyInterpreterState_New()\n属于 稳定 ABI.\n新建一个解释器状态对象。 不需要有 attached thread state，但如果有必要序列化对此函数的\n调用则可能选择有。\n引发一个不带参数的 审计事件 cpython.PyInterpreterState_New。\nvoid PyInterpreterState_Clear(PyInterpreterState *interp)\n属于 稳定 ABI.\n重置解释器状态对象中的所有信息。解释器必须存在一个 attached thread state。\n引发一个不带参数的 审计事件 cpython.PyInterpreterState_Clear。\nvoid PyInterpreterState_Delete(PyInterpreterState *interp)\n属于 稳定 ABI.\n销毁一个解释器状态对象。目标解释器 不应 存在 attached thread state。 在调用此函数之前，\n必须先调用 PyInterpreterState_Clear() 重置解释器状态。\nPyThreadState *PyThreadState_New(PyInterpreterState *interp)\n属于 稳定 ABI.\n创建一个属于指定解释器对象的新线程状态对象。此操作不需要存在 attached thread state。\n\n|  | 属于 稳定 ABI.\n此宏扩展为 PyEval_RestoreThread(_save); }。 注意它包含一个右花括号；它必须与之前的\nPy_BEGIN_ALLOW_THREADS 宏匹配。 请参阅上文以进一步讨论此宏。\nPy_BLOCK_THREADS\n属于 稳定 ABI.\n这个宏扩展为 PyEval_RestoreThread(_save);: 它等价于没有关闭花括号的\nPy_END_ALLOW_THREADS。\nPy_UNBLOCK_THREADS\n属于 稳定 ABI.\n这个宏扩展为 _save = PyEval_SaveThread();: 它等价于没有开始花括号和变量声明的\nPy_BEGIN_ALLOW_THREADS。\n底层级 API\n下列所有函数都必须在 Py_Initialize() 之后被调用。\n在 3.7 版本发生变更: 现在 Py_Initialize() 会初始化 GIL 并设置一个 attached thread\nstate。\nPyInterpreterState *PyInterpreterState_New()\n属于 稳定 ABI.\n新建一个解释器状态对象。 不需要有 attached thread state，但如果有必要序列化对此函数的\n调用则可能选择有。\n引发一个不带参数的 审计事件 cpython.PyInterpreterState_New。\nvoid PyInterpreterState_Clear(PyInterpreterState *interp)\n属于 稳定 ABI.\n重置解释器状态对象中的所有信息。解释器必须存在一个 attached thread state。\n引发一个不带参数的 审计事件 cpython.PyInterpreterState_Clear。\nvoid PyInterpreterState_Delete(PyInterpreterState *interp)\n属于 稳定 ABI.\n销毁一个解释器状态对象。目标解释器 不应 存在 attached thread state。 在调用此函数之前，\n必须先调用 PyInterpreterState_Clear() 重置解释器状态。\nPyThreadState *PyThreadState_New(PyInterpreterState *interp)\n属于 稳定 ABI.\n创建一个属于指定解释器对象的新线程状态对象。此操作不需要存在 attached thread state。 |  |\n| --- | --- | --- |\n\nvoid PyThreadState_Clear(PyThreadState *tstate)\n属于 稳定 ABI.\n重置 thread state 对象中的所有信息。 tstate 必须处于 已附加 状态。\n在 3.9 版本发生变更: This function now calls the PyThreadState.on_delete callback.\nPreviously, that happened in PyThreadState_Delete().\n在 3.13 版本发生变更: PyThreadState.on_delete 回调已被移除。\nvoid PyThreadState_Delete(PyThreadState *tstate)\n属于 稳定 ABI.\n销毁一个 thread state 对象。tstate 不应被 已附加 到任何线程。tstate 必须在之前通过调用\nPyThreadState_Clear() 进行过重置。\nvoid PyThreadState_DeleteCurrent(void)\n分离 attached thread state (该状态必须已通过先前调用 PyThreadState_Clear() 进行重置)，\n然后销毁它。\n返回时将不会有任何 thread state 处于 已附加 状态。\nPyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 的当前帧。\n返回一个 strong reference。 如果没有当前执行的帧则返回 NULL。\n另请参阅 PyEval_GetFrame()。\ntstate 不得为 NULL，并且必须处于 已附加 状态。\nAdded in version 3.9.\nuint64_t PyThreadState_GetID(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 的唯一 thread state 标识符。\ntstate 不得为 NULL，并且必须处于 已附加 状态。\nAdded in version 3.9.\nPyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 对应的解释器。\ntstate 不得为 NULL，并且必须处于 已附加 状态。\n\n|  | void PyThreadState_Clear(PyThreadState *tstate)\n属于 稳定 ABI.\n重置 thread state 对象中的所有信息。 tstate 必须处于 已附加 状态。\n在 3.9 版本发生变更: This function now calls the PyThreadState.on_delete callback.\nPreviously, that happened in PyThreadState_Delete().\n在 3.13 版本发生变更: PyThreadState.on_delete 回调已被移除。\nvoid PyThreadState_Delete(PyThreadState *tstate)\n属于 稳定 ABI.\n销毁一个 thread state 对象。tstate 不应被 已附加 到任何线程。tstate 必须在之前通过调用\nPyThreadState_Clear() 进行过重置。\nvoid PyThreadState_DeleteCurrent(void)\n分离 attached thread state (该状态必须已通过先前调用 PyThreadState_Clear() 进行重置)，\n然后销毁它。\n返回时将不会有任何 thread state 处于 已附加 状态。\nPyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 的当前帧。\n返回一个 strong reference。 如果没有当前执行的帧则返回 NULL。\n另请参阅 PyEval_GetFrame()。\ntstate 不得为 NULL，并且必须处于 已附加 状态。\nAdded in version 3.9.\nuint64_t PyThreadState_GetID(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 的唯一 thread state 标识符。\ntstate 不得为 NULL，并且必须处于 已附加 状态。\nAdded in version 3.9.\nPyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)\n属于 稳定 ABI 自 3.10 版起.\n获取 Python 线程状态 tstate 对应的解释器。\ntstate 不得为 NULL，并且必须处于 已附加 状态。 |  |\n| --- | --- | --- |\n\nAdded in version 3.9.\nvoid PyThreadState_EnterTracing(PyThreadState *tstate)\n暂停 Python 线程状态 tstate 中的追踪和性能分析。\n使用 PyThreadState_LeaveTracing() 函数来恢复它们。\nAdded in version 3.11.\nvoid PyThreadState_LeaveTracing(PyThreadState *tstate)\n恢复 Python 线程状态 tstate 中被 PyThreadState_EnterTracing() 函数暂停的追踪和性能分\n析。\n另请参阅 PyEval_SetTrace() 和 PyEval_SetProfile() 函数。\nAdded in version 3.11.\nPyInterpreterState *PyInterpreterState_Get(void)\n属于 稳定 ABI 自 3.9 版起.\n获取当前解释器。\n如果不存在 attached thread state，则触发致命错误。此函数不会返回 NULL。\nAdded in version 3.9.\nint64_t PyInterpreterState_GetID(PyInterpreterState *interp)\n属于 稳定 ABI 自 3.7 版起.\n返回解释器的唯一 ID。 如果执行过程中发生任何错误则将返回 -1 并设置错误。\n调用方必须有已附加的线程状态 attached thread state。\nAdded in version 3.7.\nPyObject *PyInterpreterState_GetDict(PyInterpreterState *interp)\n返回值：借入的引用。 属于 稳定 ABI 自 3.8 版起.\n返回一个存储解释器专属数据的字典。 如果此函数返回 NULL 则没有任何异常被引发并且调用\n方应当将解释器专属字典视为不可用。\n这不是 PyModule_GetState() 的替代，扩展仍应使用它来存储解释器专属的状态信息。\n返回的字典是从解释器借入的并将保持可用直到解释器关闭。\nAdded in version 3.8.\ntypedef PyObject *(*_PyFrameEvalFunction)(PyThreadState *tstate,\n_PyInterpreterFrame *frame, int throwflag)\n帧评估函数的类型\n\n|  | Added in version 3.9.\nvoid PyThreadState_EnterTracing(PyThreadState *tstate)\n暂停 Python 线程状态 tstate 中的追踪和性能分析。\n使用 PyThreadState_LeaveTracing() 函数来恢复它们。\nAdded in version 3.11.\nvoid PyThreadState_LeaveTracing(PyThreadState *tstate)\n恢复 Python 线程状态 tstate 中被 PyThreadState_EnterTracing() 函数暂停的追踪和性能分\n析。\n另请参阅 PyEval_SetTrace() 和 PyEval_SetProfile() 函数。\nAdded in version 3.11.\nPyInterpreterState *PyInterpreterState_Get(void)\n属于 稳定 ABI 自 3.9 版起.\n获取当前解释器。\n如果不存在 attached thread state，则触发致命错误。此函数不会返回 NULL。\nAdded in version 3.9.\nint64_t PyInterpreterState_GetID(PyInterpreterState *interp)\n属于 稳定 ABI 自 3.7 版起.\n返回解释器的唯一 ID。 如果执行过程中发生任何错误则将返回 -1 并设置错误。\n调用方必须有已附加的线程状态 attached thread state。\nAdded in version 3.7.\nPyObject *PyInterpreterState_GetDict(PyInterpreterState *interp)\n返回值：借入的引用。 属于 稳定 ABI 自 3.8 版起.\n返回一个存储解释器专属数据的字典。 如果此函数返回 NULL 则没有任何异常被引发并且调用\n方应当将解释器专属字典视为不可用。\n这不是 PyModule_GetState() 的替代，扩展仍应使用它来存储解释器专属的状态信息。\n返回的字典是从解释器借入的并将保持可用直到解释器关闭。\nAdded in version 3.8.\ntypedef PyObject *(*_PyFrameEvalFunction)(PyThreadState *tstate,\n_PyInterpreterFrame *frame, int throwflag)\n帧评估函数的类型 |  |\n| --- | --- | --- |\n\nthrowflag 形参将由生成器的 throw() 方法来使用：如为非零值，则处理当前异常。\n在 3.9 版本发生变更: 此函数现在可接受一个 tstate 形参。\n在 3.11 版本发生变更: frame 形参由 PyFrameObject* 改为 _PyInterpreterFrame*。\n_PyFrameEvalFunction\n_PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)\n获取帧评估函数。\n请参阅 PEP 523 \"Adding a frame evaluation API to CPython\"。\nAdded in version 3.9.\nvoid _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp,\n_PyFrameEvalFunction eval_frame)\n设置帧评估函数。\n请参阅 PEP 523 \"Adding a frame evaluation API to CPython\"。\nAdded in version 3.9.\nPyObject *PyThreadState_GetDict()\n返回值：借入的引用。 属于 稳定 ABI.\n返回一个字典，扩展模块可在其中存储线程特定的状态信息。 每个扩展模块应使用唯一的键来\n在此字典中存储状态。当没有 thread state 处于 已附加 状态时，调用此函数是安全的。 如果此\n函数返回 NULL，则表示没有引发异常，调用者应假定没有线程状态被附加。\nint PyThreadState_SetAsyncExc(unsigned long id, PyObject *exc)\n属于 稳定 ABI.\n在一个线程中异步引发异常。id 参数是目标线程的线程 ID；exc 是要引发的异常对象。此函数\n不会窃取对 exc 的引用。 为防止误用，必须编写自己的 C 扩展来调用此函数。必须在 attached\nthread state 下调用此函数。 返回被修改的线程状态数量；通常为 1，如果找不到线程 ID 则返\n回 0。如果 exc 为 NULL，则清除该线程的待处理异常（如果有）。 此函数不会引发任何异常。\n在 3.7 版本发生变更: id 形参的类型已从 long 变为 unsigned long。\nvoid PyEval_AcquireThread(PyThreadState *tstate)\n属于 稳定 ABI.\n将 tstate 附加 到当前线程，当前线程不能为 NULL 或者已经 附加线程状态。\n调用方线程不能已经具有 attached thread state。\n备注: 当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退\n出，即便是由非 Python 创建的线程也不例外。更多详情请参考 有关运行时最终化的注意事\n项。\n\n|  | throwflag 形参将由生成器的 throw() 方法来使用：如为非零值，则处理当前异常。\n在 3.9 版本发生变更: 此函数现在可接受一个 tstate 形参。\n在 3.11 版本发生变更: frame 形参由 PyFrameObject* 改为 _PyInterpreterFrame*。\n_PyFrameEvalFunction\n_PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)\n获取帧评估函数。\n请参阅 PEP 523 \"Adding a frame evaluation API to CPython\"。\nAdded in version 3.9.\nvoid _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp,\n_PyFrameEvalFunction eval_frame)\n设置帧评估函数。\n请参阅 PEP 523 \"Adding a frame evaluation API to CPython\"。\nAdded in version 3.9.\nPyObject *PyThreadState_GetDict()\n返回值：借入的引用。 属于 稳定 ABI.\n返回一个字典，扩展模块可在其中存储线程特定的状态信息。 每个扩展模块应使用唯一的键来\n在此字典中存储状态。当没有 thread state 处于 已附加 状态时，调用此函数是安全的。 如果此\n函数返回 NULL，则表示没有引发异常，调用者应假定没有线程状态被附加。\nint PyThreadState_SetAsyncExc(unsigned long id, PyObject *exc)\n属于 稳定 ABI.\n在一个线程中异步引发异常。id 参数是目标线程的线程 ID；exc 是要引发的异常对象。此函数\n不会窃取对 exc 的引用。 为防止误用，必须编写自己的 C 扩展来调用此函数。必须在 attached\nthread state 下调用此函数。 返回被修改的线程状态数量；通常为 1，如果找不到线程 ID 则返\n回 0。如果 exc 为 NULL，则清除该线程的待处理异常（如果有）。 此函数不会引发任何异常。\n在 3.7 版本发生变更: id 形参的类型已从 long 变为 unsigned long。\nvoid PyEval_AcquireThread(PyThreadState *tstate)\n属于 稳定 ABI.\n将 tstate 附加 到当前线程，当前线程不能为 NULL 或者已经 附加线程状态。\n调用方线程不能已经具有 attached thread state。\n备注: 当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退\n出，即便是由非 Python 创建的线程也不例外。更多详情请参考 有关运行时最终化的注意事\n项。 |  |\n| --- | --- | --- |\n\n在 3.8 版本发生变更: 已被更新为与 PyEval_RestoreThread(),\nPy_END_ALLOW_THREADS() 和 PyGILState_Ensure() 保持一致，如果在解释器正在最终\n化时被调用则会终结当前线程。\n在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nPyEval_RestoreThread() 是一个始终可用的（即使线程尚未初始化）更高层级函数。\nvoid PyEval_ReleaseThread(PyThreadState *tstate)\n属于 稳定 ABI.\n分离 attached thread state。 tstate 参数必须不为 NULL，该参数仅被用于检查它是否代表\nattached thread state --- 如果不是，则会报告一个致命级错误。\nPyEval_SaveThread() 是一个始终可用的（即使线程尚未初始化）更高层级函数。\n子解释器支持\n虽然在大多数用例中，你都只会嵌入一个单独的 Python 解释器，但某些场景需要你在同一个进程甚\n至同一个线程中创建多个独立的解释器。 子解释器让你能够做到这一点。\n“主”解释器是在运行时初始化时创建的第一个解释器。 它通常是一个进程中唯一的 Python 解释器。\n与子解释器不同，主解释器具有唯一的进程全局责任比如信号处理等。 它还负责在运行时初始化期\n间的执行并且通常还是运行时最终化期间的活动解释器。 PyInterpreterState_Main() 函数将返\n回一个指向其状态的指针。\n你可以使用 PyThreadState_Swap() 函数在子解释器之间进行切换。 你可以使用下列函数来创建和\n销毁它们：\ntype PyInterpreterConfig\n包含用于配置子解释器的大部分形参的结构体。 其值仅在 Py_NewInterpreterFromConfig()\n中被使用而绝不会被运行时所修改。\nAdded in version 3.12.\n结构体字段:\nint use_main_obmalloc\n如果该值为 0 则子解释器将使用自己的“对象”分配器状态。 否则它将使用（共享）主解释\n器的状态。\n如果该值为 0 则 check_multi_interp_extensions 必须为 1 (非零值)。 如果该值为 1\n则 gil 不可为 PyInterpreterConfig_OWN_GIL。\nint allow_fork\n如果该值为 0 则运行时将不支持在当前激活了子解释器的任何线程中 fork 进程。 否则\nfork 将不受限制。\n\n|  | 在 3.8 版本发生变更: 已被更新为与 PyEval_RestoreThread(),\nPy_END_ALLOW_THREADS() 和 PyGILState_Ensure() 保持一致，如果在解释器正在最终\n化时被调用则会终结当前线程。\n在 3.14 版本发生变更: 如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非\n终止。\nPyEval_RestoreThread() 是一个始终可用的（即使线程尚未初始化）更高层级函数。\nvoid PyEval_ReleaseThread(PyThreadState *tstate)\n属于 稳定 ABI.\n分离 attached thread state。 tstate 参数必须不为 NULL，该参数仅被用于检查它是否代表\nattached thread state --- 如果不是，则会报告一个致命级错误。\nPyEval_SaveThread() 是一个始终可用的（即使线程尚未初始化）更高层级函数。\n子解释器支持\n虽然在大多数用例中，你都只会嵌入一个单独的 Python 解释器，但某些场景需要你在同一个进程甚\n至同一个线程中创建多个独立的解释器。 子解释器让你能够做到这一点。\n“主”解释器是在运行时初始化时创建的第一个解释器。 它通常是一个进程中唯一的 Python 解释器。\n与子解释器不同，主解释器具有唯一的进程全局责任比如信号处理等。 它还负责在运行时初始化期\n间的执行并且通常还是运行时最终化期间的活动解释器。 PyInterpreterState_Main() 函数将返\n回一个指向其状态的指针。\n你可以使用 PyThreadState_Swap() 函数在子解释器之间进行切换。 你可以使用下列函数来创建和\n销毁它们：\ntype PyInterpreterConfig\n包含用于配置子解释器的大部分形参的结构体。 其值仅在 Py_NewInterpreterFromConfig()\n中被使用而绝不会被运行时所修改。\nAdded in version 3.12.\n结构体字段:\nint use_main_obmalloc\n如果该值为 0 则子解释器将使用自己的“对象”分配器状态。 否则它将使用（共享）主解释\n器的状态。\n如果该值为 0 则 check_multi_interp_extensions 必须为 1 (非零值)。 如果该值为 1\n则 gil 不可为 PyInterpreterConfig_OWN_GIL。\nint allow_fork\n如果该值为 0 则运行时将不支持在当前激活了子解释器的任何线程中 fork 进程。 否则\nfork 将不受限制。 |  |\n| --- | --- | --- |\n\n请注意当 fork 被禁止时 subprocess 模块将仍然可用。\nint allow_exec\n如果该值为 0 则运行时将不支持在当前激活了子解释器的任何线程中通过 exec (例如\nos.execv()) 替换当前进程。 否则 exec 将不受限制。\n请注意当 exec 被禁止时 subprocess 模块将仍然可用。\nint allow_threads\n如果该值为 0 则子解释器的 threading 模块将不会创建线程。 否则线程将被允许。\nint allow_daemon_threads\n如果该值为 0 则子解释器的 threading 模块将不会创建守护线程。 否则将允许守护线程\n（只要 allow_threads 是非零值）。\nint check_multi_interp_extensions\n如果该值为 0 则所有扩展模块均可在当前子解释器被激活的任何线程中被导入，包括旧式\n的 (单阶段初始化) 模块。 否则将只有多阶段初始化扩展模块 (参见 PEP 489) 可以被导\n入。 (另请参阅 Py_mod_multiple_interpreters。)\n如果 use_main_obmalloc 为 0 则该值必须为 1 (非零值)。\nint gil\n这将确定针对子解释器的 GIL 操作方式。 它可以是以下的几种之一：\nPyInterpreterConfig_DEFAULT_GIL\n使用默认选择 (PyInterpreterConfig_SHARED_GIL)。\nPyInterpreterConfig_SHARED_GIL\n使用（共享）主解释器的 GIL。\nPyInterpreterConfig_OWN_GIL\n使用子解释器自己的 GIL。\n如果该值为 PyInterpreterConfig_OWN_GIL 则\nPyInterpreterConfig.use_main_obmalloc 必须为 0。\nPyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const\nPyInterpreterConfig *config)\n新建一个子解释器。 这是一个 (几乎) 完全隔离的 Python 代码执行环境。 特别需要注意，新的\n子解释器具有全部已导入模块的隔离的、独立的版本，包括基本模块 builtins, __main__ 和\nsys 等。 已加载模块表 (sys.modules) 和模块搜索路径 (sys.path) 也是隔离的。 新环境没有\nsys.argv 变量。 它具有新的标准 I/O 流文件对象 sys.stdin, sys.stdout 和 sys.stderr (不\n过这些对象都指向相同的底层文件描述符)。\n给定的 config 控制着初始化解释器所使用的选项。\n\n|  | 请注意当 fork 被禁止时 subprocess 模块将仍然可用。\nint allow_exec\n如果该值为 0 则运行时将不支持在当前激活了子解释器的任何线程中通过 exec (例如\nos.execv()) 替换当前进程。 否则 exec 将不受限制。\n请注意当 exec 被禁止时 subprocess 模块将仍然可用。\nint allow_threads\n如果该值为 0 则子解释器的 threading 模块将不会创建线程。 否则线程将被允许。\nint allow_daemon_threads\n如果该值为 0 则子解释器的 threading 模块将不会创建守护线程。 否则将允许守护线程\n（只要 allow_threads 是非零值）。\nint check_multi_interp_extensions\n如果该值为 0 则所有扩展模块均可在当前子解释器被激活的任何线程中被导入，包括旧式\n的 (单阶段初始化) 模块。 否则将只有多阶段初始化扩展模块 (参见 PEP 489) 可以被导\n入。 (另请参阅 Py_mod_multiple_interpreters。)\n如果 use_main_obmalloc 为 0 则该值必须为 1 (非零值)。\nint gil\n这将确定针对子解释器的 GIL 操作方式。 它可以是以下的几种之一：\nPyInterpreterConfig_DEFAULT_GIL\n使用默认选择 (PyInterpreterConfig_SHARED_GIL)。\nPyInterpreterConfig_SHARED_GIL\n使用（共享）主解释器的 GIL。\nPyInterpreterConfig_OWN_GIL\n使用子解释器自己的 GIL。\n如果该值为 PyInterpreterConfig_OWN_GIL 则\nPyInterpreterConfig.use_main_obmalloc 必须为 0。\nPyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const\nPyInterpreterConfig *config)\n新建一个子解释器。 这是一个 (几乎) 完全隔离的 Python 代码执行环境。 特别需要注意，新的\n子解释器具有全部已导入模块的隔离的、独立的版本，包括基本模块 builtins, __main__ 和\nsys 等。 已加载模块表 (sys.modules) 和模块搜索路径 (sys.path) 也是隔离的。 新环境没有\nsys.argv 变量。 它具有新的标准 I/O 流文件对象 sys.stdin, sys.stdout 和 sys.stderr (不\n过这些对象都指向相同的底层文件描述符)。\n给定的 config 控制着初始化解释器所使用的选项。 |  |\n| --- | --- | --- |\n\n成功后，tstate_p 将被设为新的子解释器中创建的第一个 thread state。 该线程状态是 已附加\n的。 请注意并没有真实的线程被创建；请参阅下文有关线程状态的讨论。 如果新解释器的创建\n没有成功，则 tstate_p 将被设为 NULL；不会设置任何异常因为异常状态是存储在 attached\nthread state 中的，而它并不一定存在。\n与所有其他 Python/C API 函数一样，调用此函数前必须存在 attached thread state，但返回时\n该状态可能会被分离。 成功时，返回的线程状态将处于 已附加 状态。 如果子解释器使用自己\n的 GIL 创建，则调用解释器的 attached thread state 将被分离。 当函数返回时，新解释器的\nthread state 将 已附加 到当前线程，而先前解释器的 attached thread state 将保持分离状态。\nAdded in version 3.12.\n子解释器在彼此相互隔离，并让特定功能受限的情况下是最有效率的:\nPyInterpreterConfig config = {\n.use_main_obmalloc = 0,\n.allow_fork = 0,\n.allow_exec = 0,\n.allow_threads = 1,\n.allow_daemon_threads = 0,\n.check_multi_interp_extensions = 1,\n.gil = PyInterpreterConfig_OWN_GIL,\n};\nPyThreadState *tstate = NULL;\nPyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\n请注意该配置只会被短暂使用而不会被修改。 在初始化期间配置的值会被转换成各种\nPyInterpreterState 值。 配置的只读副本可以被内部存储于 PyInterpreterState 中。\n扩展模块将以如下方式在（子）解释器之间共享：\n对于使用多阶段初始化的模块 ，例如 PyModule_FromDefAndSpec()，将为每个解释器创建\n并初始化一个单独的模块对象。 只有 C 层级的静态和全局变量能在这些模块 对象之间共\n享。\n对于使用单阶段初始化的模块，例如 PyModule_Create()，当特定扩展被首次导入时，它将\n被正常初始化，并会保存其模块字典的一个 (浅) 拷贝。 当同一扩展被另一个 (子) 解释器导\n入时，将初始化一个新模块并填充该拷贝的内容；扩展的 init 函数不会被调用。 因此模块\n字典中的对象最终会被 (子) 解释器所共享，这可能会导致预期之外的行为 (参见下文的 Bugs\nand caveats)。\n请注意这不同于在调用 Py_FinalizeEx() 和 Py_Initialize() 完全重新初始化解释器之后\n导入扩展时所发生的情况；对于那种情况，扩展的 initmodule 函数 会被 再次调用。 与多\n阶段初始化一样，这意味着只有 C 层级的静态和全局变量能在这些模块之间共享。\nPyThreadState *Py_NewInterpreter(void)\n属于 稳定 ABI.\n\n|  | 成功后，tstate_p 将被设为新的子解释器中创建的第一个 thread state。 该线程状态是 已附加\n的。 请注意并没有真实的线程被创建；请参阅下文有关线程状态的讨论。 如果新解释器的创建\n没有成功，则 tstate_p 将被设为 NULL；不会设置任何异常因为异常状态是存储在 attached\nthread state 中的，而它并不一定存在。\n与所有其他 Python/C API 函数一样，调用此函数前必须存在 attached thread state，但返回时\n该状态可能会被分离。 成功时，返回的线程状态将处于 已附加 状态。 如果子解释器使用自己\n的 GIL 创建，则调用解释器的 attached thread state 将被分离。 当函数返回时，新解释器的\nthread state 将 已附加 到当前线程，而先前解释器的 attached thread state 将保持分离状态。\nAdded in version 3.12.\n子解释器在彼此相互隔离，并让特定功能受限的情况下是最有效率的:\nPyInterpreterConfig config = {\n.use_main_obmalloc = 0,\n.allow_fork = 0,\n.allow_exec = 0,\n.allow_threads = 1,\n.allow_daemon_threads = 0,\n.check_multi_interp_extensions = 1,\n.gil = PyInterpreterConfig_OWN_GIL,\n};\nPyThreadState *tstate = NULL;\nPyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);\nif (PyStatus_Exception(status)) {\nPy_ExitStatusException(status);\n}\n请注意该配置只会被短暂使用而不会被修改。 在初始化期间配置的值会被转换成各种\nPyInterpreterState 值。 配置的只读副本可以被内部存储于 PyInterpreterState 中。\n扩展模块将以如下方式在（子）解释器之间共享：\n对于使用多阶段初始化的模块 ，例如 PyModule_FromDefAndSpec()，将为每个解释器创建\n并初始化一个单独的模块对象。 只有 C 层级的静态和全局变量能在这些模块 对象之间共\n享。\n对于使用单阶段初始化的模块，例如 PyModule_Create()，当特定扩展被首次导入时，它将\n被正常初始化，并会保存其模块字典的一个 (浅) 拷贝。 当同一扩展被另一个 (子) 解释器导\n入时，将初始化一个新模块并填充该拷贝的内容；扩展的 init 函数不会被调用。 因此模块\n字典中的对象最终会被 (子) 解释器所共享，这可能会导致预期之外的行为 (参见下文的 Bugs\nand caveats)。\n请注意这不同于在调用 Py_FinalizeEx() 和 Py_Initialize() 完全重新初始化解释器之后\n导入扩展时所发生的情况；对于那种情况，扩展的 initmodule 函数 会被 再次调用。 与多\n阶段初始化一样，这意味着只有 C 层级的静态和全局变量能在这些模块之间共享。\nPyThreadState *Py_NewInterpreter(void)\n属于 稳定 ABI. |  |\n| --- | --- | --- |\n\n新建一个子解释器。 这在本质上只是针对 Py_NewInterpreterFromConfig() 的包装器，其配\n置保留了现有的行为。 结果是一个未隔离的子解释器，它会共享主解释器的 GIL，允许\nfork/exec，允许守护线程，也允许单阶段初始化模块。\nvoid Py_EndInterpreter(PyThreadState *tstate)\n属于 稳定 ABI.\n销毁由给定 thread state 表示的（子）解释器。给定的线程状态必须处于 已附加 状态。调用返\n回时，将不存在任何 attached thread state。 与此解释器关联的所有线程状态都会被销毁。\nPy_FinalizeEx() 将销毁所有在当前时间点上尚未被明确销毁的子解释器。\n解释器级 GIL\n使用 Py_NewInterpreterFromConfig() 你将可以创建一个与其他解释器完全隔离的子解释器，包\n括具有自己的 GIL。 这种隔离带来的最大好处在于这样的解释器执行 Python 代码时不会被其他解释\n器所阻塞或者阻塞任何其他解释器。 因此在运行 Python 代码时单个 Python 进程可以真正地利用多\n个 CPU 核心。 这种隔离还能鼓励开发者采取不同于仅使用线程的并发方式。 (参见 PEP 554 和 PEP\n684 )。\n使用隔离的解释器要求谨慎地保持隔离状态。 尤其是意味着不要在未确保线程安全的情况下共享任\n何对象或可变的状态。 由于引用计数的存在即使是在其他情况下不可变的对象 (例如 None, (1, 5))\n通常也不可被共享。 针对此问题的一种简单但效率较低的解决方式是在使用某些状态 (或对象) 时总\n是使用一个全局锁。 或者，对象实际上不可变的对象 (如整数或字符串) 可以通过将其设为 immortal\n对象而无视其引用计数来确保其安全性。 事实上，对于内置单例、小整数和其他一些内置对象都是\n这样做的。\n如果你能保持隔离状态那么你将能获得真正的多核计算能力而不会遇到自由线程所带来的复杂性。\n如果未能保持隔离状态那么你将面对自由线程所带来的全部后果，包括线程竞争和难以调试的崩\n溃。\n除此之外，使用多个相互隔离的解释器的一个主要挑战是如何在它们之间安全 (不破坏隔离状态)、\n高效地进行通信。 运行时和标准库还没有为此提供任何标准方式。 未来的标准库模块将会帮助减少\n保持隔离状态所需的工作量并为解释器之间的数据通信（和共享）公开有效的工具。\nAdded in version 3.12.\n错误和警告\n由于子解释器 (以及主解释器) 都是同一个进程的组成部分，它们之间的隔离状态并非完美 --- 举例\n来说，使用低层级的文件操作如 os.close() 时它们可能 (无意或恶意地) 影响它们各自打开的文\n件。 由于 (子) 解释器之间共享扩展的方式，某些扩展可能无法正常工作；在使用单阶段初始化或者\n(静态) 全局变量时尤其如此。 在一个子解释器中创建的对象有可能被插入到另一个 (子) 解释器的命\n名空间中；这种情况应当尽可能地避免。\n应当特别注意避免在子解释器之间共享用户自定义的函数、方法、实例或类，因为由这些对象执行\n的导入 操作可能会影响错误的已加载模块的 (子) 解释器的字典。 同样重要的一点是应当避免共享可\n\n|  | 新建一个子解释器。 这在本质上只是针对 Py_NewInterpreterFromConfig() 的包装器，其配\n置保留了现有的行为。 结果是一个未隔离的子解释器，它会共享主解释器的 GIL，允许\nfork/exec，允许守护线程，也允许单阶段初始化模块。\nvoid Py_EndInterpreter(PyThreadState *tstate)\n属于 稳定 ABI.\n销毁由给定 thread state 表示的（子）解释器。给定的线程状态必须处于 已附加 状态。调用返\n回时，将不存在任何 attached thread state。 与此解释器关联的所有线程状态都会被销毁。\nPy_FinalizeEx() 将销毁所有在当前时间点上尚未被明确销毁的子解释器。\n解释器级 GIL\n使用 Py_NewInterpreterFromConfig() 你将可以创建一个与其他解释器完全隔离的子解释器，包\n括具有自己的 GIL。 这种隔离带来的最大好处在于这样的解释器执行 Python 代码时不会被其他解释\n器所阻塞或者阻塞任何其他解释器。 因此在运行 Python 代码时单个 Python 进程可以真正地利用多\n个 CPU 核心。 这种隔离还能鼓励开发者采取不同于仅使用线程的并发方式。 (参见 PEP 554 和 PEP\n684 )。\n使用隔离的解释器要求谨慎地保持隔离状态。 尤其是意味着不要在未确保线程安全的情况下共享任\n何对象或可变的状态。 由于引用计数的存在即使是在其他情况下不可变的对象 (例如 None, (1, 5))\n通常也不可被共享。 针对此问题的一种简单但效率较低的解决方式是在使用某些状态 (或对象) 时总\n是使用一个全局锁。 或者，对象实际上不可变的对象 (如整数或字符串) 可以通过将其设为 immortal\n对象而无视其引用计数来确保其安全性。 事实上，对于内置单例、小整数和其他一些内置对象都是\n这样做的。\n如果你能保持隔离状态那么你将能获得真正的多核计算能力而不会遇到自由线程所带来的复杂性。\n如果未能保持隔离状态那么你将面对自由线程所带来的全部后果，包括线程竞争和难以调试的崩\n溃。\n除此之外，使用多个相互隔离的解释器的一个主要挑战是如何在它们之间安全 (不破坏隔离状态)、\n高效地进行通信。 运行时和标准库还没有为此提供任何标准方式。 未来的标准库模块将会帮助减少\n保持隔离状态所需的工作量并为解释器之间的数据通信（和共享）公开有效的工具。\nAdded in version 3.12.\n错误和警告\n由于子解释器 (以及主解释器) 都是同一个进程的组成部分，它们之间的隔离状态并非完美 --- 举例\n来说，使用低层级的文件操作如 os.close() 时它们可能 (无意或恶意地) 影响它们各自打开的文\n件。 由于 (子) 解释器之间共享扩展的方式，某些扩展可能无法正常工作；在使用单阶段初始化或者\n(静态) 全局变量时尤其如此。 在一个子解释器中创建的对象有可能被插入到另一个 (子) 解释器的命\n名空间中；这种情况应当尽可能地避免。\n应当特别注意避免在子解释器之间共享用户自定义的函数、方法、实例或类，因为由这些对象执行\n的导入 操作可能会影响错误的已加载模块的 (子) 解释器的字典。 同样重要的一点是应当避免共享可 |  |\n| --- | --- | --- |\n\n被上述对象访问的对象 。\n还要注意的一点是将此功能与 PyGILState_* API 结合使用是很微妙的，因为这些 API 会假定\nPython线程状态与操作系统级线程之间存在双向投影关系，而子解释器的存在打破了这一假定。 强\n烈建议你不要在一对互相匹配的 PyGILState_Ensure() 和 PyGILState_Release() 调用之间切换\n子解释器。 此外，使用这些 API 以允许从非 Python 创建的线程调用 Python 代码的扩展 (如\nctypes) 在使用子解释器时很可能会出现问题。\n异步通知\n提供了一种向主解释器线程发送异步通知的机制。 这些通知将采用函数指针和空指针参数的形式。\nint Py_AddPendingCall(int (*func)(void*), void *arg)\n属于 稳定 ABI.\n将一个函数加入从主解释器线程调用的计划任务。 成功时，将返回 0 并将 func 加入要被主线\n程调用的等待队列。 失败时，将返回 -1 但不会设置任何异常。\n当成功加入队列后，func 将 最终 附带参数 arg 被主解释器线程调用。 对于正常运行的 Python\n代码来说它将被异步地调用，但要同时满足以下两个条件：\n位于 bytecode 的边界上；\n主线程持有一个 attached thread state (因此 func 可以使用完整的 C API)。\nfunc 必须在成功时返回 0，或在失败时返回 -1 并设置一个异常集合。 func 不会被中断来递归\n地执行另一个异步通知，但如果 thread state 已被分离则它仍可被中断以切换线程。\n此函数不需要 attached thread state。 不过，要在子解释器中调用此函数，调用方必须具有\nattached thread state。 否则，函数 func 可能会被安排给错误的解释器来调用。\n警告: 这是一个低层级函数，只在非常特殊的情况下有用。 不能保证 func 会尽快被调用。\n如果主线程忙于执行某个系统调用，func 将不会在系统调用返回之前被调用。 此函数 通常\n不适合 从任意 C 线程调用 Python 代码。 作为替代，请使用 PyGILStateAPI。\nAdded in version 3.1.\n在 3.9 版本发生变更: 如果此函数在子解释器中被调用，则函数 func 将被安排在子解释器\n中调用，而不是在主解释器中调用。现在每个子解释器都有自己的计划调用列表。\n在 3.12 版本发生变更: 此函数现在总是会安排 func 在主解释器中运行。to be run in the\nmain interpreter.\n分析和跟踪\nPython 解释器为附加的性能分析和执行跟踪工具提供了一些低层级的支持。 它们可被用于性能分\n析、调试和覆盖分析工具。\n\n|  | 被上述对象访问的对象 。\n还要注意的一点是将此功能与 PyGILState_* API 结合使用是很微妙的，因为这些 API 会假定\nPython线程状态与操作系统级线程之间存在双向投影关系，而子解释器的存在打破了这一假定。 强\n烈建议你不要在一对互相匹配的 PyGILState_Ensure() 和 PyGILState_Release() 调用之间切换\n子解释器。 此外，使用这些 API 以允许从非 Python 创建的线程调用 Python 代码的扩展 (如\nctypes) 在使用子解释器时很可能会出现问题。\n异步通知\n提供了一种向主解释器线程发送异步通知的机制。 这些通知将采用函数指针和空指针参数的形式。\nint Py_AddPendingCall(int (*func)(void*), void *arg)\n属于 稳定 ABI.\n将一个函数加入从主解释器线程调用的计划任务。 成功时，将返回 0 并将 func 加入要被主线\n程调用的等待队列。 失败时，将返回 -1 但不会设置任何异常。\n当成功加入队列后，func 将 最终 附带参数 arg 被主解释器线程调用。 对于正常运行的 Python\n代码来说它将被异步地调用，但要同时满足以下两个条件：\n位于 bytecode 的边界上；\n主线程持有一个 attached thread state (因此 func 可以使用完整的 C API)。\nfunc 必须在成功时返回 0，或在失败时返回 -1 并设置一个异常集合。 func 不会被中断来递归\n地执行另一个异步通知，但如果 thread state 已被分离则它仍可被中断以切换线程。\n此函数不需要 attached thread state。 不过，要在子解释器中调用此函数，调用方必须具有\nattached thread state。 否则，函数 func 可能会被安排给错误的解释器来调用。\n警告: 这是一个低层级函数，只在非常特殊的情况下有用。 不能保证 func 会尽快被调用。\n如果主线程忙于执行某个系统调用，func 将不会在系统调用返回之前被调用。 此函数 通常\n不适合 从任意 C 线程调用 Python 代码。 作为替代，请使用 PyGILStateAPI。\nAdded in version 3.1.\n在 3.9 版本发生变更: 如果此函数在子解释器中被调用，则函数 func 将被安排在子解释器\n中调用，而不是在主解释器中调用。现在每个子解释器都有自己的计划调用列表。\n在 3.12 版本发生变更: 此函数现在总是会安排 func 在主解释器中运行。to be run in the\nmain interpreter.\n分析和跟踪\nPython 解释器为附加的性能分析和执行跟踪工具提供了一些低层级的支持。 它们可被用于性能分\n析、调试和覆盖分析工具。 |  |\n| --- | --- | --- |\n\n这个 C 接口允许性能分析或跟踪代码避免调用 Python 层级的可调用对象带来的开销，它能直接执行\nC 函数调用。 此工具的基本属性没有变化；这个接口允许针对每个线程安装跟踪函数，并且向跟踪\n函数报告的基本事件与之前版本中向 Python 层级跟踪函数报告的事件相同。\ntypedef int (*Py_tracefunc)(PyObject *obj, PyFrameObject *frame, int what,\nPyObject *arg)\n使用 PyEval_SetProfile() 和 PyEval_SetTrace() 注册的跟踪函数的类型。 第一个形参是\n作为 obj 传递给注册函数的对象，frame 是与事件相关的帧对象，what 是常量 PyTrace_CALL,\nPyTrace_EXCEPTION, PyTrace_LINE, PyTrace_RETURN, PyTrace_C_CALL,\nPyTrace_C_EXCEPTION, PyTrace_C_RETURN 或 PyTrace_OPCODE 中的一个，而 arg 将依赖于\nwhat 的值：\nwhat 的值 arg 的含义\nPyTrace_CALL 总是 Py_None.\nPyTrace_EXCEPTION sys.exc_info() 返回的异常信息。\nPyTrace_LINE 总是 Py_None.\nPyTrace_RETURN 返回给调用方的值，或者如果是由异常导致的则返回 NULL。\nPyTrace_C_CALL 正在调用函数对象。\nPyTrace_C_EXCEPTION 正在调用函数对象。\nPyTrace_C_RETURN 正在调用函数对象。\nPyTrace_OPCODE 总是 Py_None.\nint PyTrace_CALL\n当对一个函数或方法的新调用被报告，或是向一个生成器增加新条目时传给 Py_tracefunc 函\n数的 what 形参的值。 请注意针对生成器函数的迭代器的创建情况不会被报告因为在相应的帧\n中没有向 Python字节码转移控制权。\nint PyTrace_EXCEPTION\n当一个异常被引发时传给 Py_tracefunc 函数的 what 形参的值。 在处理完任何字节码之后将\n附带 what 的值调用回调函数，在此之后该异常将会被设置在正在执行的帧中。 这样做的效果\n是当异常传播导致 Python 栈展开时，被调用的回调函数将随异常传播返回到每个帧。 只有跟\n踪函数才会接收到这些事件；性能分析器并不需要它们。\nint PyTrace_LINE\n当一个行编号事件被报告时传给 Py_tracefunc 函数 (但不会传给性能分析函数) 的 what 形参\n的值。 它可以通过将 f_trace_lines 设为 0 在某个帧中被禁用。\nint PyTrace_RETURN\n当一个调用即将返回时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_CALL\n\n|  | 这个 C 接口允许性能分析或跟踪代码避免调用 Python 层级的可调用对象带来的开销，它能直接执行\nC 函数调用。 此工具的基本属性没有变化；这个接口允许针对每个线程安装跟踪函数，并且向跟踪\n函数报告的基本事件与之前版本中向 Python 层级跟踪函数报告的事件相同。\ntypedef int (*Py_tracefunc)(PyObject *obj, PyFrameObject *frame, int what,\nPyObject *arg)\n使用 PyEval_SetProfile() 和 PyEval_SetTrace() 注册的跟踪函数的类型。 第一个形参是\n作为 obj 传递给注册函数的对象，frame 是与事件相关的帧对象，what 是常量 PyTrace_CALL,\nPyTrace_EXCEPTION, PyTrace_LINE, PyTrace_RETURN, PyTrace_C_CALL,\nPyTrace_C_EXCEPTION, PyTrace_C_RETURN 或 PyTrace_OPCODE 中的一个，而 arg 将依赖于\nwhat 的值：\nwhat 的值 arg 的含义\nPyTrace_CALL 总是 Py_None.\nPyTrace_EXCEPTION sys.exc_info() 返回的异常信息。\nPyTrace_LINE 总是 Py_None.\nPyTrace_RETURN 返回给调用方的值，或者如果是由异常导致的则返回 NULL。\nPyTrace_C_CALL 正在调用函数对象。\nPyTrace_C_EXCEPTION 正在调用函数对象。\nPyTrace_C_RETURN 正在调用函数对象。\nPyTrace_OPCODE 总是 Py_None.\nint PyTrace_CALL\n当对一个函数或方法的新调用被报告，或是向一个生成器增加新条目时传给 Py_tracefunc 函\n数的 what 形参的值。 请注意针对生成器函数的迭代器的创建情况不会被报告因为在相应的帧\n中没有向 Python字节码转移控制权。\nint PyTrace_EXCEPTION\n当一个异常被引发时传给 Py_tracefunc 函数的 what 形参的值。 在处理完任何字节码之后将\n附带 what 的值调用回调函数，在此之后该异常将会被设置在正在执行的帧中。 这样做的效果\n是当异常传播导致 Python 栈展开时，被调用的回调函数将随异常传播返回到每个帧。 只有跟\n踪函数才会接收到这些事件；性能分析器并不需要它们。\nint PyTrace_LINE\n当一个行编号事件被报告时传给 Py_tracefunc 函数 (但不会传给性能分析函数) 的 what 形参\n的值。 它可以通过将 f_trace_lines 设为 0 在某个帧中被禁用。\nint PyTrace_RETURN\n当一个调用即将返回时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_CALL |  |\n| --- | --- | --- |\n\n| what 的值 | arg 的含义 |\n| --- | --- |\n| PyTrace_CALL | 总是 Py_None. |\n| PyTrace_EXCEPTION | sys.exc_info() 返回的异常信息。 |\n| PyTrace_LINE | 总是 Py_None. |\n| PyTrace_RETURN | 返回给调用方的值，或者如果是由异常导致的则返回 NULL。 |\n| PyTrace_C_CALL | 正在调用函数对象。 |\n| PyTrace_C_EXCEPTION | 正在调用函数对象。 |\n| PyTrace_C_RETURN | 正在调用函数对象。 |\n| PyTrace_OPCODE | 总是 Py_None. |\n\n当一个 C 函数即将被调用时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_EXCEPTION\n当一个 C 函数引发异常时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_RETURN\n当一个 C 函数返回时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_OPCODE\n当一个新操作码即将被执行时传给 Py_tracefunc 函数 (但不会传给性能分析函数) 的 what 形\n参的值。 在默认情况下此事件不会被发送：它必须通过在某个帧上将 f_trace_opcodes 设为\n1 来显式地请求。\nvoid PyEval_SetProfile(Py_tracefunc func, PyObject *obj)\n将性能分析器函数设为 func。 obj 形参将作为第一个形参传给该函数，它可以是任意 Python 对\n象或为 NULL。 如果性能分析函数需要维护状态，则为每个线程的 obj 使用不同的值将提供一个\n方便而线程安全的存储位置。 这个性能分析函数将针对除 PyTrace_LINE PyTrace_OPCODE 和\nPyTrace_EXCEPTION 以外的所有被监控事件进行调用。\n另请参阅 sys.setprofile() 函数。\n调用方必须有已附加的线程状态 attached thread state。\nvoid PyEval_SetProfileAllThreads(Py_tracefunc func, PyObject *obj)\n类似于 PyEval_SetProfile() 但会在属于当前解释器的所有在运行线程中设置性能分析函数\n而不是仅在当前线程上设置。\n调用方必须有已附加的线程状态 attached thread state。\n与 PyEval_SetProfile() 一样，该函数会忽略任何被引发的异常同时在所有线程中设置性能\n分析函数。\nAdded in version 3.12.\nvoid PyEval_SetTrace(Py_tracefunc func, PyObject *obj)\n将跟踪函数设为 func。 这类似于 PyEval_SetProfile()，区别在于跟踪函数会接收行编号事\n件和操作码级事件，但不会接收与被调用的 C 函数对象相关的任何事件。 使用\nPyEval_SetTrace() 注册的任何跟踪函数将不会接收 PyTrace_C_CALL、\nPyTrace_C_EXCEPTION 或 PyTrace_C_RETURN 作为 what 形参的值。\n另请参阅 sys.settrace() 函数。\n调用方必须有已附加的线程状态 attached thread state。\nvoid PyEval_SetTraceAllThreads(Py_tracefunc func, PyObject *obj)\n类似于 PyEval_SetTrace() 但会在属于当前解释器的所有在运行线程中设置跟踪函数而不是仅\n在当前线程上设置。\n\n|  | 当一个 C 函数即将被调用时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_EXCEPTION\n当一个 C 函数引发异常时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_C_RETURN\n当一个 C 函数返回时传给 Py_tracefunc 函数的 what 形参的值。\nint PyTrace_OPCODE\n当一个新操作码即将被执行时传给 Py_tracefunc 函数 (但不会传给性能分析函数) 的 what 形\n参的值。 在默认情况下此事件不会被发送：它必须通过在某个帧上将 f_trace_opcodes 设为\n1 来显式地请求。\nvoid PyEval_SetProfile(Py_tracefunc func, PyObject *obj)\n将性能分析器函数设为 func。 obj 形参将作为第一个形参传给该函数，它可以是任意 Python 对\n象或为 NULL。 如果性能分析函数需要维护状态，则为每个线程的 obj 使用不同的值将提供一个\n方便而线程安全的存储位置。 这个性能分析函数将针对除 PyTrace_LINE PyTrace_OPCODE 和\nPyTrace_EXCEPTION 以外的所有被监控事件进行调用。\n另请参阅 sys.setprofile() 函数。\n调用方必须有已附加的线程状态 attached thread state。\nvoid PyEval_SetProfileAllThreads(Py_tracefunc func, PyObject *obj)\n类似于 PyEval_SetProfile() 但会在属于当前解释器的所有在运行线程中设置性能分析函数\n而不是仅在当前线程上设置。\n调用方必须有已附加的线程状态 attached thread state。\n与 PyEval_SetProfile() 一样，该函数会忽略任何被引发的异常同时在所有线程中设置性能\n分析函数。\nAdded in version 3.12.\nvoid PyEval_SetTrace(Py_tracefunc func, PyObject *obj)\n将跟踪函数设为 func。 这类似于 PyEval_SetProfile()，区别在于跟踪函数会接收行编号事\n件和操作码级事件，但不会接收与被调用的 C 函数对象相关的任何事件。 使用\nPyEval_SetTrace() 注册的任何跟踪函数将不会接收 PyTrace_C_CALL、\nPyTrace_C_EXCEPTION 或 PyTrace_C_RETURN 作为 what 形参的值。\n另请参阅 sys.settrace() 函数。\n调用方必须有已附加的线程状态 attached thread state。\nvoid PyEval_SetTraceAllThreads(Py_tracefunc func, PyObject *obj)\n类似于 PyEval_SetTrace() 但会在属于当前解释器的所有在运行线程中设置跟踪函数而不是仅\n在当前线程上设置。 |  |\n| --- | --- | --- |\n\n调用方必须有已附加的线程状态 attached thread state。\n与 PyEval_SetTrace() 一样，该函数会忽略任何被引发的异常同时在所有线程中设置跟踪函\n数。\nAdded in version 3.12.\n引用追踪\nAdded in version 3.13.\ntypedef int (*PyRefTracer)(PyObject*, int event, void *data)\n使用 PyRefTracer_SetTracer() 注册的追踪函数的类型。 第一个形参是刚创建（当 event 被\n设为 PyRefTracer_CREATE 时）或将销毁（当 event 被设为 PyRefTracer_DESTROY 时）的\nPython 对象。 data 参数是当 PyRefTracer_SetTracer() 被调用时所提供的不透明指针。\nAdded in version 3.13.\nint PyRefTracer_CREATE\n当一个 Python 对象被创建时传给 PyRefTracer 函数的 event 形参。\nint PyRefTracer_DESTROY\n当一个 Python 对象被销毁时传给 PyRefTracer 函数的 event 形参。\nint PyRefTracer_SetTracer(PyRefTracer tracer, void *data)\n注册一个引用追踪函数。 该函数将在新的 Python 对象被创建或对象被销毁时被调用。 如果提\n供了 data 则它必须是一个当追踪函数被调用时所提供的不透明指针。 成功时返回 0。 发生错\n误时将设置一个异常并返回 -1。\n追踪函数 不可 在内部创建 Python 对象否则调用将被重入。 追踪器也 不可 清除任何现有异常\n或设置异常。 每次当追踪器被调用时都将激活一个 thread state。\n当调用此函数时必须有一个 attached thread state。\nAdded in version 3.13.\nPyRefTracer PyRefTracer_GetTracer(void **data)\n获取已注册的引用追踪函数以及当 PyRefTracer_SetTracer() 被调用时所注册的不透明数据\n指针的值。 如果未注册任何追踪器则此函数将返回 NULL 并将 data 指针设为 NULL。\n当调用此函数时必须有一个 attached thread state。\nAdded in version 3.13.\n高级调试器支持\n这些函数仅供高级调试工具使用。\nPyInterpreterState *PyInterpreterState_Head()\n\n|  | 调用方必须有已附加的线程状态 attached thread state。\n与 PyEval_SetTrace() 一样，该函数会忽略任何被引发的异常同时在所有线程中设置跟踪函\n数。\nAdded in version 3.12.\n引用追踪\nAdded in version 3.13.\ntypedef int (*PyRefTracer)(PyObject*, int event, void *data)\n使用 PyRefTracer_SetTracer() 注册的追踪函数的类型。 第一个形参是刚创建（当 event 被\n设为 PyRefTracer_CREATE 时）或将销毁（当 event 被设为 PyRefTracer_DESTROY 时）的\nPython 对象。 data 参数是当 PyRefTracer_SetTracer() 被调用时所提供的不透明指针。\nAdded in version 3.13.\nint PyRefTracer_CREATE\n当一个 Python 对象被创建时传给 PyRefTracer 函数的 event 形参。\nint PyRefTracer_DESTROY\n当一个 Python 对象被销毁时传给 PyRefTracer 函数的 event 形参。\nint PyRefTracer_SetTracer(PyRefTracer tracer, void *data)\n注册一个引用追踪函数。 该函数将在新的 Python 对象被创建或对象被销毁时被调用。 如果提\n供了 data 则它必须是一个当追踪函数被调用时所提供的不透明指针。 成功时返回 0。 发生错\n误时将设置一个异常并返回 -1。\n追踪函数 不可 在内部创建 Python 对象否则调用将被重入。 追踪器也 不可 清除任何现有异常\n或设置异常。 每次当追踪器被调用时都将激活一个 thread state。\n当调用此函数时必须有一个 attached thread state。\nAdded in version 3.13.\nPyRefTracer PyRefTracer_GetTracer(void **data)\n获取已注册的引用追踪函数以及当 PyRefTracer_SetTracer() 被调用时所注册的不透明数据\n指针的值。 如果未注册任何追踪器则此函数将返回 NULL 并将 data 指针设为 NULL。\n当调用此函数时必须有一个 attached thread state。\nAdded in version 3.13.\n高级调试器支持\n这些函数仅供高级调试工具使用。\nPyInterpreterState *PyInterpreterState_Head() |  |\n| --- | --- | --- |\n\n将解释器状态对象返回到由所有此类对象组成的列表的开头。\nPyInterpreterState *PyInterpreterState_Main()\n返回主解释器状态对象。\nPyInterpreterState *PyInterpreterState_Next(PyInterpreterState *interp)\n从由解释器状态对象组成的列表中返回 interp 之后的下一项。\nPyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *interp)\n在由与解释器 interp 相关联的线程组成的列表中返回指向第一个 PyThreadState 对象的指针。\nPyThreadState *PyThreadState_Next(PyThreadState *tstate)\n从由属于同一个 PyInterpreterState 对象的线程状态对象组成的列表中返回 tstate 之后的下\n一项。\n线程本地存储支持\nPython 解释器提供也对线程本地存储 (TLS) 的低层级支持，它对下层的原生 TLS 实现进行了包装以\n支持 Python 层级的线程本地存储 API (threading.local)。 CPython 的 C 层级 API 与 pthreads 和\nWindows 所提供的类似：使用一个线程键和函数来为每个线程关联一个 void* 值。\n当调用这些函数时 不需要 附加 一个 thread state；它们会提供自己的锁机制。\n请注意 Python.h 并不包括 TLS API 的声明，你需要包括 pythread.h 来使用线程本地存储。\n备注: 这些 API 函数都不会为 void* 的值处理内存管理问题。 你需要自己分配和释放它们。 如\n果 void* 值碰巧为 PyObject*，这些函数也不会对它们执行引用计数操作。\n线程专属存储 (TSS) API\n引入 TSSAPI 是为了取代 CPython 解释器中现有 TLS API 的使用。 该 API 使用一个新类型 Py_tss_t\n而不是 int 来表示线程键。\nAdded in version 3.7.\n参见: \"A New C-API for Thread-Local Storage in CPython\" (PEP 539)\ntype Py_tss_t\n该数据结构表示线程键的状态，其定义可能依赖于下层的 TLS 实现，并且它有一个表示键初始\n化状态的内部字段。 该结构体中不存在公有成员。\n当未定义 Py_LIMITED_API 时，允许由 Py_tss_NEEDS_INIT 执行此类型的静态分配。\nPy_tss_NEEDS_INIT\n这个宏将扩展为 Py_tss_t 变量的初始化器。 请注意这个宏不会用 Py_LIMITED_API 来定义。\n动态分配\n\n|  | 将解释器状态对象返回到由所有此类对象组成的列表的开头。\nPyInterpreterState *PyInterpreterState_Main()\n返回主解释器状态对象。\nPyInterpreterState *PyInterpreterState_Next(PyInterpreterState *interp)\n从由解释器状态对象组成的列表中返回 interp 之后的下一项。\nPyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *interp)\n在由与解释器 interp 相关联的线程组成的列表中返回指向第一个 PyThreadState 对象的指针。\nPyThreadState *PyThreadState_Next(PyThreadState *tstate)\n从由属于同一个 PyInterpreterState 对象的线程状态对象组成的列表中返回 tstate 之后的下\n一项。\n线程本地存储支持\nPython 解释器提供也对线程本地存储 (TLS) 的低层级支持，它对下层的原生 TLS 实现进行了包装以\n支持 Python 层级的线程本地存储 API (threading.local)。 CPython 的 C 层级 API 与 pthreads 和\nWindows 所提供的类似：使用一个线程键和函数来为每个线程关联一个 void* 值。\n当调用这些函数时 不需要 附加 一个 thread state；它们会提供自己的锁机制。\n请注意 Python.h 并不包括 TLS API 的声明，你需要包括 pythread.h 来使用线程本地存储。 |  |\n| --- | --- | --- |\n|  | 备注: 这些 API 函数都不会为 void* 的值处理内存管理问题。 你需要自己分配和释放它们。 如\n果 void* 值碰巧为 PyObject*，这些函数也不会对它们执行引用计数操作。 |  |\n|  | 线程专属存储 (TSS) API\n引入 TSSAPI 是为了取代 CPython 解释器中现有 TLS API 的使用。 该 API 使用一个新类型 Py_tss_t\n而不是 int 来表示线程键。\nAdded in version 3.7. |  |\n|  | 参见: \"A New C-API for Thread-Local Storage in CPython\" (PEP 539) |  |\n|  | type Py_tss_t\n该数据结构表示线程键的状态，其定义可能依赖于下层的 TLS 实现，并且它有一个表示键初始\n化状态的内部字段。 该结构体中不存在公有成员。\n当未定义 Py_LIMITED_API 时，允许由 Py_tss_NEEDS_INIT 执行此类型的静态分配。\nPy_tss_NEEDS_INIT\n这个宏将扩展为 Py_tss_t 变量的初始化器。 请注意这个宏不会用 Py_LIMITED_API 来定义。\n动态分配 |  |\n\nPy_tss_t 的动态分配，在使用 Py_LIMITED_API 编译的扩展模块中是必须的，在这些模块由于此类\n型的实现在编译时是不透明的因此它不可能静态分配。\nPy_tss_t *PyThread_tss_alloc()\n属于 稳定 ABI 自 3.7 版起.\n返回一个与使用 Py_tss_NEEDS_INIT 初始化的值的状态相同的值，或者当动态分配失败时则返\n回 NULL。\nvoid PyThread_tss_free(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n在首次调用 PyThread_tss_delete() 以确保任何相关联的线程局部变量已被撤销赋值之后释\n放由 PyThread_tss_alloc() 所分配的给定的 key。 如果 key 参数为 NULL 则这将无任何操\n作。\n备注: 被释放的 key 将变成一个悬空指针。 你应当将 key 重置为 NULL。\n方法\n这些函数的形参 key 不可为 NULL。 并且，如果给定的 Py_tss_t 还未被 PyThread_tss_create()\n初始化则 PyThread_tss_set() 和 PyThread_tss_get() 的行为将是未定义的。\nint PyThread_tss_is_created(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n如果给定的 Py_tss_t 已通过has been initialized by PyThread_tss_create() 被初始化则返回\n一个非零值。\nint PyThread_tss_create(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n当成功初始化一个 TSS 键时将返回零值。 如果 key 参数所指向的值未被 Py_tss_NEEDS_INIT\n初始化则其行为是未定义的。 此函数可在相同的键上重复调用 -- 在已初始化的键上调用它将不\n执行任何操作并立即成功返回。\nvoid PyThread_tss_delete(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n销毁一个 TSS 键以便在所有线程中遗忘与该键相关联的值，并将该键的初始化状态改为未初始\n化的。 已销毁的键可以通过 PyThread_tss_create() 再次被初始化。 此函数可以在同一个键\n上重复调用 -- 但在一个已被销毁的键上调用将是无效的。\nint PyThread_tss_set(Py_tss_t *key, void *value)\n属于 稳定 ABI 自 3.7 版起.\n返回零值来表示成功将一个 void* 值与当前线程中的 TSS 键相关联。 每个线程都有一个从键到\nvoid* 值的独立映射。\n\n|  | Py_tss_t 的动态分配，在使用 Py_LIMITED_API 编译的扩展模块中是必须的，在这些模块由于此类\n型的实现在编译时是不透明的因此它不可能静态分配。\nPy_tss_t *PyThread_tss_alloc()\n属于 稳定 ABI 自 3.7 版起.\n返回一个与使用 Py_tss_NEEDS_INIT 初始化的值的状态相同的值，或者当动态分配失败时则返\n回 NULL。\nvoid PyThread_tss_free(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n在首次调用 PyThread_tss_delete() 以确保任何相关联的线程局部变量已被撤销赋值之后释\n放由 PyThread_tss_alloc() 所分配的给定的 key。 如果 key 参数为 NULL 则这将无任何操\n作。\n备注: 被释放的 key 将变成一个悬空指针。 你应当将 key 重置为 NULL。\n方法\n这些函数的形参 key 不可为 NULL。 并且，如果给定的 Py_tss_t 还未被 PyThread_tss_create()\n初始化则 PyThread_tss_set() 和 PyThread_tss_get() 的行为将是未定义的。\nint PyThread_tss_is_created(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n如果给定的 Py_tss_t 已通过has been initialized by PyThread_tss_create() 被初始化则返回\n一个非零值。\nint PyThread_tss_create(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n当成功初始化一个 TSS 键时将返回零值。 如果 key 参数所指向的值未被 Py_tss_NEEDS_INIT\n初始化则其行为是未定义的。 此函数可在相同的键上重复调用 -- 在已初始化的键上调用它将不\n执行任何操作并立即成功返回。\nvoid PyThread_tss_delete(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n销毁一个 TSS 键以便在所有线程中遗忘与该键相关联的值，并将该键的初始化状态改为未初始\n化的。 已销毁的键可以通过 PyThread_tss_create() 再次被初始化。 此函数可以在同一个键\n上重复调用 -- 但在一个已被销毁的键上调用将是无效的。\nint PyThread_tss_set(Py_tss_t *key, void *value)\n属于 稳定 ABI 自 3.7 版起.\n返回零值来表示成功将一个 void* 值与当前线程中的 TSS 键相关联。 每个线程都有一个从键到\nvoid* 值的独立映射。 |  |\n| --- | --- | --- |\n\nvoid *PyThread_tss_get(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n返回当前线程中与一个 TSS 键相关联的 void* 值。 如果当前线程中没有与该键相关联的值则返\n回 NULL。\n线程本地存储 (TLS) API\n自 3.7 版本弃用: 此 API 已被 线程专属存储 (TSS) API 所取代。\n备注: 这个 API 版本不支持原生 TLS 键采用无法被安全转换为 int 的的定义方式的平台。 在这\n样的平台上，PyThread_create_key() 将立即返回一个失败状态，并且其他 TLS 函数在这样的平\n台上也都无效。\n由于上面提到的兼容性问题，不应在新代码中使用此版本的API。\nint PyThread_create_key()\n属于 稳定 ABI.\nvoid PyThread_delete_key(int key)\n属于 稳定 ABI.\nint PyThread_set_key_value(int key, void *value)\n属于 稳定 ABI.\nvoid *PyThread_get_key_value(int key)\n属于 稳定 ABI.\nvoid PyThread_delete_key_value(int key)\n属于 稳定 ABI.\nvoid PyThread_ReInitTLS()\n属于 稳定 ABI.\n同步原语\nC-API 提供了一个基本的互斥锁。\ntype PyMutex\n一个互斥锁。 PyMutex 应当被初始化为零以代表未加锁状态。 例如:\nPyMutex mutex = {0};\nPyMutex 的实例不应被拷贝或移动。 PyMutex 的内容和地址都是有意义的，它必须在内存中保\n持一个固定的、可写的位置。\n备注: PyMutex 目前占用一个字节，但这个大小应当被视为是不稳定的。 这个大小可能在\n未来的 Python 发布版中发生改变而不会设置弃用期。\n\n|  | void *PyThread_tss_get(Py_tss_t *key)\n属于 稳定 ABI 自 3.7 版起.\n返回当前线程中与一个 TSS 键相关联的 void* 值。 如果当前线程中没有与该键相关联的值则返\n回 NULL。\n线程本地存储 (TLS) API\n自 3.7 版本弃用: 此 API 已被 线程专属存储 (TSS) API 所取代。 |  |\n| --- | --- | --- |\n|  | 备注: 这个 API 版本不支持原生 TLS 键采用无法被安全转换为 int 的的定义方式的平台。 在这\n样的平台上，PyThread_create_key() 将立即返回一个失败状态，并且其他 TLS 函数在这样的平\n台上也都无效。 |  |\n|  | 由于上面提到的兼容性问题，不应在新代码中使用此版本的API。\nint PyThread_create_key()\n属于 稳定 ABI.\nvoid PyThread_delete_key(int key)\n属于 稳定 ABI.\nint PyThread_set_key_value(int key, void *value)\n属于 稳定 ABI.\nvoid *PyThread_get_key_value(int key)\n属于 稳定 ABI.\nvoid PyThread_delete_key_value(int key)\n属于 稳定 ABI.\nvoid PyThread_ReInitTLS()\n属于 稳定 ABI.\n同步原语\nC-API 提供了一个基本的互斥锁。\ntype PyMutex\n一个互斥锁。 PyMutex 应当被初始化为零以代表未加锁状态。 例如:\nPyMutex mutex = {0};\nPyMutex 的实例不应被拷贝或移动。 PyMutex 的内容和地址都是有意义的，它必须在内存中保\n持一个固定的、可写的位置。\n备注: PyMutex 目前占用一个字节，但这个大小应当被视为是不稳定的。 这个大小可能在\n未来的 Python 发布版中发生改变而不会设置弃用期。 |  |\n\nAdded in version 3.13.\nvoid PyMutex_Lock(PyMutex *m)\n锁定互斥锁 m。 如果另一个线程已经锁定了它，调用方线程将会阻塞直到互斥锁被解锁。 在阻\n塞期间，如果线程存在 线程状态 则会临时释放它。\nAdded in version 3.13.\nvoid PyMutex_Unlock(PyMutex *m)\n解锁互斥锁 m。 该互斥锁必须已被锁定 --- 否则，此函数将发生致命错误。\nAdded in version 3.13.\nint PyMutex_IsLocked(PyMutex *m)\n若互斥锁 m 当前处于锁定状态，则返回非零值；否则返回零。\n备注: 此函数仅适用于断言和调试场景，请勿将其用于并发控制决策，因为锁状态可能在检\n查后立即发生变化。\nAdded in version 3.14.\nPython 关键节 API\n此关键节 API 为 自由线程 CPython 的每对象锁之上提供了一个死锁避免层。 它们旨在替代对\nglobal interpreter lock 的依赖，而在具有全局解释器锁的 Python 版本上将不做任何操作。\n关键节被设计用于在 C-API 扩展中实现的自定义类型。 它们通常不应当被用于内置类型如 list 和\ndict 因为它们的公有 C-API 已经在内部使用了关键节，一个显著的例外是 PyDict_Next()，它需\n要在外部获取关键节。\n关键节是通过隐式地挂起活动关键节来避免死锁的，因此，它们并不提供传统锁如 PyMutex 所提供\n的那种独占访问。 当一个关键节启动时，将会获取对象的每对象锁。 如果关键节内部执行的代码调\n用了 C-API 函数那么它可以挂起关键节从而释放这个每对象锁，这样其他线程就可以获取同一个对\n象的每对象锁。\n此外，还提供了接受 PyMutex 指针（而非 Python 对象）的函数变体。当你处于没有 PyObject 的\n场景中时（例如，处理一个既未继承也未封装 PyObject 的 C 类型，但仍需以可能导致死锁的方式\n调用 C API），请使用这些变体来启动临界区。\n宏所使用的函数和结构体是针对 C 宏不可用的场景而公开的。 它们应当仅被用于给定的宏扩展中。\n请注意这些结构体的大小和内容在未来的 Python 版本中可能发生改变。\n备注: 需要同时锁定两个对象的操作必须使用 Py_BEGIN_CRITICAL_SECTION2。 你 不可 使用嵌\n套的关键节来同时锁定一个以上的对象，因为内层的关键节可能会挂起外层的关键节。 这个 API\n没有提供同时锁定两个以上对象的办法。\n用法示例:\n\n|  | Added in version 3.13.\nvoid PyMutex_Lock(PyMutex *m)\n锁定互斥锁 m。 如果另一个线程已经锁定了它，调用方线程将会阻塞直到互斥锁被解锁。 在阻\n塞期间，如果线程存在 线程状态 则会临时释放它。\nAdded in version 3.13.\nvoid PyMutex_Unlock(PyMutex *m)\n解锁互斥锁 m。 该互斥锁必须已被锁定 --- 否则，此函数将发生致命错误。\nAdded in version 3.13.\nint PyMutex_IsLocked(PyMutex *m)\n若互斥锁 m 当前处于锁定状态，则返回非零值；否则返回零。\n备注: 此函数仅适用于断言和调试场景，请勿将其用于并发控制决策，因为锁状态可能在检\n查后立即发生变化。\nAdded in version 3.14.\nPython 关键节 API\n此关键节 API 为 自由线程 CPython 的每对象锁之上提供了一个死锁避免层。 它们旨在替代对\nglobal interpreter lock 的依赖，而在具有全局解释器锁的 Python 版本上将不做任何操作。\n关键节被设计用于在 C-API 扩展中实现的自定义类型。 它们通常不应当被用于内置类型如 list 和\ndict 因为它们的公有 C-API 已经在内部使用了关键节，一个显著的例外是 PyDict_Next()，它需\n要在外部获取关键节。\n关键节是通过隐式地挂起活动关键节来避免死锁的，因此，它们并不提供传统锁如 PyMutex 所提供\n的那种独占访问。 当一个关键节启动时，将会获取对象的每对象锁。 如果关键节内部执行的代码调\n用了 C-API 函数那么它可以挂起关键节从而释放这个每对象锁，这样其他线程就可以获取同一个对\n象的每对象锁。\n此外，还提供了接受 PyMutex 指针（而非 Python 对象）的函数变体。当你处于没有 PyObject 的\n场景中时（例如，处理一个既未继承也未封装 PyObject 的 C 类型，但仍需以可能导致死锁的方式\n调用 C API），请使用这些变体来启动临界区。\n宏所使用的函数和结构体是针对 C 宏不可用的场景而公开的。 它们应当仅被用于给定的宏扩展中。\n请注意这些结构体的大小和内容在未来的 Python 版本中可能发生改变。 |  |\n| --- | --- | --- |\n|  | 备注: 需要同时锁定两个对象的操作必须使用 Py_BEGIN_CRITICAL_SECTION2。 你 不可 使用嵌\n套的关键节来同时锁定一个以上的对象，因为内层的关键节可能会挂起外层的关键节。 这个 API\n没有提供同时锁定两个以上对象的办法。 |  |\n|  | 用法示例: |  |\n\nstatic PyObject *\nset_field(MyObject *self, PyObject *value)\n{\nPy_BEGIN_CRITICAL_SECTION(self);\nPy_SETREF(self->field, Py_XNewRef(value));\nPy_END_CRITICAL_SECTION();\nPy_RETURN_NONE;\n}\n在上面的例子中，Py_SETREF 调用了 Py_DECREF，它可以通过一个对象的取消分配函数来调用任意\n代码。 当由最终化器触发的代码发生阻塞并调用 PyEval_SaveThread() 时关键节 API 将通过允许\n运行临时挂起关键节来避免由于重入和锁顺序导致的潜在死锁。\nPy_BEGIN_CRITICAL_SECTION(op)\n为对象 op 获取每对象锁并开始一个关键节。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection _py_cs;\nPyCriticalSection_Begin(&_py_cs, (PyObject*)(op))\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.13.\nPy_BEGIN_CRITICAL_SECTION_MUTEX(m)\n锁定互斥锁 m 并开始一个临界区。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection _py_cs;\nPyCriticalSection_BeginMutex(&_py_cs, m)\n需要注意的是，与 Py_BEGIN_CRITICAL_SECTION 不同，此宏的参数无需类型转换——它必须\n是一个 PyMutex 指针。\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.14.\nPy_END_CRITICAL_SECTION()\n结束关键节并释放每对象锁。\n在自由线程构建版中，该宏将扩展为:\nPyCriticalSection_End(&_py_cs);\n}\n在默认构建版中，该宏将扩展为 }。\n\n|  | static PyObject *\nset_field(MyObject *self, PyObject *value)\n{\nPy_BEGIN_CRITICAL_SECTION(self);\nPy_SETREF(self->field, Py_XNewRef(value));\nPy_END_CRITICAL_SECTION();\nPy_RETURN_NONE;\n} |  |\n| --- | --- | --- |\n|  | 在上面的例子中，Py_SETREF 调用了 Py_DECREF，它可以通过一个对象的取消分配函数来调用任意\n代码。 当由最终化器触发的代码发生阻塞并调用 PyEval_SaveThread() 时关键节 API 将通过允许\n运行临时挂起关键节来避免由于重入和锁顺序导致的潜在死锁。\nPy_BEGIN_CRITICAL_SECTION(op)\n为对象 op 获取每对象锁并开始一个关键节。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection _py_cs;\nPyCriticalSection_Begin(&_py_cs, (PyObject*)(op))\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.13.\nPy_BEGIN_CRITICAL_SECTION_MUTEX(m)\n锁定互斥锁 m 并开始一个临界区。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection _py_cs;\nPyCriticalSection_BeginMutex(&_py_cs, m)\n需要注意的是，与 Py_BEGIN_CRITICAL_SECTION 不同，此宏的参数无需类型转换——它必须\n是一个 PyMutex 指针。\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.14.\nPy_END_CRITICAL_SECTION()\n结束关键节并释放每对象锁。\n在自由线程构建版中，该宏将扩展为:\nPyCriticalSection_End(&_py_cs);\n}\n在默认构建版中，该宏将扩展为 }。 |  |\n\nAdded in version 3.13.\nPy_BEGIN_CRITICAL_SECTION2(a, b)\n为对象 a 和 b 获取每对象锁并开始一个关键节。 这些锁是按连续顺序获取的（最低的地址在最\n前）以避免锁顺序列死锁。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection2 _py_cs2;\nPyCriticalSection2_Begin(&_py_cs2, (PyObject*)(a), (PyObject*)(b))\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.13.\nPy_BEGIN_CRITICAL_SECTION2_MUTEX(m1, m2)\n锁定互斥锁 m1 和 m2 并开始一个临界区。\n在自由线程构建版中，该宏将扩展为:\n{\nPyCriticalSection2 _py_cs2;\nPyCriticalSection2_BeginMutex(&_py_cs2, m1, m2)\n需要注意的是，与 Py_BEGIN_CRITICAL_SECTION2 不同，此宏的参数无需类型转换——它们必\n须是 PyMutex 指针。\n在默认构建版中，该宏将扩展为 {。\nAdded in version 3.14.\nPy_END_CRITICAL_SECTION2()\n结束关键节并释放每对象锁。\n在自由线程构建版中，该宏将扩展为:\nPyCriticalSection2_End(&_py_cs2);\n}\n在默认构建版中，该宏将扩展为 }。\nAdded in version 3.13.", "metadata": {"title": "00_初始化，最终化和线程", "source": "md_docs\\python_c-api_md\\00_初始化，最终化和线程.md", "doc_type": "C API", "language": "中文", "doc_id": "3951a3f2"}}
{"doc_id": "4d20c655", "content": "定义扩展模块\n针对 CPython 的 C 扩展就是一个共享库（例如，Linux 上的 .so 文件，Windows 上的 .pyd\nDLL），它可被加载到 Python 进程中（例如，它可以用兼容的编译器设置进行编译），并且它会导\n出一个 初始化函数。\n要在默认情况下可被导入 (也就是说，通过 importlib.machinery.ExtensionFileLoader)，共享\n库必须在 sys.path 中可用，并且必须命名为模块名之后加一个在\nimportlib.machinery.EXTENSION_SUFFIXES 中列出的扩展名。\n备注: 构建、打包和分发扩展模块最好使用第三方工具完成，并且超出了本文的范围。一个合适\n的工具是Setuptools，其文档可以在 https://setuptools.pypa.io/en/latest/setuptools.html 上找\n到。\n通常，初始化函数将返回一个使用 PyModuleDef_Init() 来初始化的模块定义。 这允许将创建过程\n拆分为几个阶段：\n在任何实质性代码被执行之前，Python 可以确定该模块支持哪些功能，并且可以调整环境或者拒\n绝加载不兼容的扩展。\n默认情况下，Python 本身会创建模块对象 -- 也就是说，它所做的与类的 object.__new__() 所\n做的相当。 它还会设置一些初始属性如 __package__ 和 __loader__。\n在此之后，模块对象将使用扩展专属的代码来初始化 -- 相当于类的 __init__()。\n这被称为 多阶段初始化 以便区别旧式 (但仍受支持的) 单阶段初始化 方案，旧式方案的初始化函数\n会返回一个构造完成的模块。 请参阅下面的 单阶段初始化 小节了解详情。\n在 3.5 版本发生变更: 增加了对多阶段初始化的支持 (PEP 489)。\n多个模块实例\n在默认情况下，扩展模块都不是单例。 举例来说，如果 sys.modules 条目被移除并且模块被重新导\n入，则会创建一个新的模块对象，并且通常会以新的方法和类型对象充实其内容。 旧模块将成为正\n常垃圾回收的目标。 这类似于纯 Python 模块的行为。modules.\n额外的模块实例可能会在 子解释器 中或者 Python 运行时重新初始化之后 (Py_Finalize() 和\nPy_Initialize()) 被创建。 在这些情况下，模块实例间共享 Python 对象可能导致程序崩溃或未定\n义的行为。\n为避免这种问题，每个扩展模块的实例都应当是 隔离的: 对一个实例的修改不应隐式地影响其他的实\n例，以及模块所拥有的全部状态，包括对 Python 对象的引发，都应当是特定模块实例专属的。 请\n参阅 隔离扩展模块 了解更多的细节和实用的指南。\n一个避免这些问题的简单方式是 针对重复的初始化引发一个错误。\n\n| 定义扩展模块\n针对 CPython 的 C 扩展就是一个共享库（例如，Linux 上的 .so 文件，Windows 上的 .pyd\nDLL），它可被加载到 Python 进程中（例如，它可以用兼容的编译器设置进行编译），并且它会导\n出一个 初始化函数。\n要在默认情况下可被导入 (也就是说，通过 importlib.machinery.ExtensionFileLoader)，共享\n库必须在 sys.path 中可用，并且必须命名为模块名之后加一个在\nimportlib.machinery.EXTENSION_SUFFIXES 中列出的扩展名。 |\n| --- |\n| 备注: 构建、打包和分发扩展模块最好使用第三方工具完成，并且超出了本文的范围。一个合适\n的工具是Setuptools，其文档可以在 https://setuptools.pypa.io/en/latest/setuptools.html 上找\n到。 |\n| 通常，初始化函数将返回一个使用 PyModuleDef_Init() 来初始化的模块定义。 这允许将创建过程\n拆分为几个阶段：\n在任何实质性代码被执行之前，Python 可以确定该模块支持哪些功能，并且可以调整环境或者拒\n绝加载不兼容的扩展。\n默认情况下，Python 本身会创建模块对象 -- 也就是说，它所做的与类的 object.__new__() 所\n做的相当。 它还会设置一些初始属性如 __package__ 和 __loader__。\n在此之后，模块对象将使用扩展专属的代码来初始化 -- 相当于类的 __init__()。\n这被称为 多阶段初始化 以便区别旧式 (但仍受支持的) 单阶段初始化 方案，旧式方案的初始化函数\n会返回一个构造完成的模块。 请参阅下面的 单阶段初始化 小节了解详情。\n在 3.5 版本发生变更: 增加了对多阶段初始化的支持 (PEP 489)。\n多个模块实例\n在默认情况下，扩展模块都不是单例。 举例来说，如果 sys.modules 条目被移除并且模块被重新导\n入，则会创建一个新的模块对象，并且通常会以新的方法和类型对象充实其内容。 旧模块将成为正\n常垃圾回收的目标。 这类似于纯 Python 模块的行为。modules.\n额外的模块实例可能会在 子解释器 中或者 Python 运行时重新初始化之后 (Py_Finalize() 和\nPy_Initialize()) 被创建。 在这些情况下，模块实例间共享 Python 对象可能导致程序崩溃或未定\n义的行为。\n为避免这种问题，每个扩展模块的实例都应当是 隔离的: 对一个实例的修改不应隐式地影响其他的实\n例，以及模块所拥有的全部状态，包括对 Python 对象的引发，都应当是特定模块实例专属的。 请\n参阅 隔离扩展模块 了解更多的细节和实用的指南。\n一个避免这些问题的简单方式是 针对重复的初始化引发一个错误。 |\n\n所有模块都应当支持 子解释器，否则就要显式地发出缺乏支持的信号 。 这往往是通过隔离或阻止重\n复的初始化，如上文所述。 一个模块也可以使用 Py_mod_multiple_interpreters 槽位将其限制于\n主解释器中。\n初始化函数\n由扩展模块定义的初始化函数具有以下签名：\nPyObject *PyInit_modulename(void)\n其名称应为 PyInit_<name>，其中 <name> 要替换为模块的名称。\n对于名称仅包含 ASCII 字符的模块，函数必须被命名为 PyInit_<name>，其中 <name> 将用模块的\n名称为替换。 当使用 多阶段初始化 时，允许包含非 ASCII 字符的模块名称。 在此情况下，初始化\n函数名称为 PyInitU_<name>，其中 <name> 将使用 Python 的 punycode 编码格式来编码并将连字\n符替换为下划线。 在 Python 中：\ndef initfunc_name(name):\ntry:\nsuffix = b'_' + name.encode('ascii')\nexcept UnicodeEncodeError:\nsuffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\nreturn b'PyInit' + suffix\n建议使用一个辅助宏来定义初始化函数：\nPyMODINIT_FUNC\n声明一个扩展模块初始化函数。 这个宏：\n指定了 PyObject* 返回类型，\n添加平台所需的任何特殊链接声明，以及\n对于 C++，将函数声明为 extern \"C\"。\n例如,一个名为 spam 模块可以这样定义:\nstatic struct PyModuleDef spam_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"spam\",\n...\n};\nPyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n}\n可以通过定义多个初始化函数从一个共享库导出多个模块。 不过，导入它们需要使用符号链接或自\n定义导入器，因为默认只有与文件名对应的函数才会被发现。 请参阅 PEP 489 中的 Multiple\nmodules in one library 一节了解详情。\n\n|  | 所有模块都应当支持 子解释器，否则就要显式地发出缺乏支持的信号 。 这往往是通过隔离或阻止重\n复的初始化，如上文所述。 一个模块也可以使用 Py_mod_multiple_interpreters 槽位将其限制于\n主解释器中。\n初始化函数\n由扩展模块定义的初始化函数具有以下签名：\nPyObject *PyInit_modulename(void)\n其名称应为 PyInit_<name>，其中 <name> 要替换为模块的名称。\n对于名称仅包含 ASCII 字符的模块，函数必须被命名为 PyInit_<name>，其中 <name> 将用模块的\n名称为替换。 当使用 多阶段初始化 时，允许包含非 ASCII 字符的模块名称。 在此情况下，初始化\n函数名称为 PyInitU_<name>，其中 <name> 将使用 Python 的 punycode 编码格式来编码并将连字\n符替换为下划线。 在 Python 中： |  |\n| --- | --- | --- |\n|  | def initfunc_name(name):\ntry:\nsuffix = b'_' + name.encode('ascii')\nexcept UnicodeEncodeError:\nsuffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\nreturn b'PyInit' + suffix |  |\n|  | 建议使用一个辅助宏来定义初始化函数：\nPyMODINIT_FUNC\n声明一个扩展模块初始化函数。 这个宏：\n指定了 PyObject* 返回类型，\n添加平台所需的任何特殊链接声明，以及\n对于 C++，将函数声明为 extern \"C\"。\n例如,一个名为 spam 模块可以这样定义: |  |\n|  | static struct PyModuleDef spam_module = {\n.m_base = PyModuleDef_HEAD_INIT,\n.m_name = \"spam\",\n...\n};\nPyMODINIT_FUNC\nPyInit_spam(void)\n{\nreturn PyModuleDef_Init(&spam_module);\n} |  |\n|  | 可以通过定义多个初始化函数从一个共享库导出多个模块。 不过，导入它们需要使用符号链接或自\n定义导入器，因为默认只有与文件名对应的函数才会被发现。 请参阅 PEP 489 中的 Multiple\nmodules in one library 一节了解详情。 |  |\n\n初始化函数通常是定义于模块的 C 源代码中唯一的非 static 条目。\n多阶段初始化\n通常，初始化函数 (PyInit_modulename) 返回一个带有非 NULL 的 m_slots 的 PyModuleDef 实\n例。 在它被返回之前，这个 PyModuleDef 实例必须先使用以下函数来初始化：instance must be\ninitialized using the following function:\nPyObject *PyModuleDef_Init(PyModuleDef *def)\n属于 稳定 ABI 自 3.5 版起.\n确保模块定义是一个正确初始化的 Python 对象，并正确报告其类型以及引用计数。\n返回强制转换为 PyObject* 的 def，或者如果出生错误则返回 NULL。\n调用此函数是 多阶段初始化 所必需的。 它不应在其他上下文中被使用。\n请注意 Python 会假定 PyModuleDef 结构体是静态分配的。 此函数可以返回一个新引用或借入\n引用；这个引用不可被释放。\nAdded in version 3.5.\n旧式的单阶段初始化\n注意: 单阶段初始化是一种用于初始化扩展模块的旧机制，它具有已知的缺点和设计瑕疵。 建议\n扩展模块作者改用多阶段初始化。\n在单阶段初始化中，初始化函数 (PyInit_modulename) 应当完成模块对象的创建、填充和返回操\n作。通常使用 PyModule_Create() 和 PyModule_AddObjectRef() 等函数实现该流程。\n单阶段初始化与 默认方式 的主要区别如下：\n单阶段模块本质上是（更准确地说，包含）\"单例对象\"。\n当模块首次初始化时，Python会保存该模块 __dict__ 中的内容（通常包括模块的函数和类型\n等）。\n对于后续导入操作，Python不会再次调用初始化函数，而是创建一个带有新 __dict__ 的模块对\n象，并将已保存的内容复制到其中。例如，假设有一个单阶段模块 _testsinglephase [1] 定义了\n函数 sum 和异常类 error：\n>>> import sys\n>>> import _testsinglephase as one\n>>> del sys.modules['_testsinglephase']\n>>> import _testsinglephase as two\n>>> one is two\nFalse\n>>> one.__dict__ is two.__dict__\nFalse\n>>> one.sum is two.sum\n\n|  | 初始化函数通常是定义于模块的 C 源代码中唯一的非 static 条目。\n多阶段初始化\n通常，初始化函数 (PyInit_modulename) 返回一个带有非 NULL 的 m_slots 的 PyModuleDef 实\n例。 在它被返回之前，这个 PyModuleDef 实例必须先使用以下函数来初始化：instance must be\ninitialized using the following function:\nPyObject *PyModuleDef_Init(PyModuleDef *def)\n属于 稳定 ABI 自 3.5 版起.\n确保模块定义是一个正确初始化的 Python 对象，并正确报告其类型以及引用计数。\n返回强制转换为 PyObject* 的 def，或者如果出生错误则返回 NULL。\n调用此函数是 多阶段初始化 所必需的。 它不应在其他上下文中被使用。\n请注意 Python 会假定 PyModuleDef 结构体是静态分配的。 此函数可以返回一个新引用或借入\n引用；这个引用不可被释放。\nAdded in version 3.5.\n旧式的单阶段初始化 |  |  |\n| --- | --- | --- | --- |\n|  | 注意: 单阶段初始化是一种用于初始化扩展模块的旧机制，它具有已知的缺点和设计瑕疵。 建议\n扩展模块作者改用多阶段初始化。 |  |  |\n|  | 在单阶段初始化中，初始化函数 (PyInit_modulename) 应当完成模块对象的创建、填充和返回操\n作。通常使用 PyModule_Create() 和 PyModule_AddObjectRef() 等函数实现该流程。\n单阶段初始化与 默认方式 的主要区别如下：\n单阶段模块本质上是（更准确地说，包含）\"单例对象\"。\n当模块首次初始化时，Python会保存该模块 __dict__ 中的内容（通常包括模块的函数和类型\n等）。\n对于后续导入操作，Python不会再次调用初始化函数，而是创建一个带有新 __dict__ 的模块对\n象，并将已保存的内容复制到其中。例如，假设有一个单阶段模块 _testsinglephase [1] 定义了\n函数 sum 和异常类 error：\n>>> import sys\n>>> import _testsinglephase as one\n>>> del sys.modules['_testsinglephase']\n>>> import _testsinglephase as two\n>>> one is two\nFalse\n>>> one.__dict__ is two.__dict__\nFalse\n>>> one.sum is two.sum |  |  |\n|  |  | >>> import sys\n>>> import _testsinglephase as one\n>>> del sys.modules['_testsinglephase']\n>>> import _testsinglephase as two\n>>> one is two\nFalse\n>>> one.__dict__ is two.__dict__\nFalse\n>>> one.sum is two.sum |  |\n\nTrue\n>>> one.error is two.error\nTrue\n该具体行为应被视为CPython的实现细节。\n为解决 PyInit_modulename 函数不接受 spec 参数的限制，导入机制会保存部分状态，并在\nPyInit_modulename 调用期间将其应用于首个匹配的模块对象。具体表现为：当导入子模块时，\n该机制会将父包名称自动前置到模块名前。\n单阶段 PyInit_modulename 函数应当尽早创建\"其所属\"模块对象，该操作需在任何其他模块对象\n创建之前完成。\n不支持非ASCII模块命名格式（如 PyInitU_modulename）。\n单阶段模块支持模块查找函数如 PyState_FindModule()。\n[1] _testsinglephase 是一个在 CPython 的自我测试套件中使用的内部模块；你的安装版可能包\n括它也可能不包括它。\n\n| True\n>>> one.error is two.error\nTrue\n该具体行为应被视为CPython的实现细节。\n为解决 PyInit_modulename 函数不接受 spec 参数的限制，导入机制会保存部分状态，并在\nPyInit_modulename 调用期间将其应用于首个匹配的模块对象。具体表现为：当导入子模块时，\n该机制会将父包名称自动前置到模块名前。\n单阶段 PyInit_modulename 函数应当尽早创建\"其所属\"模块对象，该操作需在任何其他模块对象\n创建之前完成。\n不支持非ASCII模块命名格式（如 PyInitU_modulename）。\n单阶段模块支持模块查找函数如 PyState_FindModule()。\n[1] _testsinglephase 是一个在 CPython 的自我测试套件中使用的内部模块；你的安装版可能包\n括它也可能不包括它。 | True\n>>> one.error is two.error\nTrue |\n| --- | --- |", "metadata": {"title": "00_定义扩展模块", "source": "md_docs\\python_c-api_md\\00_定义扩展模块.md", "doc_type": "C API", "language": "中文", "doc_id": "4d20c655"}}
{"doc_id": "d240fa80", "content": "对象实现支持\n本章描述了定义新对象类型时所使用的函数、类型和宏。\n在堆上分配对象\n对象生命周期\n生命周期事件\n循环隔离销毁\n函数\n公用对象结构体\n基本的对象类型和宏\n实现函数和方法\n访问扩展类型的属性\n成员旗标\n成员类型\n定义读取器和设置器\n类型对象结构体\n快速参考\n\"tp 槽位\"\n子槽位\n槽位 typedef\nPyTypeObject 定义\nPyObject 槽位\nPyVarObject 槽位\nPyTypeObject 槽\n静态类型\n堆类型\n数字对象结构体\n映射对象结构体\n序列对象结构体\n缓冲区对象结构体\n异步对象结构体\n槽位类型 typedef\n例子\n使对象类型支持循环垃圾回收\n控制垃圾回收器状态\n查询垃圾回收器状态", "metadata": {"title": "00_对象实现支持", "source": "md_docs\\python_c-api_md\\00_对象实现支持.md", "doc_type": "C API", "language": "中文", "doc_id": "d240fa80"}}
{"doc_id": "c7e58ed7", "content": "工具\n本章中的函数执行各种实用工具任务，包括帮助 C 代码提升跨平台可移植性，在 C 中使用 Python\n模块，以及解析函数参数并根据 C 中的值构建 Python 中的值等等。\n操作系统实用工具\n系统功能\n过程控制\n导入模块\n数据 marshal 操作支持\n解析参数并构建值变量\n解析参数\n字符串和缓存区\n数字\n其他对象\nAPI 函数\n创建变量\n字符串转换与格式化\nPyHash API\n反射\n编解码器注册与支持功能\nCodec 查找API\n用于Unicode编码错误处理程序的注册表API\nPyTime C API\n类型\n时钟函数\n原始时钟函数\n转换函数\n对 Perf Maps 的支持", "metadata": {"title": "00_工具", "source": "md_docs\\python_c-api_md\\00_工具.md", "doc_type": "C API", "language": "中文", "doc_id": "c7e58ed7"}}
{"doc_id": "25f1189a", "content": "异常处理\n本章描述的函数将让你处理和触发 Python 异常。 了解一些 Python 异常处理的基础知识是很重要\n的。 它的工作原理有点像 POSIX errno 变量: (每个线程) 有一个最近发生的错误的全局指示器。 大\n多数 C API 函数在成功执行时将不理会它。 大多数 C API 函数也会返回一个错误指示器，如果它们\n应当返回一个指针则会返回 NULL，或者如果它们应当返回一个整数则会返回 -1 (例外情况:\nPyArg_* 函数返回 1 表示成功而 0 表示失败)。\n具体地说，错误指示器由三个对象指针组成：异常的类型，异常的值，和回溯对象。如果没有错误\n被设置，这些指针都可以是 NULL （尽管一些组合使禁止的，例如，如果异常类型是 NULL，你不能\n有一个非 NULL 的回溯）。\n当一个函数由于它调用的某个函数失败而必须失败时，通常不会设置错误指示器；它调用的那个函\n数已经设置了它。而它负责处理错误和清理异常，或在清除其拥有的所有资源后返回（如对象应用\n或内存分配）。如果不准备处理异常，则 不 应该正常地继续。如果是由于一个错误返回，那么一定\n要向调用者表明已经设置了错误。如果错误没有得到处理或小心传播，对 Python/C API的其它调用\n可能不会有预期的行为，并且可能会以某种神秘的方式失败。\n备注: 错误指示器 不是 sys.exc_info() 的执行结果。 前者对应于尚未捕获（因而仍在传播）\n的异常，而后者会在异常被捕获之后（因而已停止传播）返回它。\n打印和清理\nvoid PyErr_Clear()\n属于 稳定 ABI.\n清除错误指示器。如果没有设置错误指示器，则不会有作用。\nvoid PyErr_PrintEx(int set_sys_last_vars)\n属于 稳定 ABI.\n将标准回溯打印到 sys.stderr 并清除错误指示器。除非 错误是 SystemExit，这种情况下不\n会打印回溯进程，且会退出 Python 进程，并显示 SystemExit 实例指定的错误代码。\n只有在错误指示器被设置时才需要调用这个函数，否则这会导致错误！\n如果 set_sys_last_vars 为非零值，则变量 sys.last_exc 将被设为要打印的异常。 出于向下兼\n容性考虑，已弃用的变量 sys.last_type, sys.last_value 和 sys.last_traceback 也会被\n分别设为该异常的类型, 值和回溯。\n在 3.12 版本发生变更: 增加了对 sys.last_exc 的设置。\nvoid PyErr_Print()\n\n| 异常处理\n本章描述的函数将让你处理和触发 Python 异常。 了解一些 Python 异常处理的基础知识是很重要\n的。 它的工作原理有点像 POSIX errno 变量: (每个线程) 有一个最近发生的错误的全局指示器。 大\n多数 C API 函数在成功执行时将不理会它。 大多数 C API 函数也会返回一个错误指示器，如果它们\n应当返回一个指针则会返回 NULL，或者如果它们应当返回一个整数则会返回 -1 (例外情况:\nPyArg_* 函数返回 1 表示成功而 0 表示失败)。\n具体地说，错误指示器由三个对象指针组成：异常的类型，异常的值，和回溯对象。如果没有错误\n被设置，这些指针都可以是 NULL （尽管一些组合使禁止的，例如，如果异常类型是 NULL，你不能\n有一个非 NULL 的回溯）。\n当一个函数由于它调用的某个函数失败而必须失败时，通常不会设置错误指示器；它调用的那个函\n数已经设置了它。而它负责处理错误和清理异常，或在清除其拥有的所有资源后返回（如对象应用\n或内存分配）。如果不准备处理异常，则 不 应该正常地继续。如果是由于一个错误返回，那么一定\n要向调用者表明已经设置了错误。如果错误没有得到处理或小心传播，对 Python/C API的其它调用\n可能不会有预期的行为，并且可能会以某种神秘的方式失败。 |\n| --- |\n| 备注: 错误指示器 不是 sys.exc_info() 的执行结果。 前者对应于尚未捕获（因而仍在传播）\n的异常，而后者会在异常被捕获之后（因而已停止传播）返回它。 |\n| 打印和清理\nvoid PyErr_Clear()\n属于 稳定 ABI.\n清除错误指示器。如果没有设置错误指示器，则不会有作用。\nvoid PyErr_PrintEx(int set_sys_last_vars)\n属于 稳定 ABI.\n将标准回溯打印到 sys.stderr 并清除错误指示器。除非 错误是 SystemExit，这种情况下不\n会打印回溯进程，且会退出 Python 进程，并显示 SystemExit 实例指定的错误代码。\n只有在错误指示器被设置时才需要调用这个函数，否则这会导致错误！\n如果 set_sys_last_vars 为非零值，则变量 sys.last_exc 将被设为要打印的异常。 出于向下兼\n容性考虑，已弃用的变量 sys.last_type, sys.last_value 和 sys.last_traceback 也会被\n分别设为该异常的类型, 值和回溯。\n在 3.12 版本发生变更: 增加了对 sys.last_exc 的设置。\nvoid PyErr_Print() |\n\n属于 稳定 ABI.\nPyErr_PrintEx(1) 的别名。\nvoid PyErr_WriteUnraisable(PyObject *obj)\n属于 稳定 ABI.\n使用当前异常和 obj 参数调用 sys.unraisablehook()。\n当异常已被设置但解释器不可能实际引发该异常时，这个工具函数会向 sys.stderr 打印一条\n警告消息。 例如，当异常发生在 __del__() 方法中时就会使用该函数。\n该函数调用时将传入单个参数 obj，它标识发生不可引发的异常所在的上下文。 如果可能，obj\n的表示形式将打印在警告消息中。 如果 obj 为 NULL，将只打印回溯。\n调用此函数时必须设置一个异常。\n在 3.4 版本发生变更: 打印回溯信息。 如果 obj 为 NULL 将只打印回溯。\n在 3.8 版本发生变更: 使用 sys.unraisablehook()。\nvoid PyErr_FormatUnraisable(const char *format, ...)\n与 PyErr_WriteUnraisable() 类似，但 format 和后续的形参有助于格式化警告消息；它们的\n含义和值与 PyUnicode_FromFormat() 中的相同。 PyErr_WriteUnraisable(obj) 大致等价\n于 PyErr_FormatUnraisable(\"Exception ignored in: %R\", obj)。 如果 format 为\nNULL，则只打印回溯信息。\nAdded in version 3.13.\nvoid PyErr_DisplayException(PyObject *exc)\n属于 稳定 ABI 自 3.12 版起.\n将 exc 的标准回溯显示打印到 sys.stderr，包括链式异常和注释。\nAdded in version 3.12.\n抛出异常\n这些函数可帮助你设置当前线程的错误指示器。为了方便起见，一些函数将始终返回 NULL 指针，以\n便用于 return 语句。\nvoid PyErr_SetString(PyObject *type, const char *message)\n属于 稳定 ABI.\n这是设置错误指示器最常用的方式。 第一个参数指定异常类型；它通常为某个标准异常，例如\nPyExc_RuntimeError。 你无需为其创建新的 strong reference (例如使用 Py_INCREF())。 第\n二个参数是一条错误消息；它是用 'utf-8' 解码的。\nvoid PyErr_SetObject(PyObject *type, PyObject *value)\n\n|  | 属于 稳定 ABI.\nPyErr_PrintEx(1) 的别名。\nvoid PyErr_WriteUnraisable(PyObject *obj)\n属于 稳定 ABI.\n使用当前异常和 obj 参数调用 sys.unraisablehook()。\n当异常已被设置但解释器不可能实际引发该异常时，这个工具函数会向 sys.stderr 打印一条\n警告消息。 例如，当异常发生在 __del__() 方法中时就会使用该函数。\n该函数调用时将传入单个参数 obj，它标识发生不可引发的异常所在的上下文。 如果可能，obj\n的表示形式将打印在警告消息中。 如果 obj 为 NULL，将只打印回溯。\n调用此函数时必须设置一个异常。\n在 3.4 版本发生变更: 打印回溯信息。 如果 obj 为 NULL 将只打印回溯。\n在 3.8 版本发生变更: 使用 sys.unraisablehook()。\nvoid PyErr_FormatUnraisable(const char *format, ...)\n与 PyErr_WriteUnraisable() 类似，但 format 和后续的形参有助于格式化警告消息；它们的\n含义和值与 PyUnicode_FromFormat() 中的相同。 PyErr_WriteUnraisable(obj) 大致等价\n于 PyErr_FormatUnraisable(\"Exception ignored in: %R\", obj)。 如果 format 为\nNULL，则只打印回溯信息。\nAdded in version 3.13.\nvoid PyErr_DisplayException(PyObject *exc)\n属于 稳定 ABI 自 3.12 版起.\n将 exc 的标准回溯显示打印到 sys.stderr，包括链式异常和注释。\nAdded in version 3.12.\n抛出异常\n这些函数可帮助你设置当前线程的错误指示器。为了方便起见，一些函数将始终返回 NULL 指针，以\n便用于 return 语句。\nvoid PyErr_SetString(PyObject *type, const char *message)\n属于 稳定 ABI.\n这是设置错误指示器最常用的方式。 第一个参数指定异常类型；它通常为某个标准异常，例如\nPyExc_RuntimeError。 你无需为其创建新的 strong reference (例如使用 Py_INCREF())。 第\n二个参数是一条错误消息；它是用 'utf-8' 解码的。\nvoid PyErr_SetObject(PyObject *type, PyObject *value) |  |\n| --- | --- | --- |\n\n属于 稳定 ABI.\n此函数类似于 PyErr_SetString()，但是允许你为异常的“值”指定任意一个 Python 对象。\nPyObject *PyErr_Format(PyObject *exception, const char *format, ...)\n返回值：恒为 NULL。 属于 稳定 ABI.\n这个函数设置了一个错误指示器并且返回了 NULL，exception 应当是一个 Python 中的异常类。\nformat 和随后的形参会帮助格式化这个错误的信息；它们与 PyUnicode_FromFormat() 有着相\n同的含义和值。format 是一个ASCII编码的字符串。\nPyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list\nvargs)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.5 版起.\n和 PyErr_Format() 相同，但它接受一个 va_list 类型的参数而不是可变数量的参数集。\nAdded in version 3.5.\nvoid PyErr_SetNone(PyObject *type)\n属于 稳定 ABI.\n这是 PyErr_SetObject(type, Py_None) 的简写。\nint PyErr_BadArgument()\n属于 稳定 ABI.\n这是 PyErr_SetString(PyExc_TypeError, message) 的简写，其中 message 指出使用了非法\n参数调用内置操作。它主要用于内部使用。\nPyObject *PyErr_NoMemory()\n返回值：恒为 NULL。 属于 稳定 ABI.\n这是 PyErr_SetNone(PyExc_MemoryError) 的简写；它返回 NULL ，以便当内存耗尽时，对象\n分配函数可以写 return PyErr_NoMemory(); 。\nPyObject *PyErr_SetFromErrno(PyObject *type)\n返回值：恒为 NULL。 属于 稳定 ABI.\n这是一个便捷函数，当在 C 库函数返回错误并设置 C 变量 errno 时它会引发一个异常。 它构\n造了一个元组对象，其第一项是整数值 errno 而第二项是对应的错误信息（从 strerror() 获\n取），然后调用 PyErr_SetObject(type, object)。 在 Unix 上，当 errno 的值为 EINTR\n时，表示有一个中断的系统调用，这将会调用 PyErr_CheckSignals()，如果它设置了错误指\n示符，则让其保持该设置。 该函数总是返回 NULL，因此当系统调用返回错误时该系统调用的\n包装函数可以写入 return PyErr_SetFromErrno(type);。\nPyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *type, PyObject\n*filenameObject)\n返回值：恒为 NULL。 属于 稳定 ABI.\n\n|  | 属于 稳定 ABI.\n此函数类似于 PyErr_SetString()，但是允许你为异常的“值”指定任意一个 Python 对象。\nPyObject *PyErr_Format(PyObject *exception, const char *format, ...)\n返回值：恒为 NULL。 属于 稳定 ABI.\n这个函数设置了一个错误指示器并且返回了 NULL，exception 应当是一个 Python 中的异常类。\nformat 和随后的形参会帮助格式化这个错误的信息；它们与 PyUnicode_FromFormat() 有着相\n同的含义和值。format 是一个ASCII编码的字符串。\nPyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list\nvargs)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.5 版起.\n和 PyErr_Format() 相同，但它接受一个 va_list 类型的参数而不是可变数量的参数集。\nAdded in version 3.5.\nvoid PyErr_SetNone(PyObject *type)\n属于 稳定 ABI.\n这是 PyErr_SetObject(type, Py_None) 的简写。\nint PyErr_BadArgument()\n属于 稳定 ABI.\n这是 PyErr_SetString(PyExc_TypeError, message) 的简写，其中 message 指出使用了非法\n参数调用内置操作。它主要用于内部使用。\nPyObject *PyErr_NoMemory()\n返回值：恒为 NULL。 属于 稳定 ABI.\n这是 PyErr_SetNone(PyExc_MemoryError) 的简写；它返回 NULL ，以便当内存耗尽时，对象\n分配函数可以写 return PyErr_NoMemory(); 。\nPyObject *PyErr_SetFromErrno(PyObject *type)\n返回值：恒为 NULL。 属于 稳定 ABI.\n这是一个便捷函数，当在 C 库函数返回错误并设置 C 变量 errno 时它会引发一个异常。 它构\n造了一个元组对象，其第一项是整数值 errno 而第二项是对应的错误信息（从 strerror() 获\n取），然后调用 PyErr_SetObject(type, object)。 在 Unix 上，当 errno 的值为 EINTR\n时，表示有一个中断的系统调用，这将会调用 PyErr_CheckSignals()，如果它设置了错误指\n示符，则让其保持该设置。 该函数总是返回 NULL，因此当系统调用返回错误时该系统调用的\n包装函数可以写入 return PyErr_SetFromErrno(type);。\nPyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *type, PyObject\n*filenameObject)\n返回值：恒为 NULL。 属于 稳定 ABI. |  |\n| --- | --- | --- |\n\n与 PyErr_SetFromErrno() 类似，但如果 filenameObject 不为 NULL，它将作为第三个参数传\n递给 type 的构造函数。 在 OSError 异常的情况下，它将被用于定义异常实例的 filename 属\n性。\nPyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *type, PyObject\n*filenameObject, PyObject *filenameObject2)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.7 版起.\n类似于 PyErr_SetFromErrnoWithFilenameObject() ，但接受第二个 filename 对象，用于当\n一个接受两个 filename 的函数失败时触发错误。\nAdded in version 3.4.\nPyObject *PyErr_SetFromErrnoWithFilename(PyObject *type, const char\n*filename)\n返回值：恒为 NULL。 属于 稳定 ABI.\n类似于 PyErr_SetFromErrnoWithFilenameObject()，但文件名以 C 字符串形式给出。\nfilename 是用 filesystem encoding and error handler 解码的。\nPyObject *PyErr_SetFromWindowsErr(int ierr)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n这是一个用于引发 OSError 的便捷函数。 如果调用时传入的 ierr 值为 0，则会改用对\nGetLastError() 的调用所返回的错误代码。 它将调用 Win32 函数 FormatMessage() 来获取\nierr 或 GetLastError() 所给出的错误代码的 Windows 描述，然后构造一个 OSError 对象，\n其中 winerror 属性将设为该错误代码，strerror 属性将设为相应的错误消息（从\nFormatMessage() 获得），然后再调用 PyErr_SetObject(PyExc_OSError, object)。 该函\n数将总是返回 NULL。\nAvailability: Windows.\nPyObject *PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetFromWindowsErr() ，额外的参数指定要触发的异常类型。\nAvailability: Windows.\nPyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char\n*filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n与 PyErr_SetFromWindowsErr() 类似，额外的不同点是如果 filename 不为 NULL ，则会使用\n文件系统编码格式 (os.fsdecode()) 进行解码并作为第三个参数传递给 OSError 的构造器用于\n定义异常实例的 filename 属性。\nAvailability: Windows.\n\n|  | 与 PyErr_SetFromErrno() 类似，但如果 filenameObject 不为 NULL，它将作为第三个参数传\n递给 type 的构造函数。 在 OSError 异常的情况下，它将被用于定义异常实例的 filename 属\n性。\nPyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *type, PyObject\n*filenameObject, PyObject *filenameObject2)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.7 版起.\n类似于 PyErr_SetFromErrnoWithFilenameObject() ，但接受第二个 filename 对象，用于当\n一个接受两个 filename 的函数失败时触发错误。\nAdded in version 3.4.\nPyObject *PyErr_SetFromErrnoWithFilename(PyObject *type, const char\n*filename)\n返回值：恒为 NULL。 属于 稳定 ABI.\n类似于 PyErr_SetFromErrnoWithFilenameObject()，但文件名以 C 字符串形式给出。\nfilename 是用 filesystem encoding and error handler 解码的。\nPyObject *PyErr_SetFromWindowsErr(int ierr)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n这是一个用于引发 OSError 的便捷函数。 如果调用时传入的 ierr 值为 0，则会改用对\nGetLastError() 的调用所返回的错误代码。 它将调用 Win32 函数 FormatMessage() 来获取\nierr 或 GetLastError() 所给出的错误代码的 Windows 描述，然后构造一个 OSError 对象，\n其中 winerror 属性将设为该错误代码，strerror 属性将设为相应的错误消息（从\nFormatMessage() 获得），然后再调用 PyErr_SetObject(PyExc_OSError, object)。 该函\n数将总是返回 NULL。\nAvailability: Windows.\nPyObject *PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetFromWindowsErr() ，额外的参数指定要触发的异常类型。\nAvailability: Windows.\nPyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char\n*filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n与 PyErr_SetFromWindowsErr() 类似，额外的不同点是如果 filename 不为 NULL ，则会使用\n文件系统编码格式 (os.fsdecode()) 进行解码并作为第三个参数传递给 OSError 的构造器用于\n定义异常实例的 filename 属性。\nAvailability: Windows. |  |\n| --- | --- | --- |\n\nPyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *type, int\nierr, PyObject *filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n与 PyErr_SetExcFromWindowsErr() 类似，额外的不同点是如果 filename 不为 NULL，它将作\n为第三个参数传递给 OSError 的构造器用于定义异常实例的 filename 属性。\nAvailability: Windows.\nPyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *type, int\nierr, PyObject *filename, PyObject *filename2)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetExcFromWindowsErrWithFilenameObject() ，但是接受第二个 filename 对\n象。\nAvailability: Windows.\nAdded in version 3.4.\nPyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr,\nconst char *filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetFromWindowsErrWithFilename() ，额外参数指定要触发的异常类型。\nAvailability: Windows.\nPyObject *PyErr_SetImportError(PyObject *msg, PyObject *name, PyObject\n*path)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.7 版起.\n这是触发 ImportError 的便捷函数。 msg 将被设为异常的消息字符串。 name 和 path ，（都\n可以为 NULL ），将用来被设置 ImportError 对应的属性 name 和 path。\nAdded in version 3.3.\nPyObject *PyErr_SetImportErrorSubclass(PyObject *exception, PyObject *msg,\nPyObject *name, PyObject *path)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.6 版起.\n和 PyErr_SetImportError() 很类似，但这个函数允许指定一个 ImportError 的子类来触\n发。\nAdded in version 3.6.\nvoid PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int\ncol_offset)\n设置当前异常的文件，行和偏移信息。如果当前异常不是 SyntaxError ，则它设置额外的属\n性，使异常打印子系统认为异常是 SyntaxError。\n\n|  | PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *type, int\nierr, PyObject *filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n与 PyErr_SetExcFromWindowsErr() 类似，额外的不同点是如果 filename 不为 NULL，它将作\n为第三个参数传递给 OSError 的构造器用于定义异常实例的 filename 属性。\nAvailability: Windows.\nPyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *type, int\nierr, PyObject *filename, PyObject *filename2)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetExcFromWindowsErrWithFilenameObject() ，但是接受第二个 filename 对\n象。\nAvailability: Windows.\nAdded in version 3.4.\nPyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr,\nconst char *filename)\n返回值：恒为 NULL。 属于 稳定 ABI on Windows 自 3.7 版起.\n类似于 PyErr_SetFromWindowsErrWithFilename() ，额外参数指定要触发的异常类型。\nAvailability: Windows.\nPyObject *PyErr_SetImportError(PyObject *msg, PyObject *name, PyObject\n*path)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.7 版起.\n这是触发 ImportError 的便捷函数。 msg 将被设为异常的消息字符串。 name 和 path ，（都\n可以为 NULL ），将用来被设置 ImportError 对应的属性 name 和 path。\nAdded in version 3.3.\nPyObject *PyErr_SetImportErrorSubclass(PyObject *exception, PyObject *msg,\nPyObject *name, PyObject *path)\n返回值：恒为 NULL。 属于 稳定 ABI 自 3.6 版起.\n和 PyErr_SetImportError() 很类似，但这个函数允许指定一个 ImportError 的子类来触\n发。\nAdded in version 3.6.\nvoid PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int\ncol_offset)\n设置当前异常的文件，行和偏移信息。如果当前异常不是 SyntaxError ，则它设置额外的属\n性，使异常打印子系统认为异常是 SyntaxError。 |  |\n| --- | --- | --- |\n\nAdded in version 3.4.\nvoid PyErr_SyntaxLocationEx(const char *filename, int lineno, int\ncol_offset)\n属于 稳定 ABI 自 3.7 版起.\n类似于 PyErr_SyntaxLocationObject()，但 filename 是用 filesystem encoding and error\nhandler 解码的字节串。\nAdded in version 3.2.\nvoid PyErr_SyntaxLocation(const char *filename, int lineno)\n属于 稳定 ABI.\n类似于 PyErr_SyntaxLocationEx()，但省略了 col_offset parameter 形参。\nvoid PyErr_BadInternalCall()\n属于 稳定 ABI.\n这是 PyErr_SetString(PyExc_SystemError, message) 的缩写，其中 message 表示使用了\n非法参数调用内部操作（例如，Python/C API 函数）。它主要用于内部使用。\n发出警告\n这些函数可以从 C 代码中发出警告。它们仿照了由 Python 模块 warnings 导出的那些函数。它们通\n常向 sys.stderr 打印一条警告信息；当然，用户也有可能已经指定将警告转换为错误，在这种情况\n下，它们将触发异常。也有可能由于警告机制出现问题，使得函数触发异常。如果没有触发异常，\n返回值为 0 ；如果触发异常，返回值为 -1。（无法确定是否实际打印了警告信息，也无法确定异常\n触发的原因。这是故意为之）。如果触发了异常，调用者应该进行正常的异常处理（例如，\nPy_DECREF() 持有引用并返回一个错误值）。\nint PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t\nstack_level)\n属于 稳定 ABI.\n发出一个警告信息。参数 category 是一个警告类别（见下面）或 NULL ； message 是一个 UTF-\n8 编码的字符串。 stack_level 是一个给出栈帧数量的正数；警告将从该栈帧中当前正在执行的\n代码行发出。 stack_level 为 1 的是调用 PyErr_WarnEx() 的函数，2 是在此之上的函数，以此\n类推。\n警告类别必须是 PyExc_Warning 的子类， PyExc_Warning 是 PyExc_Exception 的子类；默\n认警告类别是 PyExc_RuntimeWarning 。标准 Python 警告类别作为全局变量可用，所有其名\n称见 警告类型 。\n有关警告控制的信息，参见模块文档 warnings 和命令行文档中的 -W 选项。没有用于警告控制\n的 C API。\nint PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject\n*filename, int lineno, PyObject *module, PyObject *registry)\n\n|  | Added in version 3.4.\nvoid PyErr_SyntaxLocationEx(const char *filename, int lineno, int\ncol_offset)\n属于 稳定 ABI 自 3.7 版起.\n类似于 PyErr_SyntaxLocationObject()，但 filename 是用 filesystem encoding and error\nhandler 解码的字节串。\nAdded in version 3.2.\nvoid PyErr_SyntaxLocation(const char *filename, int lineno)\n属于 稳定 ABI.\n类似于 PyErr_SyntaxLocationEx()，但省略了 col_offset parameter 形参。\nvoid PyErr_BadInternalCall()\n属于 稳定 ABI.\n这是 PyErr_SetString(PyExc_SystemError, message) 的缩写，其中 message 表示使用了\n非法参数调用内部操作（例如，Python/C API 函数）。它主要用于内部使用。\n发出警告\n这些函数可以从 C 代码中发出警告。它们仿照了由 Python 模块 warnings 导出的那些函数。它们通\n常向 sys.stderr 打印一条警告信息；当然，用户也有可能已经指定将警告转换为错误，在这种情况\n下，它们将触发异常。也有可能由于警告机制出现问题，使得函数触发异常。如果没有触发异常，\n返回值为 0 ；如果触发异常，返回值为 -1。（无法确定是否实际打印了警告信息，也无法确定异常\n触发的原因。这是故意为之）。如果触发了异常，调用者应该进行正常的异常处理（例如，\nPy_DECREF() 持有引用并返回一个错误值）。\nint PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t\nstack_level)\n属于 稳定 ABI.\n发出一个警告信息。参数 category 是一个警告类别（见下面）或 NULL ； message 是一个 UTF-\n8 编码的字符串。 stack_level 是一个给出栈帧数量的正数；警告将从该栈帧中当前正在执行的\n代码行发出。 stack_level 为 1 的是调用 PyErr_WarnEx() 的函数，2 是在此之上的函数，以此\n类推。\n警告类别必须是 PyExc_Warning 的子类， PyExc_Warning 是 PyExc_Exception 的子类；默\n认警告类别是 PyExc_RuntimeWarning 。标准 Python 警告类别作为全局变量可用，所有其名\n称见 警告类型 。\n有关警告控制的信息，参见模块文档 warnings 和命令行文档中的 -W 选项。没有用于警告控制\n的 C API。\nint PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject\n*filename, int lineno, PyObject *module, PyObject *registry) |  |\n| --- | --- | --- |\n\n发出一个对所有警告属性进行显式控制的警告消息。 这是位于 Python 函数\nwarnings.warn_explicit() 外层的直接包装；请查看其文档了解详情。 module 和 registry 参\n数可被设为 NULL 以得到相关文档所描述的默认效果。\nAdded in version 3.4.\nint PyErr_WarnExplicit(PyObject *category, const char *message, const char\n*filename, int lineno, const char *module, PyObject *registry)\n属于 稳定 ABI.\n类似于 PyErr_WarnExplicitObject() 不过 message 和 module 是 UTF-8 编码的字符串，而\nfilename 是由 filesystem encoding and error handler 解码的。\nint PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char\n*format, ...)\n属于 稳定 ABI.\n类似于 PyErr_WarnEx() 的函数，但使用 PyUnicode_FromFormat() 来格式化警告消息。\nformat 是使用 ASCII 编码的字符串。\nAdded in version 3.2.\nint PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const\nchar *format, ...)\n属于 稳定 ABI 自 3.6 版起.\n类似于 PyErr_WarnFormat() 的函数，但 category 是 ResourceWarning 并且它会将 source 传\n给 warnings.WarningMessage。\nAdded in version 3.6.\n查询错误指示器\nPyObject *PyErr_Occurred()\n返回值：借入的引用。 属于 稳定 ABI.\n测试是否设置了错误指示器。 如已设置，则返回异常 type (传给对某个 PyErr_Set* 函数或\nPyErr_Restore() 的最后一次调用的第一个参数)。 如未设置，则返回 NULL。 你并不会拥有\n对返回值的引用，因此你不需要对它执行 Py_DECREF()。\n调用方必须有已附加的线程状态 attached thread state。\n备注: 不要将返回值与特定的异常进行比较；请改为使用 PyErr_ExceptionMatches()，如\n下所示。 （比较很容易失败因为对于类异常来说，异常可能是一个实例而不是类，或者它可\n能是预期的异常的一个子类。）\nint PyErr_ExceptionMatches(PyObject *exc)\n属于 稳定 ABI.\n\n|  | 发出一个对所有警告属性进行显式控制的警告消息。 这是位于 Python 函数\nwarnings.warn_explicit() 外层的直接包装；请查看其文档了解详情。 module 和 registry 参\n数可被设为 NULL 以得到相关文档所描述的默认效果。\nAdded in version 3.4.\nint PyErr_WarnExplicit(PyObject *category, const char *message, const char\n*filename, int lineno, const char *module, PyObject *registry)\n属于 稳定 ABI.\n类似于 PyErr_WarnExplicitObject() 不过 message 和 module 是 UTF-8 编码的字符串，而\nfilename 是由 filesystem encoding and error handler 解码的。\nint PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char\n*format, ...)\n属于 稳定 ABI.\n类似于 PyErr_WarnEx() 的函数，但使用 PyUnicode_FromFormat() 来格式化警告消息。\nformat 是使用 ASCII 编码的字符串。\nAdded in version 3.2.\nint PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const\nchar *format, ...)\n属于 稳定 ABI 自 3.6 版起.\n类似于 PyErr_WarnFormat() 的函数，但 category 是 ResourceWarning 并且它会将 source 传\n给 warnings.WarningMessage。\nAdded in version 3.6.\n查询错误指示器\nPyObject *PyErr_Occurred()\n返回值：借入的引用。 属于 稳定 ABI.\n测试是否设置了错误指示器。 如已设置，则返回异常 type (传给对某个 PyErr_Set* 函数或\nPyErr_Restore() 的最后一次调用的第一个参数)。 如未设置，则返回 NULL。 你并不会拥有\n对返回值的引用，因此你不需要对它执行 Py_DECREF()。\n调用方必须有已附加的线程状态 attached thread state。\n备注: 不要将返回值与特定的异常进行比较；请改为使用 PyErr_ExceptionMatches()，如\n下所示。 （比较很容易失败因为对于类异常来说，异常可能是一个实例而不是类，或者它可\n能是预期的异常的一个子类。）\nint PyErr_ExceptionMatches(PyObject *exc)\n属于 稳定 ABI. |  |\n| --- | --- | --- |\n\n等价于 PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)。 此函数应当只在实际设\n置了异常时才被调用；如果没有任何异常被引发则将发生非法内存访问。\nint PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)\n属于 稳定 ABI.\n如果 given 异常与 exc 中的异常类型相匹配则返回真值。 如果 exc 是一个类对象，则当 given\n是一个子类的实例时也将返回真值。 如果 exc 是一个元组，则该元组（以及递归的子元组）中\n的所有异常类型都将被搜索进行匹配。\nPyObject *PyErr_GetRaisedException(void)\n返回值：新的引用。 属于 稳定 ABI 自 3.12 版起.\n返回当前被引发的异常，同时清除错误指示器。 如果错误指示器尚未设置则返回 NULL。\n此函数会被需要捕获异常的代码，或需要临时保存和恢复错误指示器的代码所使用。\n例如：\n{\nPyObject *exc = PyErr_GetRaisedException();\n/* ... 可能产生其他错误的代码 ... */\nPyErr_SetRaisedException(exc);\n}\n参见: PyErr_GetHandledException()，保存当前正在处理的异常。\nAdded in version 3.12.\nvoid PyErr_SetRaisedException(PyObject *exc)\n属于 稳定 ABI 自 3.12 版起.\n将 exc 设为当前被引发的异常，如果已设置则清空现有的异常。\n警告: 此调用将偷取一个对 exc 的引用，它必须是一个有效的异常。\nAdded in version 3.12.\nvoid PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)\n属于 稳定 ABI.\n自 3.12 版本弃用: 使用 PyErr_GetRaisedException() 代替。\n将错误指示符提取到三个变量中并传递其地址。 如果未设置错误指示符，则将三个变量都设为\nNULL。 如果已设置，则将其清除并且你将得到对所提取的每个对象的引用。 值和回溯对象可\n以为 NULL 即使类型对象不为空。\n\n|  | 等价于 PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)。 此函数应当只在实际设\n置了异常时才被调用；如果没有任何异常被引发则将发生非法内存访问。\nint PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)\n属于 稳定 ABI.\n如果 given 异常与 exc 中的异常类型相匹配则返回真值。 如果 exc 是一个类对象，则当 given\n是一个子类的实例时也将返回真值。 如果 exc 是一个元组，则该元组（以及递归的子元组）中\n的所有异常类型都将被搜索进行匹配。\nPyObject *PyErr_GetRaisedException(void)\n返回值：新的引用。 属于 稳定 ABI 自 3.12 版起.\n返回当前被引发的异常，同时清除错误指示器。 如果错误指示器尚未设置则返回 NULL。\n此函数会被需要捕获异常的代码，或需要临时保存和恢复错误指示器的代码所使用。\n例如：\n{\nPyObject *exc = PyErr_GetRaisedException();\n/* ... 可能产生其他错误的代码 ... */\nPyErr_SetRaisedException(exc);\n}\n参见: PyErr_GetHandledException()，保存当前正在处理的异常。\nAdded in version 3.12.\nvoid PyErr_SetRaisedException(PyObject *exc)\n属于 稳定 ABI 自 3.12 版起.\n将 exc 设为当前被引发的异常，如果已设置则清空现有的异常。\n警告: 此调用将偷取一个对 exc 的引用，它必须是一个有效的异常。\nAdded in version 3.12.\nvoid PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)\n属于 稳定 ABI.\n自 3.12 版本弃用: 使用 PyErr_GetRaisedException() 代替。\n将错误指示符提取到三个变量中并传递其地址。 如果未设置错误指示符，则将三个变量都设为\nNULL。 如果已设置，则将其清除并且你将得到对所提取的每个对象的引用。 值和回溯对象可\n以为 NULL 即使类型对象不为空。 |  |\n| --- | --- | --- |\n\n备注: 此函数通常只被需要捕获异常或临时保存和恢复错误指示符的旧式代码所使用。\n例如：\n{\nPyObject *type, *value, *traceback;\nPyErr_Fetch(&type, &value, &traceback);\n/* ... 可能产生其他错误的代码 ... */\nPyErr_Restore(type, value, traceback);\n}\nvoid PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)\n属于 稳定 ABI.\n自 3.12 版本弃用: 请改用 PyErr_SetRaisedException()。\n根据 type, value 和 traceback 这三个对象设置错误指示符，如果已设置了错误指示符则先清除\n它。如果三个对象均为 NULL，则清除错误指示符。 请不要传入 NULL 类型和非 NULL 的值或回\n溯。 异常类型应当是一个类。 请不要传入无效的异常类型或值。 （违反这些规则将导致微妙\n的后继问题。） 此调用会带走对每个对象的引用：你必须在调用之前拥有对每个对象的引用并\n且在调用之后你将不再拥有这些引用。 （如果你不理解这一点，就不要使用此函数。 勿谓言之\n不预。）\n备注: 此函数通常只被需要临时保存和恢复错误指示符的旧代码所使用。 请使用\nPyErr_Fetch() 来保存当前的错误指示符。\nvoid PyErr_NormalizeException(PyObject **exc, PyObject **val, PyObject\n**tb)\n属于 稳定 ABI.\n自 3.12 版本弃用: 请改用 PyErr_GetRaisedException()，以避免任何可能的去正规化。\n在特定情况下，下面 PyErr_Fetch() 所返回的值可以是“非正规化的”，即 *exc 是一个类对象\n而 *val 不是同一个类的实例。 在这种情况下此函数可以被用来实例化类。 如果值已经是正规\n化的，则不做任何操作。 实现这种延迟正规化是为了提升性能。\n备注: 此函数 不会 隐式地在异常值上设置 __traceback__ 属性。 如果想要适当地设置回\n溯，还需要以下附加代码片段:\nif (tb != NULL) {\nPyException_SetTraceback(val, tb);\n}\nPyObject *PyErr_GetHandledException(void)\n属于 稳定 ABI 自 3.11 版起.\n\n|  | 备注: 此函数通常只被需要捕获异常或临时保存和恢复错误指示符的旧式代码所使用。\n例如：\n{\nPyObject *type, *value, *traceback;\nPyErr_Fetch(&type, &value, &traceback);\n/* ... 可能产生其他错误的代码 ... */\nPyErr_Restore(type, value, traceback);\n}\nvoid PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)\n属于 稳定 ABI.\n自 3.12 版本弃用: 请改用 PyErr_SetRaisedException()。\n根据 type, value 和 traceback 这三个对象设置错误指示符，如果已设置了错误指示符则先清除\n它。如果三个对象均为 NULL，则清除错误指示符。 请不要传入 NULL 类型和非 NULL 的值或回\n溯。 异常类型应当是一个类。 请不要传入无效的异常类型或值。 （违反这些规则将导致微妙\n的后继问题。） 此调用会带走对每个对象的引用：你必须在调用之前拥有对每个对象的引用并\n且在调用之后你将不再拥有这些引用。 （如果你不理解这一点，就不要使用此函数。 勿谓言之\n不预。）\n备注: 此函数通常只被需要临时保存和恢复错误指示符的旧代码所使用。 请使用\nPyErr_Fetch() 来保存当前的错误指示符。\nvoid PyErr_NormalizeException(PyObject **exc, PyObject **val, PyObject\n**tb)\n属于 稳定 ABI.\n自 3.12 版本弃用: 请改用 PyErr_GetRaisedException()，以避免任何可能的去正规化。\n在特定情况下，下面 PyErr_Fetch() 所返回的值可以是“非正规化的”，即 *exc 是一个类对象\n而 *val 不是同一个类的实例。 在这种情况下此函数可以被用来实例化类。 如果值已经是正规\n化的，则不做任何操作。 实现这种延迟正规化是为了提升性能。\n备注: 此函数 不会 隐式地在异常值上设置 __traceback__ 属性。 如果想要适当地设置回\n溯，还需要以下附加代码片段:\nif (tb != NULL) {\nPyException_SetTraceback(val, tb);\n}\nPyObject *PyErr_GetHandledException(void)\n属于 稳定 ABI 自 3.11 版起. | 备注: 此函数通常只被需要捕获异常或临时保存和恢复错误指示符的旧式代码所使用。\n例如：\n{\nPyObject *type, *value, *traceback;\nPyErr_Fetch(&type, &value, &traceback);\n/* ... 可能产生其他错误的代码 ... */\nPyErr_Restore(type, value, traceback);\n} |  |\n| --- | --- | --- | --- |\n\n提取激活的异常实例，就如 sys.exception() 所返回的一样。 这是指一个 已被捕获 的异常，\n而不是刚被引发的异常。 返回一个指向该异常的新引用或者 NULL。 不会修改解释器的异常状\n态。 Does not modify the interpreter's exception state.\n备注: 此函数通常不会被需要处理异常的代码所使用。 它可被使用的场合是当代码需要临时\n保存并恢复异常状态的时候。 请使用 PyErr_SetHandledException() 来恢复或清除异常状\n态。\nAdded in version 3.11.\nvoid PyErr_SetHandledException(PyObject *exc)\n属于 稳定 ABI 自 3.11 版起.\n设置激活的异常，就是从 sys.exception() 所获得的。 这是指一个 已被捕获 的异常，而不是\n刚被引发的异常。 要清空异常状态，请传入 NULL。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的时候。 请使用 PyErr_GetHandledException() 来获取异常状态。\nAdded in version 3.11.\nvoid PyErr_GetExcInfo(PyObject **ptype, PyObject **pvalue, PyObject\n**ptraceback)\n属于 稳定 ABI 自 3.7 版起.\n提取旧式的异常信息表示形式，就是从 sys.exc_info() 所获得的。 这是指一个 已被捕获 的\n异常，而不是刚被引发的异常。 返回分别指向三个对象的新引用，其中任何一个都可以为\nNULL。 不会修改异常信息的状态。 此函数是为了向下兼容而保留的。 更推荐使用\nPyErr_GetHandledException()。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的时候。 请使用 PyErr_SetExcInfo() 来恢复或清除异常状态。\nAdded in version 3.3.\nvoid PyErr_SetExcInfo(PyObject *type, PyObject *value, PyObject *traceback)\n属于 稳定 ABI 自 3.7 版起.\n设置异常信息，就是从 sys.exc_info() 所获得的，这是指一个 已被捕获 的异常，而不是刚被\n引发的异常。 此函数会偷取对参数的引用。 要清空异常状态，请为所有三个参数传入 NULL。\n此函数是为了向下兼容而保留的。 更推荐使用 PyErr_SetHandledException()。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的情况。 请使用 PyErr_GetExcInfo() 来读取异常状态。\n\n|  | 提取激活的异常实例，就如 sys.exception() 所返回的一样。 这是指一个 已被捕获 的异常，\n而不是刚被引发的异常。 返回一个指向该异常的新引用或者 NULL。 不会修改解释器的异常状\n态。 Does not modify the interpreter's exception state.\n备注: 此函数通常不会被需要处理异常的代码所使用。 它可被使用的场合是当代码需要临时\n保存并恢复异常状态的时候。 请使用 PyErr_SetHandledException() 来恢复或清除异常状\n态。\nAdded in version 3.11.\nvoid PyErr_SetHandledException(PyObject *exc)\n属于 稳定 ABI 自 3.11 版起.\n设置激活的异常，就是从 sys.exception() 所获得的。 这是指一个 已被捕获 的异常，而不是\n刚被引发的异常。 要清空异常状态，请传入 NULL。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的时候。 请使用 PyErr_GetHandledException() 来获取异常状态。\nAdded in version 3.11.\nvoid PyErr_GetExcInfo(PyObject **ptype, PyObject **pvalue, PyObject\n**ptraceback)\n属于 稳定 ABI 自 3.7 版起.\n提取旧式的异常信息表示形式，就是从 sys.exc_info() 所获得的。 这是指一个 已被捕获 的\n异常，而不是刚被引发的异常。 返回分别指向三个对象的新引用，其中任何一个都可以为\nNULL。 不会修改异常信息的状态。 此函数是为了向下兼容而保留的。 更推荐使用\nPyErr_GetHandledException()。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的时候。 请使用 PyErr_SetExcInfo() 来恢复或清除异常状态。\nAdded in version 3.3.\nvoid PyErr_SetExcInfo(PyObject *type, PyObject *value, PyObject *traceback)\n属于 稳定 ABI 自 3.7 版起.\n设置异常信息，就是从 sys.exc_info() 所获得的，这是指一个 已被捕获 的异常，而不是刚被\n引发的异常。 此函数会偷取对参数的引用。 要清空异常状态，请为所有三个参数传入 NULL。\n此函数是为了向下兼容而保留的。 更推荐使用 PyErr_SetHandledException()。\n备注: 此函数通常不会被需要处理异常的代码所使用。 它被使用的场合是在代码需要临时保\n存并恢复异常状态的情况。 请使用 PyErr_GetExcInfo() 来读取异常状态。 |  |\n| --- | --- | --- |\n\nAdded in version 3.3.\n在 3.11 版本发生变更: type 和 traceback 参数已不再被使用并且可以为 NULL。 解释器\n现在会根据异常实例（即 value 参数）来推断出它们。 此函数仍然会偷取对所有三个参\n数的引用。\n信号处理\nint PyErr_CheckSignals()\n属于 稳定 ABI.\n这个函数与Python的信号处理交互。\n如果在主 Python 解释器下从主线程调用该函数，它将检查是否向进程发送了信号，如果是，则\n唤起相应的信号处理器。 如果支持 signal 模块，则可以唤起以 Python 编写的信号处理器。\n该函数会尝试处理所有待处理信号，然后返回 0。 但是，如果 Python 信号处理器引发了异\n常，则设置错误指示符并且函数将立即返回 -1 (这样其他待处理信号可能还没有被处理：它们\n将在下次唤起 PyErr_CheckSignals() 时被处理)。\n如果函数从非主线程调用，或在非主Python解释器下调用，则它不执行任何操作并返回0。\n这个函数可以由希望被用户请求(例如按Ctrl-C)中断的长时间运行的C代码调用。\n备注: 针对 SIGINT 的默认 Python 信号处理器会引发 KeyboardInterrupt 异常。\nvoid PyErr_SetInterrupt()\n属于 稳定 ABI.\n模拟一个 SIGINT 信号到达的效果。 这等价于 PyErr_SetInterruptEx(SIGINT)。\n备注: 此函数是异步信号安全的。 它可以在没有 attached thread state 的情况下以及从 C\n信号处理器中被调用。\nint PyErr_SetInterruptEx(int signum)\n属于 稳定 ABI 自 3.10 版起.\n模拟一个信号到达的效果。 当下次 PyErr_CheckSignals() 被调用时，将会调用针对指定的信\n号编号的 Python 信号处理器。\n此函数可由自行设置信号处理，并希望 Python 信号处理器会在请求中断时（例如当用户按下\nCtrl-C 来中断操作时）按照预期被唤起的 C 代码来调用。\n如果给定的信号不是由 Python 来处理的 (即被设为 signal.SIG_DFL 或 signal.SIG_IGN)，它\n将会被忽略。\n如果 signum 在被允许的信号编号范围之外，将返回 -1。 在其他情况下，则返回 0。 错误指示\n符绝不会被此函数所修改。\n\n|  | Added in version 3.3.\n在 3.11 版本发生变更: type 和 traceback 参数已不再被使用并且可以为 NULL。 解释器\n现在会根据异常实例（即 value 参数）来推断出它们。 此函数仍然会偷取对所有三个参\n数的引用。\n信号处理\nint PyErr_CheckSignals()\n属于 稳定 ABI.\n这个函数与Python的信号处理交互。\n如果在主 Python 解释器下从主线程调用该函数，它将检查是否向进程发送了信号，如果是，则\n唤起相应的信号处理器。 如果支持 signal 模块，则可以唤起以 Python 编写的信号处理器。\n该函数会尝试处理所有待处理信号，然后返回 0。 但是，如果 Python 信号处理器引发了异\n常，则设置错误指示符并且函数将立即返回 -1 (这样其他待处理信号可能还没有被处理：它们\n将在下次唤起 PyErr_CheckSignals() 时被处理)。\n如果函数从非主线程调用，或在非主Python解释器下调用，则它不执行任何操作并返回0。\n这个函数可以由希望被用户请求(例如按Ctrl-C)中断的长时间运行的C代码调用。\n备注: 针对 SIGINT 的默认 Python 信号处理器会引发 KeyboardInterrupt 异常。\nvoid PyErr_SetInterrupt()\n属于 稳定 ABI.\n模拟一个 SIGINT 信号到达的效果。 这等价于 PyErr_SetInterruptEx(SIGINT)。\n备注: 此函数是异步信号安全的。 它可以在没有 attached thread state 的情况下以及从 C\n信号处理器中被调用。\nint PyErr_SetInterruptEx(int signum)\n属于 稳定 ABI 自 3.10 版起.\n模拟一个信号到达的效果。 当下次 PyErr_CheckSignals() 被调用时，将会调用针对指定的信\n号编号的 Python 信号处理器。\n此函数可由自行设置信号处理，并希望 Python 信号处理器会在请求中断时（例如当用户按下\nCtrl-C 来中断操作时）按照预期被唤起的 C 代码来调用。\n如果给定的信号不是由 Python 来处理的 (即被设为 signal.SIG_DFL 或 signal.SIG_IGN)，它\n将会被忽略。\n如果 signum 在被允许的信号编号范围之外，将返回 -1。 在其他情况下，则返回 0。 错误指示\n符绝不会被此函数所修改。 |  |\n| --- | --- | --- |\n\n备注: 此函数是异步信号安全的。 它可以在没有 attached thread state 的情况下以及从 C\n信号处理器中被调用。\nAdded in version 3.10.\nint PySignal_SetWakeupFd(int fd)\n这个工具函数指定了一个每当收到信号时将被作为以单个字节的形式写入信号编号的目标的文\n件描述符。 fd 必须是非阻塞的。 它将返回前一个这样的文件描述符。\n设置值 -1 将禁用该特性；这是初始状态。 这等价于 Python 中的\nsignal.set_wakeup_fd()，但是没有任何错误检查。 fd 应当是一个有效的文件描述符。 此函\n数应当只从主线程来调用。\n在 3.5 版本发生变更: 在 Windows 上，此函数现在也支持套接字处理。\nException 类\nPyObject *PyErr_NewException(const char *name, PyObject *base, PyObject\n*dict)\n返回值：新的引用。 属于 稳定 ABI.\n这个工具函数会创建并返回一个新的异常类。 name 参数必须为新异常的名称，是\nmodule.classname 形式的 C 字符串。 base 和 dict 参数通常为 NULL。 这将创建一个派生自\nException 的类对象（在 C 中可以通过 PyExc_Exception 访问）。\n新类的 __module__ 属性将被设为 name 参数的前半部分（最后一个点号之前），而类名将被\n设为后半部分（最后一个点号之后）。 base 参数可被用来指定替代基类；它可以是一个类或是\n一个由类组成的元组。 dict 参数可被用来指定一个由类变量和方法组成的字典。\nPyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc,\nPyObject *base, PyObject *dict)\n返回值：新的引用。 属于 稳定 ABI.\n和 PyErr_NewException() 一样，除了可以轻松地给新的异常类一个文档字符串：如果 doc 属\n性非空，它将用作异常类的文档字符串。\nAdded in version 3.2.\nint PyExceptionClass_Check(PyObject *ob)\n如果 ob 是异常类则返回非零，否则返回零。此函数总是会成功执行。\nconst char *PyExceptionClass_Name(PyObject *ob)\n属于 稳定 ABI 自 3.8 版起.\n返回异常类 ob 的 tp_name。\n异常对象\n\n|  | 备注: 此函数是异步信号安全的。 它可以在没有 attached thread state 的情况下以及从 C\n信号处理器中被调用。\nAdded in version 3.10.\nint PySignal_SetWakeupFd(int fd)\n这个工具函数指定了一个每当收到信号时将被作为以单个字节的形式写入信号编号的目标的文\n件描述符。 fd 必须是非阻塞的。 它将返回前一个这样的文件描述符。\n设置值 -1 将禁用该特性；这是初始状态。 这等价于 Python 中的\nsignal.set_wakeup_fd()，但是没有任何错误检查。 fd 应当是一个有效的文件描述符。 此函\n数应当只从主线程来调用。\n在 3.5 版本发生变更: 在 Windows 上，此函数现在也支持套接字处理。\nException 类\nPyObject *PyErr_NewException(const char *name, PyObject *base, PyObject\n*dict)\n返回值：新的引用。 属于 稳定 ABI.\n这个工具函数会创建并返回一个新的异常类。 name 参数必须为新异常的名称，是\nmodule.classname 形式的 C 字符串。 base 和 dict 参数通常为 NULL。 这将创建一个派生自\nException 的类对象（在 C 中可以通过 PyExc_Exception 访问）。\n新类的 __module__ 属性将被设为 name 参数的前半部分（最后一个点号之前），而类名将被\n设为后半部分（最后一个点号之后）。 base 参数可被用来指定替代基类；它可以是一个类或是\n一个由类组成的元组。 dict 参数可被用来指定一个由类变量和方法组成的字典。\nPyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc,\nPyObject *base, PyObject *dict)\n返回值：新的引用。 属于 稳定 ABI.\n和 PyErr_NewException() 一样，除了可以轻松地给新的异常类一个文档字符串：如果 doc 属\n性非空，它将用作异常类的文档字符串。\nAdded in version 3.2.\nint PyExceptionClass_Check(PyObject *ob)\n如果 ob 是异常类则返回非零，否则返回零。此函数总是会成功执行。\nconst char *PyExceptionClass_Name(PyObject *ob)\n属于 稳定 ABI 自 3.8 版起.\n返回异常类 ob 的 tp_name。\n异常对象 | 备注: 此函数是异步信号安全的。 它可以在没有 attached thread state 的情况下以及从 C\n信号处理器中被调用。 |  |\n| --- | --- | --- | --- |\n\nPyObject *PyException_GetTraceback(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的回溯作为一个新引用返回，可以通过 __traceback__ 属性在 Python 中访\n问。 如果没有已关联的回溯，则返回 NULL。\nint PyException_SetTraceback(PyObject *ex, PyObject *tb)\n属于 稳定 ABI.\n将异常关联的回溯设置为 tb 。使用 Py_None 清除它。\nPyObject *PyException_GetContext(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的上下文（在处理 ex 过程中引发的另一个异常实例）作为一个新引用返回，可\n以通过 __context__ 属性在 Python 中访问。 如果没有已关联的上下文，则返回 NULL。\nvoid PyException_SetContext(PyObject *ex, PyObject *ctx)\n属于 稳定 ABI.\n将与异常相关联的上下文设置为 ctx。 使用 NULL 来清空它。 没有用来确保 ctx 是一个异常实例\n的类型检查。 这将窃取一个指向 ctx 的引用。\nPyObject *PyException_GetCause(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的原因（一个异常实例，或为 None，由 raise ... from ... 设置）作为一\n个新引用返回，可通过 __cause__ 属性在 Python 中访问。\nvoid PyException_SetCause(PyObject *ex, PyObject *cause)\n属于 稳定 ABI.\n将与异常相关联的原因设为 cause。 使用 NULL 来清空它。 不存在类型检查用来确保 cause 是\n一个异常实例或为 None。 这个偷取一个指向 cause 的引用。\n__suppress_context__ 属性会被此函数隐式地设为 True。\nPyObject *PyException_GetArgs(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI 自 3.12 版起.\n返回异常 ex 的 args。\nvoid PyException_SetArgs(PyObject *ex, PyObject *args)\n属于 稳定 ABI 自 3.12 版起.\n将异常 ex 的 args 设为 args。\nPyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)\n这是 不稳定 API。它可在次发布版中不经警告地改变。\n\n|  | PyObject *PyException_GetTraceback(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的回溯作为一个新引用返回，可以通过 __traceback__ 属性在 Python 中访\n问。 如果没有已关联的回溯，则返回 NULL。\nint PyException_SetTraceback(PyObject *ex, PyObject *tb)\n属于 稳定 ABI.\n将异常关联的回溯设置为 tb 。使用 Py_None 清除它。\nPyObject *PyException_GetContext(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的上下文（在处理 ex 过程中引发的另一个异常实例）作为一个新引用返回，可\n以通过 __context__ 属性在 Python 中访问。 如果没有已关联的上下文，则返回 NULL。\nvoid PyException_SetContext(PyObject *ex, PyObject *ctx)\n属于 稳定 ABI.\n将与异常相关联的上下文设置为 ctx。 使用 NULL 来清空它。 没有用来确保 ctx 是一个异常实例\n的类型检查。 这将窃取一个指向 ctx 的引用。\nPyObject *PyException_GetCause(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI.\n将与异常相关联的原因（一个异常实例，或为 None，由 raise ... from ... 设置）作为一\n个新引用返回，可通过 __cause__ 属性在 Python 中访问。\nvoid PyException_SetCause(PyObject *ex, PyObject *cause)\n属于 稳定 ABI.\n将与异常相关联的原因设为 cause。 使用 NULL 来清空它。 不存在类型检查用来确保 cause 是\n一个异常实例或为 None。 这个偷取一个指向 cause 的引用。\n__suppress_context__ 属性会被此函数隐式地设为 True。\nPyObject *PyException_GetArgs(PyObject *ex)\n返回值：新的引用。 属于 稳定 ABI 自 3.12 版起.\n返回异常 ex 的 args。\nvoid PyException_SetArgs(PyObject *ex, PyObject *args)\n属于 稳定 ABI 自 3.12 版起.\n将异常 ex 的 args 设为 args。\nPyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)\n这是 不稳定 API。它可在次发布版中不经警告地改变。 |  |  |\n| --- | --- | --- | --- |\n|  |  | 这是 不稳定 API。它可在次发布版中不经警告地改变。 |  |\n\n解释器的 except* 实现的具体实现部分。 orig 是被捕获的原始异常，而 excs 是需要被引发的\n异常组成的列表。 该列表包含 orig 可能存在的未被处理的部分，以及在 except* 子句中被引\n发的异常（因而它们具有与 orig 不同的回溯数据）和被重新引发的异常（因而它们具有与 orig\n相同的回溯）。 返回需要被最终引发的 ExceptionGroup，或者如果没有要被引发的异常则返\n回 None。\nAdded in version 3.12.\nUnicode 异常对象\n下列函数被用于创建和修改来自 C 的 Unicode 异常。\nPyObject *PyUnicodeDecodeError_Create(const char *encoding, const char\n*object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char\n*reason)\n返回值：新的引用。 属于 稳定 ABI.\n创建一个 UnicodeDecodeError 对象并附带 encoding, object, length, start, end 和 reason 等属\n性。 encoding 和 reason 为 UTF-8 编码的字符串。\nPyObject *PyUnicodeDecodeError_GetEncoding(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetEncoding(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 encoding 属性\nPyObject *PyUnicodeDecodeError_GetObject(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetObject(PyObject *exc)\nPyObject *PyUnicodeTranslateError_GetObject(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 object 属性\nint PyUnicodeDecodeError_GetStart(PyObject *exc, Py_ssize_t *start)\nint PyUnicodeEncodeError_GetStart(PyObject *exc, Py_ssize_t *start)\nint PyUnicodeTranslateError_GetStart(PyObject *exc, Py_ssize_t *start)\n属于 稳定 ABI.\n获取给定异常对象的 start 属性并将其放入 *start。 start 必须不为 NULL。 成功时返回 0，失败\n时返回 -1。\n如果 UnicodeError.object 是一个空序列，则得到的 start 将为 0。 在其他情况下，它会被剪\n切为 [0, len(object) - 1]。\n参见: UnicodeError.start\nint PyUnicodeDecodeError_SetStart(PyObject *exc, Py_ssize_t start)\nint PyUnicodeEncodeError_SetStart(PyObject *exc, Py_ssize_t start)\n\n|  | 解释器的 except* 实现的具体实现部分。 orig 是被捕获的原始异常，而 excs 是需要被引发的\n异常组成的列表。 该列表包含 orig 可能存在的未被处理的部分，以及在 except* 子句中被引\n发的异常（因而它们具有与 orig 不同的回溯数据）和被重新引发的异常（因而它们具有与 orig\n相同的回溯）。 返回需要被最终引发的 ExceptionGroup，或者如果没有要被引发的异常则返\n回 None。\nAdded in version 3.12.\nUnicode 异常对象\n下列函数被用于创建和修改来自 C 的 Unicode 异常。\nPyObject *PyUnicodeDecodeError_Create(const char *encoding, const char\n*object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char\n*reason)\n返回值：新的引用。 属于 稳定 ABI.\n创建一个 UnicodeDecodeError 对象并附带 encoding, object, length, start, end 和 reason 等属\n性。 encoding 和 reason 为 UTF-8 编码的字符串。\nPyObject *PyUnicodeDecodeError_GetEncoding(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetEncoding(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 encoding 属性\nPyObject *PyUnicodeDecodeError_GetObject(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetObject(PyObject *exc)\nPyObject *PyUnicodeTranslateError_GetObject(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 object 属性\nint PyUnicodeDecodeError_GetStart(PyObject *exc, Py_ssize_t *start)\nint PyUnicodeEncodeError_GetStart(PyObject *exc, Py_ssize_t *start)\nint PyUnicodeTranslateError_GetStart(PyObject *exc, Py_ssize_t *start)\n属于 稳定 ABI.\n获取给定异常对象的 start 属性并将其放入 *start。 start 必须不为 NULL。 成功时返回 0，失败\n时返回 -1。\n如果 UnicodeError.object 是一个空序列，则得到的 start 将为 0。 在其他情况下，它会被剪\n切为 [0, len(object) - 1]。\n参见: UnicodeError.start\nint PyUnicodeDecodeError_SetStart(PyObject *exc, Py_ssize_t start)\nint PyUnicodeEncodeError_SetStart(PyObject *exc, Py_ssize_t start) |  |  |\n| --- | --- | --- | --- |\n\nint PyUnicodeTranslateError_SetStart(PyObject *exc, Py_ssize_t start)\n属于 稳定 ABI.\n将给定异常对象的 start 属性设为 start。 成功时返回 0，失败时返回 -1。\n备注: 虽然传入负的 start 不会引发异常，但是对应的获取器也不会把它当作是相对偏移\n量。\nint PyUnicodeDecodeError_GetEnd(PyObject *exc, Py_ssize_t *end)\nint PyUnicodeEncodeError_GetEnd(PyObject *exc, Py_ssize_t *end)\nint PyUnicodeTranslateError_GetEnd(PyObject *exc, Py_ssize_t *end)\n属于 稳定 ABI.\n获取给定异常对象的 end 属性并将其放入 *end。 end 必须不为 NULL。 成功时返回 0，失败时\n返回 -1。\n如果 UnicodeError.object 是一个空序列，则得到的 end 将为 0。 在其他情况下，它会被剪\n切为 [1, len(object)]。\nint PyUnicodeDecodeError_SetEnd(PyObject *exc, Py_ssize_t end)\nint PyUnicodeEncodeError_SetEnd(PyObject *exc, Py_ssize_t end)\nint PyUnicodeTranslateError_SetEnd(PyObject *exc, Py_ssize_t end)\n属于 稳定 ABI.\n将给定异常对象的 end 属性设为 end。 成功时返回 0，失败时返回 -1。\n参见: UnicodeError.end\nPyObject *PyUnicodeDecodeError_GetReason(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetReason(PyObject *exc)\nPyObject *PyUnicodeTranslateError_GetReason(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 reason 属性\nint PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)\nint PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)\nint PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)\n属于 稳定 ABI.\n将给定异常对象的 reason 属性设为 reason。 成功时返回 0，失败时返回 -1。\n递归控制\n这两个函数提供了一种在 C 层级上进行安全的递归调用的方式，在核心模块与扩展模块中均适用。\n当递归代码不一定会唤起 Python 代码（后者会自动跟踪其递归深度）时就需要用到它们。 它们对\n于 tp_call 实现来说也无必要因为 调用协议 会负责递归处理。\n\n|  | int PyUnicodeTranslateError_SetStart(PyObject *exc, Py_ssize_t start)\n属于 稳定 ABI.\n将给定异常对象的 start 属性设为 start。 成功时返回 0，失败时返回 -1。\n备注: 虽然传入负的 start 不会引发异常，但是对应的获取器也不会把它当作是相对偏移\n量。\nint PyUnicodeDecodeError_GetEnd(PyObject *exc, Py_ssize_t *end)\nint PyUnicodeEncodeError_GetEnd(PyObject *exc, Py_ssize_t *end)\nint PyUnicodeTranslateError_GetEnd(PyObject *exc, Py_ssize_t *end)\n属于 稳定 ABI.\n获取给定异常对象的 end 属性并将其放入 *end。 end 必须不为 NULL。 成功时返回 0，失败时\n返回 -1。\n如果 UnicodeError.object 是一个空序列，则得到的 end 将为 0。 在其他情况下，它会被剪\n切为 [1, len(object)]。\nint PyUnicodeDecodeError_SetEnd(PyObject *exc, Py_ssize_t end)\nint PyUnicodeEncodeError_SetEnd(PyObject *exc, Py_ssize_t end)\nint PyUnicodeTranslateError_SetEnd(PyObject *exc, Py_ssize_t end)\n属于 稳定 ABI.\n将给定异常对象的 end 属性设为 end。 成功时返回 0，失败时返回 -1。\n参见: UnicodeError.end\nPyObject *PyUnicodeDecodeError_GetReason(PyObject *exc)\nPyObject *PyUnicodeEncodeError_GetReason(PyObject *exc)\nPyObject *PyUnicodeTranslateError_GetReason(PyObject *exc)\n返回值：新的引用。 属于 稳定 ABI.\n返回给定异常对象的 reason 属性\nint PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)\nint PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)\nint PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)\n属于 稳定 ABI.\n将给定异常对象的 reason 属性设为 reason。 成功时返回 0，失败时返回 -1。\n递归控制\n这两个函数提供了一种在 C 层级上进行安全的递归调用的方式，在核心模块与扩展模块中均适用。\n当递归代码不一定会唤起 Python 代码（后者会自动跟踪其递归深度）时就需要用到它们。 它们对\n于 tp_call 实现来说也无必要因为 调用协议 会负责递归处理。 |  |\n| --- | --- | --- |\n\nint Py_EnterRecursiveCall(const char *where)\n属于 稳定 ABI 自 3.9 版起.\n标记一个递归的 C 层级调用即将被执行的点位。\n随后此函数将检查是否达到栈限制。 如果是的话，将设置一个 RecursionError 并返回一个非\n零值。 在其他情况下，将返回零。\nwhere 应为一个 UTF-8 编码的字符串如 \" in instance check\"，它将与由递归深度限制所导\n致的 RecursionError 消息相拼接。\n在 3.9 版本发生变更: 此函数现在也在 受限 API 中可用。\nvoid Py_LeaveRecursiveCall(void)\n属于 稳定 ABI 自 3.9 版起.\n结束一个 Py_EnterRecursiveCall()。 必须针对 Py_EnterRecursiveCall() 的每个 成功的\n唤起操作执行一次调用。\n在 3.9 版本发生变更: 此函数现在也在 受限 API 中可用。\n正确地针对容器类型实现 tp_repr 需要特别的递归处理。 在保护栈之外，tp_repr 还需要追踪对象\n以防止出现循环。 以下两个函数将帮助完成此功能。 从实际效果来说，这两个函数是 C 中对应\nreprlib.recursive_repr() 的等价物。\nint Py_ReprEnter(PyObject *object)\n属于 稳定 ABI.\n在 tp_repr 实现的开头被调用以检测循环。\n如果对象已经被处理，此函数将返回一个正整数。 在此情况下 tp_repr 实现应当返回一个指明\n发生循环的字符串对象。 例如，dict 对象将返回 {...} 而 list 对象将返回 [...]。\n如果已达到递归限制则此函数将返回一个负正数。 在此情况下 tp_repr 实现通常应当返回\nNULL。\n在其他情况下，此函数将返回零而 tp_repr 实现将可正常继续。\nvoid Py_ReprLeave(PyObject *object)\n属于 稳定 ABI.\n结束一个 Py_ReprEnter()。 必须针对每个返回零的 Py_ReprEnter() 的唤起操作调用一次。\n异常与警告类型\n所有的标准 Python 异常和警告类别都可以用作全局变量，其名称为 PyExc_ 加上 Python 异常名\n称。 这些类型是 PyObject* 类型；它们都是类对象。\n为完整说明，以下是全部的变量：\n\n|  | int Py_EnterRecursiveCall(const char *where)\n属于 稳定 ABI 自 3.9 版起.\n标记一个递归的 C 层级调用即将被执行的点位。\n随后此函数将检查是否达到栈限制。 如果是的话，将设置一个 RecursionError 并返回一个非\n零值。 在其他情况下，将返回零。\nwhere 应为一个 UTF-8 编码的字符串如 \" in instance check\"，它将与由递归深度限制所导\n致的 RecursionError 消息相拼接。\n在 3.9 版本发生变更: 此函数现在也在 受限 API 中可用。\nvoid Py_LeaveRecursiveCall(void)\n属于 稳定 ABI 自 3.9 版起.\n结束一个 Py_EnterRecursiveCall()。 必须针对 Py_EnterRecursiveCall() 的每个 成功的\n唤起操作执行一次调用。\n在 3.9 版本发生变更: 此函数现在也在 受限 API 中可用。\n正确地针对容器类型实现 tp_repr 需要特别的递归处理。 在保护栈之外，tp_repr 还需要追踪对象\n以防止出现循环。 以下两个函数将帮助完成此功能。 从实际效果来说，这两个函数是 C 中对应\nreprlib.recursive_repr() 的等价物。\nint Py_ReprEnter(PyObject *object)\n属于 稳定 ABI.\n在 tp_repr 实现的开头被调用以检测循环。\n如果对象已经被处理，此函数将返回一个正整数。 在此情况下 tp_repr 实现应当返回一个指明\n发生循环的字符串对象。 例如，dict 对象将返回 {...} 而 list 对象将返回 [...]。\n如果已达到递归限制则此函数将返回一个负正数。 在此情况下 tp_repr 实现通常应当返回\nNULL。\n在其他情况下，此函数将返回零而 tp_repr 实现将可正常继续。\nvoid Py_ReprLeave(PyObject *object)\n属于 稳定 ABI.\n结束一个 Py_ReprEnter()。 必须针对每个返回零的 Py_ReprEnter() 的唤起操作调用一次。\n异常与警告类型\n所有的标准 Python 异常和警告类别都可以用作全局变量，其名称为 PyExc_ 加上 Python 异常名\n称。 这些类型是 PyObject* 类型；它们都是类对象。\n为完整说明，以下是全部的变量： |  |\n| --- | --- | --- |\n\n异常类型\nC 名称 Python 名称\nPyObject *PyExc_BaseException\nBaseException\n属于 稳定 ABI.\nPyObject *PyExc_BaseExceptionGroup\nBaseExceptionGroup\n属于 稳定 ABI 自 3.11 版起.\nPyObject *PyExc_Exception\nException\n属于 稳定 ABI.\nPyObject *PyExc_ArithmeticError\nArithmeticError\n属于 稳定 ABI.\nPyObject *PyExc_AssertionError\nAssertionError\n属于 稳定 ABI.\nPyObject *PyExc_AttributeError\nAttributeError\n属于 稳定 ABI.\nPyObject *PyExc_BlockingIOError\nBlockingIOError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_BrokenPipeError\nBrokenPipeError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_BufferError\nBufferError\n属于 稳定 ABI.\nPyObject *PyExc_ChildProcessError\nChildProcessError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionAbortedError\nConnectionAbortedError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionError\nConnectionError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionRefusedError\nConnectionRefusedError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionResetError\nConnectionResetError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_EOFError\nEOFError\n属于 稳定 ABI.\nPyObject *PyExc_FileExistsError\nFileExistsError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_FileNotFoundError\nFileNotFoundError\n属于 稳定 ABI 自 3.7 版起.\n\n|  | 异常类型\nC 名称 Python 名称\nPyObject *PyExc_BaseException\nBaseException\n属于 稳定 ABI.\nPyObject *PyExc_BaseExceptionGroup\nBaseExceptionGroup\n属于 稳定 ABI 自 3.11 版起.\nPyObject *PyExc_Exception\nException\n属于 稳定 ABI.\nPyObject *PyExc_ArithmeticError\nArithmeticError\n属于 稳定 ABI.\nPyObject *PyExc_AssertionError\nAssertionError\n属于 稳定 ABI.\nPyObject *PyExc_AttributeError\nAttributeError\n属于 稳定 ABI.\nPyObject *PyExc_BlockingIOError\nBlockingIOError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_BrokenPipeError\nBrokenPipeError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_BufferError\nBufferError\n属于 稳定 ABI.\nPyObject *PyExc_ChildProcessError\nChildProcessError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionAbortedError\nConnectionAbortedError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionError\nConnectionError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionRefusedError\nConnectionRefusedError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ConnectionResetError\nConnectionResetError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_EOFError\nEOFError\n属于 稳定 ABI.\nPyObject *PyExc_FileExistsError\nFileExistsError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_FileNotFoundError\nFileNotFoundError\n属于 稳定 ABI 自 3.7 版起. |  |\n| --- | --- | --- |\n\n| C 名称 | Python 名称 |\n| --- | --- |\n| PyObject *PyExc_BaseException\n属于 稳定 ABI. | BaseException |\n| PyObject *PyExc_BaseExceptionGroup\n属于 稳定 ABI 自 3.11 版起. | BaseExceptionGroup |\n| PyObject *PyExc_Exception\n属于 稳定 ABI. | Exception |\n| PyObject *PyExc_ArithmeticError\n属于 稳定 ABI. | ArithmeticError |\n| PyObject *PyExc_AssertionError\n属于 稳定 ABI. | AssertionError |\n| PyObject *PyExc_AttributeError\n属于 稳定 ABI. | AttributeError |\n| PyObject *PyExc_BlockingIOError\n属于 稳定 ABI 自 3.7 版起. | BlockingIOError |\n| PyObject *PyExc_BrokenPipeError\n属于 稳定 ABI 自 3.7 版起. | BrokenPipeError |\n| PyObject *PyExc_BufferError\n属于 稳定 ABI. | BufferError |\n| PyObject *PyExc_ChildProcessError\n属于 稳定 ABI 自 3.7 版起. | ChildProcessError |\n| PyObject *PyExc_ConnectionAbortedError\n属于 稳定 ABI 自 3.7 版起. | ConnectionAbortedError |\n| PyObject *PyExc_ConnectionError\n属于 稳定 ABI 自 3.7 版起. | ConnectionError |\n| PyObject *PyExc_ConnectionRefusedError\n属于 稳定 ABI 自 3.7 版起. | ConnectionRefusedError |\n| PyObject *PyExc_ConnectionResetError\n属于 稳定 ABI 自 3.7 版起. | ConnectionResetError |\n| PyObject *PyExc_EOFError\n属于 稳定 ABI. | EOFError |\n| PyObject *PyExc_FileExistsError\n属于 稳定 ABI 自 3.7 版起. | FileExistsError |\n| PyObject *PyExc_FileNotFoundError\n属于 稳定 ABI 自 3.7 版起. | FileNotFoundError |\n\nC 名称 Python 名称\nPyObject *PyExc_FloatingPointError\nFloatingPointError\n属于 稳定 ABI.\nPyObject *PyExc_GeneratorExit\nGeneratorExit\n属于 稳定 ABI.\nPyObject *PyExc_ImportError\nImportError\n属于 稳定 ABI.\nPyObject *PyExc_IndentationError\nIndentationError\n属于 稳定 ABI.\nPyObject *PyExc_IndexError\nIndexError\n属于 稳定 ABI.\nPyObject *PyExc_InterruptedError\nInterruptedError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_IsADirectoryError\nIsADirectoryError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_KeyError\nKeyError\n属于 稳定 ABI.\nPyObject *PyExc_KeyboardInterrupt\nKeyboardInterrupt\n属于 稳定 ABI.\nPyObject *PyExc_LookupError\nLookupError\n属于 稳定 ABI.\nPyObject *PyExc_MemoryError\nMemoryError\n属于 稳定 ABI.\nPyObject *PyExc_ModuleNotFoundError\nModuleNotFoundError\n属于 稳定 ABI 自 3.6 版起.\nPyObject *PyExc_NameError\nNameError\n属于 稳定 ABI.\nPyObject *PyExc_NotADirectoryError\nNotADirectoryError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_NotImplementedError\nNotImplementedError\n属于 稳定 ABI.\nPyObject *PyExc_OSError\nOSError\n属于 稳定 ABI.\nPyObject *PyExc_OverflowError\nOverflowError\n属于 稳定 ABI.\nPyObject *PyExc_PermissionError PermissionError\n\n|  | C 名称 | Python 名称 |  |  |\n| --- | --- | --- | --- | --- |\n|  | PyObject *PyExc_FloatingPointError\n属于 稳定 ABI. | FloatingPointError |  |  |\n|  | PyObject *PyExc_GeneratorExit\n属于 稳定 ABI. | GeneratorExit |  |  |\n|  | PyObject *PyExc_ImportError\n属于 稳定 ABI. | ImportError |  |  |\n|  | PyObject *PyExc_IndentationError\n属于 稳定 ABI. | IndentationError |  |  |\n|  | PyObject *PyExc_IndexError\n属于 稳定 ABI. | IndexError |  |  |\n|  | PyObject *PyExc_InterruptedError\n属于 稳定 ABI 自 3.7 版起. | InterruptedError |  |  |\n|  | PyObject *PyExc_IsADirectoryError\n属于 稳定 ABI 自 3.7 版起. | IsADirectoryError |  |  |\n|  | PyObject *PyExc_KeyError\n属于 稳定 ABI. | KeyError |  |  |\n|  | PyObject *PyExc_KeyboardInterrupt\n属于 稳定 ABI. | KeyboardInterrupt |  |  |\n|  | PyObject *PyExc_LookupError\n属于 稳定 ABI. | LookupError |  |  |\n|  | PyObject *PyExc_MemoryError\n属于 稳定 ABI. | MemoryError |  |  |\n|  | PyObject *PyExc_ModuleNotFoundError\n属于 稳定 ABI 自 3.6 版起. | ModuleNotFoundError |  |  |\n|  | PyObject *PyExc_NameError\n属于 稳定 ABI. | NameError |  |  |\n|  | PyObject *PyExc_NotADirectoryError\n属于 稳定 ABI 自 3.7 版起. | NotADirectoryError |  |  |\n|  | PyObject *PyExc_NotImplementedError\n属于 稳定 ABI. | NotImplementedError |  |  |\n|  | PyObject *PyExc_OSError\n属于 稳定 ABI. | OSError |  |  |\n|  | PyObject *PyExc_OverflowError\n属于 稳定 ABI. | OverflowError |  |  |\n|  | PyObject *PyExc_PermissionError | PermissionError |  |  |\n\nC 名称 Python 名称\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ProcessLookupError\nProcessLookupError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_PythonFinalizationError PythonFinalizationError\nPyObject *PyExc_RecursionError\nRecursionError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_ReferenceError\nReferenceError\n属于 稳定 ABI.\nPyObject *PyExc_RuntimeError\nRuntimeError\n属于 稳定 ABI.\nPyObject *PyExc_StopAsyncIteration\nStopAsyncIteration\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_StopIteration\nStopIteration\n属于 稳定 ABI.\nPyObject *PyExc_SyntaxError\nSyntaxError\n属于 稳定 ABI.\nPyObject *PyExc_SystemError\nSystemError\n属于 稳定 ABI.\nPyObject *PyExc_SystemExit\nSystemExit\n属于 稳定 ABI.\nPyObject *PyExc_TabError\nTabError\n属于 稳定 ABI.\nPyObject *PyExc_TimeoutError\nTimeoutError\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_TypeError\nTypeError\n属于 稳定 ABI.\nPyObject *PyExc_UnboundLocalError\nUnboundLocalError\n属于 稳定 ABI.\nPyObject *PyExc_UnicodeDecodeError\nUnicodeDecodeError\n属于 稳定 ABI.\nPyObject *PyExc_UnicodeEncodeError\nUnicodeEncodeError\n属于 稳定 ABI.\nPyObject *PyExc_UnicodeError\nUnicodeError\n属于 稳定 ABI.\nPyObject *PyExc_UnicodeTranslateError UnicodeTranslateError\n\n|  | C 名称 | Python 名称 |  |  |\n| --- | --- | --- | --- | --- |\n|  | 属于 稳定 ABI 自 3.7 版起. |  |  |  |\n|  | PyObject *PyExc_ProcessLookupError\n属于 稳定 ABI 自 3.7 版起. | ProcessLookupError |  |  |\n|  | PyObject *PyExc_PythonFinalizationError | PythonFinalizationError |  |  |\n|  | PyObject *PyExc_RecursionError\n属于 稳定 ABI 自 3.7 版起. | RecursionError |  |  |\n|  | PyObject *PyExc_ReferenceError\n属于 稳定 ABI. | ReferenceError |  |  |\n|  | PyObject *PyExc_RuntimeError\n属于 稳定 ABI. | RuntimeError |  |  |\n|  | PyObject *PyExc_StopAsyncIteration\n属于 稳定 ABI 自 3.7 版起. | StopAsyncIteration |  |  |\n|  | PyObject *PyExc_StopIteration\n属于 稳定 ABI. | StopIteration |  |  |\n|  | PyObject *PyExc_SyntaxError\n属于 稳定 ABI. | SyntaxError |  |  |\n|  | PyObject *PyExc_SystemError\n属于 稳定 ABI. | SystemError |  |  |\n|  | PyObject *PyExc_SystemExit\n属于 稳定 ABI. | SystemExit |  |  |\n|  | PyObject *PyExc_TabError\n属于 稳定 ABI. | TabError |  |  |\n|  | PyObject *PyExc_TimeoutError\n属于 稳定 ABI 自 3.7 版起. | TimeoutError |  |  |\n|  | PyObject *PyExc_TypeError\n属于 稳定 ABI. | TypeError |  |  |\n|  | PyObject *PyExc_UnboundLocalError\n属于 稳定 ABI. | UnboundLocalError |  |  |\n|  | PyObject *PyExc_UnicodeDecodeError\n属于 稳定 ABI. | UnicodeDecodeError |  |  |\n|  | PyObject *PyExc_UnicodeEncodeError\n属于 稳定 ABI. | UnicodeEncodeError |  |  |\n|  | PyObject *PyExc_UnicodeError\n属于 稳定 ABI. | UnicodeError |  |  |\n|  | PyObject *PyExc_UnicodeTranslateError | UnicodeTranslateError |  |  |\n\nC 名称 Python 名称\n属于 稳定 ABI.\nPyObject *PyExc_ValueError\nValueError\n属于 稳定 ABI.\nPyObject *PyExc_ZeroDivisionError\nZeroDivisionError\n属于 稳定 ABI.\nAdded in version 3.3: PyExc_BlockingIOError, PyExc_BrokenPipeError,\nPyExc_ChildProcessError, PyExc_ConnectionError, PyExc_ConnectionAbortedError,\nPyExc_ConnectionRefusedError, PyExc_ConnectionResetError,\nPyExc_FileExistsError, PyExc_FileNotFoundError, PyExc_InterruptedError,\nPyExc_IsADirectoryError, PyExc_NotADirectoryError, PyExc_PermissionError,\nPyExc_ProcessLookupError and PyExc_TimeoutError 介绍如下 PEP 3151.\nAdded in version 3.5: PyExc_StopAsyncIteration 和 PyExc_RecursionError.\nAdded in version 3.6: PyExc_ModuleNotFoundError.\nAdded in version 3.11: PyExc_BaseExceptionGroup.\nOSError 别名\n以下是 PyExc_OSError 的兼容性别名。\n在 3.3 版本发生变更: 这些别名曾经是单独的异常类型。\nC 名称 Python 名称 备注\nPyObject *PyExc_EnvironmentError\nOSError\n属于 稳定 ABI.\nPyObject *PyExc_IOError\nOSError\n属于 稳定 ABI.\nPyObject *PyExc_WindowsError\nOSError [win]\n属于 稳定 ABI on Windows 自 3.7 版起.\n注：\n[win] PyExc_WindowsError 仅在 Windows 上定义；通过测试是否定义了预处理器宏\nMS_WINDOWS 来保护用到它的代码。\n警告类型\nC 名称 Python 名称\nPyObject *PyExc_Warning Warning\n\n|  | C 名称 | Python 名称 |  |\n| --- | --- | --- | --- |\n|  | 属于 稳定 ABI. |  |  |\n|  | PyObject *PyExc_ValueError\n属于 稳定 ABI. | ValueError |  |\n|  | PyObject *PyExc_ZeroDivisionError\n属于 稳定 ABI. | ZeroDivisionError |  |\n|  | C 名称 |  | Python 名称 |\n|  | PyObject *PyExc_Warning |  | Warning |\n\n| C 名称 | Python 名称 | 备注 |\n| --- | --- | --- |\n| PyObject *PyExc_EnvironmentError\n属于 稳定 ABI. | OSError |  |\n| PyObject *PyExc_IOError\n属于 稳定 ABI. | OSError |  |\n| PyObject *PyExc_WindowsError\n属于 稳定 ABI on Windows 自 3.7 版起. | OSError | [win] |\n\nC 名称 Python 名称\n属于 稳定 ABI.\nPyObject *PyExc_BytesWarning\nBytesWarning\n属于 稳定 ABI.\nPyObject *PyExc_DeprecationWarning\nDeprecationWarning\n属于 稳定 ABI.\nPyObject *PyExc_EncodingWarning\nEncodingWarning\n属于 稳定 ABI 自 3.10 版起.\nPyObject *PyExc_FutureWarning\nFutureWarning\n属于 稳定 ABI.\nPyObject *PyExc_ImportWarning\nImportWarning\n属于 稳定 ABI.\nPyObject *PyExc_PendingDeprecationWarning\nPendingDeprecationWarning\n属于 稳定 ABI.\nPyObject *PyExc_ResourceWarning\nResourceWarning\n属于 稳定 ABI 自 3.7 版起.\nPyObject *PyExc_RuntimeWarning\nRuntimeWarning\n属于 稳定 ABI.\nPyObject *PyExc_SyntaxWarning\nSyntaxWarning\n属于 稳定 ABI.\nPyObject *PyExc_UnicodeWarning\nUnicodeWarning\n属于 稳定 ABI.\nPyObject *PyExc_UserWarning\nUserWarning\n属于 稳定 ABI.\nAdded in version 3.2: PyExc_ResourceWarning.\nAdded in version 3.10: PyExc_EncodingWarning.\n\n| C 名称 | Python 名称 |\n| --- | --- |\n| 属于 稳定 ABI. |  |\n| PyObject *PyExc_BytesWarning\n属于 稳定 ABI. | BytesWarning |\n| PyObject *PyExc_DeprecationWarning\n属于 稳定 ABI. | DeprecationWarning |\n| PyObject *PyExc_EncodingWarning\n属于 稳定 ABI 自 3.10 版起. | EncodingWarning |\n| PyObject *PyExc_FutureWarning\n属于 稳定 ABI. | FutureWarning |\n| PyObject *PyExc_ImportWarning\n属于 稳定 ABI. | ImportWarning |\n| PyObject *PyExc_PendingDeprecationWarning\n属于 稳定 ABI. | PendingDeprecationWarning |\n| PyObject *PyExc_ResourceWarning\n属于 稳定 ABI 自 3.7 版起. | ResourceWarning |\n| PyObject *PyExc_RuntimeWarning\n属于 稳定 ABI. | RuntimeWarning |\n| PyObject *PyExc_SyntaxWarning\n属于 稳定 ABI. | SyntaxWarning |\n| PyObject *PyExc_UnicodeWarning\n属于 稳定 ABI. | UnicodeWarning |\n| PyObject *PyExc_UserWarning\n属于 稳定 ABI. | UserWarning |", "metadata": {"title": "00_异常处理", "source": "md_docs\\python_c-api_md\\00_异常处理.md", "doc_type": "C API", "language": "中文", "doc_id": "25f1189a"}}
{"doc_id": "0a8b43f3", "content": "引用计数\n本节介绍的函数和宏被用于管理 Python 对象的引用计数。\nPy_ssize_t Py_REFCNT(PyObject *o)\n属于 稳定 ABI 自 3.14 版起.\n获取 Python 对象 o 的引用计数。\n请注意返回的值可能并不真正反映实际持有的对象引用数。 例如，有些对象属于 immortal 对\n象并具有并不反映实际引用数的非常高的 refcount 值。 因此，除了 0 或 1 这两个值，不要依赖\n返回值的准确性。\n使用 Py_SET_REFCNT() 函数来设置一个对象引用计数。\n备注: 在 Python 的 自由线程 构建版中，返回 1 并不足以确定是否能安全地将 o 视为不可\n被其他线程访问。 对于此场景请改用 PyUnstable_Object_IsUniquelyReferenced()。\n另请参阅 PyUnstable_Object_IsUniqueReferencedTemporary() 函数。\n在 3.10 版本发生变更: Py_REFCNT() 被改为内联的静态函数。\n在 3.11 版本发生变更: 形参类型不再是 const PyObject*。\nvoid Py_SET_REFCNT(PyObject *o, Py_ssize_t refcnt)\n将对象 o 的引用计数器设为 refcnt。\n在 启用自由线程的 Python 编译版 中，如果 refcnt 大于 UINT32_MAX，该对象将被设为\nimmortal 对象。\n此函数对 immortal 对象没有效果。\nAdded in version 3.9.\n在 3.12 版本发生变更: 永生对象不会被修改。\nvoid Py_INCREF(PyObject *o)\n表示为对象 o 获取一个新的 strong reference，指明该对象正在被使用且不应被销毁。\n此函数对 immortal 对象没有效果。\n此函数通常被用来将 borrowed reference 原地转换为 strong reference。 Py_NewRef() 函数可\n被用来创建新的 strong reference。\n当对象使用完毕后，可调用 Py_DECREF() 来释放它。\n\n此对象必须不为 NULL；如果你不能确定它不为 NULL，请使用 Py_XINCREF()。\n不要预期此函数会以任何方式实际地改变 o。 至少对 某些对象 来说，此函数将没有任何效果。\n在 3.12 版本发生变更: 永生对象不会被修改。\nvoid Py_XINCREF(PyObject *o)\n与 Py_INCREF() 类似，但对象 o 可以为 NULL，在这种情况下此函数将没有任何效果。\n另请参阅 Py_XNewRef()。\nPyObject *Py_NewRef(PyObject *o)\n属于 稳定 ABI 自 3.10 版起.\n为对象创建一个新的 strong reference: 在 o 上调用 Py_INCREF() 并返回对象 o。\n当不再需要这个 strong reference 时，应当在其上调用 Py_DECREF() 来释放引用。\n对象 o 必须不为 NULL；如果 o 可以为 NULL 则应改用 Py_XNewRef()。\n例如：\nPy_INCREF(obj);\nself->attr = obj;\n可以写成:\nself->attr = Py_NewRef(obj);\n另请参阅 Py_INCREF()。\nAdded in version 3.10.\nPyObject *Py_XNewRef(PyObject *o)\n属于 稳定 ABI 自 3.10 版起.\n类似于 Py_NewRef()，但对象 o 可以为 NULL。\n如果对象 o 为 NULL，该函数也·将返回 NULL。\nAdded in version 3.10.\nvoid Py_DECREF(PyObject *o)\n释放一个指向对象 o 的 strong reference，表明该引用不再被使用。\n此函数对 immortal 对象没有效果。\n当最后一个 strong reference 被释放时 (即对象的引用计数变为 0)，将会唤起该对象所属类型的\ndeallocation 函数 (它必须不为 NULL)。\n此函数通常被用于在退出作用域之前删除一个 strong reference。\n\n|  | 此对象必须不为 NULL；如果你不能确定它不为 NULL，请使用 Py_XINCREF()。\n不要预期此函数会以任何方式实际地改变 o。 至少对 某些对象 来说，此函数将没有任何效果。\n在 3.12 版本发生变更: 永生对象不会被修改。\nvoid Py_XINCREF(PyObject *o)\n与 Py_INCREF() 类似，但对象 o 可以为 NULL，在这种情况下此函数将没有任何效果。\n另请参阅 Py_XNewRef()。\nPyObject *Py_NewRef(PyObject *o)\n属于 稳定 ABI 自 3.10 版起.\n为对象创建一个新的 strong reference: 在 o 上调用 Py_INCREF() 并返回对象 o。\n当不再需要这个 strong reference 时，应当在其上调用 Py_DECREF() 来释放引用。\n对象 o 必须不为 NULL；如果 o 可以为 NULL 则应改用 Py_XNewRef()。\n例如：\nPy_INCREF(obj);\nself->attr = obj;\n可以写成:\nself->attr = Py_NewRef(obj);\n另请参阅 Py_INCREF()。\nAdded in version 3.10.\nPyObject *Py_XNewRef(PyObject *o)\n属于 稳定 ABI 自 3.10 版起.\n类似于 Py_NewRef()，但对象 o 可以为 NULL。\n如果对象 o 为 NULL，该函数也·将返回 NULL。\nAdded in version 3.10.\nvoid Py_DECREF(PyObject *o)\n释放一个指向对象 o 的 strong reference，表明该引用不再被使用。\n此函数对 immortal 对象没有效果。\n当最后一个 strong reference 被释放时 (即对象的引用计数变为 0)，将会唤起该对象所属类型的\ndeallocation 函数 (它必须不为 NULL)。\n此函数通常被用于在退出作用域之前删除一个 strong reference。 |  |\n| --- | --- | --- |\n\n此对象必须不为 NULL；如果你不能确定它不为 NULL，请使用 Py_XDECREF()。\n不要预期此函数会以任何方式实际地改变 o。 至少对 某些对象 来说，此函数将没有任何效果。\n警告: 释放函数会导致任意 Python 代码被唤起（例如当一个带有 __del__() 方法的类实例\n被释放时就是如此）。 虽然这些代码中的异常不会被传播，但被执行的代码能够自由访问所\n有 Python 全局变量。 这意味着在调用 Py_DECREF() 之前任何可通过全局变量获取的对象都\n应该处于完好的状态。 例如，从一个列表中删除对象的代码应该将被删除对象的引用拷贝到\n一个临时变量中，更新列表数据结构，然后再为临时变量调用 Py_DECREF()。\n在 3.12 版本发生变更: 永生对象不会被修改。\nvoid Py_XDECREF(PyObject *o)\n与 Py_DECREF() 类似，但对象 o 可以为 NULL，在这种情况下此函数将没有任何效果。 来自\nPy_DECREF() 的警告同样适用于此处。\nvoid Py_CLEAR(PyObject *o)\n释放一个指向对象 o 的 strong reference。 对象可以为 NULL，在此情况下该宏将没有任何效\n果；在其他情况下其效果与 Py_DECREF() 相同，区别在于其参数也会被设为 NULL。 针对\nPy_DECREF() 的警告不适用于所传递的对象，因为该宏会细心地使用一个临时变量并在释放引\n用之前将参数设为 NULL。\n当需要释放指向一个在垃圾回收期间可能被会遍历的对象的引用时使用该宏是一个好主意。\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果该参数具有附带影响，它们将\n不会再被复制。\nvoid Py_IncRef(PyObject *o)\n属于 稳定 ABI.\n表示获取一个指向对象 o 的新 strong reference。 Py_XINCREF() 的函数版本。 它可被用于\nPython 的运行时动态嵌入。\nvoid Py_DecRef(PyObject *o)\n属于 稳定 ABI.\n释放一个指向对象 o 的 strong reference。 Py_XDECREF() 的函数版本。 它可被用于 Python 的\n运行时动态嵌入。\nPy_SETREF(dst, src)\n该宏可安全地释放一个指向对象 dst 的 strong reference，并将 dst 设为 src。\n在 Py_CLEAR() 的情况中，这样“直观”的代码可能会是致命的:\nPy_DECREF(dst);\ndst = src;\n安全的方式是这样:\n\n|  | 此对象必须不为 NULL；如果你不能确定它不为 NULL，请使用 Py_XDECREF()。\n不要预期此函数会以任何方式实际地改变 o。 至少对 某些对象 来说，此函数将没有任何效果。\n警告: 释放函数会导致任意 Python 代码被唤起（例如当一个带有 __del__() 方法的类实例\n被释放时就是如此）。 虽然这些代码中的异常不会被传播，但被执行的代码能够自由访问所\n有 Python 全局变量。 这意味着在调用 Py_DECREF() 之前任何可通过全局变量获取的对象都\n应该处于完好的状态。 例如，从一个列表中删除对象的代码应该将被删除对象的引用拷贝到\n一个临时变量中，更新列表数据结构，然后再为临时变量调用 Py_DECREF()。\n在 3.12 版本发生变更: 永生对象不会被修改。\nvoid Py_XDECREF(PyObject *o)\n与 Py_DECREF() 类似，但对象 o 可以为 NULL，在这种情况下此函数将没有任何效果。 来自\nPy_DECREF() 的警告同样适用于此处。\nvoid Py_CLEAR(PyObject *o)\n释放一个指向对象 o 的 strong reference。 对象可以为 NULL，在此情况下该宏将没有任何效\n果；在其他情况下其效果与 Py_DECREF() 相同，区别在于其参数也会被设为 NULL。 针对\nPy_DECREF() 的警告不适用于所传递的对象，因为该宏会细心地使用一个临时变量并在释放引\n用之前将参数设为 NULL。\n当需要释放指向一个在垃圾回收期间可能被会遍历的对象的引用时使用该宏是一个好主意。\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果该参数具有附带影响，它们将\n不会再被复制。\nvoid Py_IncRef(PyObject *o)\n属于 稳定 ABI.\n表示获取一个指向对象 o 的新 strong reference。 Py_XINCREF() 的函数版本。 它可被用于\nPython 的运行时动态嵌入。\nvoid Py_DecRef(PyObject *o)\n属于 稳定 ABI.\n释放一个指向对象 o 的 strong reference。 Py_XDECREF() 的函数版本。 它可被用于 Python 的\n运行时动态嵌入。\nPy_SETREF(dst, src)\n该宏可安全地释放一个指向对象 dst 的 strong reference，并将 dst 设为 src。\n在 Py_CLEAR() 的情况中，这样“直观”的代码可能会是致命的:\nPy_DECREF(dst);\ndst = src;\n安全的方式是这样: |  |\n| --- | --- | --- |\n\nPy_SETREF(dst, src);\n这样使得在释放对旧 dst 值的引用 之前 将 dst 设为 src，从而让任何因 dst 被去除而触发的代码\n不再相信 dst 指向一个有效的对象。\nAdded in version 3.6.\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果某个参数具有附带影响，它们\n将不会再被复制。\nPy_XSETREF(dst, src)\n使用 Py_XDECREF() 代替 Py_DECREF() 的 Py_SETREF 宏的变种。\nAdded in version 3.6.\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果某个参数具有附带影响，它们\n将不会再被复制。\n\n| Py_SETREF(dst, src);\n这样使得在释放对旧 dst 值的引用 之前 将 dst 设为 src，从而让任何因 dst 被去除而触发的代码\n不再相信 dst 指向一个有效的对象。\nAdded in version 3.6.\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果某个参数具有附带影响，它们\n将不会再被复制。\nPy_XSETREF(dst, src)\n使用 Py_XDECREF() 代替 Py_DECREF() 的 Py_SETREF 宏的变种。\nAdded in version 3.6.\n在 3.12 版本发生变更: 该宏参数现在只会被求值一次。 如果某个参数具有附带影响，它们\n将不会再被复制。 | Py_SETREF(dst, src); |\n| --- | --- |", "metadata": {"title": "00_引用计数", "source": "md_docs\\python_c-api_md\\00_引用计数.md", "doc_type": "C API", "language": "中文", "doc_id": "0a8b43f3"}}
{"doc_id": "260fa1ed", "content": "抽象对象层\n本章中的函数与 Python对象交互，无论其类型，或具有广泛类的对象类型（例如，所有数值类型，\n或所有序列类型）。当使用对象类型并不适用时，他们会产生一个 Python 异常。\n这些函数是不可能用于未正确初始化的对象的，如一个列表对象被 PyList_New() 创建，但其中的\n项目没有被设置为一些非 NULL 的值。\n对象协议\n调用协议\ntp_call 协议\nVectorcall 协议\n递归控制\nVectorcall 支持 API\n调用对象的 API\n调用支持 API\n数字协议\n序列协议\n映射协议\n迭代器协议\n缓冲协议\n缓冲区结构\n缓冲区请求的类型\n与请求无关的字段\n只读，格式\n形状，步幅，子偏移量\n连续性的请求\n复合请求\n复杂数组\nNumPy-风格：形状和步幅\nPIL-风格：形状，步幅和子偏移量\n缓冲区相关函数", "metadata": {"title": "00_抽象对象层", "source": "md_docs\\python_c-api_md\\00_抽象对象层.md", "doc_type": "C API", "language": "中文", "doc_id": "260fa1ed"}}
{"doc_id": "d5b919df", "content": "极高层级 API\n本章节的函数将允许你执行在文件或缓冲区中提供的 Python 源代码，但它们将不允许你在更细节化\n的方式与解释器进行交互。\n这些函数中有几个可以接受特定的语法前缀符号作为形参。 可用的前缀符号有 Py_eval_input,\nPy_file_input 和 Py_single_input。 这些符号会在接受它们作为形参的函数文档中加以说明。\n还要注意这些函数中有几个可以接受 FILE* 形参。 有一个需要小心处理的特别问题是针对不同 C 库\n的 FILE 结构体可能是不相同且不兼容的。 （至少是）在 Windows 中，动态链接的扩展实际上有可\n能会使用不同的库，所以应当特别注意只有在确定这些函数是由 Python 运行时所使用的相同的库创\n建的情况下才将 FILE* 形参传给它们。\nint PyRun_AnyFile(FILE *fp, const char *filename)\n这是针对下面 PyRun_AnyFileExFlags() 的简化版接口，将 closeit 设为 0 而将 flags 设为\nNULL。\nint PyRun_AnyFileFlags(FILE *fp, const char *filename, PyCompilerFlags\n*flags)\n这是针对下面 PyRun_AnyFileExFlags() 的简化版接口，将 closeit 参数设为 0。\nint PyRun_AnyFileEx(FILE *fp, const char *filename, int closeit)\n这是针对下面 PyRun_AnyFileExFlags() 的简化版接口，将 flags 参数设为 NULL。\nint PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit,\nPyCompilerFlags *flags)\n如果 fp 指向一个关联到交互设备（控制台或终端输入或 Unix 伪终端）的文件，则返回\nPyRun_InteractiveLoop() 的值，否则返回 PyRun_SimpleFile() 的结果。 filename 会使用\n文件系统的编码格式 (sys.getfilesystemencoding()) 来解码。 如果 filename 为 NULL，此\n函数会使用 \"???\" 作为文件名。 如果 closeit 为真值，文件会在 PyRun_SimpleFileExFlags()\n返回之前被关闭。\nint PyRun_SimpleString(const char *command)\n这是针对下面 PyRun_SimpleStringFlags() 的简化版接口，将 PyCompilerFlags* 参数设为\nNULL。\nint PyRun_SimpleStringFlags(const char *command, PyCompilerFlags *flags)\n根据 flags 参数，在 __main__ 模块中执行 Python 源代码。 如果 __main__ 尚不存在，它将被\n创建。 成功时返回 0，如果引发异常则返回 -1。 如果发生错误，则将无法获得异常信息。 对\n于 flags 的含义，请参阅下文。\n请注意如果引发了一个在其他场合下未处理的 SystemExit，此函数将不会返回 -1，而是退出\n进程，只要 PyConfig.inspect 为零就会这样。\n\nint PyRun_SimpleFile(FILE *fp, const char *filename)\n这是针对下面 PyRun_SimpleFileExFlags() 的简化版接口，将 closeit 设为 0 而将 flags 设为\nNULL。\nint PyRun_SimpleFileEx(FILE *fp, const char *filename, int closeit)\n这是针对下面 PyRun_SimpleFileExFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit,\nPyCompilerFlags *flags)\n类似于 PyRun_SimpleStringFlags()，但 Python 源代码是从 fp 读取而不是一个内存中的字\n符串。 filename 应为文件名，它将使用 filesystem encoding and error handler 来解码。 如果\ncloseit 为真值，则文件将在 PyRun_SimpleFileExFlags() 返回之前被关闭。\n备注: 在 Windows 上，fp 应当以二进制模式打开 (即 fopen(filename, \"rb\"))。 否则，\nPython 可能无法正确地处理使用 LF 行结束符的脚本文件。\nint PyRun_InteractiveOne(FILE *fp, const char *filename)\n这是针对下面 PyRun_InteractiveOneFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags\n*flags)\n根据 flags 参数读取并执行来自与交互设备相关联的文件的一条语句。 用户将得到使用\nsys.ps1 和 sys.ps2 的提示。 filename 将使用 filesystem encoding and error handler 来解\n码。\n当输入被成功执行时返回 0，如果引发异常则返回 -1，或者如果存在解析错误则返回来自作为\nPython 的组成部分发布的 errcode.h 包括文件的错误代码。 （请注意 errcode.h 并未被\nPython.h 所包括，因此如果需要则必须专门地包括。）\nint PyRun_InteractiveLoop(FILE *fp, const char *filename)\n这是针对下面 PyRun_InteractiveLoopFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_InteractiveLoopFlags(FILE *fp, const char *filename,\nPyCompilerFlags *flags)\n读取并执行来自与交互设备相关联的语句直至到达 EOF。 用户将得到使用 sys.ps1 和\nsys.ps2 的提示。 filename 将使用 filesystem encoding and error handler 来解码。 当位于\nEOF 时将返回 0，或者当失败时将返回一个负数。\nint (*PyOS_InputHook)(void)\n属于 稳定 ABI.\n可以被设为指向一个原型为 int func(void) 的函数。 该函数将在Python 的解释器提示符即\n将空闲并等待用户从终端输入时被调用。 返回值会被忽略。 重写这个钩子可被用来将解释器的\n提示符集成到其他事件循环中，就像 Python 码中 Modules/_tkinter.c 所做的那样。\n在 3.12 版本发生变更: 此函数只能被 主解释器 调用。\n\n|  | int PyRun_SimpleFile(FILE *fp, const char *filename)\n这是针对下面 PyRun_SimpleFileExFlags() 的简化版接口，将 closeit 设为 0 而将 flags 设为\nNULL。\nint PyRun_SimpleFileEx(FILE *fp, const char *filename, int closeit)\n这是针对下面 PyRun_SimpleFileExFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit,\nPyCompilerFlags *flags)\n类似于 PyRun_SimpleStringFlags()，但 Python 源代码是从 fp 读取而不是一个内存中的字\n符串。 filename 应为文件名，它将使用 filesystem encoding and error handler 来解码。 如果\ncloseit 为真值，则文件将在 PyRun_SimpleFileExFlags() 返回之前被关闭。\n备注: 在 Windows 上，fp 应当以二进制模式打开 (即 fopen(filename, \"rb\"))。 否则，\nPython 可能无法正确地处理使用 LF 行结束符的脚本文件。\nint PyRun_InteractiveOne(FILE *fp, const char *filename)\n这是针对下面 PyRun_InteractiveOneFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags\n*flags)\n根据 flags 参数读取并执行来自与交互设备相关联的文件的一条语句。 用户将得到使用\nsys.ps1 和 sys.ps2 的提示。 filename 将使用 filesystem encoding and error handler 来解\n码。\n当输入被成功执行时返回 0，如果引发异常则返回 -1，或者如果存在解析错误则返回来自作为\nPython 的组成部分发布的 errcode.h 包括文件的错误代码。 （请注意 errcode.h 并未被\nPython.h 所包括，因此如果需要则必须专门地包括。）\nint PyRun_InteractiveLoop(FILE *fp, const char *filename)\n这是针对下面 PyRun_InteractiveLoopFlags() 的简化版接口，将 flags 设为 NULL。\nint PyRun_InteractiveLoopFlags(FILE *fp, const char *filename,\nPyCompilerFlags *flags)\n读取并执行来自与交互设备相关联的语句直至到达 EOF。 用户将得到使用 sys.ps1 和\nsys.ps2 的提示。 filename 将使用 filesystem encoding and error handler 来解码。 当位于\nEOF 时将返回 0，或者当失败时将返回一个负数。\nint (*PyOS_InputHook)(void)\n属于 稳定 ABI.\n可以被设为指向一个原型为 int func(void) 的函数。 该函数将在Python 的解释器提示符即\n将空闲并等待用户从终端输入时被调用。 返回值会被忽略。 重写这个钩子可被用来将解释器的\n提示符集成到其他事件循环中，就像 Python 码中 Modules/_tkinter.c 所做的那样。\n在 3.12 版本发生变更: 此函数只能被 主解释器 调用。 |  |\n| --- | --- | --- |\n\nchar *(*PyOS_ReadlineFunctionPointer)(FILE*, FILE*, const char*)\n可以被设为指向一个原型为 char *func(FILE *stdin, FILE *stdout, char *prompt) 的\n函数，重写被用来读取解释器提示符的一行输入的默认函数。 该函数被预期为如果字符串\nprompt 不为 NULL 就输出它，然后从所提供的标准输入文件读取一行输入，并返回结果字符\n串。 例如，readline 模块将这个钩子设置为提供行编辑和 tab 键补全等功能。\n结果必须是一个由 PyMem_RawMalloc() 或 PyMem_RawRealloc() 分配的字符串，或者如果发\n生错误则为 NULL。\n在 3.4 版本发生变更: 结果必须由 PyMem_RawMalloc() 或 PyMem_RawRealloc() 分配，\n而不是由 PyMem_Malloc() 或 PyMem_Realloc() 分配。\n在 3.12 版本发生变更: 此函数只能被 主解释器 调用。\nPyObject *PyRun_String(const char *str, int start, PyObject *globals, PyObject\n*locals)\n返回值：新的引用。\n这是针对下面 PyRun_StringFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *PyRun_StringFlags(const char *str, int start, PyObject *globals,\nPyObject *locals, PyCompilerFlags *flags)\n返回值：新的引用。\n在由对象 globals 和 locals 指定的上下文中执行来自 str 的 Python 源代码并使用以 flags 指定的\n编译器旗标。 globals 必须是一个字典; locals 可以是任何实现了映射协议的对象。 形参 start 指\n定的起始符号必须是以下几种之一: Py_eval_input, Py_file_input, or Py_single_input。\n返回将代码作为 Python 对象执行的结果，或者如果引发了异常则返回 NULL。\nPyObject *PyRun_File(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 closeit 设为 0 并将 flags 设为 NULL。\nPyObject *PyRun_FileEx(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals, int closeit)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *PyRun_FileFlags(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals, PyCompilerFlags *flags)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 closeit 设为 0。\n\n|  | char *(*PyOS_ReadlineFunctionPointer)(FILE*, FILE*, const char*)\n可以被设为指向一个原型为 char *func(FILE *stdin, FILE *stdout, char *prompt) 的\n函数，重写被用来读取解释器提示符的一行输入的默认函数。 该函数被预期为如果字符串\nprompt 不为 NULL 就输出它，然后从所提供的标准输入文件读取一行输入，并返回结果字符\n串。 例如，readline 模块将这个钩子设置为提供行编辑和 tab 键补全等功能。\n结果必须是一个由 PyMem_RawMalloc() 或 PyMem_RawRealloc() 分配的字符串，或者如果发\n生错误则为 NULL。\n在 3.4 版本发生变更: 结果必须由 PyMem_RawMalloc() 或 PyMem_RawRealloc() 分配，\n而不是由 PyMem_Malloc() 或 PyMem_Realloc() 分配。\n在 3.12 版本发生变更: 此函数只能被 主解释器 调用。\nPyObject *PyRun_String(const char *str, int start, PyObject *globals, PyObject\n*locals)\n返回值：新的引用。\n这是针对下面 PyRun_StringFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *PyRun_StringFlags(const char *str, int start, PyObject *globals,\nPyObject *locals, PyCompilerFlags *flags)\n返回值：新的引用。\n在由对象 globals 和 locals 指定的上下文中执行来自 str 的 Python 源代码并使用以 flags 指定的\n编译器旗标。 globals 必须是一个字典; locals 可以是任何实现了映射协议的对象。 形参 start 指\n定的起始符号必须是以下几种之一: Py_eval_input, Py_file_input, or Py_single_input。\n返回将代码作为 Python 对象执行的结果，或者如果引发了异常则返回 NULL。\nPyObject *PyRun_File(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 closeit 设为 0 并将 flags 设为 NULL。\nPyObject *PyRun_FileEx(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals, int closeit)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *PyRun_FileFlags(FILE *fp, const char *filename, int start, PyObject\n*globals, PyObject *locals, PyCompilerFlags *flags)\n返回值：新的引用。\n这是针对下面 PyRun_FileExFlags() 的简化版接口，将 closeit 设为 0。 |  |\n| --- | --- | --- |\n\nPyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start,\nPyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)\n返回值：新的引用。\n类似于 PyRun_StringFlags()，但 Python 源代码是从 fp 读取而不是一个内存中的字符串。\nfilename 应为文件名，它将使用 filesystem encoding and error handler 来解码。 如果 closeit\n为真值，则文件将在 PyRun_FileExFlags() 返回之前被关闭。\nPyObject *Py_CompileString(const char *str, const char *filename, int\nstart)\n返回值：新的引用。 属于 稳定 ABI.\n这是针对下面 Py_CompileStringFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *Py_CompileStringFlags(const char *str, const char *filename, int\nstart, PyCompilerFlags *flags)\n返回值：新的引用。\n这是针对下面 Py_CompileStringExFlags() 的简化版接口，将 optimize 设为 -1。\nPyObject *Py_CompileStringObject(const char *str, PyObject *filename, int\nstart, PyCompilerFlags *flags, int optimize)\n返回值：新的引用。\n解析并编译 str 中的 Python 源代码，返回结果代码对象。 起始符号由 start 给出；这可被用来\n约束能被编译的代码并且应当为 Py_eval_input, Py_file_input 或 Py_single_input。 由\nfilename 指定的文件名会被用来构造代码对象并可能出现在回溯信息或 SyntaxError 异常消息\n中。 如果代码无法被解析或编译则此函数将返回 NULL。\n整数 optimize 指定编译器的优化级别；值 -1 将选择与 -O 选项相同的解释器优化级别。 显式\n级别为 0 (无优化；__debug__ 为真值)、1 (断言被移除，__debug__ 为假值) 或 2 (文档字符串\n也被移除)。\nAdded in version 3.4.\nPyObject *Py_CompileStringExFlags(const char *str, const char *filename, int\nstart, PyCompilerFlags *flags, int optimize)\n返回值：新的引用。\n与 Py_CompileStringObject() 类似，但 filename 是以 filesystem encoding and error\nhandler 解码出的字节串。\nAdded in version 3.2.\nPyObject *PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n返回值：新的引用。 属于 稳定 ABI.\n这是针对 PyEval_EvalCodeEx() 的简化版接口，只附带代码对象，以及全局和局部变量。 其\n他参数均设为 NULL。\n\n|  | PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start,\nPyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)\n返回值：新的引用。\n类似于 PyRun_StringFlags()，但 Python 源代码是从 fp 读取而不是一个内存中的字符串。\nfilename 应为文件名，它将使用 filesystem encoding and error handler 来解码。 如果 closeit\n为真值，则文件将在 PyRun_FileExFlags() 返回之前被关闭。\nPyObject *Py_CompileString(const char *str, const char *filename, int\nstart)\n返回值：新的引用。 属于 稳定 ABI.\n这是针对下面 Py_CompileStringFlags() 的简化版接口，将 flags 设为 NULL。\nPyObject *Py_CompileStringFlags(const char *str, const char *filename, int\nstart, PyCompilerFlags *flags)\n返回值：新的引用。\n这是针对下面 Py_CompileStringExFlags() 的简化版接口，将 optimize 设为 -1。\nPyObject *Py_CompileStringObject(const char *str, PyObject *filename, int\nstart, PyCompilerFlags *flags, int optimize)\n返回值：新的引用。\n解析并编译 str 中的 Python 源代码，返回结果代码对象。 起始符号由 start 给出；这可被用来\n约束能被编译的代码并且应当为 Py_eval_input, Py_file_input 或 Py_single_input。 由\nfilename 指定的文件名会被用来构造代码对象并可能出现在回溯信息或 SyntaxError 异常消息\n中。 如果代码无法被解析或编译则此函数将返回 NULL。\n整数 optimize 指定编译器的优化级别；值 -1 将选择与 -O 选项相同的解释器优化级别。 显式\n级别为 0 (无优化；__debug__ 为真值)、1 (断言被移除，__debug__ 为假值) 或 2 (文档字符串\n也被移除)。\nAdded in version 3.4.\nPyObject *Py_CompileStringExFlags(const char *str, const char *filename, int\nstart, PyCompilerFlags *flags, int optimize)\n返回值：新的引用。\n与 Py_CompileStringObject() 类似，但 filename 是以 filesystem encoding and error\nhandler 解码出的字节串。\nAdded in version 3.2.\nPyObject *PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)\n返回值：新的引用。 属于 稳定 ABI.\n这是针对 PyEval_EvalCodeEx() 的简化版接口，只附带代码对象，以及全局和局部变量。 其\n他参数均设为 NULL。 |  |\n| --- | --- | --- |\n\nPyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject\n*locals, PyObject *const *args, int argcount, PyObject *const *kws, int\nkwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject\n*closure)\n返回值：新的引用。 属于 稳定 ABI.\n对一个预编译的代码对象求值，为其求值给出特定的环境。 此环境由全局变量的字典，局部变\n量映射对象，参数、关键字和默认值的数组，仅限关键字 参数的默认值的字典和单元的封闭元\n组构成。\nPyObject *PyEval_EvalFrame(PyFrameObject *f)\n返回值：新的引用。 属于 稳定 ABI.\n对一个执行帧求值。 这是针对 PyEval_EvalFrameEx() 的简化版接口，用于保持向下兼容性。\nPyObject *PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n返回值：新的引用。 属于 稳定 ABI.\n这是 Python 解释运行不带修饰的主函数。 与执行帧 f 相关联的代码对象将被执行，解释字节\n码并根据需要执行调用。 额外的 throwflag 形参基本可以被忽略 —— 如果为真值，则会导致立\n即抛出一个异常；这会被用于生成器对象的 throw() 方法。\n在 3.4 版本发生变更: 该函数现在包含一个调试断言，用以确保不会静默地丢弃活动的异\n常。\nint PyEval_MergeCompilerFlags(PyCompilerFlags *cf)\n此函数会修改当前求值帧的旗标，并在成功时返回真值，失败时返回假值。\nint Py_eval_input\nPython 语法中用于孤立表达式的起始符号；配合 Py_CompileString() 使用。\nint Py_file_input\nPython 语法中用于从文件或其他源读取语句序列的起始符号；配合 Py_CompileString() 使\n用。 这是在编译任意长的 Python 源代码时要使用的符号。\nint Py_single_input\nPython 语法中用于单独语句的起始符号；配合 Py_CompileString() 使用。 这是用于交互式\n解释器循环的符号。\nstruct PyCompilerFlags\n这是用来存放编译器旗标的结构体。 对于代码仅被编译的情况，它将作为 int flags 传入，\n而对于代码要被执行的情况，它将作为 PyCompilerFlags *flags 传入。 在这种情况下，\nfrom __future__ import 可以修改 flags。\n只要 PyCompilerFlags *flags 是 NULL，cf_flags 就会被视为等同于 0，而由于 from\n__future__ import 而产生的任何修改都会被丢弃。\nint cf_flags\n\n|  | PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject\n*locals, PyObject *const *args, int argcount, PyObject *const *kws, int\nkwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject\n*closure)\n返回值：新的引用。 属于 稳定 ABI.\n对一个预编译的代码对象求值，为其求值给出特定的环境。 此环境由全局变量的字典，局部变\n量映射对象，参数、关键字和默认值的数组，仅限关键字 参数的默认值的字典和单元的封闭元\n组构成。\nPyObject *PyEval_EvalFrame(PyFrameObject *f)\n返回值：新的引用。 属于 稳定 ABI.\n对一个执行帧求值。 这是针对 PyEval_EvalFrameEx() 的简化版接口，用于保持向下兼容性。\nPyObject *PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n返回值：新的引用。 属于 稳定 ABI.\n这是 Python 解释运行不带修饰的主函数。 与执行帧 f 相关联的代码对象将被执行，解释字节\n码并根据需要执行调用。 额外的 throwflag 形参基本可以被忽略 —— 如果为真值，则会导致立\n即抛出一个异常；这会被用于生成器对象的 throw() 方法。\n在 3.4 版本发生变更: 该函数现在包含一个调试断言，用以确保不会静默地丢弃活动的异\n常。\nint PyEval_MergeCompilerFlags(PyCompilerFlags *cf)\n此函数会修改当前求值帧的旗标，并在成功时返回真值，失败时返回假值。\nint Py_eval_input\nPython 语法中用于孤立表达式的起始符号；配合 Py_CompileString() 使用。\nint Py_file_input\nPython 语法中用于从文件或其他源读取语句序列的起始符号；配合 Py_CompileString() 使\n用。 这是在编译任意长的 Python 源代码时要使用的符号。\nint Py_single_input\nPython 语法中用于单独语句的起始符号；配合 Py_CompileString() 使用。 这是用于交互式\n解释器循环的符号。\nstruct PyCompilerFlags\n这是用来存放编译器旗标的结构体。 对于代码仅被编译的情况，它将作为 int flags 传入，\n而对于代码要被执行的情况，它将作为 PyCompilerFlags *flags 传入。 在这种情况下，\nfrom __future__ import 可以修改 flags。\n只要 PyCompilerFlags *flags 是 NULL，cf_flags 就会被视为等同于 0，而由于 from\n__future__ import 而产生的任何修改都会被丢弃。\nint cf_flags |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | from |  |  |\n|  |  |  |  |  |\n\n编译器旗标。\nint cf_feature_version\ncf_feature_version 是 Python 的小版本号。 它应当被初始化为 PY_MINOR_VERSION。\n该字段默认会被忽略，当且仅当在 cf_flags 中设置了 PyCF_ONLY_AST 旗标时它才会被使\n用。\n在 3.8 版本发生变更: 增加了 cf_feature_version 字段。\n现有的编译器旗标可作为宏来使用：\nPyCF_ALLOW_TOP_LEVEL_AWAIT\nPyCF_ONLY_AST\nPyCF_OPTIMIZED_AST\nPyCF_TYPE_COMMENTS\n请参阅 ast Python 模块文档中的 编译器旗标，它们会将这些常量以相同的名称导出。\n上述 \"PyCF\" 标志可与 \"CO_FUTURE\" 类标志如 CO_FUTURE_ANNOTATIONS 组合使用，以启用通常\n通过 future 语句 选择的功能特性。 完整标志列表请参见 代码对象标志。", "metadata": {"title": "00_极高层级_API", "source": "md_docs\\python_c-api_md\\00_极高层级_API.md", "doc_type": "C API", "language": "中文", "doc_id": "d5b919df"}}
{"doc_id": "35e53aa9", "content": "概述\nPython 的应用编程接口（API）使得 C 和 C++ 程序员可以在多个层级上访问 Python 解释器。该\nAPI 在 C++ 中同样可用，但为简化描述，通常将其称为 Python/C API。使用 Python/C API 有两个基\n本的理由。第一个理由是为了特定目的而编写 扩展模块；它们是扩展 Python 解释器功能的 C 模\n块。这可能是最常见的使用场景。第二个理由是将 Python 用作更大规模应用的组件；这种技巧通常\n被称为在一个应用中 embedding Python。\n编写扩展模块的过程相对来说更易于理解，可以通过“菜谱”的形式分步骤介绍。使用某些工具可在一\n定程度上自动化这一过程。虽然人们在其他应用中嵌入 Python 的做法早已有之，但嵌入 Python 的\n过程没有编写扩展模块那样方便直观。\n许多 API 函数在你嵌入或是扩展 Python 这两种场景下都能发挥作用；此外，大多数嵌入 Python 的\n应用程序也需要提供自定义扩展，因此在尝试在实际应用中嵌入 Python 之前先熟悉编写扩展应该会\n是个好主意。\n语言版本兼容性\nPython的 C API 与 C11 和 C++11 版本的 C 和 C++ 兼容。\n这是一个下限：C API 不需要以后 C/C++ 版本的特性 。您 不 需要启用编译器的 \"c11 模式\"。\n代码标准\n如果你想要编写可包含于 CPython 的 C 代码，你 必须 遵循在 PEP 7 中定义的指导原则和标准。这\n些指导原则适用于任何你所要扩展的 Python 版本。在编写你自己的第三方扩展模块时可以不必遵循\n这些规范，除非你准备在日后向 Python 贡献这些模块。\n包含文件\n使用 Python/C API 所需要的全部函数、类型和宏定义可通过下面这行语句包含到你的代码之中：\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n这意味着包含以下标准头文件：<stdio.h>，<string.h>，<errno.h>，<limits.h>，\n<assert.h> 和 <stdlib.h>（如果可用）。\n备注: 由于 Python 可能会定义一些能在某些系统上影响标准头文件的预处理器定义，因此在包\n含任何标准头文件之前，你 必须 先包含 Python.h。\n推荐总是在 Python.h 前定义 PY_SSIZE_T_CLEAN 。查看 解析参数并构建值变量 来了解这个宏的\n更多内容。\n\n| 概述\nPython 的应用编程接口（API）使得 C 和 C++ 程序员可以在多个层级上访问 Python 解释器。该\nAPI 在 C++ 中同样可用，但为简化描述，通常将其称为 Python/C API。使用 Python/C API 有两个基\n本的理由。第一个理由是为了特定目的而编写 扩展模块；它们是扩展 Python 解释器功能的 C 模\n块。这可能是最常见的使用场景。第二个理由是将 Python 用作更大规模应用的组件；这种技巧通常\n被称为在一个应用中 embedding Python。\n编写扩展模块的过程相对来说更易于理解，可以通过“菜谱”的形式分步骤介绍。使用某些工具可在一\n定程度上自动化这一过程。虽然人们在其他应用中嵌入 Python 的做法早已有之，但嵌入 Python 的\n过程没有编写扩展模块那样方便直观。\n许多 API 函数在你嵌入或是扩展 Python 这两种场景下都能发挥作用；此外，大多数嵌入 Python 的\n应用程序也需要提供自定义扩展，因此在尝试在实际应用中嵌入 Python 之前先熟悉编写扩展应该会\n是个好主意。\n语言版本兼容性\nPython的 C API 与 C11 和 C++11 版本的 C 和 C++ 兼容。\n这是一个下限：C API 不需要以后 C/C++ 版本的特性 。您 不 需要启用编译器的 \"c11 模式\"。\n代码标准\n如果你想要编写可包含于 CPython 的 C 代码，你 必须 遵循在 PEP 7 中定义的指导原则和标准。这\n些指导原则适用于任何你所要扩展的 Python 版本。在编写你自己的第三方扩展模块时可以不必遵循\n这些规范，除非你准备在日后向 Python 贡献这些模块。\n包含文件\n使用 Python/C API 所需要的全部函数、类型和宏定义可通过下面这行语句包含到你的代码之中： |\n| --- |\n| #define PY_SSIZE_T_CLEAN\n#include <Python.h> |\n| 这意味着包含以下标准头文件：<stdio.h>，<string.h>，<errno.h>，<limits.h>，\n<assert.h> 和 <stdlib.h>（如果可用）。 |\n| 备注: 由于 Python 可能会定义一些能在某些系统上影响标准头文件的预处理器定义，因此在包\n含任何标准头文件之前，你 必须 先包含 Python.h。\n推荐总是在 Python.h 前定义 PY_SSIZE_T_CLEAN 。查看 解析参数并构建值变量 来了解这个宏的\n更多内容。 |\n\nPython.h 所定义的全部用户可见名称（由包含的标准头文件所定义的除外）都带有前缀 Py 或者\n_Py。以 _Py 打头的名称是供 Python 实现内部使用的，不应被扩展编写者使用。结构成员名称没有\n保留前缀。\n备注: 用户代码永远不应该定义以 Py 或 _Py 开头的名称。这会使读者感到困惑，并危及用户代\n码对未来Python版本的可移植性，这些版本可能会定义以这些前缀之一开头的其他名称。\n头文件通常会与 Python 一起安装。 在 Unix 上，它们位于 prefix/include/pythonversion/ 和\nexec_prefix/include/pythonversion/ 目录，其中 prefix 和 exec_prefix 是由向 Python 的\nconfigure 脚本传入的对应形参定义，而 version 则为 '%d.%d' % sys.version_info[:2]。 在\nWindows 上，头文件安装于 prefix/include，其中 prefix 是为安装程序指定的安装目录。\n要包括这些头文件，请将两个目录（如果不同）都放到你所用编译器用于包括头文件的搜索目录\n中。 请 不要 将父目录放入搜索路径然后使用 #include <pythonX.Y/Python.h>；这将使得多平台\n编译不可用，因为 prefix 下与平台无关的头文件包括了来自 exec_prefix 的平台专属头文件。\nC++ 用户应该注意，尽管 API 是完全使用 C 来定义的，但头文件正确地将入口点声明为 extern\n\"C\"，因此 API 在 C++ 中使用此 API 不必再做任何特殊处理。\n有用的宏\nPython 头文件中定义了一些有用的宏。许多是在靠近它们被使用的地方定义的（例如：\nPy_RETURN_NONE、PyMODINIT_FUNC）。其他更为通用的则定义在这里。这里所显示的并不是一个\n完整的列表。\nPy_ABS(x)\n返回 x 的绝对值。\nAdded in version 3.3.\nPy_ALWAYS_INLINE\n让编译器始终内联静态的内联函数。 编译器可以忽略它并决定不内联该函数。\n它可被用来在禁用函数内联的调试模式下构建 Python 时内联严重影响性能的静态内联函数。\n例如，MSC 在调试模式下构建时就禁用了函数内联。\n随意使用 Py_ALWAYS_INLINE 标记内联函数可能导致极差的性能（例如由于增加了代码量）。\n对于成本/收益分析来说计算机通常都比开发者更聪明。\n如果 Python 是 在调试模式下构建的 (即定义了 Py_DEBUG 宏)，则 Py_ALWAYS_INLINE 宏将不\n做任何事情。\n它必须在函数返回类型之前指明。 用法:\nstatic inline Py_ALWAYS_INLINE int random(void) { return 4; }\n\n|  |  |  |  |\n| --- | --- | --- | --- |\n|  |  | Python.h 所定义的全部用户可见名称（由包含的标准头文件所定义的除外）都带有前缀 Py 或者\n_Py。以 _Py 打头的名称是供 Python 实现内部使用的，不应被扩展编写者使用。结构成员名称没有\n保留前缀。 |  |\n|  |  | 备注: 用户代码永远不应该定义以 Py 或 _Py 开头的名称。这会使读者感到困惑，并危及用户代\n码对未来Python版本的可移植性，这些版本可能会定义以这些前缀之一开头的其他名称。 |  |\n|  |  | 头文件通常会与 Python 一起安装。 在 Unix 上，它们位于 prefix/include/pythonversion/ 和\nexec_prefix/include/pythonversion/ 目录，其中 prefix 和 exec_prefix 是由向 Python 的\nconfigure 脚本传入的对应形参定义，而 version 则为 '%d.%d' % sys.version_info[:2]。 在\nWindows 上，头文件安装于 prefix/include，其中 prefix 是为安装程序指定的安装目录。\n要包括这些头文件，请将两个目录（如果不同）都放到你所用编译器用于包括头文件的搜索目录\n中。 请 不要 将父目录放入搜索路径然后使用 #include <pythonX.Y/Python.h>；这将使得多平台\n编译不可用，因为 prefix 下与平台无关的头文件包括了来自 exec_prefix 的平台专属头文件。\nC++ 用户应该注意，尽管 API 是完全使用 C 来定义的，但头文件正确地将入口点声明为 extern\n\"C\"，因此 API 在 C++ 中使用此 API 不必再做任何特殊处理。\n有用的宏\nPython 头文件中定义了一些有用的宏。许多是在靠近它们被使用的地方定义的（例如：\nPy_RETURN_NONE、PyMODINIT_FUNC）。其他更为通用的则定义在这里。这里所显示的并不是一个\n完整的列表。\nPy_ABS(x)\n返回 x 的绝对值。\nAdded in version 3.3.\nPy_ALWAYS_INLINE\n让编译器始终内联静态的内联函数。 编译器可以忽略它并决定不内联该函数。\n它可被用来在禁用函数内联的调试模式下构建 Python 时内联严重影响性能的静态内联函数。\n例如，MSC 在调试模式下构建时就禁用了函数内联。\n随意使用 Py_ALWAYS_INLINE 标记内联函数可能导致极差的性能（例如由于增加了代码量）。\n对于成本/收益分析来说计算机通常都比开发者更聪明。\n如果 Python 是 在调试模式下构建的 (即定义了 Py_DEBUG 宏)，则 Py_ALWAYS_INLINE 宏将不\n做任何事情。\n它必须在函数返回类型之前指明。 用法:\nstatic inline Py_ALWAYS_INLINE int random(void) { return 4; } |  |\n|  |  | \"C\" |  |\n|  |  |  |  |\n\nAdded in version 3.11.\nPy_CHARMASK(c)\n参数必须为 [-128, 127] 或 [0, 255] 范围内的字符或整数类型。这个宏将 c 强制转换为\nunsigned char 返回。\nPy_DEPRECATED(version)\n弃用声明。该宏必须放置在符号名称前。\n示例:\nPy_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);\n在 3.8 版本发生变更: 添加了 MSVC 支持。\nPy_GETENV(s)\n与 getenv(s) 类似，但是如果从命令行传入了 -E 则返回 NULL (参见\nPyConfig.use_environment)。\nPy_MAX(x, y)\n返回 x 和 y 当中的最大值。\nAdded in version 3.3.\nPy_MEMBER_SIZE(type, member)\n返回结构 (type) member 的大小，以字节表示。\nAdded in version 3.6.\nPy_MIN(x, y)\n返回 x 和 y 当中的最小值。\nAdded in version 3.3.\nPy_NO_INLINE\n启用内联某个函数。 例如，它会减少 C 栈消耗：适用于大量内联代码的 LTO+PGO 编译版 (参\n见 bpo-33720)。\n用法：\nPy_NO_INLINE static int random(void) { return 4; }\nAdded in version 3.11.\nPy_STRINGIFY(x)\n将 x 转换为 C 字符串。例如 Py_STRINGIFY(123) 返回 \"123\"。\nAdded in version 3.4.\n\n|  | Added in version 3.11.\nPy_CHARMASK(c)\n参数必须为 [-128, 127] 或 [0, 255] 范围内的字符或整数类型。这个宏将 c 强制转换为\nunsigned char 返回。\nPy_DEPRECATED(version)\n弃用声明。该宏必须放置在符号名称前。\n示例:\nPy_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);\n在 3.8 版本发生变更: 添加了 MSVC 支持。\nPy_GETENV(s)\n与 getenv(s) 类似，但是如果从命令行传入了 -E 则返回 NULL (参见\nPyConfig.use_environment)。\nPy_MAX(x, y)\n返回 x 和 y 当中的最大值。\nAdded in version 3.3.\nPy_MEMBER_SIZE(type, member)\n返回结构 (type) member 的大小，以字节表示。\nAdded in version 3.6.\nPy_MIN(x, y)\n返回 x 和 y 当中的最小值。\nAdded in version 3.3.\nPy_NO_INLINE\n启用内联某个函数。 例如，它会减少 C 栈消耗：适用于大量内联代码的 LTO+PGO 编译版 (参\n见 bpo-33720)。\n用法：\nPy_NO_INLINE static int random(void) { return 4; }\nAdded in version 3.11.\nPy_STRINGIFY(x)\n将 x 转换为 C 字符串。例如 Py_STRINGIFY(123) 返回 \"123\"。\nAdded in version 3.4. |  |\n| --- | --- | --- |\n\nPy_UNREACHABLE()\n这个可以在你有一个设计上无法到达的代码路径时使用。例如，当一个 switch 语句中所有可\n能的值都已被 case 子句覆盖了，就可将其用在 default: 子句中。当你非常想在某个位置放\n一个 assert(0) 或 abort() 调用时也可以用这个。\n在 release 模式下，该宏帮助编译器优化代码，并避免发出不可到达代码的警告。例如，在\nGCC 的 release 模式下，该宏使用 __builtin_unreachable() 实现。\nPy_UNREACHABLE() 的一个用法是调用一个不会返回，但却没有声明 _Py_NO_RETURN 的函数之\n后。\n如果一个代码路径不太可能是正常代码，但在特殊情况下可以到达，就不能使用该宏。例如，\n在低内存条件下，或者一个系统调用返回超出预期范围值，诸如此类，最好将错误报告给调用\n者。如果无法将错误报告给调用者，可以使用 Py_FatalError() 。\nAdded in version 3.7.\nPy_UNUSED(arg)\n用于函数定义中未使用的参数，从而消除编译器警告。例如： int func(int a, int\nPy_UNUSED(b)) { return a; } 。\nAdded in version 3.4.\nPyDoc_STRVAR(name, str)\n创建一个可以在文档字符串中使用的，名字为 name 的变量。如果不和文档字符串一起构建\nPython，该值将为空。\n如 PEP 7 所述，使用 PyDoc_STRVAR 作为文档字符串，以支持不和文档字符串一起构建 Python\n的情况。\n示例:\nPyDoc_STRVAR(pop_doc, \"Remove and return the rightmost element.\");\nstatic PyMethodDef deque_methods[] = {\n// ...\n{\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n// ...\n}\nPyDoc_STR(str)\n为给定的字符串输入创建一个文档字符串，或者当文档字符串被禁用时，创建一个空字符串。\n如 PEP 7 所述，使用 PyDoc_STR 指定文档字符串，以支持不和文档字符串一起构建 Python 的\n情况。\n示例:\nstatic PyMethodDef pysqlite_row_methods[] = {\n{\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n\n|  |  | Py_UNREACHABLE()\n这个可以在你有一个设计上无法到达的代码路径时使用。例如，当一个 switch 语句中所有可\n能的值都已被 case 子句覆盖了，就可将其用在 default: 子句中。当你非常想在某个位置放\n一个 assert(0) 或 abort() 调用时也可以用这个。\n在 release 模式下，该宏帮助编译器优化代码，并避免发出不可到达代码的警告。例如，在\nGCC 的 release 模式下，该宏使用 __builtin_unreachable() 实现。\nPy_UNREACHABLE() 的一个用法是调用一个不会返回，但却没有声明 _Py_NO_RETURN 的函数之\n后。\n如果一个代码路径不太可能是正常代码，但在特殊情况下可以到达，就不能使用该宏。例如，\n在低内存条件下，或者一个系统调用返回超出预期范围值，诸如此类，最好将错误报告给调用\n者。如果无法将错误报告给调用者，可以使用 Py_FatalError() 。\nAdded in version 3.7.\nPy_UNUSED(arg)\n用于函数定义中未使用的参数，从而消除编译器警告。例如： int func(int a, int\nPy_UNUSED(b)) { return a; } 。\nAdded in version 3.4.\nPyDoc_STRVAR(name, str)\n创建一个可以在文档字符串中使用的，名字为 name 的变量。如果不和文档字符串一起构建\nPython，该值将为空。\n如 PEP 7 所述，使用 PyDoc_STRVAR 作为文档字符串，以支持不和文档字符串一起构建 Python\n的情况。\n示例:\nPyDoc_STRVAR(pop_doc, \"Remove and return the rightmost element.\");\nstatic PyMethodDef deque_methods[] = {\n// ...\n{\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n// ...\n}\nPyDoc_STR(str)\n为给定的字符串输入创建一个文档字符串，或者当文档字符串被禁用时，创建一个空字符串。\n如 PEP 7 所述，使用 PyDoc_STR 指定文档字符串，以支持不和文档字符串一起构建 Python 的\n情况。\n示例:\nstatic PyMethodDef pysqlite_row_methods[] = {\n{\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS, |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | int func(int a, int |  |  |\n|  |  |  |  |  |  |  |\n|  |  | Py_UNUSED(b)) { return a; } |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | static PyMethodDef pysqlite_row_methods[] = {\n{\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS, |  |  |  |\n\nPyDoc_STR(\"Returns the keys of the row.\")},\n{NULL, NULL}\n};\n对象、类型和引用计数\n多数 Python/C API 函数都有一个或多个参数以及一个 PyObject* 类型的返回值。 这种类型是指向\n任意 Python 对象的不透明数据类型的指针。 由于所有 Python 对象类型在大多数情况下都被\nPython 语言用相同的方式处理（例如，赋值、作用域规则和参数传递等），因此用单个 C 类型来表\n示它们是很适宜的。 几乎所有 Python 对象都存在于堆中：你不可声明一个类型为 PyObject 的自\n动或静态的变量，只能声明类型为 PyObject* 的指针变量。 唯一的例外是 type 对象；因为这种对\n象永远不能被释放，所以它们通常都是静态的 PyTypeObject 对象。\n所有 Python 对象（甚至 Python 整数）都有一个 type 和一个 reference count。对象的类型确定它是\n什么类型的对象（例如整数、列表或用户定义函数；还有更多，如 标准类型层级结构 中所述）。对\n于每个众所周知的类型，都有一个宏来检查对象是否属于该类型；例如，当（且仅当） a 所指的对\n象是 Python 列表时 PyList_Check(a) 为真。\n引用计数\n引用计数之所以重要是因为现有计算机的内存大小是有限的（并且往往限制得很严格）；它会计算\n有多少不同的地方对一个对象进行了 strong reference。 这些地方可以是另一个对象，也可以是全局\n（或静态）C 变量，或是某个 C 函数中的局部变量。 当某个对象的最后一个 strong reference 被释\n放时（即其引用计数变为零），该对象就会被取消分配。 如果该对象包含对其他对象的引用，则会\n释放这些引用。 如果不再有对其他对象的引用，这些对象也会同样地被取消分配，依此类推。 （在\n这里对象之间的相互引用显然是个问题；目前的解决办法，就是“不要这样做”。）\n对于引用计数总是会显式地执行操作。 通常的做法是使用 Py_INCREF() 宏来获取对象的新引用（即\n让引用计数加一），并使用 Py_DECREF() 宏来释放引用（即让引用计数减一）。 Py_DECREF() 宏\n比 incref 宏复杂得多，因为它必须检查引用计数是否为零然后再调用对象的释放器。 释放器是一个\n函数指针，它包含在对象的类型结构体中。 如果对象是复合对象类型，如列表，则特定于类型的释\n放器会负责释放对象中包含的其他对象的引用，并执行所需的其他终结化操作。 引用计数不会发生\n溢出；用于保存引用计数的位数至少会与虚拟内存中不同内存位置的位数相同 (假设\nsizeof(Py_ssize_t) >= sizeof(void*))。 因此，引用计数的递增是一个简单的操作。\n没有必要为每个包含指向对象指针的局部变量持有 strong reference (即增加引用计数)。 理论上说，\n当变量指向对象时对象的引用计数就会加一，而当变量离开其作用域时引用计数就会减一。 不过，\n这两种情况会相互抵消，所以最后引用计数并没有改变。 使用引用计数的唯一真正原因在于只要我\n们的变量指向对象就可以防止对象被释放。 只要我们知道至少还有一个指向某对象的引用与我们的\n变量同时存在，就没有必要临时获取一个新的 strong reference (即增加引用计数)。 出现引用计数增\n加的一种重要情况是对象作为参数被传递给扩展模块中的 C 函数而这些函数又在 Python 中被调用；\n调用机制会保证在调用期间对每个参数持有一个引用。\n然而，一个常见的陷阱是从列表中提取对象并在不获取新引用的情况下将其保留一段时间。 某个其\n他操作可能在无意中从列表中移除该对象，释放这个引用，并可能撤销分配其资源。 真正的危险在\n\n|  | PyDoc_STR(\"Returns the keys of the row.\")},\n{NULL, NULL}\n};\n对象、类型和引用计数\n多数 Python/C API 函数都有一个或多个参数以及一个 PyObject* 类型的返回值。 这种类型是指向\n任意 Python 对象的不透明数据类型的指针。 由于所有 Python 对象类型在大多数情况下都被\nPython 语言用相同的方式处理（例如，赋值、作用域规则和参数传递等），因此用单个 C 类型来表\n示它们是很适宜的。 几乎所有 Python 对象都存在于堆中：你不可声明一个类型为 PyObject 的自\n动或静态的变量，只能声明类型为 PyObject* 的指针变量。 唯一的例外是 type 对象；因为这种对\n象永远不能被释放，所以它们通常都是静态的 PyTypeObject 对象。\n所有 Python 对象（甚至 Python 整数）都有一个 type 和一个 reference count。对象的类型确定它是\n什么类型的对象（例如整数、列表或用户定义函数；还有更多，如 标准类型层级结构 中所述）。对\n于每个众所周知的类型，都有一个宏来检查对象是否属于该类型；例如，当（且仅当） a 所指的对\n象是 Python 列表时 PyList_Check(a) 为真。\n引用计数\n引用计数之所以重要是因为现有计算机的内存大小是有限的（并且往往限制得很严格）；它会计算\n有多少不同的地方对一个对象进行了 strong reference。 这些地方可以是另一个对象，也可以是全局\n（或静态）C 变量，或是某个 C 函数中的局部变量。 当某个对象的最后一个 strong reference 被释\n放时（即其引用计数变为零），该对象就会被取消分配。 如果该对象包含对其他对象的引用，则会\n释放这些引用。 如果不再有对其他对象的引用，这些对象也会同样地被取消分配，依此类推。 （在\n这里对象之间的相互引用显然是个问题；目前的解决办法，就是“不要这样做”。）\n对于引用计数总是会显式地执行操作。 通常的做法是使用 Py_INCREF() 宏来获取对象的新引用（即\n让引用计数加一），并使用 Py_DECREF() 宏来释放引用（即让引用计数减一）。 Py_DECREF() 宏\n比 incref 宏复杂得多，因为它必须检查引用计数是否为零然后再调用对象的释放器。 释放器是一个\n函数指针，它包含在对象的类型结构体中。 如果对象是复合对象类型，如列表，则特定于类型的释\n放器会负责释放对象中包含的其他对象的引用，并执行所需的其他终结化操作。 引用计数不会发生\n溢出；用于保存引用计数的位数至少会与虚拟内存中不同内存位置的位数相同 (假设\nsizeof(Py_ssize_t) >= sizeof(void*))。 因此，引用计数的递增是一个简单的操作。\n没有必要为每个包含指向对象指针的局部变量持有 strong reference (即增加引用计数)。 理论上说，\n当变量指向对象时对象的引用计数就会加一，而当变量离开其作用域时引用计数就会减一。 不过，\n这两种情况会相互抵消，所以最后引用计数并没有改变。 使用引用计数的唯一真正原因在于只要我\n们的变量指向对象就可以防止对象被释放。 只要我们知道至少还有一个指向某对象的引用与我们的\n变量同时存在，就没有必要临时获取一个新的 strong reference (即增加引用计数)。 出现引用计数增\n加的一种重要情况是对象作为参数被传递给扩展模块中的 C 函数而这些函数又在 Python 中被调用；\n调用机制会保证在调用期间对每个参数持有一个引用。\n然而，一个常见的陷阱是从列表中提取对象并在不获取新引用的情况下将其保留一段时间。 某个其\n他操作可能在无意中从列表中移除该对象，释放这个引用，并可能撤销分配其资源。 真正的危险在 | PyDoc_STR(\"Returns the keys of the row.\")},\n{NULL, NULL}\n}; |  |\n| --- | --- | --- | --- |\n\n于看似无害的操作可能会唤起任意的 Python 代码来做这件事；有一条代码路径允许控制权从\nPy_DECREF() 流回到用户，因此几乎任何操作都有潜在的危险。\n安全的做法是始终使用泛型操作（名称以 PyObject_, PyNumber_, PySequence_ 或 PyMapping_ 开\n头的函数）。 这些操作总是为其返回的对象创建一个新的 strong reference (即增加引用计数)。 这\n使得调用者有责任在获得结果之后调用 Py_DECREF()；这种做法很快就能习惯成自然。\n引用计数细节\nPython/C API 中函数的引用计数最好是使用 引用所有权 来解释。 所有权是关联到引用，而不是对\n象（对象不能被拥有：它们总是会被共享）。 “拥有一个引用”意味着当不再需要该引用时必须在其\n上调用 Py_DECREF。 所有权也可以被转移，这意味着接受该引用所有权的代码在不再需要它时必须\n通过调用 Py_DECREF() 或 Py_XDECREF() 来最终释放它 --- 或是继续转移这个责任（通常是转给其\n调用方）。 当一个函数将引用所有权转给其调用方时，则称调用方收到一个 新的 引用。 当未转移\n所有权时，则称调用方是 借入 这个引用。 对于 borrowed reference 来说不需要任何额外操作。\n相反地，当调用方函数传入一个对象的引用时，存在两种可能：该函数 窃取 了一个对象的引用，或\n是没有窃取。 窃取引用 意味着当你向一个函数传入引用时，该函数会假定它拥有该引用，而你将不\n再对它负有责任。\n很少有函数会窃取引用；两个重要的例外是 PyList_SetItem() 和 PyTuple_SetItem()，它们会窃\n取对条目的引用（但不是条目所在的元组或列表！）。 这些函数被设计为会窃取引用是因为在使用\n新创建的对象来填充元组或列表时有一个通常的惯例；例如，创建元组 (1, 2, \"three\") 的代码看\n起来可以是这样的（暂时不要管错误处理；下面会显示更好的代码编写方式）:\nPyObject *t;\nt = PyTuple_New(3);\nPyTuple_SetItem(t, 0, PyLong_FromLong(1L));\nPyTuple_SetItem(t, 1, PyLong_FromLong(2L));\nPyTuple_SetItem(t, 2, PyUnicode_FromString(\"three\"));\n在这里，PyLong_FromLong() 返回了一个新的引用并且它立即被 PyTuple_SetItem() 所窃取。 当\n你想要继续使用一个对象而对它的引用将被窃取时，请在调用窃取引用的函数之前使用\nPy_INCREF() 来抓取另一个引用。\n顺便提一下，PyTuple_SetItem() 是设置元组条目的 唯一 方式；PySequence_SetItem() 和\nPyObject_SetItem() 会拒绝这样做因为元组是不可变数据类型。 你应当只对你自己创建的元组使\n用 PyTuple_SetItem()。\n等价于填充一个列表的代码可以使用 PyList_New() 和 PyList_SetItem() 来编写。\n然而，在实践中，你很少会使用这些创建和填充元组或列表的方式。 有一个通用的函数\nPy_BuildValue() 可以根据 C 值来创建大多数常用对象，由一个 格式字符串 来指明。 例如，上面\n的两个代码块可以用下面的代码来代替（还会负责错误检测）:\nPyObject *tuple, *list;\n\n|  | 于看似无害的操作可能会唤起任意的 Python 代码来做这件事；有一条代码路径允许控制权从\nPy_DECREF() 流回到用户，因此几乎任何操作都有潜在的危险。\n安全的做法是始终使用泛型操作（名称以 PyObject_, PyNumber_, PySequence_ 或 PyMapping_ 开\n头的函数）。 这些操作总是为其返回的对象创建一个新的 strong reference (即增加引用计数)。 这\n使得调用者有责任在获得结果之后调用 Py_DECREF()；这种做法很快就能习惯成自然。\n引用计数细节\nPython/C API 中函数的引用计数最好是使用 引用所有权 来解释。 所有权是关联到引用，而不是对\n象（对象不能被拥有：它们总是会被共享）。 “拥有一个引用”意味着当不再需要该引用时必须在其\n上调用 Py_DECREF。 所有权也可以被转移，这意味着接受该引用所有权的代码在不再需要它时必须\n通过调用 Py_DECREF() 或 Py_XDECREF() 来最终释放它 --- 或是继续转移这个责任（通常是转给其\n调用方）。 当一个函数将引用所有权转给其调用方时，则称调用方收到一个 新的 引用。 当未转移\n所有权时，则称调用方是 借入 这个引用。 对于 borrowed reference 来说不需要任何额外操作。\n相反地，当调用方函数传入一个对象的引用时，存在两种可能：该函数 窃取 了一个对象的引用，或\n是没有窃取。 窃取引用 意味着当你向一个函数传入引用时，该函数会假定它拥有该引用，而你将不\n再对它负有责任。\n很少有函数会窃取引用；两个重要的例外是 PyList_SetItem() 和 PyTuple_SetItem()，它们会窃\n取对条目的引用（但不是条目所在的元组或列表！）。 这些函数被设计为会窃取引用是因为在使用\n新创建的对象来填充元组或列表时有一个通常的惯例；例如，创建元组 (1, 2, \"three\") 的代码看\n起来可以是这样的（暂时不要管错误处理；下面会显示更好的代码编写方式）: |  |\n| --- | --- | --- |\n|  | PyObject *t;\nt = PyTuple_New(3);\nPyTuple_SetItem(t, 0, PyLong_FromLong(1L));\nPyTuple_SetItem(t, 1, PyLong_FromLong(2L));\nPyTuple_SetItem(t, 2, PyUnicode_FromString(\"three\")); |  |\n|  | 在这里，PyLong_FromLong() 返回了一个新的引用并且它立即被 PyTuple_SetItem() 所窃取。 当\n你想要继续使用一个对象而对它的引用将被窃取时，请在调用窃取引用的函数之前使用\nPy_INCREF() 来抓取另一个引用。\n顺便提一下，PyTuple_SetItem() 是设置元组条目的 唯一 方式；PySequence_SetItem() 和\nPyObject_SetItem() 会拒绝这样做因为元组是不可变数据类型。 你应当只对你自己创建的元组使\n用 PyTuple_SetItem()。\n等价于填充一个列表的代码可以使用 PyList_New() 和 PyList_SetItem() 来编写。\n然而，在实践中，你很少会使用这些创建和填充元组或列表的方式。 有一个通用的函数\nPy_BuildValue() 可以根据 C 值来创建大多数常用对象，由一个 格式字符串 来指明。 例如，上面\n的两个代码块可以用下面的代码来代替（还会负责错误检测）: |  |\n|  | PyObject *tuple, *list; |  |\n\ntuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\nlist = Py_BuildValue(\"[iis]\", 1, 2, \"three\");\n在对条目使用 PyObject_SetItem() 等操作时更常见的做法是只借入引用，比如将参数传递给你正\n在编写的函数。 在这种情况下，它们在引用方面的行为更为清晰，因为你不必为了把引用转走而获\n取一个新的引用（“让它被偷取”）。 例如，这个函数将列表（实际上是任何可变序列）中的所有条\n目都设为给定的条目:\nint\nset_all(PyObject *target, PyObject *item)\n{\nPy_ssize_t i, n;\nn = PyObject_Length(target);\nif (n < 0)\nreturn -1;\nfor (i = 0; i < n; i++) {\nPyObject *index = PyLong_FromSsize_t(i);\nif (!index)\nreturn -1;\nif (PyObject_SetItem(target, index, item) < 0) {\nPy_DECREF(index);\nreturn -1;\n}\nPy_DECREF(index);\n}\nreturn 0;\n}\n对于函数返回值的情况略有不同。 虽然向大多数函数传递一个引用不会改变你对该引用的所有权责\n任，但许多返回一个引用的函数会给你该引用的所有权。 原因很简单：在许多情况下，返回的对象\n是临时创建的，而你得到的引用是对该对象的唯一引用。 因此，返回对象引用的通用函数，如\nPyObject_GetItem() 和 PySequence_GetItem()，将总是返回一个新的引用（调用方将成为该引\n用的所有者）。\n一个需要了解的重点在于你是否拥有一个由函数返回的引用只取决于你所调用的函数 --- 附带物 (作\n为参数传给函数的对象的类型) 不会带来额外影响！ 因此，如果你使用 PyList_GetItem() 从一个\n列表提取条目，你并不会拥有其引用 --- 但是如果你使用 PySequence_GetItem() (它恰好接受完全\n相同的参数) 从同一个列表获取同样的条目，你就会拥有一个对所返回对象的引用。\n下面是说明你要如何编写一个函数来计算一个整数列表中条目的示例；一个是使用\nPyList_GetItem()，而另一个是使用 PySequence_GetItem()。\nlong\nsum_list(PyObject *list)\n{\nPy_ssize_t i, n;\nlong total = 0, value;\nPyObject *item;\nn = PyList_Size(list);\nif (n < 0)\nreturn -1; /* Not a list */\n\n|  | tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\nlist = Py_BuildValue(\"[iis]\", 1, 2, \"three\"); |  |\n| --- | --- | --- |\n|  | 在对条目使用 PyObject_SetItem() 等操作时更常见的做法是只借入引用，比如将参数传递给你正\n在编写的函数。 在这种情况下，它们在引用方面的行为更为清晰，因为你不必为了把引用转走而获\n取一个新的引用（“让它被偷取”）。 例如，这个函数将列表（实际上是任何可变序列）中的所有条\n目都设为给定的条目: |  |\n|  | int\nset_all(PyObject *target, PyObject *item)\n{\nPy_ssize_t i, n;\nn = PyObject_Length(target);\nif (n < 0)\nreturn -1;\nfor (i = 0; i < n; i++) {\nPyObject *index = PyLong_FromSsize_t(i);\nif (!index)\nreturn -1;\nif (PyObject_SetItem(target, index, item) < 0) {\nPy_DECREF(index);\nreturn -1;\n}\nPy_DECREF(index);\n}\nreturn 0;\n} |  |\n|  | 对于函数返回值的情况略有不同。 虽然向大多数函数传递一个引用不会改变你对该引用的所有权责\n任，但许多返回一个引用的函数会给你该引用的所有权。 原因很简单：在许多情况下，返回的对象\n是临时创建的，而你得到的引用是对该对象的唯一引用。 因此，返回对象引用的通用函数，如\nPyObject_GetItem() 和 PySequence_GetItem()，将总是返回一个新的引用（调用方将成为该引\n用的所有者）。\n一个需要了解的重点在于你是否拥有一个由函数返回的引用只取决于你所调用的函数 --- 附带物 (作\n为参数传给函数的对象的类型) 不会带来额外影响！ 因此，如果你使用 PyList_GetItem() 从一个\n列表提取条目，你并不会拥有其引用 --- 但是如果你使用 PySequence_GetItem() (它恰好接受完全\n相同的参数) 从同一个列表获取同样的条目，你就会拥有一个对所返回对象的引用。\n下面是说明你要如何编写一个函数来计算一个整数列表中条目的示例；一个是使用\nPyList_GetItem()，而另一个是使用 PySequence_GetItem()。 |  |\n|  | long\nsum_list(PyObject *list)\n{\nPy_ssize_t i, n;\nlong total = 0, value;\nPyObject *item;\nn = PyList_Size(list);\nif (n < 0)\nreturn -1; /* Not a list */ |  |\n\nfor (i = 0; i < n; i++) {\nitem = PyList_GetItem(list, i); /* 不能失败 */\nif (!PyLong_Check(item)) continue; /* 跳过非整数 */\nvalue = PyLong_AsLong(item);\nif (value == -1 && PyErr_Occurred())\n/* 太大的整数无法适应 C long 类型，放弃 */\nreturn -1;\ntotal += value;\n}\nreturn total;\n}\nlong\nsum_sequence(PyObject *sequence)\n{\nPy_ssize_t i, n;\nlong total = 0, value;\nPyObject *item;\nn = PySequence_Length(sequence);\nif (n < 0)\nreturn -1; /* 没有长度 */\nfor (i = 0; i < n; i++) {\nitem = PySequence_GetItem(sequence, i);\nif (item == NULL)\nreturn -1; /* 不是序列，或其他错误 */\nif (PyLong_Check(item)) {\nvalue = PyLong_AsLong(item);\nPy_DECREF(item);\nif (value == -1 && PyErr_Occurred())\n/* 太大的整数无法适应 C long 类型，放弃 */\nreturn -1;\ntotal += value;\n}\nelse {\nPy_DECREF(item); /* 丢弃引用所有权 */\n}\n}\nreturn total;\n}\n类型\n在 Python/C API 中扮演重要角色的其他数据类型很少；大多为简单 C 类型如 int, long, double 和\nchar* 等。 有一些结构类型被用来燃烧液体于列出模块所导出的函数或者某个新对象类型的个的一\n个，还有一个结构类型被用来描述复数的值。 这些结构类型将与使用它们的函数放到一起讨论。\ntype Py_ssize_t\n属于 稳定 ABI.\n一个使得 sizeof(Py_ssize_t) == sizeof(size_t) 的有符号整数类型。 C99 没有直接定义\n这样的东西（size_t 是一个无符号整数类型）。 请参阅 PEP 353 了解详情。 PY_SSIZE_T_MAX\n是 Py_ssize_t 类型的最大正数值。\n异常\n\n|  | for (i = 0; i < n; i++) {\nitem = PyList_GetItem(list, i); /* 不能失败 */\nif (!PyLong_Check(item)) continue; /* 跳过非整数 */\nvalue = PyLong_AsLong(item);\nif (value == -1 && PyErr_Occurred())\n/* 太大的整数无法适应 C long 类型，放弃 */\nreturn -1;\ntotal += value;\n}\nreturn total;\n} |  |\n| --- | --- | --- |\n|  |  |  |\n|  | long\nsum_sequence(PyObject *sequence)\n{\nPy_ssize_t i, n;\nlong total = 0, value;\nPyObject *item;\nn = PySequence_Length(sequence);\nif (n < 0)\nreturn -1; /* 没有长度 */\nfor (i = 0; i < n; i++) {\nitem = PySequence_GetItem(sequence, i);\nif (item == NULL)\nreturn -1; /* 不是序列，或其他错误 */\nif (PyLong_Check(item)) {\nvalue = PyLong_AsLong(item);\nPy_DECREF(item);\nif (value == -1 && PyErr_Occurred())\n/* 太大的整数无法适应 C long 类型，放弃 */\nreturn -1;\ntotal += value;\n}\nelse {\nPy_DECREF(item); /* 丢弃引用所有权 */\n}\n}\nreturn total;\n} |  |\n|  | 类型\n在 Python/C API 中扮演重要角色的其他数据类型很少；大多为简单 C 类型如 int, long, double 和\nchar* 等。 有一些结构类型被用来燃烧液体于列出模块所导出的函数或者某个新对象类型的个的一\n个，还有一个结构类型被用来描述复数的值。 这些结构类型将与使用它们的函数放到一起讨论。\ntype Py_ssize_t\n属于 稳定 ABI.\n一个使得 sizeof(Py_ssize_t) == sizeof(size_t) 的有符号整数类型。 C99 没有直接定义\n这样的东西（size_t 是一个无符号整数类型）。 请参阅 PEP 353 了解详情。 PY_SSIZE_T_MAX\n是 Py_ssize_t 类型的最大正数值。\n异常 |  |\n\nPython程序员只需要处理特定需要处理的错误异常；未处理的异常会自动传递给调用者，然后传递\n给调用者的调用者，依此类推，直到他们到达顶级解释器，在那里将它们报告给用户并伴随堆栈回\n溯。\n然而，对于 C 程序员来说，错误检查必须总是显式进行的。 Python/C API 中的所有函数都可以引发\n异常，除非在函数的文档中另外显式声明。 一般来说，当一个函数遇到错误时，它会设置一个异\n常，丢弃它所拥有的任何对象引用，并返回一个错误标示。 如果没有说明例外的文档，这个标示将\n为 NULL 或 -1，具体取决于函数的返回类型。 有少量函数会返回一个布尔真/假结果值，其中假值\n表示错误。 有极少的函数没有显式的错误标示或是具有不明确的返回值，并需要用\nPyErr_Occurred() 来进行显式的检测。 这些例外总是会被明确地记入文档中。\n异常状态是在各个线程的存储中维护的（这相当于在一个无线程的应用中使用全局存储）。 一个线\n程可以处在两种状态之一：异常已经发生，或者没有发生。 函数 PyErr_Occurred() 可以被用来检\n查此状态：当异常发生时它将返回一个借入的异常类型对象的引用，在其他情况下则返回 NULL。 有\n多个函数可以设置异常状态: PyErr_SetString() 是最常见的（尽管不是最通用的）设置异常状态\n的函数，而 PyErr_Clear() 可以清除异常状态。\n完整的异常状态由三个对象组成 (它为都可以为 NULL): 异常类型、相应的异常值，以及回溯信息。\n这些对象的含义与 Python 中 sys.exc_info() 的结果相同；然而，它们并不是一样的：Python 对\n象代表由 Python try ... except 语句所处理的最后一个异常，而 C 层级的异常状态只在异常被传入\n到 C 函数或在它们之间传递时存在直至其到达 Python 字节码解释器的主事件循环，该事件循环会负\n责将其转移至 sys.exc_info() 等处。\n请注意自 Python 1.5 开始，从 Python 代码访问异常状态的首选的、线程安全的方式是调用函数\nsys.exc_info()，它将返回 Python 代码的分线程异常状态。 此外，这两种访问异常状态的方式的\n语义都发生了变化因而捕获到异常的函数将保存并恢复其线程的异常状态以保留其调用方的异常状\n态。 这将防止异常处理代码中由一个看起来很无辜的函数覆盖了正在处理的异常所造成的常见错\n误；它还减少了在回溯由栈帧所引用的对象的往往不被需要的生命其延长。\n作为一般的原则，一个调用另一个函数来执行某些任务的函数应当检查被调用的函数是否引发了异\n常，并在引发异常时将异常状态传递给其调用方。 它应当丢弃它所拥有的任何对象引用，并返回一\n个错误标示，但它 不应 设置另一个异常 --- 那会覆盖刚引发的异常，并丢失有关错误确切原因的重\n要信息。\n上面的 sum_sequence() 示例是一个检测异常并将其传递出去的简单例子。 碰巧的是这个示例在检\n测到错误时不需要清理所拥有的任何引用。 下面的示例函数展示了一些错误清理操作。 首先，为了\n提醒你 Python 的受欢迎程度，我们展示了等价的 Python 代码:\ndef incr_item(dict, key):\ntry:\nitem = dict[key]\nexcept KeyError:\nitem = 0\ndict[key] = item + 1\n对应的 C 代码如下：\n\n|  | Python程序员只需要处理特定需要处理的错误异常；未处理的异常会自动传递给调用者，然后传递\n给调用者的调用者，依此类推，直到他们到达顶级解释器，在那里将它们报告给用户并伴随堆栈回\n溯。\n然而，对于 C 程序员来说，错误检查必须总是显式进行的。 Python/C API 中的所有函数都可以引发\n异常，除非在函数的文档中另外显式声明。 一般来说，当一个函数遇到错误时，它会设置一个异\n常，丢弃它所拥有的任何对象引用，并返回一个错误标示。 如果没有说明例外的文档，这个标示将\n为 NULL 或 -1，具体取决于函数的返回类型。 有少量函数会返回一个布尔真/假结果值，其中假值\n表示错误。 有极少的函数没有显式的错误标示或是具有不明确的返回值，并需要用\nPyErr_Occurred() 来进行显式的检测。 这些例外总是会被明确地记入文档中。\n异常状态是在各个线程的存储中维护的（这相当于在一个无线程的应用中使用全局存储）。 一个线\n程可以处在两种状态之一：异常已经发生，或者没有发生。 函数 PyErr_Occurred() 可以被用来检\n查此状态：当异常发生时它将返回一个借入的异常类型对象的引用，在其他情况下则返回 NULL。 有\n多个函数可以设置异常状态: PyErr_SetString() 是最常见的（尽管不是最通用的）设置异常状态\n的函数，而 PyErr_Clear() 可以清除异常状态。\n完整的异常状态由三个对象组成 (它为都可以为 NULL): 异常类型、相应的异常值，以及回溯信息。\n这些对象的含义与 Python 中 sys.exc_info() 的结果相同；然而，它们并不是一样的：Python 对\n象代表由 Python try ... except 语句所处理的最后一个异常，而 C 层级的异常状态只在异常被传入\n到 C 函数或在它们之间传递时存在直至其到达 Python 字节码解释器的主事件循环，该事件循环会负\n责将其转移至 sys.exc_info() 等处。\n请注意自 Python 1.5 开始，从 Python 代码访问异常状态的首选的、线程安全的方式是调用函数\nsys.exc_info()，它将返回 Python 代码的分线程异常状态。 此外，这两种访问异常状态的方式的\n语义都发生了变化因而捕获到异常的函数将保存并恢复其线程的异常状态以保留其调用方的异常状\n态。 这将防止异常处理代码中由一个看起来很无辜的函数覆盖了正在处理的异常所造成的常见错\n误；它还减少了在回溯由栈帧所引用的对象的往往不被需要的生命其延长。\n作为一般的原则，一个调用另一个函数来执行某些任务的函数应当检查被调用的函数是否引发了异\n常，并在引发异常时将异常状态传递给其调用方。 它应当丢弃它所拥有的任何对象引用，并返回一\n个错误标示，但它 不应 设置另一个异常 --- 那会覆盖刚引发的异常，并丢失有关错误确切原因的重\n要信息。\n上面的 sum_sequence() 示例是一个检测异常并将其传递出去的简单例子。 碰巧的是这个示例在检\n测到错误时不需要清理所拥有的任何引用。 下面的示例函数展示了一些错误清理操作。 首先，为了\n提醒你 Python 的受欢迎程度，我们展示了等价的 Python 代码: |  |\n| --- | --- | --- |\n|  | def incr_item(dict, key):\ntry:\nitem = dict[key]\nexcept KeyError:\nitem = 0\ndict[key] = item + 1 |  |\n|  | 对应的 C 代码如下： |  |\n\nint\nincr_item(PyObject *dict, PyObject *key)\n{\n/* 对象全部初始化为 NULL 用于 Py_XDECREF */\nPyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\nint rv = -1; /* 返回值初始化为 -1 (失败) */\nitem = PyObject_GetItem(dict, key);\nif (item == NULL) {\n/* 只处理 KeyError: */\nif (!PyErr_ExceptionMatches(PyExc_KeyError))\ngoto error;\n/* 清除错误并使用零: */\nPyErr_Clear();\nitem = PyLong_FromLong(0L);\nif (item == NULL)\ngoto error;\n}\nconst_one = PyLong_FromLong(1L);\nif (const_one == NULL)\ngoto error;\nincremented_item = PyNumber_Add(item, const_one);\nif (incremented_item == NULL)\ngoto error;\nif (PyObject_SetItem(dict, key, incremented_item) < 0)\ngoto error;\nrv = 0; /* 成功 */\n/* 继续执行清理代码 */\nerror:\n/* 清理代码，由成功和失败路径所共享 */\n/* 使用 Py_XDECREF() 以忽略 NULL 引用 */\nPy_XDECREF(item);\nPy_XDECREF(const_one);\nPy_XDECREF(incremented_item);\nreturn rv; /* -1 表示错误, 0 表示成功 */\n}\n这个例子代表了 C 语言中 goto 语句一种受到认可的用法！ 它说明了如何使用\nPyErr_ExceptionMatches() 和 PyErr_Clear() 来处理特定的异常，以及如何使用 Py_XDECREF()\n来处理可能为 NULL 的自有引用（注意名称中的 'X'；Py_DECREF() 在遇到 NULL 引用时将会崩\n溃）。 重要的一点在于用来保存自有引用的变量要被初始化为 NULL 才能发挥作用；类似地，建议\n的返回值也要被初始化为 -1 (失败) 并且只有在最终执行的调用成功后才会被设置为成功。\n嵌入Python\n只有 Python 解释器的嵌入方（相对于扩展编写者而言）才需要担心的一项重要任务是它的初始化，\n可能还有它的最终化。 解释器的大多数功能只有在解释器被初始化之后才能被使用。\n\n|  | int\nincr_item(PyObject *dict, PyObject *key)\n{\n/* 对象全部初始化为 NULL 用于 Py_XDECREF */\nPyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\nint rv = -1; /* 返回值初始化为 -1 (失败) */\nitem = PyObject_GetItem(dict, key);\nif (item == NULL) {\n/* 只处理 KeyError: */\nif (!PyErr_ExceptionMatches(PyExc_KeyError))\ngoto error;\n/* 清除错误并使用零: */\nPyErr_Clear();\nitem = PyLong_FromLong(0L);\nif (item == NULL)\ngoto error;\n}\nconst_one = PyLong_FromLong(1L);\nif (const_one == NULL)\ngoto error;\nincremented_item = PyNumber_Add(item, const_one);\nif (incremented_item == NULL)\ngoto error;\nif (PyObject_SetItem(dict, key, incremented_item) < 0)\ngoto error;\nrv = 0; /* 成功 */\n/* 继续执行清理代码 */\nerror:\n/* 清理代码，由成功和失败路径所共享 */\n/* 使用 Py_XDECREF() 以忽略 NULL 引用 */\nPy_XDECREF(item);\nPy_XDECREF(const_one);\nPy_XDECREF(incremented_item);\nreturn rv; /* -1 表示错误, 0 表示成功 */\n} |  |\n| --- | --- | --- |\n|  | 这个例子代表了 C 语言中 goto 语句一种受到认可的用法！ 它说明了如何使用\nPyErr_ExceptionMatches() 和 PyErr_Clear() 来处理特定的异常，以及如何使用 Py_XDECREF()\n来处理可能为 NULL 的自有引用（注意名称中的 'X'；Py_DECREF() 在遇到 NULL 引用时将会崩\n溃）。 重要的一点在于用来保存自有引用的变量要被初始化为 NULL 才能发挥作用；类似地，建议\n的返回值也要被初始化为 -1 (失败) 并且只有在最终执行的调用成功后才会被设置为成功。\n嵌入Python\n只有 Python 解释器的嵌入方（相对于扩展编写者而言）才需要担心的一项重要任务是它的初始化，\n可能还有它的最终化。 解释器的大多数功能只有在解释器被初始化之后才能被使用。 |  |\n\n基本的初始化函数是 Py_Initialize()。 此函数将初始化已加载模块表，并创建基本模块\nbuiltins, __main__ 和 sys。 它还将初始化模块搜索路径 (sys.path)。\nPy_Initialize() 不会设置 \"脚本参数列表\" (sys.argv)。 如果稍后将要执行的 Python 代码需要此\n变量，则要设置 PyConfig.argv 并且还要设置 PyConfig.parse_argv: 参见 Python 初始化配置。\n在大多数系统上（特别是 Unix 和 Windows，虽然在细节上有所不同），Py_Initialize() 将根据\n对标准 Python 解释器可执行文件的位置的最佳猜测来计算模块搜索路径，并设定 Python 库可在相\n对于 Python 解释器可执行文件的固定位置上找到。 特别地，它将相对于在 shell 命令搜索路径 (环\n境变量 PATH) 上找到的名为 python 的可执行文件所在父目录中查找名为 lib/pythonX.Y 的目录。\n举例来说，如果 Python 可执行文件位于 /usr/local/bin/python，它将假定库位于\n/usr/local/lib/pythonX.Y。 （实际上，这个特定路径还将成为“回退”位置，会在当无法在 PATH\n中找到名为 python 的可执行文件时被使用。） 用户可以通过设置环境变量 PYTHONHOME，或通过\n设置 PYTHONPATH 在标准路径之前插入额外的目录来覆盖此行为。\n嵌入的应用程序可以通过在调用 Py_InitializeFromConfig() 之前 设置 PyConfig.program_name\n来调整搜索。 请注意 PYTHONHOME 仍然会覆盖此设置并且 PYTHONPATH 仍然会被插入到标准路径之\n前。 需要完整控制权的应用程序必须提供它自己的 Py_GetPath(), Py_GetPrefix(),\nPy_GetExecPrefix() 和 Py_GetProgramFullPath() 实现（这些函数均在 Modules/getpath.c 中\n定义）。\n有时，还需要对 Python 进行“反初始化”。 例如，应用程序可能想要重新启动 (再次调用\nPy_Initialize()) 或者应用程序对 Python 的使用已经完成并想要释放 Python 所分配的内存。 这\n可以通过调用 Py_FinalizeEx() 来实现。 如果当前 Python 处于已初始化状态则\nPy_IsInitialized() 函数将返回真值。 有关这些函数的更多信息将在之后的章节中给出。 请注意\nPy_FinalizeEx() 不会 释放所有由 Python 解释器所分配的内存，例如由扩展模块所分配的内存目\n前是不会被释放的。\n调试构建\nPython 可以附带某些宏来编译以启用对解释器和扩展模块的额外检查。 这些检查会给运行时增加大\n量额外开销因此它们默认未被启用。\n各种调试构建版的完整列表见 Python 源代码颁发包中的 Misc/SpecialBuilds.txt。 可用的构建\n版有支持追踪引用计数，调试内存分配器，或是对主解释器事件循环的低层级性能分析等等。 本节\n的剩余部分将只介绍最常用的几种构建版。\nPy_DEBUG\n在定义了 Py_DEBUG 宏的情况下编译解释器将产生通常所称的 Python 调试构建版。 Py_DEBUG 在\nUnix 编译版中是通过添加 --with-pydebug 到 ./configure 命令来启用的。 它也可以通过提供非\nPython 专属的 _DEBUG 宏来启用。 当 Py_DEBUG 在 Unix 编译版中启用时，编译器优化将被禁用。\n除了下文描述的引用计数调试，还会执行额外检查，请参阅 Python Debug Build。\n\n|  | 基本的初始化函数是 Py_Initialize()。 此函数将初始化已加载模块表，并创建基本模块\nbuiltins, __main__ 和 sys。 它还将初始化模块搜索路径 (sys.path)。\nPy_Initialize() 不会设置 \"脚本参数列表\" (sys.argv)。 如果稍后将要执行的 Python 代码需要此\n变量，则要设置 PyConfig.argv 并且还要设置 PyConfig.parse_argv: 参见 Python 初始化配置。\n在大多数系统上（特别是 Unix 和 Windows，虽然在细节上有所不同），Py_Initialize() 将根据\n对标准 Python 解释器可执行文件的位置的最佳猜测来计算模块搜索路径，并设定 Python 库可在相\n对于 Python 解释器可执行文件的固定位置上找到。 特别地，它将相对于在 shell 命令搜索路径 (环\n境变量 PATH) 上找到的名为 python 的可执行文件所在父目录中查找名为 lib/pythonX.Y 的目录。\n举例来说，如果 Python 可执行文件位于 /usr/local/bin/python，它将假定库位于\n/usr/local/lib/pythonX.Y。 （实际上，这个特定路径还将成为“回退”位置，会在当无法在 PATH\n中找到名为 python 的可执行文件时被使用。） 用户可以通过设置环境变量 PYTHONHOME，或通过\n设置 PYTHONPATH 在标准路径之前插入额外的目录来覆盖此行为。\n嵌入的应用程序可以通过在调用 Py_InitializeFromConfig() 之前 设置 PyConfig.program_name\n来调整搜索。 请注意 PYTHONHOME 仍然会覆盖此设置并且 PYTHONPATH 仍然会被插入到标准路径之\n前。 需要完整控制权的应用程序必须提供它自己的 Py_GetPath(), Py_GetPrefix(),\nPy_GetExecPrefix() 和 Py_GetProgramFullPath() 实现（这些函数均在 Modules/getpath.c 中\n定义）。\n有时，还需要对 Python 进行“反初始化”。 例如，应用程序可能想要重新启动 (再次调用\nPy_Initialize()) 或者应用程序对 Python 的使用已经完成并想要释放 Python 所分配的内存。 这\n可以通过调用 Py_FinalizeEx() 来实现。 如果当前 Python 处于已初始化状态则\nPy_IsInitialized() 函数将返回真值。 有关这些函数的更多信息将在之后的章节中给出。 请注意\nPy_FinalizeEx() 不会 释放所有由 Python 解释器所分配的内存，例如由扩展模块所分配的内存目\n前是不会被释放的。\n调试构建\nPython 可以附带某些宏来编译以启用对解释器和扩展模块的额外检查。 这些检查会给运行时增加大\n量额外开销因此它们默认未被启用。\n各种调试构建版的完整列表见 Python 源代码颁发包中的 Misc/SpecialBuilds.txt。 可用的构建\n版有支持追踪引用计数，调试内存分配器，或是对主解释器事件循环的低层级性能分析等等。 本节\n的剩余部分将只介绍最常用的几种构建版。\nPy_DEBUG\n在定义了 Py_DEBUG 宏的情况下编译解释器将产生通常所称的 Python 调试构建版。 Py_DEBUG 在\nUnix 编译版中是通过添加 --with-pydebug 到 ./configure 命令来启用的。 它也可以通过提供非\nPython 专属的 _DEBUG 宏来启用。 当 Py_DEBUG 在 Unix 编译版中启用时，编译器优化将被禁用。\n除了下文描述的引用计数调试，还会执行额外检查，请参阅 Python Debug Build。 |  |\n| --- | --- | --- |\n\n定义 Py_TRACE_REFS 将启用引用追踪 (参见 configure --with-trace-refs 选项)。 当定义了此\n宏时，将通过在每个 PyObject 上添加两个额外字段来维护一个活动对象的循环双链列表。 总的分\n配量也会被追踪。 在退出时，所有现存的引用将被打印出来。 （在交互模式下这将在解释器运行每\n条语句之后发生）。\n有关更多详细信息，请参阅Python源代码中的 Misc/SpecialBuilds.txt 。\n推荐的第三方工具\n下列第三方工具提供了为 Python 创建 C, C++ 和 Rust 扩展的更简单或更复杂的方式：\nCython\ncffi\nHPy\nnanobind (C++)\nNumba\npybind11 (C++)\nPyO3 (Rust)\nSWIG\n使用这些工具可以避免编写与特定版本的 CPython 紧密绑定的代码，避免引用计数错误，并能更多\n地关注你自己的代码而不是关注如何使用 CPython API。 总的来说，Python 的新版本可通过更新此\n类工具来获得支持，并且你的代码通常都将自动使用更新且更高效的 API。 有些工具还支持基于单\n个源代码集针对其他 Python 实现进行编译。\n这些项目并不是由维护 Python 的同一批人提供支持的，程序相关的问题需要直接向项目提出。 请\n记得检查项目是否仍然获得维护与支持，因为上面的列表可能会变得过时。\n参见:\nPython Packaging User Guide: Binary Extensions\n“ Python Packaging User Guide ”不仅涵盖了几个简化二进制扩展创建的可用工具，还讨论了\n为什么首先创建扩展模块的各种原因。\n\n| 定义 Py_TRACE_REFS 将启用引用追踪 (参见 configure --with-trace-refs 选项)。 当定义了此\n宏时，将通过在每个 PyObject 上添加两个额外字段来维护一个活动对象的循环双链列表。 总的分\n配量也会被追踪。 在退出时，所有现存的引用将被打印出来。 （在交互模式下这将在解释器运行每\n条语句之后发生）。\n有关更多详细信息，请参阅Python源代码中的 Misc/SpecialBuilds.txt 。\n推荐的第三方工具\n下列第三方工具提供了为 Python 创建 C, C++ 和 Rust 扩展的更简单或更复杂的方式：\nCython\ncffi\nHPy\nnanobind (C++)\nNumba\npybind11 (C++)\nPyO3 (Rust)\nSWIG\n使用这些工具可以避免编写与特定版本的 CPython 紧密绑定的代码，避免引用计数错误，并能更多\n地关注你自己的代码而不是关注如何使用 CPython API。 总的来说，Python 的新版本可通过更新此\n类工具来获得支持，并且你的代码通常都将自动使用更新且更高效的 API。 有些工具还支持基于单\n个源代码集针对其他 Python 实现进行编译。\n这些项目并不是由维护 Python 的同一批人提供支持的，程序相关的问题需要直接向项目提出。 请\n记得检查项目是否仍然获得维护与支持，因为上面的列表可能会变得过时。 |\n| --- |\n| 参见:\nPython Packaging User Guide: Binary Extensions\n“ Python Packaging User Guide ”不仅涵盖了几个简化二进制扩展创建的可用工具，还讨论了\n为什么首先创建扩展模块的各种原因。 |", "metadata": {"title": "00_概述", "source": "md_docs\\python_c-api_md\\00_概述.md", "doc_type": "C API", "language": "中文", "doc_id": "35e53aa9"}}
{"doc_id": "c6cd0abd", "content": "监控 C API\n在 3.13 版中添加。\n一个扩展可能需要与事件监视系统进行交互。 订阅事件和注册回调都可通过在 sys.monitoring 中\n暴露的 Python API 来完成。\n生成执行事件\n下面的函数使得扩展可以在模拟执行 Python 代码时触发监控事件。 这样的函数都接受一个\nPyMonitoringState 结构体，其中包含有关事件激活状态的简明信息以及事件参数 ，此类参数包括\n代表代码对象的 PyObject*、指令偏移量，有时还包括额外的、事件专属的参数（请参阅\nsys.monitoring 了解有关不同事件回调签名的详情）。 codelike 参数应为 types.CodeType 的\n实例或是某个模拟它的类型。\nVM 会在触发事件时禁用跟踪，因此用户不需要额外的操作。\n监控函数被调用时不应设置异常，除非是下面列出的用于处理当前异常的函数。\ntype PyMonitoringState\n事件类型状态的表示形式。 它由用户分配，但其内容则由下文描述的监控 API 函数来维护。\n下面的所有函数均在成功时返回 0 并在失败时返回 -1 (同时设置一个异常)。\n请参阅 sys.monitoring 获取事件的描述。\nint PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n发出 PY_START 事件。\nint PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n发出 PY_RESUME 事件。\nint PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 PY_RETURN 事件。\nint PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 PY_YIELD 事件。\nint PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *callable, PyObject *arg0)\n发出 CALL 事件。\n\nint PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, int lineno)\n发出 LINE 事件。\nint PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *target_offset)\n发出 JUMP 事件。\nint PyMonitoring_FireBranchLeftEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_LEFT 事件。\nint PyMonitoring_FireBranchRightEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_RIGHT 事件。\nint PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 C_RETURN 事件。\nint PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 返回的）异常发出 PY_THROW 事件。\nint PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RAISE 事件。event with\nthe current ).\nint PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 C_RAISE 事件。\nint PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RERAISE 事件。\nint PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state,\nPyObject *codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 EXCEPTION_HANDLED 事\n件。\nint PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 PY_UNWIND 事件。\nint PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *value)\n\n|  | int PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, int lineno)\n发出 LINE 事件。\nint PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *target_offset)\n发出 JUMP 事件。\nint PyMonitoring_FireBranchLeftEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_LEFT 事件。\nint PyMonitoring_FireBranchRightEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_RIGHT 事件。\nint PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 C_RETURN 事件。\nint PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 返回的）异常发出 PY_THROW 事件。\nint PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RAISE 事件。event with\nthe current ).\nint PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 C_RAISE 事件。\nint PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RERAISE 事件。\nint PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state,\nPyObject *codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 EXCEPTION_HANDLED 事\n件。\nint PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 PY_UNWIND 事件。\nint PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *value) |  |\n| --- | --- | --- |\n\n发出 STOP_ITERATION 事件。 如果 value 是一个 StopIteration 实例，它将被使用。 在其他\n情况下，将新建一个 StopIteration 实例并以 value 作为其参数。\n管理监控状态\n监控状态可在监控作用域的协助下进行管理。 一个作用域通常对应一个 python 函数。\nint PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t\n*version, const uint8_t *event_types, Py_ssize_t length)\n进入一个监控作用域。 event_types 是由可从该作用域发生事件的事件 ID 组成的数组。 例\n如，PY_START 事件的 ID 值为 PY_MONITORING_EVENT_PY_START，其对应数字等于\nsys.monitoring.events.PY_START 的以 2 为底的对数。 state_array 是由对应\nevent_types 中每个事件的监控状态组成的数组，它由用户进行分配但是由\nPyMonitoring_EnterScope() 使用事件激活状态相关信息填充。 event_types 的大小 (因而\n也是 state_array 的大小) 由 length 给出。\nversion 是一个指向应与 state_array 一起由用户分配的值并初始化为 0，然后仅由\nPyMonitoring_EnterScope() 本身来设置。 它允许此函数确定事件状态自上次调用以来是否\n发生改变，并在它们未改变时立即返回。\n这里所称的作用域是词法意义下的作用域：一个函数、类或方法。\nPyMonitoring_EnterScope() 应当在进入词法作用域时被调用。 在模拟一个递归 Python 函数\n之类的情况下，作用域可被重进入，并重用相同的 state_array 和 version。 当某个代码执行暂\n停时，例如在模拟一个生成器时，此作用域需要被退出并重进入。\n对应 event_types 的宏如下：\n宏 事件\nPY_MONITORING_EVENT_BRANCH_LEFT BRANCH_LEFT\nPY_MONITORING_EVENT_BRANCH_RIGHT BRANCH_RIGHT\nPY_MONITORING_EVENT_CALL CALL\nPY_MONITORING_EVENT_C_RAISE C_RAISE\nPY_MONITORING_EVENT_C_RETURN C_RETURN\nPY_MONITORING_EVENT_EXCEPTION_HANDLED EXCEPTION_HANDLED\nPY_MONITORING_EVENT_INSTRUCTION INSTRUCTION\nPY_MONITORING_EVENT_JUMP JUMP\nPY_MONITORING_EVENT_LINE LINE\nPY_MONITORING_EVENT_PY_RESUME PY_RESUME\n\n|  | 发出 STOP_ITERATION 事件。 如果 value 是一个 StopIteration 实例，它将被使用。 在其他\n情况下，将新建一个 StopIteration 实例并以 value 作为其参数。\n管理监控状态\n监控状态可在监控作用域的协助下进行管理。 一个作用域通常对应一个 python 函数。\nint PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t\n*version, const uint8_t *event_types, Py_ssize_t length)\n进入一个监控作用域。 event_types 是由可从该作用域发生事件的事件 ID 组成的数组。 例\n如，PY_START 事件的 ID 值为 PY_MONITORING_EVENT_PY_START，其对应数字等于\nsys.monitoring.events.PY_START 的以 2 为底的对数。 state_array 是由对应\nevent_types 中每个事件的监控状态组成的数组，它由用户进行分配但是由\nPyMonitoring_EnterScope() 使用事件激活状态相关信息填充。 event_types 的大小 (因而\n也是 state_array 的大小) 由 length 给出。\nversion 是一个指向应与 state_array 一起由用户分配的值并初始化为 0，然后仅由\nPyMonitoring_EnterScope() 本身来设置。 它允许此函数确定事件状态自上次调用以来是否\n发生改变，并在它们未改变时立即返回。\n这里所称的作用域是词法意义下的作用域：一个函数、类或方法。\nPyMonitoring_EnterScope() 应当在进入词法作用域时被调用。 在模拟一个递归 Python 函数\n之类的情况下，作用域可被重进入，并重用相同的 state_array 和 version。 当某个代码执行暂\n停时，例如在模拟一个生成器时，此作用域需要被退出并重进入。\n对应 event_types 的宏如下：\n宏 事件\nPY_MONITORING_EVENT_BRANCH_LEFT BRANCH_LEFT\nPY_MONITORING_EVENT_BRANCH_RIGHT BRANCH_RIGHT\nPY_MONITORING_EVENT_CALL CALL\nPY_MONITORING_EVENT_C_RAISE C_RAISE\nPY_MONITORING_EVENT_C_RETURN C_RETURN\nPY_MONITORING_EVENT_EXCEPTION_HANDLED EXCEPTION_HANDLED\nPY_MONITORING_EVENT_INSTRUCTION INSTRUCTION\nPY_MONITORING_EVENT_JUMP JUMP\nPY_MONITORING_EVENT_LINE LINE\nPY_MONITORING_EVENT_PY_RESUME PY_RESUME |  |\n| --- | --- | --- |\n\n| 宏 | 事件 |\n| --- | --- |\n| PY_MONITORING_EVENT_BRANCH_LEFT | BRANCH_LEFT |\n| PY_MONITORING_EVENT_BRANCH_RIGHT | BRANCH_RIGHT |\n| PY_MONITORING_EVENT_CALL | CALL |\n| PY_MONITORING_EVENT_C_RAISE | C_RAISE |\n| PY_MONITORING_EVENT_C_RETURN | C_RETURN |\n| PY_MONITORING_EVENT_EXCEPTION_HANDLED | EXCEPTION_HANDLED |\n| PY_MONITORING_EVENT_INSTRUCTION | INSTRUCTION |\n| PY_MONITORING_EVENT_JUMP | JUMP |\n| PY_MONITORING_EVENT_LINE | LINE |\n| PY_MONITORING_EVENT_PY_RESUME | PY_RESUME |\n\n宏 事件\nPY_MONITORING_EVENT_PY_RETURN PY_RETURN\nPY_MONITORING_EVENT_PY_START PY_START\nPY_MONITORING_EVENT_PY_THROW PY_THROW\nPY_MONITORING_EVENT_PY_UNWIND PY_UNWIND\nPY_MONITORING_EVENT_PY_YIELD PY_YIELD\nPY_MONITORING_EVENT_RAISE RAISE\nPY_MONITORING_EVENT_RERAISE RERAISE\nPY_MONITORING_EVENT_STOP_ITERATION STOP_ITERATION\nint PyMonitoring_ExitScope(void)\n退出使用 PyMonitoring_EnterScope() 进入的上一个作用域。\nint PY_MONITORING_IS_INSTRUMENTED_EVENT(uint8_t ev)\n如果对应事件 ID ev 的事件属于 局部事件 则返回真值。\nAdded in version 3.13.\n自 3.14 版本弃用: 此函数状态为 soft deprecated。\n\n| 宏 | 事件 |\n| --- | --- |\n| PY_MONITORING_EVENT_PY_RETURN | PY_RETURN |\n| PY_MONITORING_EVENT_PY_START | PY_START |\n| PY_MONITORING_EVENT_PY_THROW | PY_THROW |\n| PY_MONITORING_EVENT_PY_UNWIND | PY_UNWIND |\n| PY_MONITORING_EVENT_PY_YIELD | PY_YIELD |\n| PY_MONITORING_EVENT_RAISE | RAISE |\n| PY_MONITORING_EVENT_RERAISE | RERAISE |\n| PY_MONITORING_EVENT_STOP_ITERATION | STOP_ITERATION |", "metadata": {"title": "00_生成执行事件", "source": "md_docs\\python_c-api_md\\00_生成执行事件.md", "doc_type": "C API", "language": "中文", "doc_id": "c6cd0abd"}}
{"doc_id": "6d68f726", "content": "监控 C API\n在 3.13 版中添加。\n一个扩展可能需要与事件监视系统进行交互。 订阅事件和注册回调都可通过在 sys.monitoring 中\n暴露的 Python API 来完成。\n生成执行事件\n下面的函数使得扩展可以在模拟执行 Python 代码时触发监控事件。 这样的函数都接受一个\nPyMonitoringState 结构体，其中包含有关事件激活状态的简明信息以及事件参数 ，此类参数包括\n代表代码对象的 PyObject*、指令偏移量，有时还包括额外的、事件专属的参数（请参阅\nsys.monitoring 了解有关不同事件回调签名的详情）。 codelike 参数应为 types.CodeType 的\n实例或是某个模拟它的类型。\nVM 会在触发事件时禁用跟踪，因此用户不需要额外的操作。\n监控函数被调用时不应设置异常，除非是下面列出的用于处理当前异常的函数。\ntype PyMonitoringState\n事件类型状态的表示形式。 它由用户分配，但其内容则由下文描述的监控 API 函数来维护。\n下面的所有函数均在成功时返回 0 并在失败时返回 -1 (同时设置一个异常)。\n请参阅 sys.monitoring 获取事件的描述。\nint PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n发出 PY_START 事件。\nint PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n发出 PY_RESUME 事件。\nint PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 PY_RETURN 事件。\nint PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 PY_YIELD 事件。\nint PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *callable, PyObject *arg0)\n发出 CALL 事件。\n\nint PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, int lineno)\n发出 LINE 事件。\nint PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *target_offset)\n发出 JUMP 事件。\nint PyMonitoring_FireBranchLeftEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_LEFT 事件。\nint PyMonitoring_FireBranchRightEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_RIGHT 事件。\nint PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 C_RETURN 事件。\nint PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 返回的）异常发出 PY_THROW 事件。\nint PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RAISE 事件。event with\nthe current ).\nint PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 C_RAISE 事件。\nint PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RERAISE 事件。\nint PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state,\nPyObject *codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 EXCEPTION_HANDLED 事\n件。\nint PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 PY_UNWIND 事件。\nint PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *value)\n\n|  | int PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, int lineno)\n发出 LINE 事件。\nint PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike,\nint32_t offset, PyObject *target_offset)\n发出 JUMP 事件。\nint PyMonitoring_FireBranchLeftEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_LEFT 事件。\nint PyMonitoring_FireBranchRightEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *target_offset)\n发出 BRANCH_RIGHT 事件。\nint PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *retval)\n发出 C_RETURN 事件。\nint PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 返回的）异常发出 PY_THROW 事件。\nint PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RAISE 事件。event with\nthe current ).\nint PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 C_RAISE 事件。\nint PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 RERAISE 事件。\nint PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state,\nPyObject *codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 EXCEPTION_HANDLED 事\n件。\nint PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset)\n使用当前（即 PyErr_GetRaisedException() 所返回的）异常发出 PY_UNWIND 事件。\nint PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject\n*codelike, int32_t offset, PyObject *value) |  |\n| --- | --- | --- |\n\n发出 STOP_ITERATION 事件。 如果 value 是一个 StopIteration 实例，它将被使用。 在其他\n情况下，将新建一个 StopIteration 实例并以 value 作为其参数。\n管理监控状态\n监控状态可在监控作用域的协助下进行管理。 一个作用域通常对应一个 python 函数。\nint PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t\n*version, const uint8_t *event_types, Py_ssize_t length)\n进入一个监控作用域。 event_types 是由可从该作用域发生事件的事件 ID 组成的数组。 例\n如，PY_START 事件的 ID 值为 PY_MONITORING_EVENT_PY_START，其对应数字等于\nsys.monitoring.events.PY_START 的以 2 为底的对数。 state_array 是由对应\nevent_types 中每个事件的监控状态组成的数组，它由用户进行分配但是由\nPyMonitoring_EnterScope() 使用事件激活状态相关信息填充。 event_types 的大小 (因而\n也是 state_array 的大小) 由 length 给出。\nversion 是一个指向应与 state_array 一起由用户分配的值并初始化为 0，然后仅由\nPyMonitoring_EnterScope() 本身来设置。 它允许此函数确定事件状态自上次调用以来是否\n发生改变，并在它们未改变时立即返回。\n这里所称的作用域是词法意义下的作用域：一个函数、类或方法。\nPyMonitoring_EnterScope() 应当在进入词法作用域时被调用。 在模拟一个递归 Python 函数\n之类的情况下，作用域可被重进入，并重用相同的 state_array 和 version。 当某个代码执行暂\n停时，例如在模拟一个生成器时，此作用域需要被退出并重进入。\n对应 event_types 的宏如下：\n宏 事件\nPY_MONITORING_EVENT_BRANCH_LEFT BRANCH_LEFT\nPY_MONITORING_EVENT_BRANCH_RIGHT BRANCH_RIGHT\nPY_MONITORING_EVENT_CALL CALL\nPY_MONITORING_EVENT_C_RAISE C_RAISE\nPY_MONITORING_EVENT_C_RETURN C_RETURN\nPY_MONITORING_EVENT_EXCEPTION_HANDLED EXCEPTION_HANDLED\nPY_MONITORING_EVENT_INSTRUCTION INSTRUCTION\nPY_MONITORING_EVENT_JUMP JUMP\nPY_MONITORING_EVENT_LINE LINE\nPY_MONITORING_EVENT_PY_RESUME PY_RESUME\n\n|  | 发出 STOP_ITERATION 事件。 如果 value 是一个 StopIteration 实例，它将被使用。 在其他\n情况下，将新建一个 StopIteration 实例并以 value 作为其参数。\n管理监控状态\n监控状态可在监控作用域的协助下进行管理。 一个作用域通常对应一个 python 函数。\nint PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t\n*version, const uint8_t *event_types, Py_ssize_t length)\n进入一个监控作用域。 event_types 是由可从该作用域发生事件的事件 ID 组成的数组。 例\n如，PY_START 事件的 ID 值为 PY_MONITORING_EVENT_PY_START，其对应数字等于\nsys.monitoring.events.PY_START 的以 2 为底的对数。 state_array 是由对应\nevent_types 中每个事件的监控状态组成的数组，它由用户进行分配但是由\nPyMonitoring_EnterScope() 使用事件激活状态相关信息填充。 event_types 的大小 (因而\n也是 state_array 的大小) 由 length 给出。\nversion 是一个指向应与 state_array 一起由用户分配的值并初始化为 0，然后仅由\nPyMonitoring_EnterScope() 本身来设置。 它允许此函数确定事件状态自上次调用以来是否\n发生改变，并在它们未改变时立即返回。\n这里所称的作用域是词法意义下的作用域：一个函数、类或方法。\nPyMonitoring_EnterScope() 应当在进入词法作用域时被调用。 在模拟一个递归 Python 函数\n之类的情况下，作用域可被重进入，并重用相同的 state_array 和 version。 当某个代码执行暂\n停时，例如在模拟一个生成器时，此作用域需要被退出并重进入。\n对应 event_types 的宏如下：\n宏 事件\nPY_MONITORING_EVENT_BRANCH_LEFT BRANCH_LEFT\nPY_MONITORING_EVENT_BRANCH_RIGHT BRANCH_RIGHT\nPY_MONITORING_EVENT_CALL CALL\nPY_MONITORING_EVENT_C_RAISE C_RAISE\nPY_MONITORING_EVENT_C_RETURN C_RETURN\nPY_MONITORING_EVENT_EXCEPTION_HANDLED EXCEPTION_HANDLED\nPY_MONITORING_EVENT_INSTRUCTION INSTRUCTION\nPY_MONITORING_EVENT_JUMP JUMP\nPY_MONITORING_EVENT_LINE LINE\nPY_MONITORING_EVENT_PY_RESUME PY_RESUME |  |\n| --- | --- | --- |\n\n| 宏 | 事件 |\n| --- | --- |\n| PY_MONITORING_EVENT_BRANCH_LEFT | BRANCH_LEFT |\n| PY_MONITORING_EVENT_BRANCH_RIGHT | BRANCH_RIGHT |\n| PY_MONITORING_EVENT_CALL | CALL |\n| PY_MONITORING_EVENT_C_RAISE | C_RAISE |\n| PY_MONITORING_EVENT_C_RETURN | C_RETURN |\n| PY_MONITORING_EVENT_EXCEPTION_HANDLED | EXCEPTION_HANDLED |\n| PY_MONITORING_EVENT_INSTRUCTION | INSTRUCTION |\n| PY_MONITORING_EVENT_JUMP | JUMP |\n| PY_MONITORING_EVENT_LINE | LINE |\n| PY_MONITORING_EVENT_PY_RESUME | PY_RESUME |\n\n宏 事件\nPY_MONITORING_EVENT_PY_RETURN PY_RETURN\nPY_MONITORING_EVENT_PY_START PY_START\nPY_MONITORING_EVENT_PY_THROW PY_THROW\nPY_MONITORING_EVENT_PY_UNWIND PY_UNWIND\nPY_MONITORING_EVENT_PY_YIELD PY_YIELD\nPY_MONITORING_EVENT_RAISE RAISE\nPY_MONITORING_EVENT_RERAISE RERAISE\nPY_MONITORING_EVENT_STOP_ITERATION STOP_ITERATION\nint PyMonitoring_ExitScope(void)\n退出使用 PyMonitoring_EnterScope() 进入的上一个作用域。\nint PY_MONITORING_IS_INSTRUMENTED_EVENT(uint8_t ev)\n如果对应事件 ID ev 的事件属于 局部事件 则返回真值。\nAdded in version 3.13.\n自 3.14 版本弃用: 此函数状态为 soft deprecated。\n\n| 宏 | 事件 |\n| --- | --- |\n| PY_MONITORING_EVENT_PY_RETURN | PY_RETURN |\n| PY_MONITORING_EVENT_PY_START | PY_START |\n| PY_MONITORING_EVENT_PY_THROW | PY_THROW |\n| PY_MONITORING_EVENT_PY_UNWIND | PY_UNWIND |\n| PY_MONITORING_EVENT_PY_YIELD | PY_YIELD |\n| PY_MONITORING_EVENT_RAISE | RAISE |\n| PY_MONITORING_EVENT_RERAISE | RERAISE |\n| PY_MONITORING_EVENT_STOP_ITERATION | STOP_ITERATION |", "metadata": {"title": "00_监控_C_API", "source": "md_docs\\python_c-api_md\\00_监控_C_API.md", "doc_type": "C API", "language": "中文", "doc_id": "6d68f726"}}
