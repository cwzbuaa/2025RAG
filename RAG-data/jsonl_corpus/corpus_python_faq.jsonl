{"doc_id": "88a0ab61", "content": "Python在Windows上的常见问题\n目录\nPython在Windows上的常见问题\n我怎样在Windows下运行一个Python程序？\n我怎么让 Python 脚本可执行？\n为什么有时候 Python 程序会启动缓慢？\n我怎样使用 Python 脚本制作可执行文件？\n*.pyd 文件和 DLL 文件相同吗？\n我怎样将 Python 嵌入一个 Windows 程序？\n如何让编辑器不要在我的 Python 源代码中插入 tab ？\n如何在不阻塞的情况下检查按键？\n我该如何解决缺失 api-ms-win-crt-runtime-l1-1-0.dll 错误？\n我怎样在Windows下运行一个Python程序？\n这不一定是一个简单的问题。如果你已经熟悉在Windows的命令行中运行程序的方法，一切都显而\n易见；不然的话，你也许需要额外获得些许指导。\n除非你使用某种集成开发环境，否则你最终会在所谓的 \"命令提示窗口 \"中 输入 Windows命令。 通\n常情况下，你可以在搜索栏中搜索 cmd 来创建这样一个窗口。你应该能够发现你已经启动了这样一\n个窗口，因为你会看到一个 Windows \"命令提示符\"，它通常看起来像这样。\nC:\\>\n前面的字母可能会不同，而且后面有可能会有其他东西，所以你也许会看到类似这样的东西：\nD:\\YourName\\Projects\\Python>\n出现的内容具体取决与你的电脑如何设置和最近用它做的事。 当你启动了这样一个窗口后，就可以\n开始运行Python程序了。\nPython 脚本需要被另外一个叫做 Python 解释器 的程序来处理。 解释器读取脚本，把它编译成字节\n码，然后执行字节码来运行你的程序。 所以怎样安排解释器来处理你的 Python 脚本呢？\n首先，确保命令窗口能够将“py”识别为指令来开启解释器。 如果你打开过一个命令窗口， 尝试输入\n命令 py 然后按回车：\nC:\\Users\\YourName> py\n然后你应当看见类似类似这样的东西：\n\n| Python在Windows上的常见问题 |\n| --- |\n| 目录\nPython在Windows上的常见问题\n我怎样在Windows下运行一个Python程序？\n我怎么让 Python 脚本可执行？\n为什么有时候 Python 程序会启动缓慢？\n我怎样使用 Python 脚本制作可执行文件？\n*.pyd 文件和 DLL 文件相同吗？\n我怎样将 Python 嵌入一个 Windows 程序？\n如何让编辑器不要在我的 Python 源代码中插入 tab ？\n如何在不阻塞的情况下检查按键？\n我该如何解决缺失 api-ms-win-crt-runtime-l1-1-0.dll 错误？ |\n| 我怎样在Windows下运行一个Python程序？\n这不一定是一个简单的问题。如果你已经熟悉在Windows的命令行中运行程序的方法，一切都显而\n易见；不然的话，你也许需要额外获得些许指导。\n除非你使用某种集成开发环境，否则你最终会在所谓的 \"命令提示窗口 \"中 输入 Windows命令。 通\n常情况下，你可以在搜索栏中搜索 cmd 来创建这样一个窗口。你应该能够发现你已经启动了这样一\n个窗口，因为你会看到一个 Windows \"命令提示符\"，它通常看起来像这样。 |\n| C:\\> |\n| 前面的字母可能会不同，而且后面有可能会有其他东西，所以你也许会看到类似这样的东西： |\n| D:\\YourName\\Projects\\Python> |\n| 出现的内容具体取决与你的电脑如何设置和最近用它做的事。 当你启动了这样一个窗口后，就可以\n开始运行Python程序了。\nPython 脚本需要被另外一个叫做 Python 解释器 的程序来处理。 解释器读取脚本，把它编译成字节\n码，然后执行字节码来运行你的程序。 所以怎样安排解释器来处理你的 Python 脚本呢？\n首先，确保命令窗口能够将“py”识别为指令来开启解释器。 如果你打开过一个命令窗口， 尝试输入\n命令 py 然后按回车： |\n| C:\\Users\\YourName> py |\n| 然后你应当看见类似类似这样的东西： |\n\nPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] o\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n解释器已经以“交互模式”打开。这意味着你可以交互输入Python语句或表达式，并在等待时执行或评\n估它们。这是Python最强大的功能之一。输入几个表达式并看看结果：\n>>> print(\"Hello\")\nHello\n>>> \"Hello\" * 3\n'HelloHelloHello'\n许多人把交互模式当作方便和高度可编程的计算器。 想结束交互式Python会话时，调用 exit() 函\n数，或者按住 Ctrl 键时输入 Z ，之后按 Enter 键返回Windows命令提示符。\n你可能发现在开始菜单有这样一个条目 开始 ‣ 所有程序 ‣ Python 3.x ‣ Python (命令行)， 运行它后\n会出现一个有着 >>> 提示的新窗口。 在此之后，如果调用 exit() 函数或按 Ctrl-Z 组合键后窗口\n将会消失。 Windows 会在这个窗口中运行一个“python”命令，并且在你终止解释器的时候关闭它。\n现在我们知道 py 命令已经被识别，可以输入 Python 脚本了。 你需要提供 Python 脚本的绝对路径\n或相对路径。 假设 Python 脚本位于桌面上并命名为 hello.py，并且命令提示符在用户主目录打\n开，那么可以看到类似于这样的东西:\nC:\\Users\\YourName>\n那么现在可以让 py 命令执行你的脚本，只需要输入 py 和脚本路径:\nC:\\Users\\YourName> py Desktop\\hello.py\nhello\n我怎么让 Python 脚本可执行？\n在 Windows 上，标准 Python 安装程序已将 .py 扩展名与文件类型 (Python.File) 相关联，并为该文\n件类型提供运行解释器的打开命令 (D:\\Program Files\\Python\\python.exe \"%1\" %*) 。 这足以使\n脚本在命令提示符下作为“foo.py”命令被执行。 如果希望通过简单地键入“foo”而无需输入文件扩展\n名来执行脚本，则需要将 .py 添加到 PATHEXT 环境变量中。\n为什么有时候 Python 程序会启动缓慢？\n通常，Python 在 Windows 上启动得很快，但偶尔会有错误报告说 Python 突然需要很长时间才能启\n动。更令人费解的是，在其他配置相同的 Windows 系统上，Python 却可以工作得很好。\n该问题可能是由于计算机上的杀毒软件配置错误造成的。当将病毒扫描配置为监视文件系统中所有\n读取行为时，一些杀毒扫描程序会导致两个数量级的启动开销。请检查你系统安装的杀毒扫描程序\n的配置，确保两台机它们是同样的配置。已知的， McAfee 杀毒软件在将它设置为扫描所有文件系\n统访问时，会产生这个问题。\n\n|  | Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] o\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> |  |  |\n| --- | --- | --- | --- |\n|  | 解释器已经以“交互模式”打开。这意味着你可以交互输入Python语句或表达式，并在等待时执行或评\n估它们。这是Python最强大的功能之一。输入几个表达式并看看结果： |  |  |\n|  | >>> print(\"Hello\")\nHello\n>>> \"Hello\" * 3\n'HelloHelloHello' |  |  |\n|  | 许多人把交互模式当作方便和高度可编程的计算器。 想结束交互式Python会话时，调用 exit() 函\n数，或者按住 Ctrl 键时输入 Z ，之后按 Enter 键返回Windows命令提示符。\n你可能发现在开始菜单有这样一个条目 开始 ‣ 所有程序 ‣ Python 3.x ‣ Python (命令行)， 运行它后\n会出现一个有着 >>> 提示的新窗口。 在此之后，如果调用 exit() 函数或按 Ctrl-Z 组合键后窗口\n将会消失。 Windows 会在这个窗口中运行一个“python”命令，并且在你终止解释器的时候关闭它。\n现在我们知道 py 命令已经被识别，可以输入 Python 脚本了。 你需要提供 Python 脚本的绝对路径\n或相对路径。 假设 Python 脚本位于桌面上并命名为 hello.py，并且命令提示符在用户主目录打\n开，那么可以看到类似于这样的东西: |  |  |\n|  | C:\\Users\\YourName> |  |  |\n|  | 那么现在可以让 py 命令执行你的脚本，只需要输入 py 和脚本路径: |  |  |\n|  | C:\\Users\\YourName> py Desktop\\hello.py\nhello |  |  |\n|  | 我怎么让 Python 脚本可执行？\n在 Windows 上，标准 Python 安装程序已将 .py 扩展名与文件类型 (Python.File) 相关联，并为该文\n件类型提供运行解释器的打开命令 (D:\\Program Files\\Python\\python.exe \"%1\" %*) 。 这足以使\n脚本在命令提示符下作为“foo.py”命令被执行。 如果希望通过简单地键入“foo”而无需输入文件扩展\n名来执行脚本，则需要将 .py 添加到 PATHEXT 环境变量中。\n为什么有时候 Python 程序会启动缓慢？\n通常，Python 在 Windows 上启动得很快，但偶尔会有错误报告说 Python 突然需要很长时间才能启\n动。更令人费解的是，在其他配置相同的 Windows 系统上，Python 却可以工作得很好。\n该问题可能是由于计算机上的杀毒软件配置错误造成的。当将病毒扫描配置为监视文件系统中所有\n读取行为时，一些杀毒扫描程序会导致两个数量级的启动开销。请检查你系统安装的杀毒扫描程序\n的配置，确保两台机它们是同样的配置。已知的， McAfee 杀毒软件在将它设置为扫描所有文件系\n统访问时，会产生这个问题。 |  |  |\n\n我怎样使用 Python 脚本制作可执行文件？\n请参阅 如何由 Python 脚本创建能独立运行的二进制程序？ 查看可用来生成可执行文件的工具清\n单。\n*.pyd 文件和 DLL 文件相同吗？\n是的， .pyd 文件也是 dll ，但有一些差异。如果你有一个名为 foo.pyd 的DLL，那么它必须有一个\n函数 PyInit_foo() 。 然后你可以编写 Python 代码 “import foo” ，Python 将搜索 foo.pyd （以及\nfoo.py 、 foo.pyc ）。如果找到它，将尝试调用 PyInit_foo() 来初始化它。你不应将 .exe 与\nfoo.lib 链接，因为这会导致 Windows 要求存在 DLL 。\n请注意， foo.pyd 的搜索路径是 PYTHONPATH ，与 Windows 用于搜索 foo.dll 的路径不同。此外，\nfoo.pyd 不需要存在来运行你的程序，而如果你将程序与 dll 链接，则需要 dll 。 当然，如果你想\nimport foo ，则需要 foo.pyd 。在 DLL 中，链接在源代码中用 __declspec(dllexport) 声明。\n在 .pyd 中，链接在可用函数列表中定义。\n我怎样将 Python 嵌入一个 Windows 程序？\n在 Windows 应用程序中嵌入 Python 解释器可以总结如下：\n1. 请 不要 直接将 Python 编译到你的 .exe 文件中。 在 Windows 上，Python 必须是一个 DLL 以\n便处理导入本身就是 DLL 的模块。 （这是首先要知道的未写入文档的关键事实。） 正确的做\n法，应该是链接到 pythonNN.dll；它通常安装在 C:\\Windows\\System 中。 NN 是 Python\n的版本号，例如数字 \"33\" 代表 Python 3.3。\n你可以通过两种不同的方式链接到 Python 。加载时链接意味着链接到 pythonNN.lib ，而运\n行时链接意味着链接 pythonNN.dll 。（一般说明： python NN.lib 是所谓的“import lib”，\n对应于 pythonNN.dll 。它只定义了链接器的符号。）\n运行时链接极大地简化了链接选项，一切都在运行时发生。你的代码必须使用 Windows 的\nLoadLibraryEx() 程序加载 pythonNN.dll 。代码还必须使用使用 Windows 的\nGetProcAddress() 例程获得的指针访问 pythonNN.dll 中程序和数据（即 Python 的 C API\n）。宏可以使这些指针对任何调用 Python C API 中的例程的 C 代码都是透明的。\n2. 如果你是使用 SWIG，那么很容易创建一个将使得应用的数据和方法可供 Python 使用的 \"扩\n展模块\"。 SWIG 将为你处理所有繁琐的细节。 结果是让你链接 置入 你的 .exe 文件当中的 C\n代码 (!) 你 无需 创建一个 DLL 文件，而这也简化了链接过程。\n3. SWIG 将创建一个 init 函数（一个 C 函数），其名称取决于扩展模块的名称。例如，如果模块\n的名称是 leo ，则 init 函数将被称为 initleo() 。 如果您使用 SWIG 阴影类，则 init 函数将被称\n为 initleoc() 。这初始化了一个由阴影类使用的隐藏辅助类。\n你可以将步骤 2 中的 C 代码链接到 .exe 文件的原因是调用初始化函数等同于将模块导入\nPython ！ （这是第二个关键的未记载事实。）\n\n|  | 我怎样使用 Python 脚本制作可执行文件？\n请参阅 如何由 Python 脚本创建能独立运行的二进制程序？ 查看可用来生成可执行文件的工具清\n单。\n*.pyd 文件和 DLL 文件相同吗？\n是的， .pyd 文件也是 dll ，但有一些差异。如果你有一个名为 foo.pyd 的DLL，那么它必须有一个\n函数 PyInit_foo() 。 然后你可以编写 Python 代码 “import foo” ，Python 将搜索 foo.pyd （以及\nfoo.py 、 foo.pyc ）。如果找到它，将尝试调用 PyInit_foo() 来初始化它。你不应将 .exe 与\nfoo.lib 链接，因为这会导致 Windows 要求存在 DLL 。\n请注意， foo.pyd 的搜索路径是 PYTHONPATH ，与 Windows 用于搜索 foo.dll 的路径不同。此外，\nfoo.pyd 不需要存在来运行你的程序，而如果你将程序与 dll 链接，则需要 dll 。 当然，如果你想\nimport foo ，则需要 foo.pyd 。在 DLL 中，链接在源代码中用 __declspec(dllexport) 声明。\n在 .pyd 中，链接在可用函数列表中定义。\n我怎样将 Python 嵌入一个 Windows 程序？\n在 Windows 应用程序中嵌入 Python 解释器可以总结如下：\n1. 请 不要 直接将 Python 编译到你的 .exe 文件中。 在 Windows 上，Python 必须是一个 DLL 以\n便处理导入本身就是 DLL 的模块。 （这是首先要知道的未写入文档的关键事实。） 正确的做\n法，应该是链接到 pythonNN.dll；它通常安装在 C:\\Windows\\System 中。 NN 是 Python\n的版本号，例如数字 \"33\" 代表 Python 3.3。\n你可以通过两种不同的方式链接到 Python 。加载时链接意味着链接到 pythonNN.lib ，而运\n行时链接意味着链接 pythonNN.dll 。（一般说明： python NN.lib 是所谓的“import lib”，\n对应于 pythonNN.dll 。它只定义了链接器的符号。）\n运行时链接极大地简化了链接选项，一切都在运行时发生。你的代码必须使用 Windows 的\nLoadLibraryEx() 程序加载 pythonNN.dll 。代码还必须使用使用 Windows 的\nGetProcAddress() 例程获得的指针访问 pythonNN.dll 中程序和数据（即 Python 的 C API\n）。宏可以使这些指针对任何调用 Python C API 中的例程的 C 代码都是透明的。\n2. 如果你是使用 SWIG，那么很容易创建一个将使得应用的数据和方法可供 Python 使用的 \"扩\n展模块\"。 SWIG 将为你处理所有繁琐的细节。 结果是让你链接 置入 你的 .exe 文件当中的 C\n代码 (!) 你 无需 创建一个 DLL 文件，而这也简化了链接过程。\n3. SWIG 将创建一个 init 函数（一个 C 函数），其名称取决于扩展模块的名称。例如，如果模块\n的名称是 leo ，则 init 函数将被称为 initleo() 。 如果您使用 SWIG 阴影类，则 init 函数将被称\n为 initleoc() 。这初始化了一个由阴影类使用的隐藏辅助类。\n你可以将步骤 2 中的 C 代码链接到 .exe 文件的原因是调用初始化函数等同于将模块导入\nPython ！ （这是第二个关键的未记载事实。） |  |\n| --- | --- | --- |\n\n4. 简而言之，你可以用以下代码使用扩展模块初始化 Python 解释器。\n#include <Python.h>\n...\nPy_Initialize(); // 初始化 Python。\ninitmyAppc(); // 初始化（导入）辅助类。\nPyRun_SimpleString(\"import myApp\"); // 导入影子类。\n5. Python C API 存在两个问题，如果你使用除 MSVC 之外的编译器用于构建 python.dll ，这将\n会变得明显。\n问题 1: 接受 FILE * 参数的所谓的 \"极高层级\" 函数在多编译器环境中将不起作用，因为每个\n编译器中 struct FILE 的概念都会是不同的。 从实现的角度看来这些都是极低层级的函数。\n问题2：在为 void 函数生成包装器时，SWIG 会生成以下代码：\nPy_INCREF(Py_None);\n_resultobj = Py_None;\nreturn _resultobj;\nPy_None 是一个宏，它扩展为对 pythonNN.dll 中名为 _Py_NoneStruct 的复杂数据结构的引\n用。同样，此代码将在多编译器环境中失败。将此类代码替换为：\nreturn Py_BuildValue(\"\");\n有可能使用 SWIG 的 %typemap 命令自动进行更改，但我无法使其工作（我是一个完全的\nSWIG新手）。\n6. 使用 Python shell 脚本从 Windows 应用程序内部建立 Python 解释器窗口并不是一个好主\n意；生成的窗口将独立于应用程序的窗口系统。相反，你（或 wxPythonWindow 类）应该创\n建一个“本机”解释器窗口。将该窗口连接到Python解释器很容易。你可以将 Python的 i/o 重定\n向到支持读写的 _任意_ 对象，因此你只需要一个包含 read() 和 write() 方法的 Python 对象\n（在扩展模块中定义）。\n如何让编辑器不要在我的 Python 源代码中插入 tab ？\n本 FAQ 不建议使用制表符， Python 样式指南 PEP 8 ，为发行的 Python 代码推荐 4 个空格；这也\n是 Emacs python-mode 默认值。\n在任何编辑器下，混合制表符和空格都是一个坏主意。 MSVC 在这方面没有什么不同，并且很容易\n配置为使用空格： 点击 Tools ‣ Options ‣ Tabs，对于文件类型“Default”，设置“Tab size”和“Indent\nsize”为 4 ，并选择“插入空格”单选按钮。\n如果混合制表符和空格导致前导空格出现问题， Python 会引发 IndentationError 或 TabError 。\n你还可以运行 tabnanny 模块以批处理模式检查目录树。\n如何在不阻塞的情况下检查按键？\n\n|  | 4. 简而言之，你可以用以下代码使用扩展模块初始化 Python 解释器。\n#include <Python.h>\n...\nPy_Initialize(); // 初始化 Python。\ninitmyAppc(); // 初始化（导入）辅助类。\nPyRun_SimpleString(\"import myApp\"); // 导入影子类。\n5. Python C API 存在两个问题，如果你使用除 MSVC 之外的编译器用于构建 python.dll ，这将\n会变得明显。\n问题 1: 接受 FILE * 参数的所谓的 \"极高层级\" 函数在多编译器环境中将不起作用，因为每个\n编译器中 struct FILE 的概念都会是不同的。 从实现的角度看来这些都是极低层级的函数。\n问题2：在为 void 函数生成包装器时，SWIG 会生成以下代码：\nPy_INCREF(Py_None);\n_resultobj = Py_None;\nreturn _resultobj;\nPy_None 是一个宏，它扩展为对 pythonNN.dll 中名为 _Py_NoneStruct 的复杂数据结构的引\n用。同样，此代码将在多编译器环境中失败。将此类代码替换为：\nreturn Py_BuildValue(\"\");\n有可能使用 SWIG 的 %typemap 命令自动进行更改，但我无法使其工作（我是一个完全的\nSWIG新手）。\n6. 使用 Python shell 脚本从 Windows 应用程序内部建立 Python 解释器窗口并不是一个好主\n意；生成的窗口将独立于应用程序的窗口系统。相反，你（或 wxPythonWindow 类）应该创\n建一个“本机”解释器窗口。将该窗口连接到Python解释器很容易。你可以将 Python的 i/o 重定\n向到支持读写的 _任意_ 对象，因此你只需要一个包含 read() 和 write() 方法的 Python 对象\n（在扩展模块中定义）。\n如何让编辑器不要在我的 Python 源代码中插入 tab ？\n本 FAQ 不建议使用制表符， Python 样式指南 PEP 8 ，为发行的 Python 代码推荐 4 个空格；这也\n是 Emacs python-mode 默认值。\n在任何编辑器下，混合制表符和空格都是一个坏主意。 MSVC 在这方面没有什么不同，并且很容易\n配置为使用空格： 点击 Tools ‣ Options ‣ Tabs，对于文件类型“Default”，设置“Tab size”和“Indent\nsize”为 4 ，并选择“插入空格”单选按钮。\n如果混合制表符和空格导致前导空格出现问题， Python 会引发 IndentationError 或 TabError 。\n你还可以运行 tabnanny 模块以批处理模式检查目录树。\n如何在不阻塞的情况下检查按键？ |  |\n| --- | --- | --- |\n\n使用 msvcrt 模块。 这是一个标准的 Windows 专属扩展模块。 它定义了一个函数 kbhit() 用于检\n查是否有键盘中的某个键被按下，以及 getch() 用于获取一个字符而不将其回显。\n我该如何解决缺失 api-ms-win-crt-runtime-l1-1-0.dll 错误？\n这将在使用未安装全部更新的 Windows 8.1 或更旧的系统时发生于 Python 3.5 及之后的版本上。 首\n先请确保你的操作系统受支持并且已经更新补丁，如果此问题仍未解决，请访问 Microsoft support\npage 获取有关手动安装 C 运行时更新补丁的指导。", "metadata": {"title": "00_Python在Windows上的常见问题", "source": "md_docs\\python_faq_md\\00_Python在Windows上的常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "88a0ab61"}}
{"doc_id": "fb0e6092", "content": "Python常见问题\n目录\nPython常见问题\n一般信息\n什么是 Python？\n什么是 Python 软件基金会？\n使用 Python 是否存在版权限制？\n创造 Python 的最初理由是什么？\nPython 适合做什么？\nPython 版本的编号形式是怎样的？\n我应如何获取一份 Python 源代码的副本？\n我应如何获取 Python 的文档？\n我之前从未接触过编程。 哪里有 Python 的教程？\n是否有专门针对 Python 的新闻组或邮件列表？\n我应如何获取 Python 的公开测试版本？\n我应如何为 Python 提交错误报告和补丁？\n是否有任何公开发表的 Python 相关文章可以供我参考引用？\n是否有任何 Python 相关的书籍？\nwww.python.org 具体位于世界上的哪个地点？\n为何命名为 Python？\n我必须喜欢 \"Monty Python 的飞行马戏团\" 吗？\n现实世界中的 Python\nPython 有多稳定？\n有多少人在使用 Python？\n有哪些重要的项目是用 Python 开发的？\n在未来可以期待 Python 将有什么新进展？\n提议对 Python 加入不兼容的更改是否合理？\nPython 是一种对编程初学者友好的语言吗？\n一般信息\n什么是 Python？\nPython 是一种解释型、交互式、面向对象的编程语言。 它包含了模块、异常、动态类型、高层级动\n态数据类型以及类等特性。 在面向对象编程以外它还支持多种编程范式，例如过程式和函数式编程\n等。 Python 结合了超强的功能和极清晰的语法。 它带有许多系统调用和库以及多种窗口系统的接\n口，并且能用 C 或 C++ 来进行扩展。 它还可用作需要可编程接口的应用程序的扩展语言。 最后，\n\n| Python常见问题 |\n| --- |\n| 目录\nPython常见问题\n一般信息\n什么是 Python？\n什么是 Python 软件基金会？\n使用 Python 是否存在版权限制？\n创造 Python 的最初理由是什么？\nPython 适合做什么？\nPython 版本的编号形式是怎样的？\n我应如何获取一份 Python 源代码的副本？\n我应如何获取 Python 的文档？\n我之前从未接触过编程。 哪里有 Python 的教程？\n是否有专门针对 Python 的新闻组或邮件列表？\n我应如何获取 Python 的公开测试版本？\n我应如何为 Python 提交错误报告和补丁？\n是否有任何公开发表的 Python 相关文章可以供我参考引用？\n是否有任何 Python 相关的书籍？\nwww.python.org 具体位于世界上的哪个地点？\n为何命名为 Python？\n我必须喜欢 \"Monty Python 的飞行马戏团\" 吗？\n现实世界中的 Python\nPython 有多稳定？\n有多少人在使用 Python？\n有哪些重要的项目是用 Python 开发的？\n在未来可以期待 Python 将有什么新进展？\n提议对 Python 加入不兼容的更改是否合理？\nPython 是一种对编程初学者友好的语言吗？ |\n| 一般信息\n什么是 Python？\nPython 是一种解释型、交互式、面向对象的编程语言。 它包含了模块、异常、动态类型、高层级动\n态数据类型以及类等特性。 在面向对象编程以外它还支持多种编程范式，例如过程式和函数式编程\n等。 Python 结合了超强的功能和极清晰的语法。 它带有许多系统调用和库以及多种窗口系统的接\n口，并且能用 C 或 C++ 来进行扩展。 它还可用作需要可编程接口的应用程序的扩展语言。 最后， |\n\nPython 非常易于移植：它可以在包括 Linux 和 macOS 在内的许多 Unix 变种以及 Windows 上运\n行。\n要了解更多详情，请先查看 Python 教程。 Python 新手指南 提供了学习 Python 的其他入门教程及\n资源的链接。\n什么是 Python 软件基金会？\nPython 软件基金会（Python Software Foundation，简称 PSF）是一个独立的非盈利组织，它拥有\nPython 2.1 及以上各版本的版权。 PSF 的使命是推进与 Python 编程语言相关的开源技术，并推广\nPython 的使用。 PSF 的主页是 https://www.python.org/psf/。\n向 PSF 提供捐助在美国是免税的。 如果你在使用 Python 并且感觉它对你很有帮助，可以通过 PSF\n捐助页 进行捐助。\n使用 Python 是否存在版权限制？\n你可以任意使用源码，只要你保留版权信息并在你基于 Python 的产品文档中显示该版权信息。 如\n果你遵守此版权规则，就可以将 Python 用于商业领域，以源码或二进制码的形式（不论是否经过修\n改）销售 Python 的副本，或是以某种形式包含了 Python 的产品。 当然，我们仍然希望获知所有对\nPython 的商业使用。\n请参阅 许可页 以查看进一步的说明以及 PSF 许可的完整文本。\nPython 的徽标是注册商标，在某些情况下需要获得允许方可使用。 请参阅 商标使用政策 了解详\n情。\n创造 Python 的最初理由是什么？\n以下是有关最初缘起的一份 非常 简短的摘要，由 Guido van Rossum 本人撰写:\n我在 CWI 的 ABC 部门时在实现解释型语言方面积累了丰富经验，通过与这个部门成员的协同工\n作，我学到了大量有关语言设计的知识。 这是许多 Python 特性的最初来源，包括使用缩进来组\n织语句以及包含非常高层级的数据结构（虽然在 Python 中具体的实现细节完全不同）。\n我对 ABC 语言有过许多抱怨，但同时也很喜欢它的许多特性。 没有可能通过扩展 ABC 语言（或\n它的实现）来弥补我的不满 —— 实际上缺乏可扩展性就是它最大的问题之一。 我也有一些使用\nModula-2+ 的经验，并曾与 Modula-3 的设计者进行交流，还阅读了 Modula-3 的报告。\nModula-3 是 Python 中异常机制所用语法和语义，以及其他一些语言特性的最初来源。\n我还曾在 CWI 的 Amoeba 分布式操作系统部门工作。 当时我们需要有一种比编写 C 程序或 Bash\n脚本更好的方式来进行系统管理，因为 Amoeba 有它自己的系统调用接口，并且无法方便地通过\nBash 来访问。 我在 Amoeba 中处理错误的经验令我深刻地意识到异常处理在编程语言特性当中\n的重要地位。\n我发现，某种具有 ABC 式的语法而又能访问 Amoeba 系统调用的脚本语言将可满足需求。 我意\n识到编写一种 Amoeba 专属的语言是愚蠢的，所以我决定编写一种具有全面可扩展性的语言。\n\n|  | Python 非常易于移植：它可以在包括 Linux 和 macOS 在内的许多 Unix 变种以及 Windows 上运\n行。\n要了解更多详情，请先查看 Python 教程。 Python 新手指南 提供了学习 Python 的其他入门教程及\n资源的链接。\n什么是 Python 软件基金会？\nPython 软件基金会（Python Software Foundation，简称 PSF）是一个独立的非盈利组织，它拥有\nPython 2.1 及以上各版本的版权。 PSF 的使命是推进与 Python 编程语言相关的开源技术，并推广\nPython 的使用。 PSF 的主页是 https://www.python.org/psf/。\n向 PSF 提供捐助在美国是免税的。 如果你在使用 Python 并且感觉它对你很有帮助，可以通过 PSF\n捐助页 进行捐助。\n使用 Python 是否存在版权限制？\n你可以任意使用源码，只要你保留版权信息并在你基于 Python 的产品文档中显示该版权信息。 如\n果你遵守此版权规则，就可以将 Python 用于商业领域，以源码或二进制码的形式（不论是否经过修\n改）销售 Python 的副本，或是以某种形式包含了 Python 的产品。 当然，我们仍然希望获知所有对\nPython 的商业使用。\n请参阅 许可页 以查看进一步的说明以及 PSF 许可的完整文本。\nPython 的徽标是注册商标，在某些情况下需要获得允许方可使用。 请参阅 商标使用政策 了解详\n情。\n创造 Python 的最初理由是什么？\n以下是有关最初缘起的一份 非常 简短的摘要，由 Guido van Rossum 本人撰写:\n我在 CWI 的 ABC 部门时在实现解释型语言方面积累了丰富经验，通过与这个部门成员的协同工\n作，我学到了大量有关语言设计的知识。 这是许多 Python 特性的最初来源，包括使用缩进来组\n织语句以及包含非常高层级的数据结构（虽然在 Python 中具体的实现细节完全不同）。\n我对 ABC 语言有过许多抱怨，但同时也很喜欢它的许多特性。 没有可能通过扩展 ABC 语言（或\n它的实现）来弥补我的不满 —— 实际上缺乏可扩展性就是它最大的问题之一。 我也有一些使用\nModula-2+ 的经验，并曾与 Modula-3 的设计者进行交流，还阅读了 Modula-3 的报告。\nModula-3 是 Python 中异常机制所用语法和语义，以及其他一些语言特性的最初来源。\n我还曾在 CWI 的 Amoeba 分布式操作系统部门工作。 当时我们需要有一种比编写 C 程序或 Bash\n脚本更好的方式来进行系统管理，因为 Amoeba 有它自己的系统调用接口，并且无法方便地通过\nBash 来访问。 我在 Amoeba 中处理错误的经验令我深刻地意识到异常处理在编程语言特性当中\n的重要地位。\n我发现，某种具有 ABC 式的语法而又能访问 Amoeba 系统调用的脚本语言将可满足需求。 我意\n识到编写一种 Amoeba 专属的语言是愚蠢的，所以我决定编写一种具有全面可扩展性的语言。 |  |\n| --- | --- | --- |\n\n在 1989 年的圣诞假期中，我手头的时间非常充裕，因此我决定开始尝试一下。 在接下来的一年\n里，虽然我仍然主要用我的业余时间来做这件事，但 Python 在 Amoeba 项目中的使用获得了很\n大的成功，来自同事的反馈让我得以增加了许多早期的改进。\n到 1991 年 2 月，经过一年多的开发，我决定将其发布到 USENET。 之后的事情就都可以在\nMisc/HISTORY 文件里面看了。\nPython 适合做什么？\nPython 是一种高层级的多用途编程语言，可用于解决许多不同门类的问题。\n本语言自带一个庞大标准库，所涵盖的编程领域包括字符串处理（正则表达式、Unicode、文件间的\n差异比较等），互联网协议（HTTP, FTP, SMTP, XML-RPC, POP, IMAP），软件工程（单元测试、日\n志记录、性能分析、Python 代码解析），以及操作系统接口（系统调用、文件系统、TCP/IP 套接\n字）。 请查看 Python 标准库 目录页以获取所有可用内容的概览。 此外还有大量第三方扩展包可供\n使用。 请访问 Python 软件包索引 来查找你感兴趣的软件包。\nPython 版本的编号形式是怎样的？\nPython 版本的编号形式为 \"A.B.C\" 或 \"A.B\":\nA 是主版本号 -- 它仅会针对语言中非常重大的改变而递增。\nB 是次版本号 -- 它会针对不太重大的改变而递增。\nC 是微版本号 -- 它针对每次问题修正发布而递增。\n并非所有发布版本都是问题修正版本。 在新特征发布版本的开发过程中，会制作一系列的开发版\n本，它们以 alpha, beta 或 release candidate 来标示。 其中 alpha 版本是早期发布版，它的接口尚\n未最终确定；在两个 alpha 发布版本间出现接口的改变并不意外。 而 beta 版本更为稳定，它会保留\n现有的接口，但也可能增加新的模块，而 release candidate 版则会保持冻结状态，不做任何改变，\n除非有需要修复的严重问题。\nAlpha, beta 和候选发布版带有额外的后缀:\n带有某个小数字 N 的 alpha 版后缀是 \"aN\"。\n带有某个小数字 N 的 beta 版后缀是 \"bN\"。\n带有某个小数字 N 的候选发布版后缀是 \"rcN\"。\n换句话说，所有标记为 2.0aN 的版本都早于标记为 2.0bN 的版本，后者又都早于标记为 2.0rcN 的版\n本，而 后者 又都早于标记为 2.0 的版本。\n你还可能看到带有“+”后缀的版本号，例如“2.2+”。 这表示未发布版本，直接基于 CPython 开发代码\n仓库构建。 在实际操作中，当一个小版本最终发布后，未发布版本号会递增到下一个小版本号，成\n为“a0”版本，例如“2.4a0”。\n请参阅 Developer's Guide 获取更多有关开发流程的信息，并参阅 PEP 387 了解更多有关 Python 的\n向下兼容策略的信息。 另请参阅有关 sys.version, sys.hexversion 和 sys.version_info 的文\n档。\n\n|  | 在 1989 年的圣诞假期中，我手头的时间非常充裕，因此我决定开始尝试一下。 在接下来的一年\n里，虽然我仍然主要用我的业余时间来做这件事，但 Python 在 Amoeba 项目中的使用获得了很\n大的成功，来自同事的反馈让我得以增加了许多早期的改进。\n到 1991 年 2 月，经过一年多的开发，我决定将其发布到 USENET。 之后的事情就都可以在\nMisc/HISTORY 文件里面看了。\nPython 适合做什么？\nPython 是一种高层级的多用途编程语言，可用于解决许多不同门类的问题。\n本语言自带一个庞大标准库，所涵盖的编程领域包括字符串处理（正则表达式、Unicode、文件间的\n差异比较等），互联网协议（HTTP, FTP, SMTP, XML-RPC, POP, IMAP），软件工程（单元测试、日\n志记录、性能分析、Python 代码解析），以及操作系统接口（系统调用、文件系统、TCP/IP 套接\n字）。 请查看 Python 标准库 目录页以获取所有可用内容的概览。 此外还有大量第三方扩展包可供\n使用。 请访问 Python 软件包索引 来查找你感兴趣的软件包。\nPython 版本的编号形式是怎样的？\nPython 版本的编号形式为 \"A.B.C\" 或 \"A.B\":\nA 是主版本号 -- 它仅会针对语言中非常重大的改变而递增。\nB 是次版本号 -- 它会针对不太重大的改变而递增。\nC 是微版本号 -- 它针对每次问题修正发布而递增。\n并非所有发布版本都是问题修正版本。 在新特征发布版本的开发过程中，会制作一系列的开发版\n本，它们以 alpha, beta 或 release candidate 来标示。 其中 alpha 版本是早期发布版，它的接口尚\n未最终确定；在两个 alpha 发布版本间出现接口的改变并不意外。 而 beta 版本更为稳定，它会保留\n现有的接口，但也可能增加新的模块，而 release candidate 版则会保持冻结状态，不做任何改变，\n除非有需要修复的严重问题。\nAlpha, beta 和候选发布版带有额外的后缀:\n带有某个小数字 N 的 alpha 版后缀是 \"aN\"。\n带有某个小数字 N 的 beta 版后缀是 \"bN\"。\n带有某个小数字 N 的候选发布版后缀是 \"rcN\"。\n换句话说，所有标记为 2.0aN 的版本都早于标记为 2.0bN 的版本，后者又都早于标记为 2.0rcN 的版\n本，而 后者 又都早于标记为 2.0 的版本。\n你还可能看到带有“+”后缀的版本号，例如“2.2+”。 这表示未发布版本，直接基于 CPython 开发代码\n仓库构建。 在实际操作中，当一个小版本最终发布后，未发布版本号会递增到下一个小版本号，成\n为“a0”版本，例如“2.4a0”。\n请参阅 Developer's Guide 获取更多有关开发流程的信息，并参阅 PEP 387 了解更多有关 Python 的\n向下兼容策略的信息。 另请参阅有关 sys.version, sys.hexversion 和 sys.version_info 的文\n档。 |  |\n| --- | --- | --- |\n\n我应如何获取一份 Python 源代码的副本？\n最新的 Python 发布版源代码总能从 python.org 获取，下载页链接为\nhttps://www.python.org/downloads/。 最新的开发版源代码可以在\nhttps://github.com/python/cpython/ 获取。\n发布版源代码是一个以 gzip 压缩的 tar 文件，其中包含完整的 C 源代码、Sphinx 格式的文档、\nPython 库模块、示例程序以及一些有用的自由分发软件。 该源代码将可在大多数 UNIX 类平台上直\n接编译并运行。\n请参阅 Python 开发者指南的初步上手部分 了解有关获取源代码并进行编译的更多信息。\n我应如何获取 Python 的文档？\n当前的 Python 稳定版本的标准文档可在 https://docs.python.org/3/ 查看。 也可在\nhttps://docs.python.org/3/download.html 获取 EPUB、纯文本以及可下载的 HTML 版本。\n文档以 reStructuredText 格式撰写并使用 Sphinx 文档工具 生成。 文档的 reStructuredText 源文件是\nPython 源代码发布版的一部分。\n我之前从未接触过编程。 哪里有 Python 的教程？\n有许多可选择的教程和书籍。 标准文档中也包含有 Python 教程。\n请参阅 新手指南 以获取针对 Python 编程初学者的信息，包括教程的清单。\n是否有专门针对 Python 的新闻组或邮件列表？\n有一个新闻组 comp.lang.python 和一个邮件列表 python-list。 新闻组和邮件列表是彼此互通的 ——\n如果你可以阅读新闻就不必再订阅邮件列表。 comp.lang.python 的流量很大，每天会收到数以百计\n的发帖，Usenet 使用者通常更擅长处理这样大的流量。\n有关新软件发布和活动的公告可以在 comp.lang.python.announce 中找到，这是个严格管理的低流\n量列表，每天发帖五个左右。 可在 python-announce 邮件列表 订阅。\n有关其他邮件列表和新闻组的更多信息可以在 https://www.python.org/community/lists/ 找到。\n我应如何获取 Python 的公开测试版本？\n可以从 https://www.python.org/downloads/ 下载 alpha 和 beta 发布版。 所有发布版都会在\ncomp.lang.python 和 comp.lang.python.announce 新闻组以及 Python 主页\nhttps://www.python.org/ 上进行公告；并会推送到 RSS 新闻源。\n你还可以通过 Git 访问 Python 的开发版。 请参阅 Python 开发者指南 了解详情。\n我应如何为 Python 提交错误报告和补丁？\n要报告问题或提交补丁，请使用位于 https://github.com/python/cpython/issues 的问题追踪器。\n\n|  | 我应如何获取一份 Python 源代码的副本？\n最新的 Python 发布版源代码总能从 python.org 获取，下载页链接为\nhttps://www.python.org/downloads/。 最新的开发版源代码可以在\nhttps://github.com/python/cpython/ 获取。\n发布版源代码是一个以 gzip 压缩的 tar 文件，其中包含完整的 C 源代码、Sphinx 格式的文档、\nPython 库模块、示例程序以及一些有用的自由分发软件。 该源代码将可在大多数 UNIX 类平台上直\n接编译并运行。\n请参阅 Python 开发者指南的初步上手部分 了解有关获取源代码并进行编译的更多信息。\n我应如何获取 Python 的文档？\n当前的 Python 稳定版本的标准文档可在 https://docs.python.org/3/ 查看。 也可在\nhttps://docs.python.org/3/download.html 获取 EPUB、纯文本以及可下载的 HTML 版本。\n文档以 reStructuredText 格式撰写并使用 Sphinx 文档工具 生成。 文档的 reStructuredText 源文件是\nPython 源代码发布版的一部分。\n我之前从未接触过编程。 哪里有 Python 的教程？\n有许多可选择的教程和书籍。 标准文档中也包含有 Python 教程。\n请参阅 新手指南 以获取针对 Python 编程初学者的信息，包括教程的清单。\n是否有专门针对 Python 的新闻组或邮件列表？\n有一个新闻组 comp.lang.python 和一个邮件列表 python-list。 新闻组和邮件列表是彼此互通的 ——\n如果你可以阅读新闻就不必再订阅邮件列表。 comp.lang.python 的流量很大，每天会收到数以百计\n的发帖，Usenet 使用者通常更擅长处理这样大的流量。\n有关新软件发布和活动的公告可以在 comp.lang.python.announce 中找到，这是个严格管理的低流\n量列表，每天发帖五个左右。 可在 python-announce 邮件列表 订阅。\n有关其他邮件列表和新闻组的更多信息可以在 https://www.python.org/community/lists/ 找到。\n我应如何获取 Python 的公开测试版本？\n可以从 https://www.python.org/downloads/ 下载 alpha 和 beta 发布版。 所有发布版都会在\ncomp.lang.python 和 comp.lang.python.announce 新闻组以及 Python 主页\nhttps://www.python.org/ 上进行公告；并会推送到 RSS 新闻源。\n你还可以通过 Git 访问 Python 的开发版。 请参阅 Python 开发者指南 了解详情。\n我应如何为 Python 提交错误报告和补丁？\n要报告问题或提交补丁，请使用位于 https://github.com/python/cpython/issues 的问题追踪器。 |  |\n| --- | --- | --- |\n\n有关 Python 开发流程的更多信息，请参阅 Python 开发者指南。\n是否有任何公开发表的 Python 相关文章可以供我参考引用？\n可能作为参考文献的最好方式还是引用你喜欢的 Python 相关书籍。\n有关 Python 的 最早的文章 撰写于 1991 年因而现在已相当过时。\nGuido van Rossum 与 Jelke de Boer, \"使用 Python 编程语言交互式地测试远程服务器\", CWI 季刊,\n第 4 卷, 第 4 期 (1991 年 12 月), 阿姆斯特丹, 第 283--303 页。\n是否有任何 Python 相关的书籍？\n是的，相关的书籍很多，还有更多即将发行。 请访问 python.org 的 wiki 页面\nhttps://wiki.python.org/moin/PythonBooks 获取一份清单。\n你也可以到各大在线书店搜索 \"Python\" 并过滤掉对 Monty Python 的引用；或者也可以搜索\n\"Python\" 加 \"language\"。\nwww.python.org 具体位于世界上的哪个地点？\nPython 项目的基础设施分布于世界各地并由 Python 基础设施团队负责管理。 相关细节请访问 这\n里。\n为何命名为 Python？\n在着手编写 Python 实现的时候，Guido van Rossum 同时还阅读了刚出版的 \"Monty Python 的飞行\n马戏团\" 剧本，这是一部自 1970 年代开始播出的 BBC 系列喜剧。 Van Rossum 觉得他需要选择一个\n简短、独特而又略显神秘的名字，于是他决定将这个新语言命名为 Python。\n我必须喜欢 \"Monty Python 的飞行马戏团\" 吗？\n不必，但这对学习会有帮助。 :)\n现实世界中的 Python\nPython 有多稳定？\n非常稳定。 自 1991 年起大约每隔 6 至 18 个月就会推出新的稳定发布版，这种状态看来还会持续下\n去。 从 3.9 版开始，Python 将会每隔 12 个月推出一个新增特征版本 (PEP 602)。\n开发者也会推出较旧版本的问题修正发布版，因此现有发布版的稳定性还会逐步提升。 问题修正发\n布版会以版本号第三部分的数字来标示（例如 3.5.3, 3.6.2），用于稳定性管理；只有对已知问题的\n修正会包含在问题修正发布版中，而同一系列的问题修正发布版中的接口将会始终保持一致。\n最新的稳定发布版总是可以在 Python 下载页 中找到。 Python 3.x 是推荐的版本并被大多数广泛使\n用的库所支持。 Python 2.x 已不再维护。\n有多少人在使用 Python？\n\n|  | 有关 Python 开发流程的更多信息，请参阅 Python 开发者指南。\n是否有任何公开发表的 Python 相关文章可以供我参考引用？\n可能作为参考文献的最好方式还是引用你喜欢的 Python 相关书籍。\n有关 Python 的 最早的文章 撰写于 1991 年因而现在已相当过时。\nGuido van Rossum 与 Jelke de Boer, \"使用 Python 编程语言交互式地测试远程服务器\", CWI 季刊,\n第 4 卷, 第 4 期 (1991 年 12 月), 阿姆斯特丹, 第 283--303 页。\n是否有任何 Python 相关的书籍？\n是的，相关的书籍很多，还有更多即将发行。 请访问 python.org 的 wiki 页面\nhttps://wiki.python.org/moin/PythonBooks 获取一份清单。\n你也可以到各大在线书店搜索 \"Python\" 并过滤掉对 Monty Python 的引用；或者也可以搜索\n\"Python\" 加 \"language\"。\nwww.python.org 具体位于世界上的哪个地点？\nPython 项目的基础设施分布于世界各地并由 Python 基础设施团队负责管理。 相关细节请访问 这\n里。\n为何命名为 Python？\n在着手编写 Python 实现的时候，Guido van Rossum 同时还阅读了刚出版的 \"Monty Python 的飞行\n马戏团\" 剧本，这是一部自 1970 年代开始播出的 BBC 系列喜剧。 Van Rossum 觉得他需要选择一个\n简短、独特而又略显神秘的名字，于是他决定将这个新语言命名为 Python。\n我必须喜欢 \"Monty Python 的飞行马戏团\" 吗？\n不必，但这对学习会有帮助。 :)\n现实世界中的 Python\nPython 有多稳定？\n非常稳定。 自 1991 年起大约每隔 6 至 18 个月就会推出新的稳定发布版，这种状态看来还会持续下\n去。 从 3.9 版开始，Python 将会每隔 12 个月推出一个新增特征版本 (PEP 602)。\n开发者也会推出较旧版本的问题修正发布版，因此现有发布版的稳定性还会逐步提升。 问题修正发\n布版会以版本号第三部分的数字来标示（例如 3.5.3, 3.6.2），用于稳定性管理；只有对已知问题的\n修正会包含在问题修正发布版中，而同一系列的问题修正发布版中的接口将会始终保持一致。\n最新的稳定发布版总是可以在 Python 下载页 中找到。 Python 3.x 是推荐的版本并被大多数广泛使\n用的库所支持。 Python 2.x 已不再维护。\n有多少人在使用 Python？ |  |\n| --- | --- | --- |\n\n使用者应该数以百万计，但很难获得一个精确的数字。\nPython 可以免费下载，因此并不存在销量数据，此外它也可以从许多不同网站获取，并且包含于许\n多 Linux 发行版之中，因此下载量统计同样无法完全说明问题。\ncomp.lang.python 新闻组非常活跃，但不是所有 Python 用户都会在新闻组发帖，许多人甚至不会\n阅读新闻组。\n有哪些重要的项目是用 Python 开发的？\n请访问 https://www.python.org/about/success 查看使用了 Python 的项目列表。 阅览 历次 Python\n会议 的日程纪要可以看到许多不同公司和组织所做的贡献。\n高水准的 Python 项目包括 Mailman 邮件列表管理器 和 Zope 应用服务器。 多个 Linux 发行版，其\n中最著名的是 Red Hat，都使用 Python 来编写其部分或全部的安装器和系统管理软件。 在内部使用\nPython 的公司包括了 Google, Yahoo 和 Lucasfilm 等等。\n在未来可以期待 Python 将有什么新进展？\n请访问 https://peps.python.org/ 查看 Python 增强提议（PEP）。 PEP 是为 Python 加入某种新特性\n的提议进行描述的设计文档，其中会提供简明的技术规格说明与基本原理。 可查找标题为 \"Python\nX.Y Release Schedule\" 的 PEP，其中 X.Y 是某个尚未公开发布的版本。\n新版本的开发会在 python-dev 邮件列表 中进行讨论。\n提议对 Python 加入不兼容的更改是否合理？\n通常来说是不合理的。 世界上已存在的 Python 代码数以亿计，因此，任何对该语言的更改即便仅\n会使得现有程序中极少的一部分失效也是难以令人接受的。 就算你可以提供一个转换程序，也仍然\n存在需要更新全部文档的问题；另外还有大量已出版的 Python 书籍，我们不希望让它们在一瞬间全\n部变成废纸。\n如果必须更改某个特性，则应该提供渐进式的升级路径。 PEP 5 描述了引入向后不兼容的更改所需\n遵循的流程，以尽可能减少对用户的干扰。\nPython 是一种对编程初学者友好的语言吗？\n是的。\n从过程式、静态类型的编程语言例如 Pascal, C 或者 C++ 以及 Java 的某一子集开始引导学生入门仍\n然是常见的做法。 但以 Python 作为第一种编程语言进行学习对学生可能更有利。Python 具有非常\n简单和一致的语法和庞大的标准库，而且最重要的是，在编程入门教学中使用 Python 可以让学生专\n注于更重要的编程技能，例如问题分解与数据类型设计。 使用 Python，可以快速向学生介绍基本概\n念例如循环与过程等。 他们甚至有可能在第一次课里就开始接触用户自定义对象。\n对于之前从未接触过编程的学生来说，使用静态类型语言会感觉不够自然。 这会给学生带来必须掌\n握的额外复杂性，并减慢教学的进度。 学生需要尝试像计算机一样思考，分解问题，设计一致的接\n\n|  | 使用者应该数以百万计，但很难获得一个精确的数字。\nPython 可以免费下载，因此并不存在销量数据，此外它也可以从许多不同网站获取，并且包含于许\n多 Linux 发行版之中，因此下载量统计同样无法完全说明问题。\ncomp.lang.python 新闻组非常活跃，但不是所有 Python 用户都会在新闻组发帖，许多人甚至不会\n阅读新闻组。\n有哪些重要的项目是用 Python 开发的？\n请访问 https://www.python.org/about/success 查看使用了 Python 的项目列表。 阅览 历次 Python\n会议 的日程纪要可以看到许多不同公司和组织所做的贡献。\n高水准的 Python 项目包括 Mailman 邮件列表管理器 和 Zope 应用服务器。 多个 Linux 发行版，其\n中最著名的是 Red Hat，都使用 Python 来编写其部分或全部的安装器和系统管理软件。 在内部使用\nPython 的公司包括了 Google, Yahoo 和 Lucasfilm 等等。\n在未来可以期待 Python 将有什么新进展？\n请访问 https://peps.python.org/ 查看 Python 增强提议（PEP）。 PEP 是为 Python 加入某种新特性\n的提议进行描述的设计文档，其中会提供简明的技术规格说明与基本原理。 可查找标题为 \"Python\nX.Y Release Schedule\" 的 PEP，其中 X.Y 是某个尚未公开发布的版本。\n新版本的开发会在 python-dev 邮件列表 中进行讨论。\n提议对 Python 加入不兼容的更改是否合理？\n通常来说是不合理的。 世界上已存在的 Python 代码数以亿计，因此，任何对该语言的更改即便仅\n会使得现有程序中极少的一部分失效也是难以令人接受的。 就算你可以提供一个转换程序，也仍然\n存在需要更新全部文档的问题；另外还有大量已出版的 Python 书籍，我们不希望让它们在一瞬间全\n部变成废纸。\n如果必须更改某个特性，则应该提供渐进式的升级路径。 PEP 5 描述了引入向后不兼容的更改所需\n遵循的流程，以尽可能减少对用户的干扰。\nPython 是一种对编程初学者友好的语言吗？\n是的。\n从过程式、静态类型的编程语言例如 Pascal, C 或者 C++ 以及 Java 的某一子集开始引导学生入门仍\n然是常见的做法。 但以 Python 作为第一种编程语言进行学习对学生可能更有利。Python 具有非常\n简单和一致的语法和庞大的标准库，而且最重要的是，在编程入门教学中使用 Python 可以让学生专\n注于更重要的编程技能，例如问题分解与数据类型设计。 使用 Python，可以快速向学生介绍基本概\n念例如循环与过程等。 他们甚至有可能在第一次课里就开始接触用户自定义对象。\n对于之前从未接触过编程的学生来说，使用静态类型语言会感觉不够自然。 这会给学生带来必须掌\n握的额外复杂性，并减慢教学的进度。 学生需要尝试像计算机一样思考，分解问题，设计一致的接 |  |\n| --- | --- | --- |\n\n口并封装数据。 虽然从长远来看，学习和使用一种静态类型语言是很重要的，但这并不是最适宜在\n学生的第一次编程课上就进行探讨的主题。\n还有许多其他方面的特点使得 Python 成为很好的入门语言。 像 Java 一样，Python 拥有一个庞大的\n标准库，因此可以在课程非常早期的阶段就给学生布置一些 实用 的编程项目。 编程作业不必仅限于\n标准四则运算和账目检查程序。 通过使用标准库，学生可以在学习编程基础知识的同时开发真正的\n应用，从而获得更大的满足感。 使用标准库还能使学生了解代码重用的概念。 而像 PyGame 这样的\n第三方模块同样有助于扩大学生的接触领域。\nPython 的解释器使学生能够在编程时测试语言特性。 他们可以在一个窗口中输入程序源代码的同时\n开启一个解释器运行窗口。 如果他们不记得列表有哪些方法，他们这以这样做:\n>>> L = []\n>>> dir(L)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',\n'__dir__', '__doc__', '__eq__', '__format__', '__ge__',\n'__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',\n'__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',\n'__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',\n'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n'reverse', 'sort']\n>>> [d for d in dir(L) if '__' not in d]\n['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n>>> help(L.append)\nHelp on built-in function append:\nappend(...)\nL.append(object) -> None -- append object to end\n>>> L.append(1)\n>>> L\n[1]\n通过使用解释器，学生编写程序时参考文档总是能伴随在他们身边。\nPython 还拥有一些很好的 IDE。 IDLE 是一个以 Python 基于 Tkinter 编写的跨平台 Python IDE。\nEmacs 用户将高兴地了解到 Emacs 具有非常好的 Python 模式。 所有这些编程环境都提供语法高\n亮、自动缩进以及在编写代码时使用交互式解释器等功能。 请访问 Python wiki 查看 Python 编程环\n境的完整列表。\n如果你想要讨论 Python 在教育中的使用，你可能会有兴趣加入 edu-sig 邮件列表。\n\n| 口并封装数据。 虽然从长远来看，学习和使用一种静态类型语言是很重要的，但这并不是最适宜在\n学生的第一次编程课上就进行探讨的主题。\n还有许多其他方面的特点使得 Python 成为很好的入门语言。 像 Java 一样，Python 拥有一个庞大的\n标准库，因此可以在课程非常早期的阶段就给学生布置一些 实用 的编程项目。 编程作业不必仅限于\n标准四则运算和账目检查程序。 通过使用标准库，学生可以在学习编程基础知识的同时开发真正的\n应用，从而获得更大的满足感。 使用标准库还能使学生了解代码重用的概念。 而像 PyGame 这样的\n第三方模块同样有助于扩大学生的接触领域。\nPython 的解释器使学生能够在编程时测试语言特性。 他们可以在一个窗口中输入程序源代码的同时\n开启一个解释器运行窗口。 如果他们不记得列表有哪些方法，他们这以这样做:\n>>> L = []\n>>> dir(L)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',\n'__dir__', '__doc__', '__eq__', '__format__', '__ge__',\n'__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',\n'__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',\n'__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',\n'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n'reverse', 'sort']\n>>> [d for d in dir(L) if '__' not in d]\n['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n>>> help(L.append)\nHelp on built-in function append:\nappend(...)\nL.append(object) -> None -- append object to end\n>>> L.append(1)\n>>> L\n[1]\n通过使用解释器，学生编写程序时参考文档总是能伴随在他们身边。\nPython 还拥有一些很好的 IDE。 IDLE 是一个以 Python 基于 Tkinter 编写的跨平台 Python IDE。\nEmacs 用户将高兴地了解到 Emacs 具有非常好的 Python 模式。 所有这些编程环境都提供语法高\n亮、自动缩进以及在编写代码时使用交互式解释器等功能。 请访问 Python wiki 查看 Python 编程环\n境的完整列表。\n如果你想要讨论 Python 在教育中的使用，你可能会有兴趣加入 edu-sig 邮件列表。 | 口并封装数据。 虽然从长远来看，学习和使用一种静态类型语言是很重要的，但这并不是最适宜在\n学生的第一次编程课上就进行探讨的主题。\n还有许多其他方面的特点使得 Python 成为很好的入门语言。 像 Java 一样，Python 拥有一个庞大的\n标准库，因此可以在课程非常早期的阶段就给学生布置一些 实用 的编程项目。 编程作业不必仅限于\n标准四则运算和账目检查程序。 通过使用标准库，学生可以在学习编程基础知识的同时开发真正的\n应用，从而获得更大的满足感。 使用标准库还能使学生了解代码重用的概念。 而像 PyGame 这样的\n第三方模块同样有助于扩大学生的接触领域。\nPython 的解释器使学生能够在编程时测试语言特性。 他们可以在一个窗口中输入程序源代码的同时\n开启一个解释器运行窗口。 如果他们不记得列表有哪些方法，他们这以这样做: |  |  |\n| --- | --- | --- | --- |\n|  | >>> L = []\n>>> dir(L)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',\n'__dir__', '__doc__', '__eq__', '__format__', '__ge__',\n'__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',\n'__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',\n'__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',\n'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n'reverse', 'sort']\n>>> [d for d in dir(L) if '__' not in d]\n['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n>>> help(L.append)\nHelp on built-in function append:\nappend(...)\nL.append(object) -> None -- append object to end\n>>> L.append(1)\n>>> L\n[1] |  |  |\n|  | 通过使用解释器，学生编写程序时参考文档总是能伴随在他们身边。\nPython 还拥有一些很好的 IDE。 IDLE 是一个以 Python 基于 Tkinter 编写的跨平台 Python IDE。\nEmacs 用户将高兴地了解到 Emacs 具有非常好的 Python 模式。 所有这些编程环境都提供语法高\n亮、自动缩进以及在编写代码时使用交互式解释器等功能。 请访问 Python wiki 查看 Python 编程环\n境的完整列表。\n如果你想要讨论 Python 在教育中的使用，你可能会有兴趣加入 edu-sig 邮件列表。 |  |  |", "metadata": {"title": "00_Python常见问题", "source": "md_docs\\python_faq_md\\00_Python常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "fb0e6092"}}
{"doc_id": "3196f661", "content": "“为什么我的电脑上安装了 Python ？”\n什么是 Python？\nPython 是一种程序语言，被许多应用程序使用。它不仅因易学而在许多高校用于编程入门，还被工\n作于 Google、NASA 和卢卡斯影业等公司的软件开发人员使用。\n如果你想学习更多 Python，看看 Beginner's Guide to Python.\n为什么我的电脑上安装了 Python ？\n如果你不记得你曾主动安装过 Python，但它却出现在了你的电脑上，这里有一些可能的原因。\n可能是这台电脑的其他用户因想学习编程而安装了它，你得琢磨一下谁用过这台电脑并安装了\nPython。\n电脑上安装的第三方应用程序可能由 Python 写成并附带了一份 Python。这样的应用程序有很\n多，例如GUI程序、网络服务器、管理脚本等。\n一些 Windows 可能预装了 Python。在撰写本文时，我们了解到 Hewlett-Packard 和 Compaq 的\n计算机包含Python。显然，HP/Compaq 的一些管理工具是用 Python 编写的。\n许多与Unix兼容的操作系统，如macOS和一些Linux发行版，都默认安装了Python；它包含在基本\n安装中。\n我能删除 Python 吗？\n这取决于所安装 Python 的来源\n如果有人主动安装了 Python，你可以在不影响其它程序的情况下安全移除它。在 Windows 中，可\n使用“控制面板”中的“添加/删除程序”卸载。\n如果 Python 来源于第三方应用程序，你也能删除它，但那些程序将不能正常工作。你应该使用那些\n应用程序的卸载器而不是直接删除 Python。\n如果 Python 来自于你的操作系统，不推荐删除！如果删除了它，任何用 Python 写成的工具将无法\n工作，其中某些工具对于你来说可能十分重要。你甚至可能需要重装整个系统来修复因删除 Python\n留下的烂摊子。", "metadata": {"title": "00_“为什么我的电脑上安装了_Python_？”", "source": "md_docs\\python_faq_md\\00_“为什么我的电脑上安装了_Python_？”.md", "doc_type": "常见问题", "language": "中文", "doc_id": "3196f661"}}
{"doc_id": "af85a575", "content": "代码库和插件 FAQ\n目录\n代码库和插件 FAQ\n通用的代码库问题\n如何找到可以用来做 X 任务的模块或应用？\nmath.py（socket.py，regex.py 等）的源文件在哪？\n在 Unix 中怎样让 Python 脚本可执行？\nPython 中有 curses/termcap 包吗？\nPython 中存在类似 C 的 onexit() 函数的东西吗？\n为什么我的信号处理函数不能工作？\n通用任务\n怎样测试 Python 程序或组件？\n怎样用 docstring 创建文档？\n怎样一次只获取一个按键？\n线程相关\n程序中怎样使用线程？\n我的线程都没有运行，为什么？\n如何将任务分配给多个工作线程？\n怎样修改全局变量是线程安全的？\n不能删除全局解释器锁吗？\n输入与输出\n怎样删除文件？（以及其他文件相关的问题……）\n怎样复制文件？\n怎样读取（或写入）二进制数据？\n似乎 os.popen() 创建的管道不能使用 os.read()，这是为什么？\n怎样访问（RS232）串口？\n为什么关闭 sys.stdout（stdin，stderr）并不会真正关掉它？\n网络 / Internet 编程\nPython 中的 WWW 工具是什么？\n生成 HTML 需要使用什么模块？\n怎样使用 Python 脚本发送邮件？\nsocket 的 connect() 方法怎样避免阻塞？\n数据库\nPython 中有数据库包的接口吗？\n在 Python 中如何实现持久化对象？\n数学和数字\nPython 中怎样生成随机数？\n\n| 代码库和插件 FAQ |\n| --- |\n| 目录\n代码库和插件 FAQ\n通用的代码库问题\n如何找到可以用来做 X 任务的模块或应用？\nmath.py（socket.py，regex.py 等）的源文件在哪？\n在 Unix 中怎样让 Python 脚本可执行？\nPython 中有 curses/termcap 包吗？\nPython 中存在类似 C 的 onexit() 函数的东西吗？\n为什么我的信号处理函数不能工作？\n通用任务\n怎样测试 Python 程序或组件？\n怎样用 docstring 创建文档？\n怎样一次只获取一个按键？\n线程相关\n程序中怎样使用线程？\n我的线程都没有运行，为什么？\n如何将任务分配给多个工作线程？\n怎样修改全局变量是线程安全的？\n不能删除全局解释器锁吗？\n输入与输出\n怎样删除文件？（以及其他文件相关的问题……）\n怎样复制文件？\n怎样读取（或写入）二进制数据？\n似乎 os.popen() 创建的管道不能使用 os.read()，这是为什么？\n怎样访问（RS232）串口？\n为什么关闭 sys.stdout（stdin，stderr）并不会真正关掉它？\n网络 / Internet 编程\nPython 中的 WWW 工具是什么？\n生成 HTML 需要使用什么模块？\n怎样使用 Python 脚本发送邮件？\nsocket 的 connect() 方法怎样避免阻塞？\n数据库\nPython 中有数据库包的接口吗？\n在 Python 中如何实现持久化对象？\n数学和数字\nPython 中怎样生成随机数？ |\n|  |\n\n通用的代码库问题\n如何找到可以用来做 X 任务的模块或应用？\n在 标准库参考 中查找是否有适合的标准库模块。（如果你已经了解标准库的内容，可以跳过这一\n步）\n对于第三方软件包，请搜索 Python Package Index 或者是尝试 Google 或其他网络搜索引擎。 搜索\n\"Python\" 加上一两个你感兴趣的关键词通常就会找到一些有用的信息。\nmath.py（socket.py，regex.py 等）的源文件在哪？\n如果找不到模块的源文件，可能它是一个内建的模块，或是使用 C，C++ 或其他编译型语言实现的\n动态加载模块。这种情况下可能是没有源码文件的，类似 mathmodule.c 这样的文件会存放在 C 代\n码目录中（但不在 Python 目录中）。\nPython 中（至少）有三类模块：\n1. 使用 Python 编写的模块（.py)；\n2. 使用 C 编写的动态加载模块（.dll，.pyd，.so，.sl 等）；\n3. 使用 C 编写并链接到解释器的模块，要获取此列表，输入：\nimport sys\nprint(sys.builtin_module_names)\n在 Unix 中怎样让 Python 脚本可执行？\n你需要做两件事：文件必须是可执行的，并且第一行需要以 #! 开头，后面跟上 Python 解释器的路\n径。\n第一点可以用执行 chmod +x scriptfile 或是 chmod 755 scriptfile 做到。\n第二点有很多种做法，最直接的方式是：\n#!/usr/local/bin/python\n在文件第一行，使用你所在平台上的 Python 解释器的路径。\n如果你希望脚本不依赖 Python 解释器的具体路径，你也可以使用 env 程序。假设你的 Python 解释\n器所在目录已经添加到了 PATH 环境变量中，几乎所有的类 Unix 系统都支持下面的写法：\n#!/usr/bin/env python\n不要 在 CGI 脚本中这样做。CGI 脚本的 PATH 环境变量通常会非常精简，所以你必须使用解释器的\n完整绝对路径。\n\n|  | 通用的代码库问题\n如何找到可以用来做 X 任务的模块或应用？\n在 标准库参考 中查找是否有适合的标准库模块。（如果你已经了解标准库的内容，可以跳过这一\n步）\n对于第三方软件包，请搜索 Python Package Index 或者是尝试 Google 或其他网络搜索引擎。 搜索\n\"Python\" 加上一两个你感兴趣的关键词通常就会找到一些有用的信息。\nmath.py（socket.py，regex.py 等）的源文件在哪？\n如果找不到模块的源文件，可能它是一个内建的模块，或是使用 C，C++ 或其他编译型语言实现的\n动态加载模块。这种情况下可能是没有源码文件的，类似 mathmodule.c 这样的文件会存放在 C 代\n码目录中（但不在 Python 目录中）。\nPython 中（至少）有三类模块：\n1. 使用 Python 编写的模块（.py)；\n2. 使用 C 编写的动态加载模块（.dll，.pyd，.so，.sl 等）；\n3. 使用 C 编写并链接到解释器的模块，要获取此列表，输入：\nimport sys\nprint(sys.builtin_module_names)\n在 Unix 中怎样让 Python 脚本可执行？\n你需要做两件事：文件必须是可执行的，并且第一行需要以 #! 开头，后面跟上 Python 解释器的路\n径。\n第一点可以用执行 chmod +x scriptfile 或是 chmod 755 scriptfile 做到。\n第二点有很多种做法，最直接的方式是： |  |\n| --- | --- | --- |\n|  | #!/usr/local/bin/python |  |\n|  | 在文件第一行，使用你所在平台上的 Python 解释器的路径。\n如果你希望脚本不依赖 Python 解释器的具体路径，你也可以使用 env 程序。假设你的 Python 解释\n器所在目录已经添加到了 PATH 环境变量中，几乎所有的类 Unix 系统都支持下面的写法： |  |\n|  | #!/usr/bin/env python |  |\n|  | 不要 在 CGI 脚本中这样做。CGI 脚本的 PATH 环境变量通常会非常精简，所以你必须使用解释器的\n完整绝对路径。 |  |\n\n有时候，用户的环境变量如果太长，可能会导致 /usr/bin/env 执行失败；又或者甚至根本就不存在\nenv 程序。在这种情况下，你可以尝试使用下面的 hack 方法（来自 Alex Rezinsky）：\n#! /bin/sh\n\"\"\":\"\nexec python $0 ${1+\"$@\"}\n\"\"\"\n这样做有一个小小的缺点，它会定义脚本的 __doc__ 字符串。不过可以这样修复：\n__doc__ = \"\"\"...Whatever...\"\"\"\nPython 中有 curses/termcap 包吗？\n对于类 Unix 系统：标准 Python 源码发行版会在 Modules 子目录中附带 curses 模块，但默认并不会\n编译。（注意：在 Windows 平台下不可用 —— Windows 中没有 curses 模块。）\ncurses 模块支持基本的 curses 特性，同时也支持 ncurses 和 SYSV curses 中的很多额外功能，比如\n颜色、不同的字符集支持、填充和鼠标支持。这意味着这个模块不兼容只有 BSD curses 模块的操作\n系统，但是目前仍在维护的系统应该都不会存在这种情况。\nPython 中存在类似 C 的 onexit() 函数的东西吗？\natexit 模块提供了一个与 C 的 onexit() 类似的注册函数。\n为什么我的信号处理函数不能工作？\n最常见的问题是信号处理函数没有正确定义参数列表。它会被这样调用：\nhandler(signum, frame)\n因此它应当声明为带有两个形参:\ndef handler(signum, frame):\n...\n通用任务\n怎样测试 Python 程序或组件？\nPython 带有两个测试框架。doctest 模块从模块的 docstring 中寻找示例并执行，对比输出是否与\ndocstring 中给出的是否一致。\nunittest 模块是一个模仿 Java 和 Smalltalk 测试框架的更棒的测试框架。\n为了使测试更容易，你应该在程序中使用良好的模块化设计。程序中的绝大多数功能都应该用函数\n或类方法封装 —— 有时这样做会有额外惊喜，程序会运行得更快（因为局部变量比全局变量访问要\n快）。除此之外，程序应该避免依赖可变的局部变量，这会使得测试困难许多。\n程序的“全局主逻辑”应该尽量简单：\n\n|  | 有时候，用户的环境变量如果太长，可能会导致 /usr/bin/env 执行失败；又或者甚至根本就不存在\nenv 程序。在这种情况下，你可以尝试使用下面的 hack 方法（来自 Alex Rezinsky）： |  |\n| --- | --- | --- |\n|  | #! /bin/sh\n\"\"\":\"\nexec python $0 ${1+\"$@\"}\n\"\"\" |  |\n|  | 这样做有一个小小的缺点，它会定义脚本的 __doc__ 字符串。不过可以这样修复： |  |\n|  | __doc__ = \"\"\"...Whatever...\"\"\" |  |\n|  | Python 中有 curses/termcap 包吗？\n对于类 Unix 系统：标准 Python 源码发行版会在 Modules 子目录中附带 curses 模块，但默认并不会\n编译。（注意：在 Windows 平台下不可用 —— Windows 中没有 curses 模块。）\ncurses 模块支持基本的 curses 特性，同时也支持 ncurses 和 SYSV curses 中的很多额外功能，比如\n颜色、不同的字符集支持、填充和鼠标支持。这意味着这个模块不兼容只有 BSD curses 模块的操作\n系统，但是目前仍在维护的系统应该都不会存在这种情况。\nPython 中存在类似 C 的 onexit() 函数的东西吗？\natexit 模块提供了一个与 C 的 onexit() 类似的注册函数。\n为什么我的信号处理函数不能工作？\n最常见的问题是信号处理函数没有正确定义参数列表。它会被这样调用： |  |\n|  | handler(signum, frame) |  |\n|  | 因此它应当声明为带有两个形参: |  |\n|  | def handler(signum, frame):\n... |  |\n|  | 通用任务\n怎样测试 Python 程序或组件？\nPython 带有两个测试框架。doctest 模块从模块的 docstring 中寻找示例并执行，对比输出是否与\ndocstring 中给出的是否一致。\nunittest 模块是一个模仿 Java 和 Smalltalk 测试框架的更棒的测试框架。\n为了使测试更容易，你应该在程序中使用良好的模块化设计。程序中的绝大多数功能都应该用函数\n或类方法封装 —— 有时这样做会有额外惊喜，程序会运行得更快（因为局部变量比全局变量访问要\n快）。除此之外，程序应该避免依赖可变的局部变量，这会使得测试困难许多。\n程序的“全局主逻辑”应该尽量简单： |  |\n\nif __name__ == \"__main__\":\nmain_logic()\n并放置在程序主模块的最后面。\n一旦你的程序已经组织为一个函数和类行为的有完整集合，你就应该编写测试函数来检测这些行\n为。 可以将自动执行一系列测试的测试集关联到每个模块。 这听起来似乎需要大量的工作，但是由\n于 Python 是如此简洁灵活因此它会极其容易。 你可以通过与“生产代码”同步编写测试函数使编程更\n为愉快和有趣，因为这将更容易并更早发现代码问题甚至设计缺陷。\n程序主模块之外的其他“辅助模块”中可以增加自测试的入口。\nif __name__ == \"__main__\":\nself_test()\n通过使用 Python 实现的“假”接口，即使是需要与复杂的外部接口交互的程序也可以在外部接口不可\n用时进行测试。\n怎样用 docstring 创建文档？\npydoc 模块可以用你的 Python 源代码中的文档字符串来创建 HTML。 纯粹通过文档字符串来创建\nAPI 文档的一种替代方案是 epydoc。 Sphinx 也可以包括文档字符串的内容。\n怎样一次只获取一个按键？\n在类 Unix 系统中有多种方案。最直接的方法是使用 curses，但是 curses 模块太大了，难以学习。\n线程相关\n程序中怎样使用线程？\n一定要使用 threading 模块，不要使用 _thread 模块。threading 模块对 _thread 模块提供的底\n层线程原语做了更易用的抽象。\n我的线程都没有运行，为什么？\n一旦主线程退出，所有的子线程都会被杀掉。你的主线程运行得太快了，子线程还没来得及工作。\n简单的解决方法是在程序中加一个时间足够长的 sleep，让子线程能够完成运行。\nimport threading, time\ndef thread_task(name, n):\nfor i in range(n):\nprint(name, i)\nfor i in range(10):\nT = threading.Thread(target=thread_task, args=(str(i), i))\nT.start()\ntime.sleep(10) # <---------------------------!\n\n|  | if __name__ == \"__main__\":\nmain_logic() |  |\n| --- | --- | --- |\n|  | 并放置在程序主模块的最后面。\n一旦你的程序已经组织为一个函数和类行为的有完整集合，你就应该编写测试函数来检测这些行\n为。 可以将自动执行一系列测试的测试集关联到每个模块。 这听起来似乎需要大量的工作，但是由\n于 Python 是如此简洁灵活因此它会极其容易。 你可以通过与“生产代码”同步编写测试函数使编程更\n为愉快和有趣，因为这将更容易并更早发现代码问题甚至设计缺陷。\n程序主模块之外的其他“辅助模块”中可以增加自测试的入口。 |  |\n|  | if __name__ == \"__main__\":\nself_test() |  |\n|  | 通过使用 Python 实现的“假”接口，即使是需要与复杂的外部接口交互的程序也可以在外部接口不可\n用时进行测试。\n怎样用 docstring 创建文档？\npydoc 模块可以用你的 Python 源代码中的文档字符串来创建 HTML。 纯粹通过文档字符串来创建\nAPI 文档的一种替代方案是 epydoc。 Sphinx 也可以包括文档字符串的内容。\n怎样一次只获取一个按键？\n在类 Unix 系统中有多种方案。最直接的方法是使用 curses，但是 curses 模块太大了，难以学习。\n线程相关\n程序中怎样使用线程？\n一定要使用 threading 模块，不要使用 _thread 模块。threading 模块对 _thread 模块提供的底\n层线程原语做了更易用的抽象。\n我的线程都没有运行，为什么？\n一旦主线程退出，所有的子线程都会被杀掉。你的主线程运行得太快了，子线程还没来得及工作。\n简单的解决方法是在程序中加一个时间足够长的 sleep，让子线程能够完成运行。 |  |\n|  | import threading, time\ndef thread_task(name, n):\nfor i in range(n):\nprint(name, i)\nfor i in range(10):\nT = threading.Thread(target=thread_task, args=(str(i), i))\nT.start()\ntime.sleep(10) # <---------------------------! |  |\n|  |  |  |\n\n但目前（在许多平台上）线程不是并行运行的，而是按顺序依次执行！原因是系统线程调度器在前\n一个线程阻塞之前不会启动新线程。\n简单的解决方法是在运行函数的开始处加一个时间很短的 sleep。\ndef thread_task(name, n):\ntime.sleep(0.001) # <--------------------!\nfor i in range(n):\nprint(name, i)\nfor i in range(10):\nT = threading.Thread(target=thread_task, args=(str(i), i))\nT.start()\ntime.sleep(10)\n比起用 time.sleep() 猜一个合适的等待时间，使用信号量机制会更好些。有一个办法是使用\nqueue 模块创建一个 queue 对象，让每一个线程在运行结束时 append 一个令牌到 queue 对象中，\n主线程中从 queue 对象中读取与线程数量一致的令牌数量即可。\n如何将任务分配给多个工作线程？\n最简单的方式是使用 concurrent.futures 模块，特别是其中的 ThreadPoolExecutor 类。\n或者，如果你想更好地控制分发算法，你也可以自己写逻辑实现。使用 queue 模块来创建任务列表\n队列。Queue 类维护一个了一个存有对象的列表，提供了 .put(obj) 方法添加元素，并且可以用\n.get() 方法获取元素。这个类会使用必要的加锁操作，以此确保每个任务只会执行一次。\n这是一个简单的例子：\nimport threading, queue, time\n# 工作线程会将任务移出队列。 当队列为空时，\n# 它将认为工作已完成并退出。\n# （在真实场景下工作线程将持续运行直到被终结。）\ndef worker():\nprint('Running worker')\ntime.sleep(0.1)\nwhile True:\ntry:\narg = q.get(block=False)\nexcept queue.Empty:\nprint('Worker', threading.current_thread(), end=' ')\nprint('queue empty')\nbreak\nelse:\nprint('Worker', threading.current_thread(), end=' ')\nprint('running with argument', arg)\ntime.sleep(0.5)\n# 创建队列\nq = queue.Queue()\n# 启动包含 5 个工作线程的线程池\nfor i in range(5):\n\n|  | 但目前（在许多平台上）线程不是并行运行的，而是按顺序依次执行！原因是系统线程调度器在前\n一个线程阻塞之前不会启动新线程。\n简单的解决方法是在运行函数的开始处加一个时间很短的 sleep。 |  |\n| --- | --- | --- |\n|  | def thread_task(name, n):\ntime.sleep(0.001) # <--------------------!\nfor i in range(n):\nprint(name, i)\nfor i in range(10):\nT = threading.Thread(target=thread_task, args=(str(i), i))\nT.start()\ntime.sleep(10) |  |\n|  | 比起用 time.sleep() 猜一个合适的等待时间，使用信号量机制会更好些。有一个办法是使用\nqueue 模块创建一个 queue 对象，让每一个线程在运行结束时 append 一个令牌到 queue 对象中，\n主线程中从 queue 对象中读取与线程数量一致的令牌数量即可。\n如何将任务分配给多个工作线程？\n最简单的方式是使用 concurrent.futures 模块，特别是其中的 ThreadPoolExecutor 类。\n或者，如果你想更好地控制分发算法，你也可以自己写逻辑实现。使用 queue 模块来创建任务列表\n队列。Queue 类维护一个了一个存有对象的列表，提供了 .put(obj) 方法添加元素，并且可以用\n.get() 方法获取元素。这个类会使用必要的加锁操作，以此确保每个任务只会执行一次。\n这是一个简单的例子： |  |\n|  | import threading, queue, time\n# 工作线程会将任务移出队列。 当队列为空时，\n# 它将认为工作已完成并退出。\n# （在真实场景下工作线程将持续运行直到被终结。）\ndef worker():\nprint('Running worker')\ntime.sleep(0.1)\nwhile True:\ntry:\narg = q.get(block=False)\nexcept queue.Empty:\nprint('Worker', threading.current_thread(), end=' ')\nprint('queue empty')\nbreak\nelse:\nprint('Worker', threading.current_thread(), end=' ')\nprint('running with argument', arg)\ntime.sleep(0.5)\n# 创建队列\nq = queue.Queue()\n# 启动包含 5 个工作线程的线程池\nfor i in range(5): |  |\n\nt = threading.Thread(target=worker, name='worker %i' % (i+1))\nt.start()\n# 开始向队列添加任务\nfor i in range(50):\nq.put(i)\n# 为线程留出运行的时间\nprint('Main thread sleeping')\ntime.sleep(5)\n运行时会产生如下输出：\nRunning worker\nRunning worker\nRunning worker\nRunning worker\nRunning worker\nMain thread sleeping\nWorker <Thread(worker 1, started 130283832797456)> running with argument 0\nWorker <Thread(worker 2, started 130283824404752)> running with argument 1\nWorker <Thread(worker 3, started 130283816012048)> running with argument 2\nWorker <Thread(worker 4, started 130283807619344)> running with argument 3\nWorker <Thread(worker 5, started 130283799226640)> running with argument 4\nWorker <Thread(worker 1, started 130283832797456)> running with argument 5\n...\n查看模块的文档以获取更多信息；Queue 类提供了多种接口。\n怎样修改全局变量是线程安全的？\nPython VM 内部会使用 global interpreter lock （GIL）来确保同一时间只有一个线程运行。通常\nPython 只会在字节码指令之间切换线程；切换的频率可以通过设置 sys.setswitchinterval() 指\n定。从 Python 程序的角度来看，每一条字节码指令以及每一条指令对应的 C 代码实现都是原子的。\n理论上说，具体的结果要看具体的 PVM 字节码实现对指令的解释。而实际上，对内建类型（int，\nlist，dict 等）的共享变量的“类原子”操作都是原子的。\n举例来说，下面的操作是原子的（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i，j 是 int\n变量）：\nL.append(x)\nL1.extend(L2)\nx = L[i]\nx = L.pop()\nL1[i:j] = L2\nL.sort()\nx = y\nx.field = y\nD[x] = y\nD1.update(D2)\nD.keys()\n这些不是原子的：\n\n|  | t = threading.Thread(target=worker, name='worker %i' % (i+1))\nt.start()\n# 开始向队列添加任务\nfor i in range(50):\nq.put(i)\n# 为线程留出运行的时间\nprint('Main thread sleeping')\ntime.sleep(5) |  |\n| --- | --- | --- |\n|  | 运行时会产生如下输出： |  |\n|  | Running worker\nRunning worker\nRunning worker\nRunning worker\nRunning worker\nMain thread sleeping\nWorker <Thread(worker 1, started 130283832797456)> running with argument 0\nWorker <Thread(worker 2, started 130283824404752)> running with argument 1\nWorker <Thread(worker 3, started 130283816012048)> running with argument 2\nWorker <Thread(worker 4, started 130283807619344)> running with argument 3\nWorker <Thread(worker 5, started 130283799226640)> running with argument 4\nWorker <Thread(worker 1, started 130283832797456)> running with argument 5\n... |  |\n|  | 查看模块的文档以获取更多信息；Queue 类提供了多种接口。\n怎样修改全局变量是线程安全的？\nPython VM 内部会使用 global interpreter lock （GIL）来确保同一时间只有一个线程运行。通常\nPython 只会在字节码指令之间切换线程；切换的频率可以通过设置 sys.setswitchinterval() 指\n定。从 Python 程序的角度来看，每一条字节码指令以及每一条指令对应的 C 代码实现都是原子的。\n理论上说，具体的结果要看具体的 PVM 字节码实现对指令的解释。而实际上，对内建类型（int，\nlist，dict 等）的共享变量的“类原子”操作都是原子的。\n举例来说，下面的操作是原子的（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i，j 是 int\n变量）： |  |\n|  | L.append(x)\nL1.extend(L2)\nx = L[i]\nx = L.pop()\nL1[i:j] = L2\nL.sort()\nx = y\nx.field = y\nD[x] = y\nD1.update(D2)\nD.keys() |  |\n|  | 这些不是原子的： |  |\n\ni = i+1\nL.append(L[-1])\nL[i] = L[j]\nD[x] = D[x] + 1\n替换其他对象的操作可能会在其他对象的引用计数变为零时唤起这些对象的 __del__() 方法，这可\n能会产生一些影响。 对字典和列表进行大量更新尤其如此。 如有疑问，请使用互斥锁！\n不能删除全局解释器锁吗？\nglobal interpreter lock （GIL）通常被视为 Python 在高端多核服务器上开发时的阻力，因为（几\n乎）所有 Python 代码只有在获取到 GIL 时才能运行，所以多线程的 Python 程序只能有效地使用一\n个 CPU。\n在 PEP 703 通过后目前已着手从 Python 的 CPython 实现中移除 GIL。 最初它将它将作为构建解释\n器时的可选编译器旗标来实现，因此将会存在有 GIL 和没有 GIL 的构建版本。 从长远来看，目标是\n在移除 GIL 对性能的影响被完全了解之后确定唯一的构建版本。 Python 3.13 大概是第一个包含此项\n工作的发布版，尽管在这个发布版中该功能可能尚不完整。\n当前移除 GIL 的工作是基于 Sam Gross 的 移除了 GIL 的 Python 3.9 分叉。 更早的时候，在 Python\n1.5 时期，Greg Stein 实际上实现了一个完整的补丁集（“自由线程”补丁），移除了 GIL 并用更细粒\n度的锁来代替。 Adam Olsen 也在他的 python-safethread 项目里做了类似的实验。 不幸的是，由\n于为移除 GIL 而使用了大量细粒度的锁这两个早期实验在单线程中的性能都有明显的下降（至少慢\n30%）。 Python 3.9 分叉是在移除 GIL 的同时保持可接受的性能影响的首次尝试。\n当前 Python 发布版存在 GIL 并不意味着你无法在多CPU 机器上很好地使用 Python！ 你仅需发挥创\n造性将任务在多个 进程 而不是多个 threads 线程之间进行分配。 新的 concurrent.futures 模块中\n的 ProcessPoolExecutor 类提供了完成此项工作的简单方式；如果你想要对任务分发有更强的控制\n那么 multiprocessing 模块提供了更低层级的 API。\n恰当地使用 C 拓展也很有用；使用 C 拓展处理耗时较久的任务时，拓展可以在线程执行 C 代码时释\n放 GIL，让其他线程执行。zlib 和 hashlib 等标准库模块已经这样做了。\n减小 GIL 的影响的一种替代方式是让 GIL 成为每解释器状态锁而不是真正的全局状态锁。 此特性 在\nPython 3.12 中首次实现 并在 C API 中可用。 预期会在 Python 3.13 中提供它的 Python 接口。 目前\n它的主要限制在于第 3 方扩展模块，因此这些模块的编写必须考虑到多解释器的情况才能够被使\n用，这样大量较旧的扩展模块将不再可用。\n输入与输出\n怎样删除文件？（以及其他文件相关的问题……）\n使用 os.remove(filename) 或 os.unlink(filename)。查看 os 模块以获取更多文档。这两个函\n数是一样的，unlink() 是这个函数在 Unix 系统调用中的名字。\n如果要删除目录，应该使用 os.rmdir()；使用 os.mkdir() 创建目录。os.makedirs(path) 会创\n建 path 中任何不存在的目录。os.removedirs(path) 则会删除其中的目录，只要它们都是空的；\n如果你想删除整个目录以及其中的内容，可以使用 shutil.rmtree()。\n\n|  | i = i+1\nL.append(L[-1])\nL[i] = L[j]\nD[x] = D[x] + 1 |  |\n| --- | --- | --- |\n|  | 替换其他对象的操作可能会在其他对象的引用计数变为零时唤起这些对象的 __del__() 方法，这可\n能会产生一些影响。 对字典和列表进行大量更新尤其如此。 如有疑问，请使用互斥锁！\n不能删除全局解释器锁吗？\nglobal interpreter lock （GIL）通常被视为 Python 在高端多核服务器上开发时的阻力，因为（几\n乎）所有 Python 代码只有在获取到 GIL 时才能运行，所以多线程的 Python 程序只能有效地使用一\n个 CPU。\n在 PEP 703 通过后目前已着手从 Python 的 CPython 实现中移除 GIL。 最初它将它将作为构建解释\n器时的可选编译器旗标来实现，因此将会存在有 GIL 和没有 GIL 的构建版本。 从长远来看，目标是\n在移除 GIL 对性能的影响被完全了解之后确定唯一的构建版本。 Python 3.13 大概是第一个包含此项\n工作的发布版，尽管在这个发布版中该功能可能尚不完整。\n当前移除 GIL 的工作是基于 Sam Gross 的 移除了 GIL 的 Python 3.9 分叉。 更早的时候，在 Python\n1.5 时期，Greg Stein 实际上实现了一个完整的补丁集（“自由线程”补丁），移除了 GIL 并用更细粒\n度的锁来代替。 Adam Olsen 也在他的 python-safethread 项目里做了类似的实验。 不幸的是，由\n于为移除 GIL 而使用了大量细粒度的锁这两个早期实验在单线程中的性能都有明显的下降（至少慢\n30%）。 Python 3.9 分叉是在移除 GIL 的同时保持可接受的性能影响的首次尝试。\n当前 Python 发布版存在 GIL 并不意味着你无法在多CPU 机器上很好地使用 Python！ 你仅需发挥创\n造性将任务在多个 进程 而不是多个 threads 线程之间进行分配。 新的 concurrent.futures 模块中\n的 ProcessPoolExecutor 类提供了完成此项工作的简单方式；如果你想要对任务分发有更强的控制\n那么 multiprocessing 模块提供了更低层级的 API。\n恰当地使用 C 拓展也很有用；使用 C 拓展处理耗时较久的任务时，拓展可以在线程执行 C 代码时释\n放 GIL，让其他线程执行。zlib 和 hashlib 等标准库模块已经这样做了。\n减小 GIL 的影响的一种替代方式是让 GIL 成为每解释器状态锁而不是真正的全局状态锁。 此特性 在\nPython 3.12 中首次实现 并在 C API 中可用。 预期会在 Python 3.13 中提供它的 Python 接口。 目前\n它的主要限制在于第 3 方扩展模块，因此这些模块的编写必须考虑到多解释器的情况才能够被使\n用，这样大量较旧的扩展模块将不再可用。\n输入与输出\n怎样删除文件？（以及其他文件相关的问题……）\n使用 os.remove(filename) 或 os.unlink(filename)。查看 os 模块以获取更多文档。这两个函\n数是一样的，unlink() 是这个函数在 Unix 系统调用中的名字。\n如果要删除目录，应该使用 os.rmdir()；使用 os.mkdir() 创建目录。os.makedirs(path) 会创\n建 path 中任何不存在的目录。os.removedirs(path) 则会删除其中的目录，只要它们都是空的；\n如果你想删除整个目录以及其中的内容，可以使用 shutil.rmtree()。 |  |\n\n重命名文件可以使用 os.rename(old_path, new_path)。\n如果需要截断文件，使用 f = open(filename, \"rb+\") 打开文件，然后使用\nf.truncate(offset)；offset 默认是当前的搜索位置。也可以对使用 os.open() 打开的文件使用\nos.ftruncate(fd, offset)，其中 fd 是文件描述符（一个小的整型数）。\nshutil 模块也包含了一些处理文件的函数，包括 copyfile()，copytree() 和 rmtree()。\n怎样复制文件？\nshutil 模块包含一个 copyfile() 函数。注意，在 Windows NTFS 卷上，它不复制 替代数据流 ，\n也不复制 macOS HFS+ 卷上的 资源分叉 ，尽管这两者现在很少使用。它也不复制文件权限和元数\n据，尽管使用 shutil.copy2() 可以保留大部分（但不是全部）的内容。\n怎样读取（或写入）二进制数据？\n要读写复杂的二进制数据格式，最好使用 struct 模块。该模块可以读取包含二进制数据（通常是\n数字）的字符串并转换为 Python 对象，反之亦然。\n举例来说，下面的代码会从文件中以大端序格式读取一个 2 字节的整型和一个 4 字节的整型：\nimport struct\nwith open(filename, \"rb\") as f:\ns = f.read(8)\nx, y, z = struct.unpack(\">hhl\", s)\n格式字符串中的 ‘>’ 强制以大端序读取数据；字母 ‘h’ 从字符串中读取一个“短整型”（2 字节），字母\n‘l’ 读取一个“长整型”（4 字节）。\n对于更常规的数据（例如整型或浮点类型的列表），你也可以使用 array 模块。\n备注: 要读写二进制数据的话，需要强制以二进制模式打开文件（这里为 open() 函数传入\n\"rb\"）。如果（默认）传入 \"r\" 的话，文件会以文本模式打开，f.read() 会返回 str 对象，而\n不是 bytes 对象。\n似乎 os.popen() 创建的管道不能使用 os.read()，这是为什么？\nos.read() 是一个底层函数，它接收的是文件描述符 —— 用小整型数表示的打开的文件。\nos.popen() 创建的是一个高级文件对象，和内建的 open() 方法返回的类型一样。因此，如果要从\nos.popen() 创建的管道 p 中读取 n 个字节的话，你应该使用 p.read(n)。\n怎样访问（RS232）串口？\n对于 Win32, OSX, Linux, BSD, Jython, IronPython:\npyserial\n对于 Unix，查看 Mitch Chapman 发布的帖子：\n\n|  | 重命名文件可以使用 os.rename(old_path, new_path)。\n如果需要截断文件，使用 f = open(filename, \"rb+\") 打开文件，然后使用\nf.truncate(offset)；offset 默认是当前的搜索位置。也可以对使用 os.open() 打开的文件使用\nos.ftruncate(fd, offset)，其中 fd 是文件描述符（一个小的整型数）。\nshutil 模块也包含了一些处理文件的函数，包括 copyfile()，copytree() 和 rmtree()。\n怎样复制文件？\nshutil 模块包含一个 copyfile() 函数。注意，在 Windows NTFS 卷上，它不复制 替代数据流 ，\n也不复制 macOS HFS+ 卷上的 资源分叉 ，尽管这两者现在很少使用。它也不复制文件权限和元数\n据，尽管使用 shutil.copy2() 可以保留大部分（但不是全部）的内容。\n怎样读取（或写入）二进制数据？\n要读写复杂的二进制数据格式，最好使用 struct 模块。该模块可以读取包含二进制数据（通常是\n数字）的字符串并转换为 Python 对象，反之亦然。\n举例来说，下面的代码会从文件中以大端序格式读取一个 2 字节的整型和一个 4 字节的整型： |  |\n| --- | --- | --- |\n|  | import struct\nwith open(filename, \"rb\") as f:\ns = f.read(8)\nx, y, z = struct.unpack(\">hhl\", s) |  |\n|  | 格式字符串中的 ‘>’ 强制以大端序读取数据；字母 ‘h’ 从字符串中读取一个“短整型”（2 字节），字母\n‘l’ 读取一个“长整型”（4 字节）。\n对于更常规的数据（例如整型或浮点类型的列表），你也可以使用 array 模块。 |  |\n|  | 备注: 要读写二进制数据的话，需要强制以二进制模式打开文件（这里为 open() 函数传入\n\"rb\"）。如果（默认）传入 \"r\" 的话，文件会以文本模式打开，f.read() 会返回 str 对象，而\n不是 bytes 对象。 |  |\n|  | 似乎 os.popen() 创建的管道不能使用 os.read()，这是为什么？\nos.read() 是一个底层函数，它接收的是文件描述符 —— 用小整型数表示的打开的文件。\nos.popen() 创建的是一个高级文件对象，和内建的 open() 方法返回的类型一样。因此，如果要从\nos.popen() 创建的管道 p 中读取 n 个字节的话，你应该使用 p.read(n)。\n怎样访问（RS232）串口？\n对于 Win32, OSX, Linux, BSD, Jython, IronPython:\npyserial\n对于 Unix，查看 Mitch Chapman 发布的帖子： |  |\n\nhttps://groups.google.com/groups?selm=34A04430.CF9@ohioee.com\n为什么关闭 sys.stdout（stdin，stderr）并不会真正关掉它？\nPython 文件对象 是一个对底层 C 文件描述符的高层抽象。\n对于在 Python 中通过内建的 open() 函数创建的多数文件对象来说，f.close() 从 Python 的角度\n将其标记为已关闭，并且会关闭底层的 C 文件描述符。在 f 被垃圾回收的时候，析构函数中也会自\n动处理。\n但由于 stdin，stdout 和 stderr 在 C 中的特殊地位，在 Python 中也会对它们做特殊处理。运行\nsys.stdout.close() 会将 Python 的文件对象标记为已关闭，但是 不会 关闭与之关联的文件描述\n符。\n要关闭这三者的 C 文件描述符的话，首先你应该确认确实需要关闭它（比如，这可能会影响到处理\nI/O 的拓展）。如果确实需要这么做的话，使用 os.close()：\nos.close(stdin.fileno())\nos.close(stdout.fileno())\nos.close(stderr.fileno())\n或者也可以使用常量 0，1，2 代替。\n网络 / Internet 编程\nPython 中的 WWW 工具是什么？\n参阅代码库参考手册中 互联网协议和支持 和 互联网数据处理 这两章的内容。Python 有大量模块来\n帮助你构建服务端和客户端 web 系统。\nPaul Boddie 维护了一份可用框架的概览，见 https://wiki.python.org/moin/WebProgramming 。\n生成 HTML 需要使用什么模块？\n你可以在 Web 编程 wiki 页面 找到许多有用的链接。\n怎样使用 Python 脚本发送邮件？\n使用 smtplib 标准库模块。\n下面是一个很简单的交互式发送邮件的代码。这个方法适用于任何支持 SMTP 协议的主机。\nimport sys, smtplib\nfromaddr = input(\"From: \")\ntoaddrs = input(\"To: \").split(',')\nprint(\"Enter message, end with ^D:\")\nmsg = ''\nwhile True:\nline = sys.stdin.readline()\nif not line:\nbreak\n\n|  | https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com\n为什么关闭 sys.stdout（stdin，stderr）并不会真正关掉它？\nPython 文件对象 是一个对底层 C 文件描述符的高层抽象。\n对于在 Python 中通过内建的 open() 函数创建的多数文件对象来说，f.close() 从 Python 的角度\n将其标记为已关闭，并且会关闭底层的 C 文件描述符。在 f 被垃圾回收的时候，析构函数中也会自\n动处理。\n但由于 stdin，stdout 和 stderr 在 C 中的特殊地位，在 Python 中也会对它们做特殊处理。运行\nsys.stdout.close() 会将 Python 的文件对象标记为已关闭，但是 不会 关闭与之关联的文件描述\n符。\n要关闭这三者的 C 文件描述符的话，首先你应该确认确实需要关闭它（比如，这可能会影响到处理\nI/O 的拓展）。如果确实需要这么做的话，使用 os.close()： |  |\n| --- | --- | --- |\n|  | os.close(stdin.fileno())\nos.close(stdout.fileno())\nos.close(stderr.fileno()) |  |\n|  | 或者也可以使用常量 0，1，2 代替。\n网络 / Internet 编程\nPython 中的 WWW 工具是什么？\n参阅代码库参考手册中 互联网协议和支持 和 互联网数据处理 这两章的内容。Python 有大量模块来\n帮助你构建服务端和客户端 web 系统。\nPaul Boddie 维护了一份可用框架的概览，见 https://wiki.python.org/moin/WebProgramming 。\n生成 HTML 需要使用什么模块？\n你可以在 Web 编程 wiki 页面 找到许多有用的链接。\n怎样使用 Python 脚本发送邮件？\n使用 smtplib 标准库模块。\n下面是一个很简单的交互式发送邮件的代码。这个方法适用于任何支持 SMTP 协议的主机。 |  |\n|  | import sys, smtplib\nfromaddr = input(\"From: \")\ntoaddrs = input(\"To: \").split(',')\nprint(\"Enter message, end with ^D:\")\nmsg = ''\nwhile True:\nline = sys.stdin.readline()\nif not line:\nbreak |  |\n\nmsg += line\n# 实际发送的邮件\nserver = smtplib.SMTP('localhost')\nserver.sendmail(fromaddr, toaddrs, msg)\nserver.quit()\n在 Unix 系统中还可以使用 sendmail。sendmail 程序的位置在不同系统中不一样，有时是在\n/usr/lib/sendmail，有时是在 /usr/sbin/sendmail。sendmail 手册页面会对你有所帮助。以下\n是示例代码：\nimport os\nSENDMAIL = \"/usr/sbin/sendmail\" # sendmail 的位置\np = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\np.write(\"To: receiver@example.com\\n\")\np.write(\"Subject: test\\n\")\np.write(\"\\n\") # 分隔标头和消息体的空白行\np.write(\"Some text\\n\")\np.write(\"some more text\\n\")\nsts = p.close()\nif sts != 0:\nprint(\"Sendmail exit status\", sts)\nsocket 的 connect() 方法怎样避免阻塞？\n通常会用 select 模块处理 socket 异步 I/O。\n要防止 TCP 连接发生阻塞，你可以将 socket 设为非阻塞模式。 这样当你执行 connect() 时，你将\n要么立即完成连接（不大可能）要么得到一个包含错误编号如 .errno 的异常。\nerrno.EINPROGRESS 表示连接正在进行中，但尚未完成。 不同的操作系统将返回不同的值，所以你\n需要检查一下你的系统会返回什么值。\n你可以使用 connect_ex() 方法来避免创建异常。 它将只返回 errno 值。 要进行轮询，你可以稍后\n再次调用 connect_ex() -- 0 或 errno.EISCONN 表示已经连接 -- 或者你也可以将此 socket 传给\nselect.select() 来检查它只否可写。\n备注: asyncio 模块提供了通用的单线程并发异步库，它可被用来编写非阻塞的网络代码。 第三\n方的 Twisted 库是一个热门且功能丰富的替代选择。\n数据库\nPython 中有数据库包的接口吗？\n有的。\n标准 Python 还包含了基于磁盘的哈希接口例如 DBM 和 GDBM 。除此之外还有 sqlite3 模块，该模\n块提供了一个轻量级的基于磁盘的关系型数据库。\n大多数关系型数据库都已经支持。查看 数据库编程 wiki 页面 获取更多信息。\n\n|  | msg += line\n# 实际发送的邮件\nserver = smtplib.SMTP('localhost')\nserver.sendmail(fromaddr, toaddrs, msg)\nserver.quit() |  |\n| --- | --- | --- |\n|  | 在 Unix 系统中还可以使用 sendmail。sendmail 程序的位置在不同系统中不一样，有时是在\n/usr/lib/sendmail，有时是在 /usr/sbin/sendmail。sendmail 手册页面会对你有所帮助。以下\n是示例代码： |  |\n|  | import os\nSENDMAIL = \"/usr/sbin/sendmail\" # sendmail 的位置\np = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\np.write(\"To: receiver@example.com\\n\")\np.write(\"Subject: test\\n\")\np.write(\"\\n\") # 分隔标头和消息体的空白行\np.write(\"Some text\\n\")\np.write(\"some more text\\n\")\nsts = p.close()\nif sts != 0:\nprint(\"Sendmail exit status\", sts) |  |\n|  | socket 的 connect() 方法怎样避免阻塞？\n通常会用 select 模块处理 socket 异步 I/O。\n要防止 TCP 连接发生阻塞，你可以将 socket 设为非阻塞模式。 这样当你执行 connect() 时，你将\n要么立即完成连接（不大可能）要么得到一个包含错误编号如 .errno 的异常。\nerrno.EINPROGRESS 表示连接正在进行中，但尚未完成。 不同的操作系统将返回不同的值，所以你\n需要检查一下你的系统会返回什么值。\n你可以使用 connect_ex() 方法来避免创建异常。 它将只返回 errno 值。 要进行轮询，你可以稍后\n再次调用 connect_ex() -- 0 或 errno.EISCONN 表示已经连接 -- 或者你也可以将此 socket 传给\nselect.select() 来检查它只否可写。 |  |\n|  | 备注: asyncio 模块提供了通用的单线程并发异步库，它可被用来编写非阻塞的网络代码。 第三\n方的 Twisted 库是一个热门且功能丰富的替代选择。 |  |\n|  | 数据库\nPython 中有数据库包的接口吗？\n有的。\n标准 Python 还包含了基于磁盘的哈希接口例如 DBM 和 GDBM 。除此之外还有 sqlite3 模块，该模\n块提供了一个轻量级的基于磁盘的关系型数据库。\n大多数关系型数据库都已经支持。查看 数据库编程 wiki 页面 获取更多信息。 |  |\n\n在 Python 中如何实现持久化对象？\npickle 库模块以一种非常通用的方式解决了这个问题（虽然你依然不能用它保存打开的文件、套接\n字或窗口之类的东西），此外 shelve 库模块可使用 pickle 和 (g)dbm 来创建包含任意 Python 对象\n的持久化映射。\n数学和数字\nPython 中怎样生成随机数？\nrandom 标准库模块实现了随机数生成器，使用起来非常简单：\nimport random\nrandom.random()\n这将返回一个 [0, 1) 区间的随机浮点数。\n该模块中还有许多其他的专门的生成器，例如：\nrandrange(a, b) 返回 [a, b) 区间内的一个整型数。\nuniform(a, b) 在 [a, b) 区间选择一个浮点数。\nnormalvariate(mean, sdev) 使用正态（高斯）分布采样。\n还有一些高级函数直接对序列进行操作，例如：\nchoice(S) 从给定的序列中随机选择一个元素。\nshuffle(L) 会对列表执行原地重排，即将其随机地打乱。\n还有 Random 类，你可以将其实例化，用来创建多个独立的随机数生成器。\n\n| 在 Python 中如何实现持久化对象？\npickle 库模块以一种非常通用的方式解决了这个问题（虽然你依然不能用它保存打开的文件、套接\n字或窗口之类的东西），此外 shelve 库模块可使用 pickle 和 (g)dbm 来创建包含任意 Python 对象\n的持久化映射。\n数学和数字\nPython 中怎样生成随机数？\nrandom 标准库模块实现了随机数生成器，使用起来非常简单： |\n| --- |\n| import random\nrandom.random() |\n| 这将返回一个 [0, 1) 区间的随机浮点数。\n该模块中还有许多其他的专门的生成器，例如：\nrandrange(a, b) 返回 [a, b) 区间内的一个整型数。\nuniform(a, b) 在 [a, b) 区间选择一个浮点数。\nnormalvariate(mean, sdev) 使用正态（高斯）分布采样。\n还有一些高级函数直接对序列进行操作，例如：\nchoice(S) 从给定的序列中随机选择一个元素。\nshuffle(L) 会对列表执行原地重排，即将其随机地打乱。\n还有 Random 类，你可以将其实例化，用来创建多个独立的随机数生成器。 |", "metadata": {"title": "00_代码库和插件_FAQ", "source": "md_docs\\python_faq_md\\00_代码库和插件_FAQ.md", "doc_type": "常见问题", "language": "中文", "doc_id": "af85a575"}}
{"doc_id": "013fb755", "content": "图形用户界面（GUI）常见问题\n目录\n图形用户界面（GUI）常见问题\n图形界面常见问题\nPython 有哪些 GUI 工具包？\n有关Tkinter的问题\n我怎样“冻结”Tkinter程序？\n在等待 I/O 操作时能够处理 Tk 事件吗？\n在Tkinter中键绑定不工作：为什么？\n图形界面常见问题\nPython 有哪些 GUI 工具包？\nPython 的标准构建包括一个指向 Tcl/Tk 部件集的面向对象的接口，称为 tkinter 。 这可能是最容易\n安装（因为它包含在大多数 Python 的 二进制发行版 中）和使用的。关于 Tk 的更多信息，包括指向\n源代码的信息，见 Tcl/Tk 主页 。 Tcl/Tk 可以完全移植到 macOS 、 Windows 和 Unix 平台。\n存在多种选项，具体取决于你的目标平台。 Python Wiki 上提供了一个 跨平台 和 平台专属 的 GUI\n框架列表。\n有关Tkinter的问题\n我怎样“冻结”Tkinter程序？\nFreeze （意为 “冻结”）是一个用来创建独立应用程序的工具。 当 “冻结” Tkinter 程序时，程序并不\n是真的能够独立运行，因为程序仍然需要 Tcl 和 Tk 库。\n一种解决方案是将应用程序与 Tcl 和 Tk 库同一起发布，并在运行时使用 TCL_LIBRARY 和\nTK_LIBRARY 环境变量指向它们的位置。\n各种第三方冻结库例如 py2exe 和 cx_Freeze 都能够处理 Tkinter 应用程序的内置对象。\n在等待 I/O 操作时能够处理 Tk 事件吗？\n在 Windows 以外的平台上，你甚至不需要使用线程！ 但您必须稍微调整一下你的 I/O 代码。 Tk 有\n与 Xt 的 XtAddInput() 对应的调用，它允许你注册一个回调函数，当可以对一个文件描述符进行\nI/O 操作时，该函数将从 Tk 的主循环中被调用。 参见 文件处理程序。\n在Tkinter中键绑定不工作：为什么？\n\n| 图形用户界面（GUI）常见问题 |\n| --- |\n| 目录\n图形用户界面（GUI）常见问题\n图形界面常见问题\nPython 有哪些 GUI 工具包？\n有关Tkinter的问题\n我怎样“冻结”Tkinter程序？\n在等待 I/O 操作时能够处理 Tk 事件吗？\n在Tkinter中键绑定不工作：为什么？ |\n| 图形界面常见问题\nPython 有哪些 GUI 工具包？\nPython 的标准构建包括一个指向 Tcl/Tk 部件集的面向对象的接口，称为 tkinter 。 这可能是最容易\n安装（因为它包含在大多数 Python 的 二进制发行版 中）和使用的。关于 Tk 的更多信息，包括指向\n源代码的信息，见 Tcl/Tk 主页 。 Tcl/Tk 可以完全移植到 macOS 、 Windows 和 Unix 平台。\n存在多种选项，具体取决于你的目标平台。 Python Wiki 上提供了一个 跨平台 和 平台专属 的 GUI\n框架列表。\n有关Tkinter的问题\n我怎样“冻结”Tkinter程序？\nFreeze （意为 “冻结”）是一个用来创建独立应用程序的工具。 当 “冻结” Tkinter 程序时，程序并不\n是真的能够独立运行，因为程序仍然需要 Tcl 和 Tk 库。\n一种解决方案是将应用程序与 Tcl 和 Tk 库同一起发布，并在运行时使用 TCL_LIBRARY 和\nTK_LIBRARY 环境变量指向它们的位置。\n各种第三方冻结库例如 py2exe 和 cx_Freeze 都能够处理 Tkinter 应用程序的内置对象。\n在等待 I/O 操作时能够处理 Tk 事件吗？\n在 Windows 以外的平台上，你甚至不需要使用线程！ 但您必须稍微调整一下你的 I/O 代码。 Tk 有\n与 Xt 的 XtAddInput() 对应的调用，它允许你注册一个回调函数，当可以对一个文件描述符进行\nI/O 操作时，该函数将从 Tk 的主循环中被调用。 参见 文件处理程序。\n在Tkinter中键绑定不工作：为什么？ |\n\n一个经常听到的抱怨是：已经通过 bind() 方法 绑定 到事件的事件处理器在对应的键被按下时并没\n有被处理。\n最常见的原因是，那个绑定的控件没有“键盘焦点”。请在 Tk 文档中查找 focus 指令。通常一个控件\n要获得“键盘焦点”，需要点击那个控件（而不是标签；请查看 takefocus 选项）。", "metadata": {"title": "00_图形用户界面（GUI）常见问题", "source": "md_docs\\python_faq_md\\00_图形用户界面（GUI）常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "013fb755"}}
{"doc_id": "b109155f", "content": "扩展/嵌入常见问题\n目录\n扩展/嵌入常见问题\n可以使用 C 语言创建自己的函数吗？\n可以使用 C++ 语言创建自己的函数吗？\nC很难写，有没有其他选择？\n如何在 C 中执行任意 Python 语句？\n如何在 C 中对任意 Python 表达式求值？\n如何从Python对象中提取C的值？\n如何使用Py_BuildValue()创建任意长度的元组？\n如何从C调用对象的方法？\n如何捕获PyErr_Print()（或打印到stdout / stderr的任何内容）的输出？\n如何从C访问用Python编写的模块？\n如何在 Python 中对接 C ++ 对象？\n我使用Setup文件添加了一个模块，为什么make失败了？\n如何调试扩展？\n我想在Linux系统上编译一个Python模块，但是缺少一些文件。为什么?\n如何区分“输入不完整”和“输入无效”？\n如何找到未定义的g++符号__builtin_new或__pure_virtual？\n能否创建一个对象类，其中部分方法在C中实现，而其他方法在Python中实现（例如通过继\n承）？\n可以使用 C 语言创建自己的函数吗？\n是的，您可以在C中创建包含函数、变量、异常甚至新类型的内置模块。在文档 扩展和嵌入 Python\n解释器 中有说明。\n大多数中级或高级的Python书籍也涵盖这个主题。\n可以使用 C++ 语言创建自己的函数吗？\n是的，可以使用 C++ 中兼容 C 的功能。 在 Python include 文件周围放置 extern \"C\" { ... } ，\n并在Python解释器调用的每个函数之前放置 extern \"C\" 。 具有构造函数的全局或静态 C++ 对象\n可能不是一个好主意。\nC很难写，有没有其他选择？\n\n| 扩展/嵌入常见问题 |\n| --- |\n| 目录\n扩展/嵌入常见问题\n可以使用 C 语言创建自己的函数吗？\n可以使用 C++ 语言创建自己的函数吗？\nC很难写，有没有其他选择？\n如何在 C 中执行任意 Python 语句？\n如何在 C 中对任意 Python 表达式求值？\n如何从Python对象中提取C的值？\n如何使用Py_BuildValue()创建任意长度的元组？\n如何从C调用对象的方法？\n如何捕获PyErr_Print()（或打印到stdout / stderr的任何内容）的输出？\n如何从C访问用Python编写的模块？\n如何在 Python 中对接 C ++ 对象？\n我使用Setup文件添加了一个模块，为什么make失败了？\n如何调试扩展？\n我想在Linux系统上编译一个Python模块，但是缺少一些文件。为什么?\n如何区分“输入不完整”和“输入无效”？\n如何找到未定义的g++符号__builtin_new或__pure_virtual？\n能否创建一个对象类，其中部分方法在C中实现，而其他方法在Python中实现（例如通过继\n承）？ |\n| 可以使用 C 语言创建自己的函数吗？\n是的，您可以在C中创建包含函数、变量、异常甚至新类型的内置模块。在文档 扩展和嵌入 Python\n解释器 中有说明。\n大多数中级或高级的Python书籍也涵盖这个主题。\n可以使用 C++ 语言创建自己的函数吗？\n是的，可以使用 C++ 中兼容 C 的功能。 在 Python include 文件周围放置 extern \"C\" { ... } ，\n并在Python解释器调用的每个函数之前放置 extern \"C\" 。 具有构造函数的全局或静态 C++ 对象\n可能不是一个好主意。\nC很难写，有没有其他选择？ |\n\n有多个替代选择可用来编写你自己的 C 扩展，具体取决于你想要做什么。 推荐的第三方工具 提供了\n更简单或更复杂的方式来为 Python 创建 C 和 C++ 扩展。\n如何在 C 中执行任意 Python 语句？\n执行此操作的最高层级函数为 PyRun_SimpleString()，它接受单个字符串参数用于在模块\n__main__ 的上下文中执行并在成功时返回 0 而在发生异常 (包括 SyntaxError) 时返回 -1。 如果\n你想要更多可控性，可以使用 PyRun_String()；请在 Python/pythonrun.c 中查看\nPyRun_SimpleString() 的源码。\n如何在 C 中对任意 Python 表达式求值？\n可以调用前一问题中介绍的函数 PyRun_String() 并附带起始标记符 Py_eval_input；它会解析表\n达式，对其求值并返回结果值。\n如何从Python对象中提取C的值？\n这取决于对象的类型。 如果是元组，PyTuple_Size() 将返回其长度而 PyTuple_GetItem() 将返回\n指定索引号上的项。 对于列表也有类似的函数 PyList_Size() 和 PyList_GetItem()。\n对于字节串，PyBytes_Size() 将返回其长度而 PyBytes_AsStringAndSize() 将提供一个指向其值\n和长度的指针。 请注意 Python 字节串对象可能包含空字节因此不应使用 C 的 strlen()。\n要检测一个对象的类型，首先要确保它不为 NULL，然后使用 PyBytes_Check(), PyTuple_Check(),\nPyList_Check() 等等。\n还有一个针对 Python 对象的高层级 API，通过所谓的‘抽象’接口提供 —— 请参阅\nInclude/abstract.h 了解详情。 它允许使用 PySequence_Length(), PySequence_GetItem() 这\n样的调用来与任意种类的 Python 序列进行对接，此外还可使用许多其他有用的协议例如数字\n(PyNumber_Index() 等) 以及 PyMapping API 中的各种映射等等。\n如何使用Py_BuildValue()创建任意长度的元组？\n不可以。应该使用 PyTuple_Pack() 。\n如何从C调用对象的方法？\n可以使用 PyObject_CallMethod() 函数来调用某个对象的任意方法。 形参为该对象、要调用的方\n法名、类似 Py_BuildValue() 所用的格式字符串以及要传给方法的参数值:\nPyObject *\nPyObject_CallMethod(PyObject *object, const char *method_name,\nconst char *arg_format, ...);\n这适用于任何具有方法的对象 —— 不论是内置方法还是用户自定义方法。 你需要负责对返回值进行\n最终的 Py_DECREF() 处理。\n\n|  | 有多个替代选择可用来编写你自己的 C 扩展，具体取决于你想要做什么。 推荐的第三方工具 提供了\n更简单或更复杂的方式来为 Python 创建 C 和 C++ 扩展。\n如何在 C 中执行任意 Python 语句？\n执行此操作的最高层级函数为 PyRun_SimpleString()，它接受单个字符串参数用于在模块\n__main__ 的上下文中执行并在成功时返回 0 而在发生异常 (包括 SyntaxError) 时返回 -1。 如果\n你想要更多可控性，可以使用 PyRun_String()；请在 Python/pythonrun.c 中查看\nPyRun_SimpleString() 的源码。\n如何在 C 中对任意 Python 表达式求值？\n可以调用前一问题中介绍的函数 PyRun_String() 并附带起始标记符 Py_eval_input；它会解析表\n达式，对其求值并返回结果值。\n如何从Python对象中提取C的值？\n这取决于对象的类型。 如果是元组，PyTuple_Size() 将返回其长度而 PyTuple_GetItem() 将返回\n指定索引号上的项。 对于列表也有类似的函数 PyList_Size() 和 PyList_GetItem()。\n对于字节串，PyBytes_Size() 将返回其长度而 PyBytes_AsStringAndSize() 将提供一个指向其值\n和长度的指针。 请注意 Python 字节串对象可能包含空字节因此不应使用 C 的 strlen()。\n要检测一个对象的类型，首先要确保它不为 NULL，然后使用 PyBytes_Check(), PyTuple_Check(),\nPyList_Check() 等等。\n还有一个针对 Python 对象的高层级 API，通过所谓的‘抽象’接口提供 —— 请参阅\nInclude/abstract.h 了解详情。 它允许使用 PySequence_Length(), PySequence_GetItem() 这\n样的调用来与任意种类的 Python 序列进行对接，此外还可使用许多其他有用的协议例如数字\n(PyNumber_Index() 等) 以及 PyMapping API 中的各种映射等等。\n如何使用Py_BuildValue()创建任意长度的元组？\n不可以。应该使用 PyTuple_Pack() 。\n如何从C调用对象的方法？\n可以使用 PyObject_CallMethod() 函数来调用某个对象的任意方法。 形参为该对象、要调用的方\n法名、类似 Py_BuildValue() 所用的格式字符串以及要传给方法的参数值: |  |\n| --- | --- | --- |\n|  | PyObject *\nPyObject_CallMethod(PyObject *object, const char *method_name,\nconst char *arg_format, ...); |  |\n|  | 这适用于任何具有方法的对象 —— 不论是内置方法还是用户自定义方法。 你需要负责对返回值进行\n最终的 Py_DECREF() 处理。 |  |\n\n例如调用某个文件对象的 \"seek\" 方法并传入参数 10, 0 (假定文件对象的指针为 \"f\"):\nres = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\nif (res == NULL) {\n... an exception occurred ...\n}\nelse {\nPy_DECREF(res);\n}\n请注意由于 PyObject_CallObject() 总是 接受一个元组作为参数列表，要调用不带参数的函数，\n则传入格式为 \"()\"，要调用只带一个参数的函数，则应将参数包含于圆括号中，例如 \"(i)\"。\n如何捕获PyErr_Print()（或打印到stdout / stderr的任何内容）的输出？\n在 Python 代码中，定义一个支持 write() 方法的对象。 将此对象赋值给 sys.stdout 和\nsys.stderr。 调用 print_error 或者只是允许标准回溯机制生效。 在此之后，输出将转往你的\nwrite() 方法所指向的任何地方。\n做到这一点的最简单方式是使用 io.StringIO 类：\n>>> import io, sys\n>>> sys.stdout = io.StringIO()\n>>> print('foo')\n>>> print('hello world!')\n>>> sys.stderr.write(sys.stdout.getvalue())\nfoo\nhello world!\n实现同样效果的自定义对象看起来是这样的：\n>>> import io, sys\n>>> class StdoutCatcher(io.TextIOBase):\n... def __init__(self):\n... self.data = []\n... def write(self, stuff):\n... self.data.append(stuff)\n...\n>>> import sys\n>>> sys.stdout = StdoutCatcher()\n>>> print('foo')\n>>> print('hello world!')\n>>> sys.stderr.write(''.join(sys.stdout.data))\nfoo\nhello world!\n如何从C访问用Python编写的模块？\n你可以通过如下方式获得一个指向模块对象的指针:\nmodule = PyImport_ImportModule(\"<modulename>\");\n\n|  | 例如调用某个文件对象的 \"seek\" 方法并传入参数 10, 0 (假定文件对象的指针为 \"f\"): |  |\n| --- | --- | --- |\n|  | res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\nif (res == NULL) {\n... an exception occurred ...\n}\nelse {\nPy_DECREF(res);\n} |  |\n|  | 请注意由于 PyObject_CallObject() 总是 接受一个元组作为参数列表，要调用不带参数的函数，\n则传入格式为 \"()\"，要调用只带一个参数的函数，则应将参数包含于圆括号中，例如 \"(i)\"。\n如何捕获PyErr_Print()（或打印到stdout / stderr的任何内容）的输出？ |  |\n|  | 在 Python 代码中，定义一个支持 write() 方法的对象。 将此对象赋值给 sys.stdout 和\nsys.stderr。 调用 print_error 或者只是允许标准回溯机制生效。 在此之后，输出将转往你的\nwrite() 方法所指向的任何地方。\n做到这一点的最简单方式是使用 io.StringIO 类： |  |\n|  | >>> import io, sys\n>>> sys.stdout = io.StringIO()\n>>> print('foo')\n>>> print('hello world!')\n>>> sys.stderr.write(sys.stdout.getvalue())\nfoo\nhello world! |  |\n|  | 实现同样效果的自定义对象看起来是这样的： |  |\n|  | >>> import io, sys\n>>> class StdoutCatcher(io.TextIOBase):\n... def __init__(self):\n... self.data = []\n... def write(self, stuff):\n... self.data.append(stuff)\n...\n>>> import sys\n>>> sys.stdout = StdoutCatcher()\n>>> print('foo')\n>>> print('hello world!')\n>>> sys.stderr.write(''.join(sys.stdout.data))\nfoo\nhello world! |  |\n|  | 如何从C访问用Python编写的模块？\n你可以通过如下方式获得一个指向模块对象的指针: |  |\n|  | module = PyImport_ImportModule(\"<modulename>\"); |  |\n|  |  |  |\n\n如果模块尚未被导入（即它还不存在于 sys.modules 中），这会初始化该模块；否则它只是简单地\n返回 sys.modules[\"<modulename>\"] 的值。 请注意它并不会将模块加入任何命名空间 —— 它只是\n确保模块被初始化并存在于 sys.modules 中。\n之后你就可以通过如下方式来访问模块的属性（即模块中定义的任何名称）:\nattr = PyObject_GetAttrString(module, \"<attrname>\");\n调用 PyObject_SetAttrString() 为模块中的变量赋值也是可以的。\n如何在 Python 中对接 C ++ 对象？\n根据你的需求，可以选择许多方式。 手动的实现方式请查阅 \"扩展与嵌入\" 文档 来入门。 需要知道\n的是对于 Python 运行时系统来说，C 和 C++ 并不没有太大的区别 —— 因此围绕一个 C 结构（指\n针）类型构建新 Python 对象的策略同样适用于 C++ 对象。\n有关C ++库，请参阅 C很难写，有没有其他选择？\n我使用Setup文件添加了一个模块，为什么make失败了？\n安装程序必须以换行符结束，如果没有换行符，则构建过程将失败。 （修复这个需要一些丑陋的\nshell脚本编程，而且这个bug很小，看起来不值得花这么大力气。)\n如何调试扩展？\n将GDB与动态加载的扩展名一起使用时，在加载扩展名之前，不能在扩展名中设置断点。\n在您的 .gdbinit 文件中（或交互式）添加命令：\nbr _PyImport_LoadDynamicModule\n然后运行GDB：\n$ gdb /local/bin/python\ngdb) run myscript.py\ngdb) continue # 重复直到你的扩展被载入\ngdb) finish # 你的扩展已被载入\ngdb) br myfunction.c:50\ngdb) continue\n我想在Linux系统上编译一个Python模块，但是缺少一些文件。为什\n么?\n大多数打包的 Python 版本都会省略一些编译 Python 扩展所必需的文件。\n对于 Red Hat，请安装 python3-devel RPM 来获取必需的文件。\n对于 Debian，请运行 apt-get install python3-dev。\n\n|  | 如果模块尚未被导入（即它还不存在于 sys.modules 中），这会初始化该模块；否则它只是简单地\n返回 sys.modules[\"<modulename>\"] 的值。 请注意它并不会将模块加入任何命名空间 —— 它只是\n确保模块被初始化并存在于 sys.modules 中。\n之后你就可以通过如下方式来访问模块的属性（即模块中定义的任何名称）: |  |\n| --- | --- | --- |\n|  | attr = PyObject_GetAttrString(module, \"<attrname>\"); |  |\n|  | 调用 PyObject_SetAttrString() 为模块中的变量赋值也是可以的。\n如何在 Python 中对接 C ++ 对象？\n根据你的需求，可以选择许多方式。 手动的实现方式请查阅 \"扩展与嵌入\" 文档 来入门。 需要知道\n的是对于 Python 运行时系统来说，C 和 C++ 并不没有太大的区别 —— 因此围绕一个 C 结构（指\n针）类型构建新 Python 对象的策略同样适用于 C++ 对象。\n有关C ++库，请参阅 C很难写，有没有其他选择？\n我使用Setup文件添加了一个模块，为什么make失败了？\n安装程序必须以换行符结束，如果没有换行符，则构建过程将失败。 （修复这个需要一些丑陋的\nshell脚本编程，而且这个bug很小，看起来不值得花这么大力气。)\n如何调试扩展？\n将GDB与动态加载的扩展名一起使用时，在加载扩展名之前，不能在扩展名中设置断点。\n在您的 .gdbinit 文件中（或交互式）添加命令： |  |\n|  | br _PyImport_LoadDynamicModule |  |\n|  | 然后运行GDB： |  |\n|  | $ gdb /local/bin/python\ngdb) run myscript.py\ngdb) continue # 重复直到你的扩展被载入\ngdb) finish # 你的扩展已被载入\ngdb) br myfunction.c:50\ngdb) continue |  |\n|  | 我想在Linux系统上编译一个Python模块，但是缺少一些文件。为什\n么?\n大多数打包的 Python 版本都会省略一些编译 Python 扩展所必需的文件。\n对于 Red Hat，请安装 python3-devel RPM 来获取必需的文件。\n对于 Debian，请运行 apt-get install python3-dev。 |  |\n\n如何区分“输入不完整”和“输入无效”？\n有时，希望模仿Python交互式解释器的行为，在输入不完整时(例如，您键入了“if”语句的开头，或者\n没有关闭括号或三个字符串引号)，给出一个延续提示，但当输入无效时，立即给出一条语法错误消\n息。\n在Python中，您可以使用 codeop 模块，该模块非常接近解析器的行为。例如，IDLE就使用了这\n个。\n在C中执行此操作的最简单方法是调用 PyRun_InteractiveLoop() （可能在单独的线程中）并让\nPython解释器为您处理输入。您还可以设置 PyOS_ReadlineFunctionPointer() 指向您的自定义输\n入函数。有关更多提示，请参阅 Modules/readline.c 和 Parser/myreadline.c 。\n如何找到未定义的g++符号__builtin_new或__pure_virtual？\n要动态加载g ++扩展模块，必须重新编译Python，要使用g ++重新链接（在Python Modules\nMakefile中更改LINKCC），及链接扩展模块（例如： g++ -shared -o mymodule.so mymodule.o\n）。\n能否创建一个对象类，其中部分方法在C中实现，而其他方法在\nPython中实现（例如通过继承）？\n是的，您可以继承内置类，例如 int ， list ， dict 等。\nBoost Python Library (BPL, https://www.boost.org/libs/python/doc/index.html) 提供了一种从 C++\n执行此操作的方式（即你可以使用 BPL 来继承用 C++ 编写的扩展类）。", "metadata": {"title": "00_扩展嵌入常见问题", "source": "md_docs\\python_faq_md\\00_扩展嵌入常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "b109155f"}}
{"doc_id": "90e59fbc", "content": "编程常见问题\n目录\n编程常见问题\n一般问题\nPython 有没有提供带有断点、单步调试等功能的源码级调试器？\n是否有能帮助寻找漏洞或执行静态分析的工具？\n如何由 Python 脚本创建能独立运行的二进制程序？\n是否有 Python 编码标准或风格指南？\n语言核心内容\n变量明明有值，为什么还会出现 UnboundLocalError？\nPython 的局部变量和全局变量有哪些规则？\n为什么在循环中定义的参数各异的 lambda 都返回相同的结果？\n如何跨模块共享全局变量？\n导入模块的“最佳实践”是什么？\n为什么对象之间会共享默认值？\n如何将可选参数或关键字参数从一个函数传递到另一个函数？\n形参和实参之间有什么区别？\n为什么修改列表 'y' 也会更改列表 'x'？\n如何编写带有输出参数的函数（按照引用调用）？\n如何在 Python 中创建高阶函数？\n如何复制 Python 对象？\n如何找到对象的方法或属性？\n如何用代码获取对象的名称？\n逗号运算符的优先级是什么？\n是否提供等价于 C 语言 \"?:\" 三目运算符的东西？\n是否可以用 Python 编写让人眼晕的单行程序?\n函数形参列表中的斜杠（/）是什么意思？\n数字和字符串\n如何给出十六进制和八进制整数？\n为什么 -22 // 10 会返回 -3 ？\n我如何获得 int 字面属性而不是 SyntaxError ？\n如何将字符串转换为数字？\n如何将数字转换为字符串？\n如何修改字符串？\n如何使用字符串调用函数/方法？\n是否有 Perl 的 chomp() 等价物用于从字符串中移除末尾换行符？\n是否有 scanf() 或 sscanf() 的等价物？\nUnicodeDecodeError 或 UnicodeEncodeError 错误的含义是什么？\n\n| 编程常见问题 |\n| --- |\n| 目录\n编程常见问题\n一般问题\nPython 有没有提供带有断点、单步调试等功能的源码级调试器？\n是否有能帮助寻找漏洞或执行静态分析的工具？\n如何由 Python 脚本创建能独立运行的二进制程序？\n是否有 Python 编码标准或风格指南？\n语言核心内容\n变量明明有值，为什么还会出现 UnboundLocalError？\nPython 的局部变量和全局变量有哪些规则？\n为什么在循环中定义的参数各异的 lambda 都返回相同的结果？\n如何跨模块共享全局变量？\n导入模块的“最佳实践”是什么？\n为什么对象之间会共享默认值？\n如何将可选参数或关键字参数从一个函数传递到另一个函数？\n形参和实参之间有什么区别？\n为什么修改列表 'y' 也会更改列表 'x'？\n如何编写带有输出参数的函数（按照引用调用）？\n如何在 Python 中创建高阶函数？\n如何复制 Python 对象？\n如何找到对象的方法或属性？\n如何用代码获取对象的名称？\n逗号运算符的优先级是什么？\n是否提供等价于 C 语言 \"?:\" 三目运算符的东西？\n是否可以用 Python 编写让人眼晕的单行程序?\n函数形参列表中的斜杠（/）是什么意思？\n数字和字符串\n如何给出十六进制和八进制整数？\n为什么 -22 // 10 会返回 -3 ？\n我如何获得 int 字面属性而不是 SyntaxError ？\n如何将字符串转换为数字？\n如何将数字转换为字符串？\n如何修改字符串？\n如何使用字符串调用函数/方法？\n是否有 Perl 的 chomp() 等价物用于从字符串中移除末尾换行符？\n是否有 scanf() 或 sscanf() 的等价物？\nUnicodeDecodeError 或 UnicodeEncodeError 错误的含义是什么？ |\n\n我能以奇数个反斜杠来结束一个原始字符串吗？\n性能\n我的程序太慢了。该如何加快速度？\n将多个字符串连接在一起的最有效方法是什么？\n序列（元组/列表）\n如何在元组和列表之间进行转换？\n什么是负数索引？\n序列如何以逆序遍历？\n如何从列表中删除重复项？\n如何从列表中删除多个项？\n如何在 Python 中创建数组？\n如何创建多维列表？\n我如何将一个方法或函数应用于由对象组成的序列？\n为什么 a_tuple[i] += ['item'] 会引发异常？\n我想做一个复杂的排序：能用 Python 进行施瓦茨变换吗？\n如何根据另一个列表的值对某列表进行排序？\n对象\n什么是类？\n什么是方法？\n什么是 self ？\n如何检查对象是否为给定类或其子类的一个实例？\n什么是委托？\n如何在扩展基类的派生类中调用基类中定义的方法？\n如何让代码更容易对基类进行修改？\n如何创建静态类数据和静态类方法？\n在 Python 中如何重载构造函数（或方法）？\n在用 __spam 的时候得到一个类似 _SomeClassName__spam 的错误信息。\n类定义了 __del__ 方法，但是删除对象时没有调用它。\n如何获取给定类的所有实例的列表？\n为什么 id() 的结果看起来不是唯一的？\n什么情况下可以依靠 is 运算符进行对象的身份相等性测试？\n一个子类如何控制哪些数据被存储在一个不可变的实例中？\n我该如何缓存方法调用？\n模块\n如何创建 .pyc 文件？\n如何找到当前模块名称？\n如何让模块相互导入？\n__import__('x.y.z') 返回的是 <module 'x'> ；该如何得到 z 呢？\n对已导入的模块进行了编辑并重新导入，但变动没有得以体现。这是为什么？\n一般问题\nPython 有没有提供带有断点、单步调试等功能的源码级调试器？\n\n|  | 我能以奇数个反斜杠来结束一个原始字符串吗？\n性能\n我的程序太慢了。该如何加快速度？\n将多个字符串连接在一起的最有效方法是什么？\n序列（元组/列表）\n如何在元组和列表之间进行转换？\n什么是负数索引？\n序列如何以逆序遍历？\n如何从列表中删除重复项？\n如何从列表中删除多个项？\n如何在 Python 中创建数组？\n如何创建多维列表？\n我如何将一个方法或函数应用于由对象组成的序列？\n为什么 a_tuple[i] += ['item'] 会引发异常？\n我想做一个复杂的排序：能用 Python 进行施瓦茨变换吗？\n如何根据另一个列表的值对某列表进行排序？\n对象\n什么是类？\n什么是方法？\n什么是 self ？\n如何检查对象是否为给定类或其子类的一个实例？\n什么是委托？\n如何在扩展基类的派生类中调用基类中定义的方法？\n如何让代码更容易对基类进行修改？\n如何创建静态类数据和静态类方法？\n在 Python 中如何重载构造函数（或方法）？\n在用 __spam 的时候得到一个类似 _SomeClassName__spam 的错误信息。\n类定义了 __del__ 方法，但是删除对象时没有调用它。\n如何获取给定类的所有实例的列表？\n为什么 id() 的结果看起来不是唯一的？\n什么情况下可以依靠 is 运算符进行对象的身份相等性测试？\n一个子类如何控制哪些数据被存储在一个不可变的实例中？\n我该如何缓存方法调用？\n模块\n如何创建 .pyc 文件？\n如何找到当前模块名称？\n如何让模块相互导入？\n__import__('x.y.z') 返回的是 <module 'x'> ；该如何得到 z 呢？\n对已导入的模块进行了编辑并重新导入，但变动没有得以体现。这是为什么？ |  |\n| --- | --- | --- |\n|  | 一般问题\nPython 有没有提供带有断点、单步调试等功能的源码级调试器？ |  |\n\n有的。\n以下介绍了一些 Python 的调试器，用内置函数 breakpoint() 即可切入这些调试器中。\npdb 模块是一个简单但是够用的控制台模式 Python 调试器。 它是标准 Python 库的一部分，并且\n已收录于库参考手册。 你也可以通过使用 pdb 代码作为样例来编写你自己的调试器。\n作为标准 Python 发行版组成部分的 IDLE 交互式开发环境 (通常位于 Tools/scripts/idle3)，包括一个\n图形化的调试器。\nPythonWin 是一种 Python IDE，其中包含了一个基于 pdb 的 GUI 调试器。PythonWin 的调试器会为\n断点着色，并提供了相当多的超酷特性，例如调试非 PythonWin 程序等。PythonWin 是 pywin32 项\n目的组成部分，也是 ActivePython 发行版的组成部分。\nEric 是一个基于 PyQt 和 Scintilla 编辑组件的 IDE。\ntrepan3k 是一个类似 gdb 的调试器。\nVisual Studio Code 是包含了调试工具的 IDE，并集成了版本控制软件。\n有许多商业 Python IDE 都包含了图形化调试器。包括：\nWing IDE\nKomodo IDE\nPyCharm\n是否有能帮助寻找漏洞或执行静态分析的工具？\n有的。\nPylint 和 Pyflakes 可执行基本检查来帮助你尽早捕捉漏洞。\n静态类型检查器例如 Mypy, Pyre 和 Pytype 可以检查 Python 源代码中的类型提示。\n如何由 Python 脚本创建能独立运行的二进制程序？\n如果只是想要一个独立的程序，以便用户不必预先安装 Python 即可下载和运行它，则不需要将\nPython 编译成 C 代码。有许多工具可以检测程序所需的模块，并将这些模块与 Python 二进制程序\n捆绑在一起生成单个可执行文件。\n一种方案是使用 freeze 工具，它以 Tools/freeze 的形式包含在 Python 源代码树中。 它可将 Python\n字节码转换为 C 数组；你可以使用 C 编译器将你的所有模块嵌入到一个新程序中，再将其与标准\nPython 模块进行链接。\n它的工作原理是递归扫描源代码，获取两种格式的 import 语句，并在标准 Python 路径和源码目录\n（用于内置模块）检索这些模块。然后，把这些模块的 Python 字节码转换为 C 代码（可以利用\nmarshal 模块转换为代码对象的数组初始化器），并创建一个定制的配置文件，该文件仅包含程序实\n际用到的内置模块。然后，编译生成的 C 代码并将其与 Python 解释器的其余部分链接，形成一个自\n给自足的二进制文件，其功能与 Python 脚本代码完全相同。\n\n|  | 有的。\n以下介绍了一些 Python 的调试器，用内置函数 breakpoint() 即可切入这些调试器中。\npdb 模块是一个简单但是够用的控制台模式 Python 调试器。 它是标准 Python 库的一部分，并且\n已收录于库参考手册。 你也可以通过使用 pdb 代码作为样例来编写你自己的调试器。\n作为标准 Python 发行版组成部分的 IDLE 交互式开发环境 (通常位于 Tools/scripts/idle3)，包括一个\n图形化的调试器。\nPythonWin 是一种 Python IDE，其中包含了一个基于 pdb 的 GUI 调试器。PythonWin 的调试器会为\n断点着色，并提供了相当多的超酷特性，例如调试非 PythonWin 程序等。PythonWin 是 pywin32 项\n目的组成部分，也是 ActivePython 发行版的组成部分。\nEric 是一个基于 PyQt 和 Scintilla 编辑组件的 IDE。\ntrepan3k 是一个类似 gdb 的调试器。\nVisual Studio Code 是包含了调试工具的 IDE，并集成了版本控制软件。\n有许多商业 Python IDE 都包含了图形化调试器。包括：\nWing IDE\nKomodo IDE\nPyCharm\n是否有能帮助寻找漏洞或执行静态分析的工具？\n有的。\nPylint 和 Pyflakes 可执行基本检查来帮助你尽早捕捉漏洞。\n静态类型检查器例如 Mypy, Pyre 和 Pytype 可以检查 Python 源代码中的类型提示。\n如何由 Python 脚本创建能独立运行的二进制程序？\n如果只是想要一个独立的程序，以便用户不必预先安装 Python 即可下载和运行它，则不需要将\nPython 编译成 C 代码。有许多工具可以检测程序所需的模块，并将这些模块与 Python 二进制程序\n捆绑在一起生成单个可执行文件。\n一种方案是使用 freeze 工具，它以 Tools/freeze 的形式包含在 Python 源代码树中。 它可将 Python\n字节码转换为 C 数组；你可以使用 C 编译器将你的所有模块嵌入到一个新程序中，再将其与标准\nPython 模块进行链接。\n它的工作原理是递归扫描源代码，获取两种格式的 import 语句，并在标准 Python 路径和源码目录\n（用于内置模块）检索这些模块。然后，把这些模块的 Python 字节码转换为 C 代码（可以利用\nmarshal 模块转换为代码对象的数组初始化器），并创建一个定制的配置文件，该文件仅包含程序实\n际用到的内置模块。然后，编译生成的 C 代码并将其与 Python 解释器的其余部分链接，形成一个自\n给自足的二进制文件，其功能与 Python 脚本代码完全相同。 |  |\n| --- | --- | --- |\n\n下列包可以用于帮助创建控制台和 GUI 的可执行文件:\nNuitka （跨平台）\nPyInstaller (跨平台)\nPyOxidizer （跨平台）\ncx_Freeze （跨平台）\npy2app （仅限 macOS）\npy2exe (仅限 Windows)\n是否有 Python 编码标准或风格指南？\n有的。 标准库模块所要求的编码风格记录于 PEP 8 之中。\n语言核心内容\n变量明明有值，为什么还会出现 UnboundLocalError？\n当在函数内部某处添加了一条赋值语句，因而导致之前正常工作的代码报出 UnboundLocalError 错\n误，这确实有点令人惊讶。\n以下代码：\n>>> x = 10\n>>> def bar():\n... print(x)\n...\n>>> bar()\n10\n正常工作，但是以下代码\n>>> x = 10\n>>> def foo():\n... print(x)\n... x += 1\n在 UnboundLocalError 中的结果:\n>>> foo()\nTraceback (most recent call last):\n...\nUnboundLocalError: local variable 'x' referenced before assignment\n原因就是，当对某作用域内的变量进行赋值时，该变量将成为该作用域内的局部变量，并覆盖外部\n作用域中的同名变量。由于 foo 的最后一条语句为 x 分配了一个新值，编译器会将其识别为局部变\n量。因此，前面的 print(x) 试图输出未初始化的局部变量，就会引发错误。\n在上面的示例中，可以将外部作用域的变量声明为全局变量以便访问：\n>>> x = 10\n>>> def foobar():\n... global x\n\n|  | 下列包可以用于帮助创建控制台和 GUI 的可执行文件:\nNuitka （跨平台）\nPyInstaller (跨平台)\nPyOxidizer （跨平台）\ncx_Freeze （跨平台）\npy2app （仅限 macOS）\npy2exe (仅限 Windows)\n是否有 Python 编码标准或风格指南？\n有的。 标准库模块所要求的编码风格记录于 PEP 8 之中。\n语言核心内容\n变量明明有值，为什么还会出现 UnboundLocalError？\n当在函数内部某处添加了一条赋值语句，因而导致之前正常工作的代码报出 UnboundLocalError 错\n误，这确实有点令人惊讶。\n以下代码： |  |\n| --- | --- | --- |\n|  | >>> x = 10\n>>> def bar():\n... print(x)\n...\n>>> bar()\n10 |  |\n|  | 正常工作，但是以下代码 |  |\n|  | >>> x = 10\n>>> def foo():\n... print(x)\n... x += 1 |  |\n|  | 在 UnboundLocalError 中的结果: |  |\n|  | >>> foo()\nTraceback (most recent call last):\n...\nUnboundLocalError: local variable 'x' referenced before assignment |  |\n|  | 原因就是，当对某作用域内的变量进行赋值时，该变量将成为该作用域内的局部变量，并覆盖外部\n作用域中的同名变量。由于 foo 的最后一条语句为 x 分配了一个新值，编译器会将其识别为局部变\n量。因此，前面的 print(x) 试图输出未初始化的局部变量，就会引发错误。\n在上面的示例中，可以将外部作用域的变量声明为全局变量以便访问： |  |\n|  | >>> x = 10\n>>> def foobar():\n... global x |  |\n\n... print(x)\n... x += 1\n...\n>>> foobar()\n10\n与类和实例变量貌似但不一样，其实以上是在修改外部作用域的变量值，为了提示这一点，这里需\n要显式声明一下。\n>>> print(x)\n11\n你可以使用 nonlocal 关键字在嵌套作用域中执行类似的操作：\n>>> def foo():\n... x = 10\n... def bar():\n... nonlocal x\n... print(x)\n... x += 1\n... bar()\n... print(x)\n...\n>>> foo()\n10\n11\nPython 的局部变量和全局变量有哪些规则？\n函数内部只作引用的 Python 变量隐式视为全局变量。如果在函数内部任何位置为变量赋值，则除非\n明确声明为全局变量，否则均将其视为局部变量。\n起初尽管有点令人惊讶，不过考虑片刻即可释然。一方面，已分配的变量要求加上 global 可以防\n止意外的副作用发生。另一方面，如果所有全局引用都要加上 global ，那处处都得用上 global\n了。那么每次对内置函数或导入模块中的组件进行引用时，都得声明为全局变量。这种杂乱会破坏\nglobal 声明用于警示副作用的有效性。\n为什么在循环中定义的参数各异的 lambda 都返回相同的结果？\n假设用 for 循环来定义几个取值各异的 lambda（即便是普通函数也一样）：\n>>> squares = []\n>>> for x in range(5):\n... squares.append(lambda: x**2)\n以上会得到一个包含5个 lambda 函数的列表，这些函数将计算 x**2。大家或许期望，调用这些函\n数会分别返回 0 、1 、 4 、 9 和 16。然而，真的试过就会发现，他们都会返回 16 ：\n>>> squares[2]()\n16\n>>> squares[4]()\n16\n\n|  | ... print(x)\n... x += 1\n...\n>>> foobar()\n10 |  |\n| --- | --- | --- |\n|  | 与类和实例变量貌似但不一样，其实以上是在修改外部作用域的变量值，为了提示这一点，这里需\n要显式声明一下。 |  |\n|  | >>> print(x)\n11 |  |\n|  | 你可以使用 nonlocal 关键字在嵌套作用域中执行类似的操作： |  |\n|  | >>> def foo():\n... x = 10\n... def bar():\n... nonlocal x\n... print(x)\n... x += 1\n... bar()\n... print(x)\n...\n>>> foo()\n10\n11 |  |\n|  | Python 的局部变量和全局变量有哪些规则？\n函数内部只作引用的 Python 变量隐式视为全局变量。如果在函数内部任何位置为变量赋值，则除非\n明确声明为全局变量，否则均将其视为局部变量。\n起初尽管有点令人惊讶，不过考虑片刻即可释然。一方面，已分配的变量要求加上 global 可以防\n止意外的副作用发生。另一方面，如果所有全局引用都要加上 global ，那处处都得用上 global\n了。那么每次对内置函数或导入模块中的组件进行引用时，都得声明为全局变量。这种杂乱会破坏\nglobal 声明用于警示副作用的有效性。\n为什么在循环中定义的参数各异的 lambda 都返回相同的结果？\n假设用 for 循环来定义几个取值各异的 lambda（即便是普通函数也一样）： |  |\n|  | >>> squares = []\n>>> for x in range(5):\n... squares.append(lambda: x**2) |  |\n|  | 以上会得到一个包含5个 lambda 函数的列表，这些函数将计算 x**2。大家或许期望，调用这些函\n数会分别返回 0 、1 、 4 、 9 和 16。然而，真的试过就会发现，他们都会返回 16 ： |  |\n|  | >>> squares[2]()\n16\n>>> squares[4]()\n16 |  |\n|  |  |  |\n\n这是因为 x 不是 lambda 函数的内部变量，而是定义于外部作用域中的，并且 x 是在调用 lambda\n时访问的——而不是在定义时访问。循环结束时 x 的值是 4 ，所以此时所有的函数都将返回 4**2\n，即 16 。通过改变 x 的值并查看 lambda 的结果变化，也可以验证这一点。\n>>> x = 8\n>>> squares[2]()\n64\n为了避免发生上述情况，需要将值保存在 lambda 局部变量，以使其不依赖于全局 x 的值：\n>>> squares = []\n>>> for x in range(5):\n... squares.append(lambda n=x: n**2)\n以上 n=x 创建了一个新的 lambda 本地变量 n，并在定义 lambda 时计算其值，使其与循环当前时\n点的 x 值相同。这意味着 n 的值在第 1 个 lambda 中为 0 ，在第 2 个 lambda 中为 1 ，在第 3 个中\n为 2，依此类推。因此现在每个 lambda 都会返回正确结果：\n>>> squares[2]()\n4\n>>> squares[4]()\n16\n请注意，上述表现并不是 lambda 所特有的，常规的函数也同样适用。\n如何跨模块共享全局变量？\n在单个程序中跨模块共享信息的规范方法是创建一个特殊模块（通常称为 config 或 cfg）。只需在\n应用程序的所有模块中导入该 config 模块；然后该模块就可当作全局名称使用了。因为每个模块只\n有一个实例，所以对该模块对象所做的任何更改将会在所有地方得以体现。 例如：\nconfig.py：\nx = 0 # 'x' 配置设置的默认值\nmod.py：\nimport config\nconfig.x = 1\nmain.py：\nimport config\nimport mod\nprint(config.x)\n请注意，出于同样的原因，使用模块也是实现单例设计模式的基础。\n导入模块的“最佳实践”是什么？\n\n|  | 这是因为 x 不是 lambda 函数的内部变量，而是定义于外部作用域中的，并且 x 是在调用 lambda\n时访问的——而不是在定义时访问。循环结束时 x 的值是 4 ，所以此时所有的函数都将返回 4**2\n，即 16 。通过改变 x 的值并查看 lambda 的结果变化，也可以验证这一点。 |  |\n| --- | --- | --- |\n|  | >>> x = 8\n>>> squares[2]()\n64 |  |\n|  | 为了避免发生上述情况，需要将值保存在 lambda 局部变量，以使其不依赖于全局 x 的值： |  |\n|  | >>> squares = []\n>>> for x in range(5):\n... squares.append(lambda n=x: n**2) |  |\n|  | 以上 n=x 创建了一个新的 lambda 本地变量 n，并在定义 lambda 时计算其值，使其与循环当前时\n点的 x 值相同。这意味着 n 的值在第 1 个 lambda 中为 0 ，在第 2 个 lambda 中为 1 ，在第 3 个中\n为 2，依此类推。因此现在每个 lambda 都会返回正确结果： |  |\n|  | >>> squares[2]()\n4\n>>> squares[4]()\n16 |  |\n|  | 请注意，上述表现并不是 lambda 所特有的，常规的函数也同样适用。\n如何跨模块共享全局变量？\n在单个程序中跨模块共享信息的规范方法是创建一个特殊模块（通常称为 config 或 cfg）。只需在\n应用程序的所有模块中导入该 config 模块；然后该模块就可当作全局名称使用了。因为每个模块只\n有一个实例，所以对该模块对象所做的任何更改将会在所有地方得以体现。 例如：\nconfig.py： |  |\n|  | x = 0 # 'x' 配置设置的默认值 |  |\n|  | mod.py： |  |\n|  | import config\nconfig.x = 1 |  |\n|  | main.py： |  |\n|  | import config\nimport mod\nprint(config.x) |  |\n|  | 请注意，出于同样的原因，使用模块也是实现单例设计模式的基础。\n导入模块的“最佳实践”是什么？ |  |\n\n通常请勿使用 from modulename import * 。因为这会扰乱 importer 的命名空间，且会造成未定义\n名称更难以被 Linter 检查出来。\n请在代码文件的首部就导入模块。这样代码所需的模块就一目了然了，也不用考虑模块名是否在作\n用域内的问题。每行导入一个模块则增删起来会比较容易，每行导入多个模块则更节省屏幕空间。\n按如下顺序导入模块就是一种好做法：\n1. 标准库模块——例如：sys、os、argparse、re 等。\n2. 第三方库模块（安装于 Python site-packages 目录中的内容）——例如：dateutil、\nrequests、PIL.Image 等。\n3. 本地开发的模块\n为了避免循环导入引发的问题，有时需要将模块导入语句移入函数或类的内部。Gordon McMillan\n的说法如下：\n当两个模块都采用 \"import <module>\" 的导入形式时，循环导入是没有问题的。但如果第 2 个模\n块想从第 1 个模块中取出一个名称（\"from module import name\"）并且导入处于代码的最顶层，\n那导入就会失败。原因是第 1 个模块中的名称还不可用，这时第 1 个模块正忙于导入第 2 个模块\n呢。\n如果只是在一个函数中用到第 2 个模块，那这时将导入语句移入该函数内部即可。当调用到导入语\n句时，第 1 个模块将已经完成初始化，第 2 个模块就可以进行导入了。\n如果某些模块是平台相关的，可能还需要把导入语句移出最顶级代码。这种情况下，甚至有可能无\n法导入文件首部的所有模块。于是在对应的平台相关代码中导入正确的模块，就是一种不错的选\n择。\n只有为了避免循环导入问题，或有必要减少模块初始化时间时，才把导入语句移入类似函数定义内\n部的局部作用域。如果根据程序的执行方式，许多导入操作不是必需的，那么这种技术尤其有用。\n如果模块仅在某个函数中用到，可能还要将导入操作移入该函数内部。请注意，因为模块有一次初\n始化过程，所以第一次加载模块的代价可能会比较高，但多次加载几乎没有什么花费，代价只是进\n行几次字典检索而已。即使模块名超出了作用域，模块在 sys.modules 中也是可用的。\n为什么对象之间会共享默认值？\n新手程序员常常中招这类 Bug。请看以下函数：\ndef foo(mydict={}): # 危险：所有调用共享对一个字典的引用\n... 执行一些计算 ...\nmydict[key] = value\nreturn mydict\n第一次调用此函数时， mydict 中只有一个数据项。第二次调用 mydict 则会包含两个数据项，因为\nfoo() 开始执行时， mydict 中已经带有一个数据项了。\n大家往往希望，函数调用会为默认值创建新的对象。但事实并非如此。默认值只会在函数定义时创\n建一次。如果对象发生改变，就如上例中的字典那样，则后续调用该函数时将会引用这个改动的对\n象。\n\n|  | 通常请勿使用 from modulename import * 。因为这会扰乱 importer 的命名空间，且会造成未定义\n名称更难以被 Linter 检查出来。\n请在代码文件的首部就导入模块。这样代码所需的模块就一目了然了，也不用考虑模块名是否在作\n用域内的问题。每行导入一个模块则增删起来会比较容易，每行导入多个模块则更节省屏幕空间。\n按如下顺序导入模块就是一种好做法：\n1. 标准库模块——例如：sys、os、argparse、re 等。\n2. 第三方库模块（安装于 Python site-packages 目录中的内容）——例如：dateutil、\nrequests、PIL.Image 等。\n3. 本地开发的模块\n为了避免循环导入引发的问题，有时需要将模块导入语句移入函数或类的内部。Gordon McMillan\n的说法如下：\n当两个模块都采用 \"import <module>\" 的导入形式时，循环导入是没有问题的。但如果第 2 个模\n块想从第 1 个模块中取出一个名称（\"from module import name\"）并且导入处于代码的最顶层，\n那导入就会失败。原因是第 1 个模块中的名称还不可用，这时第 1 个模块正忙于导入第 2 个模块\n呢。\n如果只是在一个函数中用到第 2 个模块，那这时将导入语句移入该函数内部即可。当调用到导入语\n句时，第 1 个模块将已经完成初始化，第 2 个模块就可以进行导入了。\n如果某些模块是平台相关的，可能还需要把导入语句移出最顶级代码。这种情况下，甚至有可能无\n法导入文件首部的所有模块。于是在对应的平台相关代码中导入正确的模块，就是一种不错的选\n择。\n只有为了避免循环导入问题，或有必要减少模块初始化时间时，才把导入语句移入类似函数定义内\n部的局部作用域。如果根据程序的执行方式，许多导入操作不是必需的，那么这种技术尤其有用。\n如果模块仅在某个函数中用到，可能还要将导入操作移入该函数内部。请注意，因为模块有一次初\n始化过程，所以第一次加载模块的代价可能会比较高，但多次加载几乎没有什么花费，代价只是进\n行几次字典检索而已。即使模块名超出了作用域，模块在 sys.modules 中也是可用的。\n为什么对象之间会共享默认值？\n新手程序员常常中招这类 Bug。请看以下函数： |  |\n| --- | --- | --- |\n|  | def foo(mydict={}): # 危险：所有调用共享对一个字典的引用\n... 执行一些计算 ...\nmydict[key] = value\nreturn mydict |  |\n|  | 第一次调用此函数时， mydict 中只有一个数据项。第二次调用 mydict 则会包含两个数据项，因为\nfoo() 开始执行时， mydict 中已经带有一个数据项了。\n大家往往希望，函数调用会为默认值创建新的对象。但事实并非如此。默认值只会在函数定义时创\n建一次。如果对象发生改变，就如上例中的字典那样，则后续调用该函数时将会引用这个改动的对\n象。 |  |\n\n按照定义，不可变对象改动起来是安全的，诸如数字、字符串、元组和 None 之类。而可变对象的改\n动则可能引起困惑，例如字典、列表和类实例等。\n因此，不把可变对象用作默认值是一种良好的编程做法。而应采用 None 作为默认值，然后在函数中\n检查参数是否为 None 并新建列表、字典或其他对象。例如，代码不应如下所示：\ndef foo(mydict={}):\n...\n而应这么写：\ndef foo(mydict=None):\nif mydict is None:\nmydict = {} # 为局部命名空间新建一个字典\n参数默认值的特性有时会很有用处。 如果有个函数的计算过程会比较耗时，有一种常见技巧是将每\n次函数调用的参数和结果缓存起来，并在同样的值被再次请求时返回缓存的值。这种技巧被称为\n“memoize”，实现代码可如下所示：\n# 调用方只能提供两个形参并可选择以关键字形式传入 _cache\ndef expensive(arg1, arg2, *, _cache={}):\nif (arg1, arg2) in _cache:\nreturn _cache[(arg1, arg2)]\n# 计算结果值\nresult = ... 高耗费的计算 ...\n_cache[(arg1, arg2)] = result # 将结果保存在缓存中\nreturn result\n也可以不用参数默认值来实现，而是采用全局的字典变量；这取决于个人偏好。\n如何将可选参数或关键字参数从一个函数传递到另一个函数？\n请利用函数参数列表中的标识符 * 和 ** 归集实参；结果会是元组形式的位置实参和字典形式的关\n键字实参。然后就可利用 * 和 ** 在调用其他函数时传入这些实参：\ndef f(x, *args, **kwargs):\n...\nkwargs['width'] = '14.3c'\n...\ng(x, *args, **kwargs)\n形参和实参之间有什么区别？\n形参 是由出现在函数定义中的名称来定义的，而 参数 则是在调用函数时实际传入的值。 形参定义\n了一个函数能接受什么 参数种类。 例如，对于以下函数定义:\ndef func(foo, bar=None, **kwargs):\npass\nfoo 、 bar 和 kwargs 是 func 的形参。 不过在调用 func 时，例如：\n\n|  | 按照定义，不可变对象改动起来是安全的，诸如数字、字符串、元组和 None 之类。而可变对象的改\n动则可能引起困惑，例如字典、列表和类实例等。\n因此，不把可变对象用作默认值是一种良好的编程做法。而应采用 None 作为默认值，然后在函数中\n检查参数是否为 None 并新建列表、字典或其他对象。例如，代码不应如下所示： |  |\n| --- | --- | --- |\n|  | def foo(mydict={}):\n... |  |\n|  | 而应这么写： |  |\n|  | def foo(mydict=None):\nif mydict is None:\nmydict = {} # 为局部命名空间新建一个字典 |  |\n|  | 参数默认值的特性有时会很有用处。 如果有个函数的计算过程会比较耗时，有一种常见技巧是将每\n次函数调用的参数和结果缓存起来，并在同样的值被再次请求时返回缓存的值。这种技巧被称为\n“memoize”，实现代码可如下所示： |  |\n|  | # 调用方只能提供两个形参并可选择以关键字形式传入 _cache\ndef expensive(arg1, arg2, *, _cache={}):\nif (arg1, arg2) in _cache:\nreturn _cache[(arg1, arg2)]\n# 计算结果值\nresult = ... 高耗费的计算 ...\n_cache[(arg1, arg2)] = result # 将结果保存在缓存中\nreturn result |  |\n|  | 也可以不用参数默认值来实现，而是采用全局的字典变量；这取决于个人偏好。\n如何将可选参数或关键字参数从一个函数传递到另一个函数？\n请利用函数参数列表中的标识符 * 和 ** 归集实参；结果会是元组形式的位置实参和字典形式的关\n键字实参。然后就可利用 * 和 ** 在调用其他函数时传入这些实参： |  |\n|  | def f(x, *args, **kwargs):\n...\nkwargs['width'] = '14.3c'\n...\ng(x, *args, **kwargs) |  |\n|  | 形参和实参之间有什么区别？\n形参 是由出现在函数定义中的名称来定义的，而 参数 则是在调用函数时实际传入的值。 形参定义\n了一个函数能接受什么 参数种类。 例如，对于以下函数定义: |  |\n|  | def func(foo, bar=None, **kwargs):\npass |  |\n|  | foo 、 bar 和 kwargs 是 func 的形参。 不过在调用 func 时，例如： |  |\n\nfunc(42, bar=314, extra=somevar)\n42 、 314 和 somevar 则是实参。\n为什么修改列表 'y' 也会更改列表 'x'？\n如果代码编写如下：\n>>> x = []\n>>> y = x\n>>> y.append(10)\n>>> y\n[10]\n>>> x\n[10]\n或许大家很想知道，为什么在 y 中添加一个元素时， x 也会改变。\n产生这种结果有两个因素：\n1. 变量只是指向对象的一个名称。执行 y = x 并不会创建列表的副本——而只是创建了一个新\n变量 y，并指向 x 所指的同一对象。这就意味着只存在一个列表对象，x 和 y 都是对它的引\n用。\n2. 列表属于 mutable 对象，这意味着它的内容是可以修改的。\n在调用 append() 之后，该可变对象的内容从 [] 变为 [10]。 由于两个变量引用了同一对象，因此\n使用其中任意一个名称访问的都是修改后的值 [10]。\n如果把赋给 x 的对象换成一个不可变对象：\n>>> x = 5 # 整数是不可变对象\n>>> y = x\n>>> x = x + 1 # 5 不能被修改，在此我们会新建一个对象\n>>> x\n6\n>>> y\n5\n可见这时 x 和 y 就不再相等了。因为整数是 immutable 对象，在执行 x = x + 1 时，并不会修改\n整数对象 5，给它加上 1；而是创建了一个新的对象（整数对象 6 ）并将其赋给 x （也就是改变了\nx 所指向的对象）。在赋值完成后，就有了两个对象（整数对象 6 和 5 ）和分别指向他俩的两个变\n量（ x 现在指向 6 而 y 仍然指向 5 ）。\n某些操作 (例如 y.append(10) 和 y.sort()) 是改变原对象，而看上去相似的另一些操作 (例如 y =\ny + [10] 和 sorted(y) <sorted>) 则是创建新对象。 通常在 Python 中 (以及在标准库的所有\n代码中) 会改变原对象的方法将返回 ``None`() 以帮助避免混淆这两种不同类型的操作。 因此如\n果你错误地使用了 y.sort() 并期望它将返回一个经过排序的 y 的副本，你得到的结果将会是\nNone，这将导致你的程序产生一个容易诊断的错误。\n不过还存在一类操作，用不同的类型执行相同的操作有时会发生不同的行为：即增量赋值运算符。\n例如，+= 会修改列表，但不会修改元组或整数（a_list += [1, 2, 3] 与 a_list.extend([1,\n\n|  |  | func(42, bar=314, extra=somevar) |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | 42 、 314 和 somevar 则是实参。\n为什么修改列表 'y' 也会更改列表 'x'？\n如果代码编写如下： |  |  |  |\n|  |  | >>> x = []\n>>> y = x\n>>> y.append(10)\n>>> y\n[10]\n>>> x\n[10] |  |  |  |\n|  |  | 或许大家很想知道，为什么在 y 中添加一个元素时， x 也会改变。\n产生这种结果有两个因素：\n1. 变量只是指向对象的一个名称。执行 y = x 并不会创建列表的副本——而只是创建了一个新\n变量 y，并指向 x 所指的同一对象。这就意味着只存在一个列表对象，x 和 y 都是对它的引\n用。\n2. 列表属于 mutable 对象，这意味着它的内容是可以修改的。\n在调用 append() 之后，该可变对象的内容从 [] 变为 [10]。 由于两个变量引用了同一对象，因此\n使用其中任意一个名称访问的都是修改后的值 [10]。\n如果把赋给 x 的对象换成一个不可变对象： |  |  |  |\n|  |  | >>> x = 5 # 整数是不可变对象\n>>> y = x\n>>> x = x + 1 # 5 不能被修改，在此我们会新建一个对象\n>>> x\n6\n>>> y\n5 |  |  |  |\n|  |  | 可见这时 x 和 y 就不再相等了。因为整数是 immutable 对象，在执行 x = x + 1 时，并不会修改\n整数对象 5，给它加上 1；而是创建了一个新的对象（整数对象 6 ）并将其赋给 x （也就是改变了\nx 所指向的对象）。在赋值完成后，就有了两个对象（整数对象 6 和 5 ）和分别指向他俩的两个变\n量（ x 现在指向 6 而 y 仍然指向 5 ）。\n某些操作 (例如 y.append(10) 和 y.sort()) 是改变原对象，而看上去相似的另一些操作 (例如 y =\ny + [10] 和 sorted(y) <sorted>) 则是创建新对象。 通常在 Python 中 (以及在标准库的所有\n代码中) 会改变原对象的方法将返回 ``None`() 以帮助避免混淆这两种不同类型的操作。 因此如\n果你错误地使用了 y.sort() 并期望它将返回一个经过排序的 y 的副本，你得到的结果将会是\nNone，这将导致你的程序产生一个容易诊断的错误。\n不过还存在一类操作，用不同的类型执行相同的操作有时会发生不同的行为：即增量赋值运算符。\n例如，+= 会修改列表，但不会修改元组或整数（a_list += [1, 2, 3] 与 a_list.extend([1, |  |  |  |\n|  |  |  | y = |  |  |\n|  |  |  |  |  |  |\n|  |  | y + [10] |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n\n2, 3]) 同样都会改变 a_list，而 some_tuple += (1, 2, 3) 和 some_int += 1 则会创建新的对\n象）。\n换而言之：\n对于一个可变对象（ list 、 dict 、 set 等等），可以利用某些特定的操作进行修改，所有引\n用它的变量都会反映出改动情况。\n对于一个不可变对象（ str 、 int 、 tuple 等），所有引用它的变量都会给出相同的值，但所\n有改变其值的操作都将返回一个新的对象。\n如要知道两个变量是否指向同一个对象，可以利用 is 运算符或内置函数 id()。\n如何编写带有输出参数的函数（按照引用调用）？\n请记住，Python 中的实参是通过赋值传递的。由于赋值只是创建了对象的引用，所以调用方和被调\n用方的参数名都不存在别名，本质上也就不存在按引用调用的方式。通过以下几种方式，可以得到\n所需的效果。\n1. 返回一个元组：\n>>> def func1(a, b):\n... a = 'new-value' # a 和 b 是局部名称\n... b = b + 1 # 赋值为新的对象\n... return a, b # 返回新的值\n...\n>>> x, y = 'old-value', 99\n>>> func1(x, y)\n('new-value', 100)\n这差不多是最明晰的解决方案了。\n2. 使用全局变量。这不是线程安全的方案，不推荐使用。\n3. 传递一个可变（即可原地修改的） 对象：\n>>> def func2(a):\n... a[0] = 'new-value' # 'a' 引用了一个可变的列表\n... a[1] = a[1] + 1 # 修改一个共享对象\n...\n>>> args = ['old-value', 99]\n>>> func2(args)\n>>> args\n['new-value', 100]\n4. 传入一个接收可变对象的字典:\n>>> def func3(args):\n... args['a'] = 'new-value' # args 是一个可变的字典\n... args['b'] = args['b'] + 1 # 对其进行原地修改\n...\n>>> args = {'a': 'old-value', 'b': 99}\n>>> func3(args)\n\n|  |  | 2, 3]) 同样都会改变 a_list，而 some_tuple += (1, 2, 3) 和 some_int += 1 则会创建新的对\n象）。\n换而言之：\n对于一个可变对象（ list 、 dict 、 set 等等），可以利用某些特定的操作进行修改，所有引\n用它的变量都会反映出改动情况。\n对于一个不可变对象（ str 、 int 、 tuple 等），所有引用它的变量都会给出相同的值，但所\n有改变其值的操作都将返回一个新的对象。\n如要知道两个变量是否指向同一个对象，可以利用 is 运算符或内置函数 id()。\n如何编写带有输出参数的函数（按照引用调用）？\n请记住，Python 中的实参是通过赋值传递的。由于赋值只是创建了对象的引用，所以调用方和被调\n用方的参数名都不存在别名，本质上也就不存在按引用调用的方式。通过以下几种方式，可以得到\n所需的效果。\n1. 返回一个元组：\n>>> def func1(a, b):\n... a = 'new-value' # a 和 b 是局部名称\n... b = b + 1 # 赋值为新的对象\n... return a, b # 返回新的值\n...\n>>> x, y = 'old-value', 99\n>>> func1(x, y)\n('new-value', 100)\n这差不多是最明晰的解决方案了。\n2. 使用全局变量。这不是线程安全的方案，不推荐使用。\n3. 传递一个可变（即可原地修改的） 对象：\n>>> def func2(a):\n... a[0] = 'new-value' # 'a' 引用了一个可变的列表\n... a[1] = a[1] + 1 # 修改一个共享对象\n...\n>>> args = ['old-value', 99]\n>>> func2(args)\n>>> args\n['new-value', 100]\n4. 传入一个接收可变对象的字典:\n>>> def func3(args):\n... args['a'] = 'new-value' # args 是一个可变的字典\n... args['b'] = args['b'] + 1 # 对其进行原地修改\n...\n>>> args = {'a': 'old-value', 'b': 99}\n>>> func3(args) |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  |  |  |\n|  |  |  | >>> def func3(args):\n... args['a'] = 'new-value' # args 是一个可变的字典\n... args['b'] = args['b'] + 1 # 对其进行原地修改\n...\n>>> args = {'a': 'old-value', 'b': 99}\n>>> func3(args) |  |\n\n>>> args\n{'a': 'new-value', 'b': 100}\n5. 或者把值用类实例封装起来：\n>>> class Namespace:\n... def __init__(self, /, **args):\n... for key, value in args.items():\n... setattr(self, key, value)\n...\n>>> def func4(args):\n... args.a = 'new-value' # args 是一个可变的 Namespace\n... args.b = args.b + 1 # 原地修改对象\n...\n>>> args = Namespace(a='old-value', b=99)\n>>> func4(args)\n>>> vars(args)\n{'a': 'new-value', 'b': 100}\n没有什么理由要把问题搞得这么复杂。\n最佳选择就是返回一个包含多个结果值的元组。\n如何在 Python 中创建高阶函数？\n有两种选择：嵌套作用域、可调用对象。假定需要定义 linear(a,b) ，其返回结果是一个计算出\na*x+b 的函数 f(x)。 采用嵌套作用域的方案如下：\ndef linear(a, b):\ndef result(x):\nreturn a * x + b\nreturn result\n或者可采用可调用对象：\nclass linear:\ndef __init__(self, a, b):\nself.a, self.b = a, b\ndef __call__(self, x):\nreturn self.a * x + self.b\n采用这两种方案时：\ntaxes = linear(0.3, 2)\n都会得到一个可调用对象，可实现 taxes(10e6) == 0.3 * 10e6 + 2 。\n可调用对象的方案有个缺点，就是速度稍慢且生成的代码略长。不过值得注意的是，同一组可调用\n对象能够通过继承来共享签名（类声明）：\nclass exponential(linear):\n# 继承了 __init__\n\n|  | >>> args\n{'a': 'new-value', 'b': 100}\n5. 或者把值用类实例封装起来：\n>>> class Namespace:\n... def __init__(self, /, **args):\n... for key, value in args.items():\n... setattr(self, key, value)\n...\n>>> def func4(args):\n... args.a = 'new-value' # args 是一个可变的 Namespace\n... args.b = args.b + 1 # 原地修改对象\n...\n>>> args = Namespace(a='old-value', b=99)\n>>> func4(args)\n>>> vars(args)\n{'a': 'new-value', 'b': 100}\n没有什么理由要把问题搞得这么复杂。\n最佳选择就是返回一个包含多个结果值的元组。\n如何在 Python 中创建高阶函数？\n有两种选择：嵌套作用域、可调用对象。假定需要定义 linear(a,b) ，其返回结果是一个计算出\na*x+b 的函数 f(x)。 采用嵌套作用域的方案如下： | >>> args\n{'a': 'new-value', 'b': 100} |  |\n| --- | --- | --- | --- |\n|  | def linear(a, b):\ndef result(x):\nreturn a * x + b\nreturn result |  |  |\n|  | 或者可采用可调用对象： |  |  |\n|  | class linear:\ndef __init__(self, a, b):\nself.a, self.b = a, b\ndef __call__(self, x):\nreturn self.a * x + self.b |  |  |\n|  | 采用这两种方案时： |  |  |\n|  | taxes = linear(0.3, 2) |  |  |\n|  | 都会得到一个可调用对象，可实现 taxes(10e6) == 0.3 * 10e6 + 2 。\n可调用对象的方案有个缺点，就是速度稍慢且生成的代码略长。不过值得注意的是，同一组可调用\n对象能够通过继承来共享签名（类声明）： |  |  |\n|  | class exponential(linear):\n# 继承了 __init__ |  |  |\n\ndef __call__(self, x):\nreturn self.a * (x ** self.b)\n对象可以为多个方法的运行状态进行封装：\nclass counter:\nvalue = 0\ndef set(self, x):\nself.value = x\ndef up(self):\nself.value = self.value + 1\ndef down(self):\nself.value = self.value - 1\ncount = counter()\ninc, dec, reset = count.up, count.down, count.set\n以上 inc() 、 dec() 和 reset() 的表现，就如同共享了同一计数变量一样。\n如何复制 Python 对象？\n一般情况下，用 copy.copy() 或 copy.deepcopy() 基本就可以了。并不是所有对象都支持复制，\n但多数是可以的。\n某些对象可以用更简便的方法进行复制。比如字典对象就提供了 copy() 方法：\nnewdict = olddict.copy()\n序列可以用切片操作进行复制：\nnew_l = l[:]\n如何找到对象的方法或属性？\n对于一个用户定义类的实例 x，dir(x) 将返回一个按字母顺序排列的名称列表，其中包含实例属性\n及由类定义的方法和属性。\n如何用代码获取对象的名称？\n一般而言这是无法实现的，因为对象并不存在真正的名称。赋值本质上是把某个名称绑定到某个值\n上；def 和 class 语句同样如此，只是值换成了某个可调用对象。比如以下代码：\n>>> class A:\n... pass\n...\n>>> B = A\n>>> a = B()\n>>> b = a\n>>> print(b)\n\n|  | def __call__(self, x):\nreturn self.a * (x ** self.b) |  |\n| --- | --- | --- |\n|  | 对象可以为多个方法的运行状态进行封装： |  |\n|  | class counter:\nvalue = 0\ndef set(self, x):\nself.value = x\ndef up(self):\nself.value = self.value + 1\ndef down(self):\nself.value = self.value - 1\ncount = counter()\ninc, dec, reset = count.up, count.down, count.set |  |\n|  | 以上 inc() 、 dec() 和 reset() 的表现，就如同共享了同一计数变量一样。\n如何复制 Python 对象？\n一般情况下，用 copy.copy() 或 copy.deepcopy() 基本就可以了。并不是所有对象都支持复制，\n但多数是可以的。\n某些对象可以用更简便的方法进行复制。比如字典对象就提供了 copy() 方法： |  |\n|  | newdict = olddict.copy() |  |\n|  | 序列可以用切片操作进行复制： |  |\n|  | new_l = l[:] |  |\n|  | 如何找到对象的方法或属性？\n对于一个用户定义类的实例 x，dir(x) 将返回一个按字母顺序排列的名称列表，其中包含实例属性\n及由类定义的方法和属性。\n如何用代码获取对象的名称？\n一般而言这是无法实现的，因为对象并不存在真正的名称。赋值本质上是把某个名称绑定到某个值\n上；def 和 class 语句同样如此，只是值换成了某个可调用对象。比如以下代码： |  |\n|  | >>> class A:\n... pass\n...\n>>> B = A\n>>> a = B()\n>>> b = a\n>>> print(b) |  |\n\n<__main__.A object at 0x16D07CC>\n>>> print(a)\n<__main__.A object at 0x16D07CC>\n可以不太严谨地说上述类有一个名称：即使它绑定了两个名称并通过名称 B 唤起所创建的实例仍将\n被报告为类 A 的实例。 但是，没有办法肯定地说实例的名称是 a 还是 b，因为这两个名称都被绑定\n到同一个值上了。\n代码一般没有必要去“知晓”某个值的名称。通常这种需求预示着还是改变方案为好，除非真的是要编\n写内审程序。\n在 comp.lang.python 中，Fredrik Lundh 在回答这样的问题时曾经给出过一个绝佳的类比：\n这就像要知道家门口的那只猫的名字一样：猫（对象）自己不会说出它的名字，它根本就不在乎\n自己叫什么——所以唯一方法就是问一遍你所有的邻居（命名空间），这是不是他们家的猫（对\n象）……\n……并且如果你发现它有很多名字或根本没有名字，那也不必惊讶！\n逗号运算符的优先级是什么？\n逗号不是 Python 的运算符。 请看以下例子：\n>>> \"a\" in \"b\", \"a\"\n(False, 'a')\n由于逗号不是运算符，而只是表达式之间的分隔符，因此上述代码就相当于：\n(\"a\" in \"b\"), \"a\"\n而不是：\n\"a\" in (\"b\", \"a\")\n对于各种赋值运算符（ = 、 += 等）来说同样如此。他们并不是真正的运算符，而只是赋值语句中\n的语法分隔符。\n是否提供等价于 C 语言 \"?:\" 三目运算符的东西？\n有的。语法如下：\n[on_true] if [expression] else [on_false]\nx, y = 50, 25\nsmall = x if x < y else y\n在 Python 2.5 引入上述语法之前，通常的做法是使用逻辑运算符：\n[expression] and [on_true] or [on_false]\n\n|  | <__main__.A object at 0x16D07CC>\n>>> print(a)\n<__main__.A object at 0x16D07CC> |  |\n| --- | --- | --- |\n|  | 可以不太严谨地说上述类有一个名称：即使它绑定了两个名称并通过名称 B 唤起所创建的实例仍将\n被报告为类 A 的实例。 但是，没有办法肯定地说实例的名称是 a 还是 b，因为这两个名称都被绑定\n到同一个值上了。\n代码一般没有必要去“知晓”某个值的名称。通常这种需求预示着还是改变方案为好，除非真的是要编\n写内审程序。\n在 comp.lang.python 中，Fredrik Lundh 在回答这样的问题时曾经给出过一个绝佳的类比：\n这就像要知道家门口的那只猫的名字一样：猫（对象）自己不会说出它的名字，它根本就不在乎\n自己叫什么——所以唯一方法就是问一遍你所有的邻居（命名空间），这是不是他们家的猫（对\n象）……\n……并且如果你发现它有很多名字或根本没有名字，那也不必惊讶！\n逗号运算符的优先级是什么？\n逗号不是 Python 的运算符。 请看以下例子： |  |\n|  | >>> \"a\" in \"b\", \"a\"\n(False, 'a') |  |\n|  | 由于逗号不是运算符，而只是表达式之间的分隔符，因此上述代码就相当于： |  |\n|  | (\"a\" in \"b\"), \"a\" |  |\n|  | 而不是： |  |\n|  | \"a\" in (\"b\", \"a\") |  |\n|  | 对于各种赋值运算符（ = 、 += 等）来说同样如此。他们并不是真正的运算符，而只是赋值语句中\n的语法分隔符。\n是否提供等价于 C 语言 \"?:\" 三目运算符的东西？\n有的。语法如下： |  |\n|  | [on_true] if [expression] else [on_false]\nx, y = 50, 25\nsmall = x if x < y else y |  |\n|  | 在 Python 2.5 引入上述语法之前，通常的做法是使用逻辑运算符： |  |\n|  | [expression] and [on_true] or [on_false] |  |\n|  |  |  |\n\n然而这种做法并不保险，因为当 on_true 为布尔值“假”时，结果将会出错。所以肯定还是采用 ...\nif ... else ... 形式为妙。\n是否可以用 Python 编写让人眼晕的单行程序?\n可以。 这一般是通过在 lambda 中嵌套 lambda 来实现的。 请参阅以下三个示例，它们是基于 Ulf\nBartelt 的代码改写的:\nfrom functools import reduce\n# < 1000 的质数\nprint(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\nmap(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n# 前 10 个斐波那契数字\nprint(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\nf(x,f), range(10))))\n# 曼德布罗集\nprint((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda y,\nIu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\nSx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\ni=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n>=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n# \\___ ___/ \\___ ___/ | | |__ 屏幕上的行\n# V V | |______ 屏幕上的列\n# | | |__________ “迭代”的最大次数\n# | |_________________ y 轴上的取值范围\n# |____________________________ x 轴上的取值范围\n请不要在家里尝试，骚年！\n函数形参列表中的斜杠（/）是什么意思？\n函数参数列表中的斜杠表示在它之前的形参都是仅限位置形参。 仅限位置形参没有可供外部使用的\n名称。 在调用接受仅限位置形参的函数时，参数将只根据其位置被映射到形参上。 例如，\ndivmod() 就是一个接受仅限位置形参的函数。 它的文档说明是这样的:\n>>> help(divmod)\nHelp on built-in function divmod in module builtins:\ndivmod(x, y, /)\nReturn the tuple (x//y, x%y). Invariant: div*y + mod == x.\n形参列表尾部的斜杠说明，两个形参都是仅限位置形参。因此，用关键字参数调用 divmod() 将会\n引发错误：\n>>> divmod(x=3, y=4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: divmod() takes no keyword arguments\n\n|  |  | 然而这种做法并不保险，因为当 on_true 为布尔值“假”时，结果将会出错。所以肯定还是采用 ...\nif ... else ... 形式为妙。\n是否可以用 Python 编写让人眼晕的单行程序?\n可以。 这一般是通过在 lambda 中嵌套 lambda 来实现的。 请参阅以下三个示例，它们是基于 Ulf\nBartelt 的代码改写的: |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  |  |  |\n|  |  | if ... else ... |  |  |\n|  |  |  |  |  |\n|  |  | from functools import reduce\n# < 1000 的质数\nprint(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\nmap(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n# 前 10 个斐波那契数字\nprint(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\nf(x,f), range(10))))\n# 曼德布罗集\nprint((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda y,\nIu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\nSx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\ni=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n>=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n# \\___ ___/ \\___ ___/ | | |__ 屏幕上的行\n# V V | |______ 屏幕上的列\n# | | |__________ “迭代”的最大次数\n# | |_________________ y 轴上的取值范围\n# |____________________________ x 轴上的取值范围 |  |  |\n|  |  | 请不要在家里尝试，骚年！\n函数形参列表中的斜杠（/）是什么意思？\n函数参数列表中的斜杠表示在它之前的形参都是仅限位置形参。 仅限位置形参没有可供外部使用的\n名称。 在调用接受仅限位置形参的函数时，参数将只根据其位置被映射到形参上。 例如，\ndivmod() 就是一个接受仅限位置形参的函数。 它的文档说明是这样的: |  |  |\n|  |  | >>> help(divmod)\nHelp on built-in function divmod in module builtins:\ndivmod(x, y, /)\nReturn the tuple (x//y, x%y). Invariant: div*y + mod == x. |  |  |\n|  |  | 形参列表尾部的斜杠说明，两个形参都是仅限位置形参。因此，用关键字参数调用 divmod() 将会\n引发错误： |  |  |\n|  |  | >>> divmod(x=3, y=4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: divmod() takes no keyword arguments |  |  |\n|  |  |  |  |  |\n\n数字和字符串\n如何给出十六进制和八进制整数？\n要给出八进制数，需在八进制数值前面加上一个零和一个小写或大写字母 \"o\" 作为前缀。例如，要\n将变量 \"a\" 设为八进制的 \"10\" （十进制的 8），写法如下：\n>>> a = 0o10\n>>> a\n8\n十六进制数也很简单。只要在十六进制数前面加上一个零和一个小写或大写的字母 \"x\"。十六进制数\n中的字母可以为大写或小写。比如在 Python 解释器中输入：\n>>> a = 0xa5\n>>> a\n165\n>>> b = 0XB2\n>>> b\n178\n为什么 -22 // 10 会返回 -3 ？\n这主要是为了让 i % j 的正负与 j 一致，如果期望如此，且期望如下等式成立：\ni == (i // j) * j + (i % j)\n那么整除就必须返回向下取整的结果。C 语言同样要求保持这种一致性，于是编译器在截断 i // j\n的结果时需要让 i % j 的正负与 i 一致。\n对于 i % j 来说 j 为负值的应用场景实际上是非常少的。 而 j 为正值的情况则非常多，并且实际\n上在所有情况下让 i % j 的结果为 >= 0 会更有用处。 如果现在时间为 10 时，那么 200 小时前应\n是几时？ -190 % 12 == 2 是有用处的；-190 % 12 == -10 则是会导致意外的漏洞。\n我如何获得 int 字面属性而不是 SyntaxError ？\n尝试以正式方式查找一个 int 字面值属性会发生 SyntaxError 因为句点会被当作是小数点:\n>>> 1.__class__\nFile \"<stdin>\", line 1\n1.__class__\n^\nSyntaxError: invalid decimal literal\n解决办法是用空格或括号将字词与句号分开。\n>>> 1 .__class__\n<class 'int'>\n>>> (1).__class__\n<class 'int'>\n\n|  | 数字和字符串\n如何给出十六进制和八进制整数？\n要给出八进制数，需在八进制数值前面加上一个零和一个小写或大写字母 \"o\" 作为前缀。例如，要\n将变量 \"a\" 设为八进制的 \"10\" （十进制的 8），写法如下： |  |\n| --- | --- | --- |\n|  | >>> a = 0o10\n>>> a\n8 |  |\n|  | 十六进制数也很简单。只要在十六进制数前面加上一个零和一个小写或大写的字母 \"x\"。十六进制数\n中的字母可以为大写或小写。比如在 Python 解释器中输入： |  |\n|  | >>> a = 0xa5\n>>> a\n165\n>>> b = 0XB2\n>>> b\n178 |  |\n|  | 为什么 -22 // 10 会返回 -3 ？\n这主要是为了让 i % j 的正负与 j 一致，如果期望如此，且期望如下等式成立： |  |\n|  | i == (i // j) * j + (i % j) |  |\n|  | 那么整除就必须返回向下取整的结果。C 语言同样要求保持这种一致性，于是编译器在截断 i // j\n的结果时需要让 i % j 的正负与 i 一致。\n对于 i % j 来说 j 为负值的应用场景实际上是非常少的。 而 j 为正值的情况则非常多，并且实际\n上在所有情况下让 i % j 的结果为 >= 0 会更有用处。 如果现在时间为 10 时，那么 200 小时前应\n是几时？ -190 % 12 == 2 是有用处的；-190 % 12 == -10 则是会导致意外的漏洞。\n我如何获得 int 字面属性而不是 SyntaxError ？\n尝试以正式方式查找一个 int 字面值属性会发生 SyntaxError 因为句点会被当作是小数点: |  |\n|  | >>> 1.__class__\nFile \"<stdin>\", line 1\n1.__class__\n^\nSyntaxError: invalid decimal literal |  |\n|  | 解决办法是用空格或括号将字词与句号分开。 |  |\n|  | >>> 1 .__class__\n<class 'int'>\n>>> (1).__class__\n<class 'int'> |  |\n|  |  |  |\n\n如何将字符串转换为数字？\n对于整数，可使用内置的 int() 类型构造器，例如 int('144') == 144。 类似地，可使用\nfloat() 转换为浮点数，例如 float('144') == 144.0。\n默认情况下，这些操作会将数字按十进制来解读，因此 int('0144') == 144 为真值，而\nint('0x144') 会引发 ValueError。 int(string, base) 接受第二个可选参数指定转换的基数，\n例如 int( '0x144', 16) == 324。 如果指定基数为 0，则按 Python 规则解读数字：前缀 '0o' 表\n示八进制，而 '0x' 表示十六进制。\n如果只是想把字符串转为数字，请不要使用内置函数 eval()。 eval() 的速度慢很多且存在安全风\n险：别人可能会传入带有不良副作用的 Python 表达式。比如可能会传入\n__import__('os').system(\"rm -rf $HOME\") ，这会把 home 目录给删了。\neval() 还有把数字解析为 Python 表达式的后果，因此如 eval('09') 将会导致语法错误，因为\nPython 不允许十进制数带有前导 '0'（'0' 除外）。\n如何将数字转换为字符串？\n例如，要把数字 144 转换为字符串 '144'，可使用内置类型构造器 str()。 如果你需要十六进制或\n八进制表示形式，可使用内置函数 hex() 或 oct()。 更复杂的格式化方式，请参阅 f-字符串 和 格\n式字符串语法 等章节，例如 \"{:04d}\".format(144) 将产生 '0144' 而 \"\n{:.3f}\".format(1.0/3.0) 将产生 '0.333'。\n如何修改字符串？\n无法修改，因为字符串是不可变对象。 在大多数情况下，只要将各个部分组合起来构造出一个新字\n符串即可。如果需要一个能原地修改 Unicode 数据的对象，可以试试 io.StringIO 对象或 array\n模块：\n>>> import io\n>>> s = \"Hello, world\"\n>>> sio = io.StringIO(s)\n>>> sio.getvalue()\n'Hello, world'\n>>> sio.seek(7)\n7\n>>> sio.write(\"there!\")\n6\n>>> sio.getvalue()\n'Hello, there!'\n>>> import array\n>>> a = array.array('w', s)\n>>> print(a)\narray('w', 'Hello, world')\n>>> a[0] = 'y'\n>>> print(a)\narray('w', 'yello, world')\n\n|  | 如何将字符串转换为数字？\n对于整数，可使用内置的 int() 类型构造器，例如 int('144') == 144。 类似地，可使用\nfloat() 转换为浮点数，例如 float('144') == 144.0。\n默认情况下，这些操作会将数字按十进制来解读，因此 int('0144') == 144 为真值，而\nint('0x144') 会引发 ValueError。 int(string, base) 接受第二个可选参数指定转换的基数，\n例如 int( '0x144', 16) == 324。 如果指定基数为 0，则按 Python 规则解读数字：前缀 '0o' 表\n示八进制，而 '0x' 表示十六进制。\n如果只是想把字符串转为数字，请不要使用内置函数 eval()。 eval() 的速度慢很多且存在安全风\n险：别人可能会传入带有不良副作用的 Python 表达式。比如可能会传入\n__import__('os').system(\"rm -rf $HOME\") ，这会把 home 目录给删了。\neval() 还有把数字解析为 Python 表达式的后果，因此如 eval('09') 将会导致语法错误，因为\nPython 不允许十进制数带有前导 '0'（'0' 除外）。\n如何将数字转换为字符串？\n例如，要把数字 144 转换为字符串 '144'，可使用内置类型构造器 str()。 如果你需要十六进制或\n八进制表示形式，可使用内置函数 hex() 或 oct()。 更复杂的格式化方式，请参阅 f-字符串 和 格\n式字符串语法 等章节，例如 \"{:04d}\".format(144) 将产生 '0144' 而 \"\n{:.3f}\".format(1.0/3.0) 将产生 '0.333'。\n如何修改字符串？\n无法修改，因为字符串是不可变对象。 在大多数情况下，只要将各个部分组合起来构造出一个新字\n符串即可。如果需要一个能原地修改 Unicode 数据的对象，可以试试 io.StringIO 对象或 array\n模块： |  |\n| --- | --- | --- |\n|  | >>> import io\n>>> s = \"Hello, world\"\n>>> sio = io.StringIO(s)\n>>> sio.getvalue()\n'Hello, world'\n>>> sio.seek(7)\n7\n>>> sio.write(\"there!\")\n6\n>>> sio.getvalue()\n'Hello, there!'\n>>> import array\n>>> a = array.array('w', s)\n>>> print(a)\narray('w', 'Hello, world')\n>>> a[0] = 'y'\n>>> print(a)\narray('w', 'yello, world') |  |\n\n| \" |  |\n| --- | --- |\n\n>>> a.tounicode()\n'yello, world'\n如何使用字符串调用函数/方法？\n有多种技巧可供选择。\n最好的做法是采用一个字典，将字符串映射为函数。其主要优势就是字符串不必与函数名一样。\n这也是用来模拟 case 结构的主要技巧：\ndef a():\npass\ndef b():\npass\ndispatch = {'go': a, 'stop': b} # 注意函数名后不带圆括号\ndispatch[get_input()]() # 注意末尾要带圆括号以调用函数\n利用内置函数 getattr() ：\nimport foo\ngetattr(foo, 'bar')()\n请注意 getattr() 可用于任何对象，包括类、类实例、模块等等。\n标准库就多次使用了这个技巧，例如：\nclass Foo:\ndef do_foo(self):\n...\ndef do_bar(self):\n...\nf = getattr(foo_instance, 'do_' + opname)\nf()\n用 locals() 解析出函数名：\ndef myFunc():\nprint(\"hello\")\nfname = \"myFunc\"\nf = locals()[fname]\nf()\n是否有 Perl 的 chomp() 等价物用于从字符串中移除末尾换行符？\n可以使用 S.rstrip(\"\\r\\n\") 从字符串 S 的末尾删除所有的换行符，而不删除其他尾随空格。如果\n字符串 S 表示多行，且末尾有几个空行，则将删除所有空行的换行符：\n\n|  | >>> a.tounicode()\n'yello, world' |  |\n| --- | --- | --- |\n|  | 如何使用字符串调用函数/方法？\n有多种技巧可供选择。\n最好的做法是采用一个字典，将字符串映射为函数。其主要优势就是字符串不必与函数名一样。\n这也是用来模拟 case 结构的主要技巧：\ndef a():\npass\ndef b():\npass\ndispatch = {'go': a, 'stop': b} # 注意函数名后不带圆括号\ndispatch[get_input()]() # 注意末尾要带圆括号以调用函数\n利用内置函数 getattr() ：\nimport foo\ngetattr(foo, 'bar')()\n请注意 getattr() 可用于任何对象，包括类、类实例、模块等等。\n标准库就多次使用了这个技巧，例如：\nclass Foo:\ndef do_foo(self):\n...\ndef do_bar(self):\n...\nf = getattr(foo_instance, 'do_' + opname)\nf()\n用 locals() 解析出函数名：\ndef myFunc():\nprint(\"hello\")\nfname = \"myFunc\"\nf = locals()[fname]\nf()\n是否有 Perl 的 chomp() 等价物用于从字符串中移除末尾换行符？\n可以使用 S.rstrip(\"\\r\\n\") 从字符串 S 的末尾删除所有的换行符，而不删除其他尾随空格。如果\n字符串 S 表示多行，且末尾有几个空行，则将删除所有空行的换行符： |  |\n\n>>> lines = (\"line 1 \\r\\n\"\n... \"\\r\\n\"\n... \"\\r\\n\")\n>>> lines.rstrip(\"\\n\\r\")\n'line 1 '\n由于通常只在一次读取一行文本时才需要这样做，所以使用 S.rstrip() 这种方式工作得很好。\n是否有 scanf() 或 sscanf() 的等价物？\n没有。\n对于简单的输入解析，最简单的方法通常是使用字符串对象的 split() 方法将行分割为空白符分隔\n的单词，然后使用 int() 或 float() 将十进制字符串转换为数字值 。 split() 支持可选的 \"sep\"\n形参 ，如果行中使用空白符以外的其他分隔符，可以使用该参数。\n对于更复杂的输入解析，正则表达式相比 C 的 sscanf 更为强大也更为适合。\nUnicodeDecodeError 或 UnicodeEncodeError 错误的含义是什么？\n见 Unicode 指南\n我能以奇数个反斜杠来结束一个原始字符串吗？\n以奇数个反斜杠结尾的原始字符串将会转义用于标记字符串的引号:\n>>> r'C:\\this\\will\\not\\work\\'\nFile \"<stdin>\", line 1\nr'C:\\this\\will\\not\\work\\'\n^\nSyntaxError: unterminated string literal (detected at line 1)\n有几种绕过此问题的办法。 其中之一是使用常规字符串以及双反斜杠:\n>>> 'C:\\\\this\\\\will\\\\work\\\\'\n'C:\\\\this\\\\will\\\\work\\\\'\n另一种办法是将一个包含被转义反斜杠的常规字符串拼接到原始字符串上:\n>>> r'C:\\this\\will\\work' '\\\\'\n'C:\\\\this\\\\will\\\\work\\\\'\n在 Windows 上还可以使用 os.path.join() 来添加反斜杠:\n>>> os.path.join(r'C:\\this\\will\\work', '')\n'C:\\\\this\\\\will\\\\work\\\\'\n请注意虽然在确定原始字符串的结束位置时反斜杠会对引号进行“转义“，但在解析原始字符串的值时\n并不会发生转义。 也就是说，反斜杠会被保留在原始字符串的值中:\n\n|  | >>> lines = (\"line 1 \\r\\n\"\n... \"\\r\\n\"\n... \"\\r\\n\")\n>>> lines.rstrip(\"\\n\\r\")\n'line 1 ' |  |\n| --- | --- | --- |\n|  | 由于通常只在一次读取一行文本时才需要这样做，所以使用 S.rstrip() 这种方式工作得很好。\n是否有 scanf() 或 sscanf() 的等价物？\n没有。\n对于简单的输入解析，最简单的方法通常是使用字符串对象的 split() 方法将行分割为空白符分隔\n的单词，然后使用 int() 或 float() 将十进制字符串转换为数字值 。 split() 支持可选的 \"sep\"\n形参 ，如果行中使用空白符以外的其他分隔符，可以使用该参数。\n对于更复杂的输入解析，正则表达式相比 C 的 sscanf 更为强大也更为适合。\nUnicodeDecodeError 或 UnicodeEncodeError 错误的含义是什么？\n见 Unicode 指南\n我能以奇数个反斜杠来结束一个原始字符串吗？\n以奇数个反斜杠结尾的原始字符串将会转义用于标记字符串的引号: |  |\n|  | >>> r'C:\\this\\will\\not\\work\\'\nFile \"<stdin>\", line 1\nr'C:\\this\\will\\not\\work\\'\n^\nSyntaxError: unterminated string literal (detected at line 1) |  |\n|  | 有几种绕过此问题的办法。 其中之一是使用常规字符串以及双反斜杠: |  |\n|  | >>> 'C:\\\\this\\\\will\\\\work\\\\'\n'C:\\\\this\\\\will\\\\work\\\\' |  |\n|  | 另一种办法是将一个包含被转义反斜杠的常规字符串拼接到原始字符串上: |  |\n|  | >>> r'C:\\this\\will\\work' '\\\\'\n'C:\\\\this\\\\will\\\\work\\\\' |  |\n|  | 在 Windows 上还可以使用 os.path.join() 来添加反斜杠: |  |\n|  | >>> os.path.join(r'C:\\this\\will\\work', '')\n'C:\\\\this\\\\will\\\\work\\\\' |  |\n|  | 请注意虽然在确定原始字符串的结束位置时反斜杠会对引号进行“转义“，但在解析原始字符串的值时\n并不会发生转义。 也就是说，反斜杠会被保留在原始字符串的值中: |  |\n\n>>> r'backslash\\'preserved'\n\"backslash\\\\'preserved\"\n另请参阅 语言参考 中的规范说明。\n性能\n我的程序太慢了。该如何加快速度？\n总的来说，这是个棘手的问题。在进一步讨论之前，首先应该记住以下几件事：\n不同的 Python 实现具有不同的性能特点。 本 FAQ 着重解答的是 CPython。\n不同操作系统可能会有不同表现，尤其是涉及 I/O 和多线程时。\n在尝试优化代码 之前 ，务必要先找出程序中的热点（请参阅 profile 模块）。\n编写基准测试脚本，在寻求性能提升的过程中就能实现快速迭代（请参阅 timeit 模块）。\n强烈建议首先要保证足够高的代码测试覆盖率（通过单元测试或其他技术），因为复杂的优化有\n可能会导致代码回退。\n话虽如此，Python 代码的提速还是有很多技巧的。以下列出了一些普适性的原则，对于让性能达到\n可接受的水平会有很大帮助：\n相较于试图对全部代码铺开做微观优化，优化算法（或换用更快的算法）可以产出更大的收益。\n使用正确的数据结构。参考 内置类型 和 collections 模块的文档。\n如果标准库已为某些操作提供了基础函数，则可能（当然不能保证）比所有自编的函数都要快。\n对于用 C 语言编写的基础函数则更是如此，比如内置函数和一些扩展类型。例如，一定要用内置\n方法 list.sort() 或 sorted() 函数进行排序（某些高级用法的示例请参阅 排序的技术 ）。\n抽象往往会造成中间层，并会迫使解释器执行更多的操作。如果抽象出来的中间层级太多，工作\n量超过了要完成的有效任务，那么程序就会被拖慢。应该避免过度的抽象，而且往往也会对可读\n性产生不利影响，特别是当函数或方法比较小的时候。\n如果你已经达到纯 Python 允许的限制，那么有一些工具可以让你走得更远。 例如，Cython 可以将\n稍加修改的 Python 代码版本编译为 C 扩展，并能在许多不同的平台上使用。 Cython 可以利用编译\n（和可选的类型标注）来让你的代码显著快于解释运行时的速度。 如果你对自己的 C 编程技能有信\n心，还可以自行 编写 C 扩展模块。\n参见: 专门介绍 性能提示 的wiki页面。\n将多个字符串连接在一起的最有效方法是什么？\nstr 和 bytes 对象是不可变的，因此连接多个字符串的效率会很低，因为每次连接都会创建一个新\n的对象。一般情况下，总耗时与字符串总长是二次方的关系。\n如果要连接多个 str 对象，通常推荐的方案是先全部放入列表，最后再调用 str.join() ：\nchunks = []\nfor s in my_strings:\nchunks.append(s)\nresult = ''.join(chunks)\n\n|  | >>> r'backslash\\'preserved'\n\"backslash\\\\'preserved\" |  |\n| --- | --- | --- |\n|  | 另请参阅 语言参考 中的规范说明。\n性能\n我的程序太慢了。该如何加快速度？\n总的来说，这是个棘手的问题。在进一步讨论之前，首先应该记住以下几件事：\n不同的 Python 实现具有不同的性能特点。 本 FAQ 着重解答的是 CPython。\n不同操作系统可能会有不同表现，尤其是涉及 I/O 和多线程时。\n在尝试优化代码 之前 ，务必要先找出程序中的热点（请参阅 profile 模块）。\n编写基准测试脚本，在寻求性能提升的过程中就能实现快速迭代（请参阅 timeit 模块）。\n强烈建议首先要保证足够高的代码测试覆盖率（通过单元测试或其他技术），因为复杂的优化有\n可能会导致代码回退。\n话虽如此，Python 代码的提速还是有很多技巧的。以下列出了一些普适性的原则，对于让性能达到\n可接受的水平会有很大帮助：\n相较于试图对全部代码铺开做微观优化，优化算法（或换用更快的算法）可以产出更大的收益。\n使用正确的数据结构。参考 内置类型 和 collections 模块的文档。\n如果标准库已为某些操作提供了基础函数，则可能（当然不能保证）比所有自编的函数都要快。\n对于用 C 语言编写的基础函数则更是如此，比如内置函数和一些扩展类型。例如，一定要用内置\n方法 list.sort() 或 sorted() 函数进行排序（某些高级用法的示例请参阅 排序的技术 ）。\n抽象往往会造成中间层，并会迫使解释器执行更多的操作。如果抽象出来的中间层级太多，工作\n量超过了要完成的有效任务，那么程序就会被拖慢。应该避免过度的抽象，而且往往也会对可读\n性产生不利影响，特别是当函数或方法比较小的时候。\n如果你已经达到纯 Python 允许的限制，那么有一些工具可以让你走得更远。 例如，Cython 可以将\n稍加修改的 Python 代码版本编译为 C 扩展，并能在许多不同的平台上使用。 Cython 可以利用编译\n（和可选的类型标注）来让你的代码显著快于解释运行时的速度。 如果你对自己的 C 编程技能有信\n心，还可以自行 编写 C 扩展模块。 |  |\n|  | 参见: 专门介绍 性能提示 的wiki页面。 |  |\n|  | 将多个字符串连接在一起的最有效方法是什么？\nstr 和 bytes 对象是不可变的，因此连接多个字符串的效率会很低，因为每次连接都会创建一个新\n的对象。一般情况下，总耗时与字符串总长是二次方的关系。\n如果要连接多个 str 对象，通常推荐的方案是先全部放入列表，最后再调用 str.join() ： |  |\n|  | chunks = []\nfor s in my_strings:\nchunks.append(s)\nresult = ''.join(chunks) |  |\n\n（还有一种合理高效的习惯做法，就是利用 io.StringIO ）\n如果要连接多个 bytes 对象，推荐做法是用 bytearray 对象的原地连接操作（ += 运算符）追加数\n据：\nresult = bytearray()\nfor b in my_bytes_objects:\nresult += b\n序列（元组/列表）\n如何在元组和列表之间进行转换？\n类型构造器 tuple(seq) 可将任意序列（实际上是任意可迭代对象）转换为数据项和顺序均不变的\n元组。\n例如，tuple([1, 2, 3]) 会生成 (1, 2, 3) ， tuple('abc') 则会生成 ('a', 'b', 'c') 。 如\n果参数就是元组，则不会创建副本而是返回同一对象，因此如果无法确定某个对象是否为元组时，\n直接调用 tuple() 也没什么代价。\n类型构造器 list(seq) 可将任意序列或可迭代对象转换为数据项和顺序均不变的列表。例如，\nlist((1, 2, 3)) 会生成 [1, 2, 3] 而 list('abc') 则会生成 ['a', 'b', 'c']。如果参数即为\n列表，则会像 seq[:] 那样创建一个副本。\n什么是负数索引？\nPython 序列的索引可以是正数或负数。索引为正数时，0 是第一个索引值， 1 为第二个，依此类\n推。索引为负数时，-1 为倒数第一个索引值，-2 为倒数第二个，依此类推。可以认为 seq[-n] 就相\n当于 seq[len(seq)-n]。\n使用负数序号有时会很方便。 例如 S[:-1] 就是原字符串去掉最后一个字符，这可以用来移除某个\n字符串末尾的换行符。\n序列如何以逆序遍历？\n使用内置函数 reversed() ：\nfor x in reversed(sequence):\n... # 对 x 执行某些操作 ...\n原序列不会变化，而是构建一个逆序的新副本以供遍历。\n如何从列表中删除重复项？\n许多完成此操作的的详细介绍，可参阅 Python Cookbook：\nhttps://code.activestate.com/recipes/52560/\n如果列表允许重新排序，不妨先对其排序，然后从列表末尾开始扫描，依次删除重复项：\n\n|  | （还有一种合理高效的习惯做法，就是利用 io.StringIO ）\n如果要连接多个 bytes 对象，推荐做法是用 bytearray 对象的原地连接操作（ += 运算符）追加数\n据： |  |\n| --- | --- | --- |\n|  | result = bytearray()\nfor b in my_bytes_objects:\nresult += b |  |\n|  | 序列（元组/列表）\n如何在元组和列表之间进行转换？\n类型构造器 tuple(seq) 可将任意序列（实际上是任意可迭代对象）转换为数据项和顺序均不变的\n元组。\n例如，tuple([1, 2, 3]) 会生成 (1, 2, 3) ， tuple('abc') 则会生成 ('a', 'b', 'c') 。 如\n果参数就是元组，则不会创建副本而是返回同一对象，因此如果无法确定某个对象是否为元组时，\n直接调用 tuple() 也没什么代价。\n类型构造器 list(seq) 可将任意序列或可迭代对象转换为数据项和顺序均不变的列表。例如，\nlist((1, 2, 3)) 会生成 [1, 2, 3] 而 list('abc') 则会生成 ['a', 'b', 'c']。如果参数即为\n列表，则会像 seq[:] 那样创建一个副本。\n什么是负数索引？\nPython 序列的索引可以是正数或负数。索引为正数时，0 是第一个索引值， 1 为第二个，依此类\n推。索引为负数时，-1 为倒数第一个索引值，-2 为倒数第二个，依此类推。可以认为 seq[-n] 就相\n当于 seq[len(seq)-n]。\n使用负数序号有时会很方便。 例如 S[:-1] 就是原字符串去掉最后一个字符，这可以用来移除某个\n字符串末尾的换行符。\n序列如何以逆序遍历？\n使用内置函数 reversed() ： |  |\n|  | for x in reversed(sequence):\n... # 对 x 执行某些操作 ... |  |\n|  | 原序列不会变化，而是构建一个逆序的新副本以供遍历。\n如何从列表中删除重复项？\n许多完成此操作的的详细介绍，可参阅 Python Cookbook：\nhttps://code.activestate.com/recipes/52560/\n如果列表允许重新排序，不妨先对其排序，然后从列表末尾开始扫描，依次删除重复项： |  |\n\nif mylist:\nmylist.sort()\nlast = mylist[-1]\nfor i in range(len(mylist)-2, -1, -1):\nif last == mylist[i]:\ndel mylist[i]\nelse:\nlast = mylist[i]\n如果列表的所有元素都能用作集合的键（即都是 hashable ），以下做法速度往往更快：\nmylist = list(set(mylist))\n以上操作会将列表转换为集合，从而删除重复项，然后返回成列表。\n如何从列表中删除多个项？\n类似于删除重复项，一种做法是反向遍历并根据条件删除。不过更简单快速的做法就是切片替换操\n作，采用隐式或显式的正向迭代遍历。以下是三种变体写法：\nmylist[:] = filter(keep_function, mylist)\nmylist[:] = (x for x in mylist if keep_condition)\nmylist[:] = [x for x in mylist if keep_condition]\n列表推导式可能是最快的。\n如何在 Python 中创建数组？\n用列表：\n[\"this\", 1, \"is\", \"an\", \"array\"]\n列表在时间复杂度方面相当于 C 或 Pascal 的数组；主要区别在于，Python 列表可以包含多种不同类\n型的对象。\narray 模块也提供了一些创建具有紧凑表示形式的固定类型数据的方法，但其索引速度要比列表\n慢。 还可关注 NumPy 和其他一些第三方包也定义了一些各具特色的数组类结构体。\n要获得 Lisp 风格的列表，可以使用元组来模拟 cons 单元:\nlisp_list = (\"like\", (\"this\", (\"example\", None) ) )\n如果需要可变特性，你可以用列表来代替元组。 在这里模拟 Lisp car 的是 lisp_list[0] 而模拟 cdr\n的是 lisp_list[1]。 只有在你确定真有需要时才这样做，因为这通常会比使用 Python 列表要慢上\n许多。\n如何创建多维列表？\n多维数组或许会用以下方式建立：\n\n|  | if mylist:\nmylist.sort()\nlast = mylist[-1]\nfor i in range(len(mylist)-2, -1, -1):\nif last == mylist[i]:\ndel mylist[i]\nelse:\nlast = mylist[i] |  |\n| --- | --- | --- |\n|  | 如果列表的所有元素都能用作集合的键（即都是 hashable ），以下做法速度往往更快： |  |\n|  | mylist = list(set(mylist)) |  |\n|  | 以上操作会将列表转换为集合，从而删除重复项，然后返回成列表。\n如何从列表中删除多个项？\n类似于删除重复项，一种做法是反向遍历并根据条件删除。不过更简单快速的做法就是切片替换操\n作，采用隐式或显式的正向迭代遍历。以下是三种变体写法： |  |\n|  | mylist[:] = filter(keep_function, mylist)\nmylist[:] = (x for x in mylist if keep_condition)\nmylist[:] = [x for x in mylist if keep_condition] |  |\n|  | 列表推导式可能是最快的。\n如何在 Python 中创建数组？\n用列表： |  |\n|  | [\"this\", 1, \"is\", \"an\", \"array\"] |  |\n|  | 列表在时间复杂度方面相当于 C 或 Pascal 的数组；主要区别在于，Python 列表可以包含多种不同类\n型的对象。\narray 模块也提供了一些创建具有紧凑表示形式的固定类型数据的方法，但其索引速度要比列表\n慢。 还可关注 NumPy 和其他一些第三方包也定义了一些各具特色的数组类结构体。\n要获得 Lisp 风格的列表，可以使用元组来模拟 cons 单元: |  |\n|  | lisp_list = (\"like\", (\"this\", (\"example\", None) ) ) |  |\n|  | 如果需要可变特性，你可以用列表来代替元组。 在这里模拟 Lisp car 的是 lisp_list[0] 而模拟 cdr\n的是 lisp_list[1]。 只有在你确定真有需要时才这样做，因为这通常会比使用 Python 列表要慢上\n许多。\n如何创建多维列表？\n多维数组或许会用以下方式建立： |  |\n\n>>> A = [[None] * 2] * 3\n打印出来貌似没错：\n>>> A\n[[None, None], [None, None], [None, None]]\n但如果给某一项赋值，结果会同时在多个位置体现出来：\n>>> A[0][0] = 5\n>>> A\n[[5, None], [5, None], [5, None]]\n原因在于用 * 对列表执行重复操作并不会创建副本，而只是创建现有对象的引用。 *3 创建的是包\n含 3 个引用的列表，每个引用指向的是同一个长度为 2 的列表。1 处改动会体现在所有地方，这一\n定不是应有的方案。\n推荐做法是先创建一个所需长度的列表，然后将每个元素都填充为一个新建列表。\nA = [None] * 3\nfor i in range(3):\nA[i] = [None] * 2\n以上生成了一个包含 3 个列表的列表，每个子列表的长度为 2。也可以采用列表推导式：\nw, h = 2, 3\nA = [[None] * w for i in range(h)]\n或者，你也可以使用提供矩阵数据类型的扩展；其中最著名的是 NumPy。\n我如何将一个方法或函数应用于由对象组成的序列？\n要调用一个方法或函数并将返回值累积到一个列表中，list comprehension 是一种优雅的解决方案:\nresult = [obj.method() for obj in mylist]\nresult = [function(obj) for obj in mylist]\n如果只需运行方法或函数而不保存返回值，那么一个简单的 for 循环就足够了:\nfor obj in mylist:\nobj.method()\nfor obj in mylist:\nfunction(obj)\n为什么 a_tuple[i] += ['item'] 会引发异常？\n这是由两个因素共同导致的，一是增强赋值运算符属于 赋值 运算符，二是 Python 可变和不可变对\n象之间的差别。\n\n|  | >>> A = [[None] * 2] * 3 |  |\n| --- | --- | --- |\n|  | 打印出来貌似没错： |  |\n|  | >>> A\n[[None, None], [None, None], [None, None]] |  |\n|  | 但如果给某一项赋值，结果会同时在多个位置体现出来： |  |\n|  | >>> A[0][0] = 5\n>>> A\n[[5, None], [5, None], [5, None]] |  |\n|  | 原因在于用 * 对列表执行重复操作并不会创建副本，而只是创建现有对象的引用。 *3 创建的是包\n含 3 个引用的列表，每个引用指向的是同一个长度为 2 的列表。1 处改动会体现在所有地方，这一\n定不是应有的方案。\n推荐做法是先创建一个所需长度的列表，然后将每个元素都填充为一个新建列表。 |  |\n|  | A = [None] * 3\nfor i in range(3):\nA[i] = [None] * 2 |  |\n|  | 以上生成了一个包含 3 个列表的列表，每个子列表的长度为 2。也可以采用列表推导式： |  |\n|  | w, h = 2, 3\nA = [[None] * w for i in range(h)] |  |\n|  | 或者，你也可以使用提供矩阵数据类型的扩展；其中最著名的是 NumPy。\n我如何将一个方法或函数应用于由对象组成的序列？\n要调用一个方法或函数并将返回值累积到一个列表中，list comprehension 是一种优雅的解决方案: |  |\n|  | result = [obj.method() for obj in mylist]\nresult = [function(obj) for obj in mylist] |  |\n|  | 如果只需运行方法或函数而不保存返回值，那么一个简单的 for 循环就足够了: |  |\n|  | for obj in mylist:\nobj.method()\nfor obj in mylist:\nfunction(obj) |  |\n|  | 为什么 a_tuple[i] += ['item'] 会引发异常？\n这是由两个因素共同导致的，一是增强赋值运算符属于 赋值 运算符，二是 Python 可变和不可变对\n象之间的差别。 |  |\n\n只要元组的元素指向可变对象，这时对元素进行增强赋值，那么这里介绍的内容都是适用的。在此\n只以 list 和 += 举例。\n如果你写成这样:\n>>> a_tuple = (1, 2)\n>>> a_tuple[0] += 1\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\n触发异常的原因显而易见： 1 会与指向（1）的对象 a_tuple[0] 相加，生成结果对象 2，但在试图\n将运算结果 2 赋值给元组的 0 号元素时就会报错，因为元组元素的指向无法更改。\n其实在幕后，上述增强赋值语句的执行过程大致如下：\n>>> result = a_tuple[0] + 1\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\n由于元组是不可变的，因此赋值这步会引发错误。\n如果写成以下这样：\n>>> a_tuple = (['foo'], 'bar')\n>>> a_tuple[0] += ['item']\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\n这时触发异常会令人略感惊讶，更让人吃惊的是虽有报错，但加法操作却生效了：\n>>> a_tuple[0]\n['foo', 'item']\n要明白为什么会这样，你需要知道 (a) 如果一个对象实现了 __iadd__() 魔术方法，那么它就会在执\n行 += 增强赋值时被调用，并且其返回值将在赋值语句中被使用；(b) 对于列表而言，__iadd__()\n等价于在列表上调用 extend() 并返回该列表。 所以对于列表我们可以这样说，+= 就是\nlist.extend() 的“快捷方式”:\n>>> a_list = []\n>>> a_list += [1]\n>>> a_list\n[1]\n这相当于：\n>>> result = a_list.__iadd__([1])\n>>> a_list = result\n\n|  | 只要元组的元素指向可变对象，这时对元素进行增强赋值，那么这里介绍的内容都是适用的。在此\n只以 list 和 += 举例。\n如果你写成这样: |  |\n| --- | --- | --- |\n|  | >>> a_tuple = (1, 2)\n>>> a_tuple[0] += 1\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment |  |\n|  | 触发异常的原因显而易见： 1 会与指向（1）的对象 a_tuple[0] 相加，生成结果对象 2，但在试图\n将运算结果 2 赋值给元组的 0 号元素时就会报错，因为元组元素的指向无法更改。\n其实在幕后，上述增强赋值语句的执行过程大致如下： |  |\n|  | >>> result = a_tuple[0] + 1\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment |  |\n|  | 由于元组是不可变的，因此赋值这步会引发错误。\n如果写成以下这样： |  |\n|  | >>> a_tuple = (['foo'], 'bar')\n>>> a_tuple[0] += ['item']\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment |  |\n|  | 这时触发异常会令人略感惊讶，更让人吃惊的是虽有报错，但加法操作却生效了： |  |\n|  | >>> a_tuple[0]\n['foo', 'item'] |  |\n|  | 要明白为什么会这样，你需要知道 (a) 如果一个对象实现了 __iadd__() 魔术方法，那么它就会在执\n行 += 增强赋值时被调用，并且其返回值将在赋值语句中被使用；(b) 对于列表而言，__iadd__()\n等价于在列表上调用 extend() 并返回该列表。 所以对于列表我们可以这样说，+= 就是\nlist.extend() 的“快捷方式”: |  |\n|  | >>> a_list = []\n>>> a_list += [1]\n>>> a_list\n[1] |  |\n|  | 这相当于： |  |\n|  | >>> result = a_list.__iadd__([1])\n>>> a_list = result |  |\n|  |  |  |\n\na_list 所引用的对象已被修改，而引用被修改对象的指针又重新被赋值给 a_list。 赋值的最终结果\n没有变化，因为它是引用 a_list 之前所引用的同一对象的指针，但仍然发生了赋值操作。\n因此，在此元组示例中，发生的事情等同于：\n>>> result = a_tuple[0].__iadd__(['item'])\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\n__iadd__() 执行成功，因此列表得到了扩充，但是即使 result 是指向 a_tuple[0] 所指向的同一\n个对象，最后的赋值仍然会导致错误，因为元组是不可变的。\n我想做一个复杂的排序：能用 Python 进行施瓦茨变换吗？\n归功于 Perl 社区的 Randal Schwartz，该技术根据度量值对列表进行排序，该度量值将每个元素映射\n为“顺序值”。在 Python 中，请利用 list.sort() 方法的 key 参数：\nIsorted = L[:]\nIsorted.sort(key=lambda s: int(s[10:15]))\n如何根据另一个列表的值对某列表进行排序？\n将它们合并到元组的迭代器中，对结果列表进行排序，然后选择所需的元素。\n>>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n>>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n>>> pairs = zip(list1, list2)\n>>> pairs = sorted(pairs)\n>>> pairs\n[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n>>> result = [x[1] for x in pairs]\n>>> result\n['else', 'sort', 'to', 'something']\n对象\n什么是类？\n类是通过执行 class 语句创建的某种对象的类型。创建实例对象时，用 Class 对象作为模板，实例对\n象既包含了数据（属性），又包含了数据类型特有的代码（方法）。\n类可以基于一个或多个其他类（称之为基类）进行创建。基类的属性和方法都得以继承。这样对象\n模型就可以通过继承不断地进行细化。比如通用的 Mailbox 类提供了邮箱的基本访问方法.，它的子\n类 MboxMailbox、 MaildirMailbox、 OutlookMailbox 则能够处理各种特定的邮箱格式。\n什么是方法？\n方法是属于对象的函数，对于对象 x ，通常以 x.name(arguments...) 的形式调用。方法以函数的\n形式给出定义，位于类的定义内：\n\n|  | a_list 所引用的对象已被修改，而引用被修改对象的指针又重新被赋值给 a_list。 赋值的最终结果\n没有变化，因为它是引用 a_list 之前所引用的同一对象的指针，但仍然发生了赋值操作。\n因此，在此元组示例中，发生的事情等同于： |  |\n| --- | --- | --- |\n|  | >>> result = a_tuple[0].__iadd__(['item'])\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment |  |\n|  | __iadd__() 执行成功，因此列表得到了扩充，但是即使 result 是指向 a_tuple[0] 所指向的同一\n个对象，最后的赋值仍然会导致错误，因为元组是不可变的。\n我想做一个复杂的排序：能用 Python 进行施瓦茨变换吗？\n归功于 Perl 社区的 Randal Schwartz，该技术根据度量值对列表进行排序，该度量值将每个元素映射\n为“顺序值”。在 Python 中，请利用 list.sort() 方法的 key 参数： |  |\n|  | Isorted = L[:]\nIsorted.sort(key=lambda s: int(s[10:15])) |  |\n|  | 如何根据另一个列表的值对某列表进行排序？\n将它们合并到元组的迭代器中，对结果列表进行排序，然后选择所需的元素。 |  |\n|  | >>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n>>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n>>> pairs = zip(list1, list2)\n>>> pairs = sorted(pairs)\n>>> pairs\n[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n>>> result = [x[1] for x in pairs]\n>>> result\n['else', 'sort', 'to', 'something'] |  |\n|  | 对象\n什么是类？\n类是通过执行 class 语句创建的某种对象的类型。创建实例对象时，用 Class 对象作为模板，实例对\n象既包含了数据（属性），又包含了数据类型特有的代码（方法）。\n类可以基于一个或多个其他类（称之为基类）进行创建。基类的属性和方法都得以继承。这样对象\n模型就可以通过继承不断地进行细化。比如通用的 Mailbox 类提供了邮箱的基本访问方法.，它的子\n类 MboxMailbox、 MaildirMailbox、 OutlookMailbox 则能够处理各种特定的邮箱格式。\n什么是方法？\n方法是属于对象的函数，对于对象 x ，通常以 x.name(arguments...) 的形式调用。方法以函数的\n形式给出定义，位于类的定义内： |  |\n\nclass C:\ndef meth(self, arg):\nreturn arg * 2 + self.attribute\n什么是 self ？\nSelf 只是方法的第一个参数的习惯性名称。假定某个类中有个方法定义为 meth(self, a, b, c) ，\n则其实例 x 应以 x.meth(a, b, c) 的形式进行调用；而被调用的方法则应视其为做了 meth(x, a,\nb, c) 形式的调用。\n另请参阅 为什么必须在方法定义和调用中显式使用“self”？ 。\n如何检查对象是否为给定类或其子类的一个实例？\n使用内置函数 isinstance(obj, cls)。 你可以检测对象是否属于多个类中的某一个的实例，只要\n提供一个元组而非单个类即可，如 isinstance(obj, (class1, class2, ...))，还可以检测对象\n是否属于 Python 的某个内置类型，如 isinstance(obj, str) 或 isinstance(obj, (int,\nfloat, complex))。\n请注意 isinstance() 还会检测派生自 abstract base class 的虚继承。 因此对于已注册的类，即便\n没有直接或间接继承自抽象基类，对抽象基类的检测都将返回 True 。要想检测“真正的继承”，请扫\n描类的 MRO:\nfrom collections.abc import Mapping\nclass P:\npass\nclass C(P):\npass\nMapping.register(P)\n>>> c = C()\n>>> isinstance(c, C) # 直接\nTrue\n>>> isinstance(c, P) # 间接\nTrue\n>>> isinstance(c, Mapping) # 虚拟\nTrue\n# 实际的继承链\n>>> type(c).__mro__\n(<class 'C'>, <class 'P'>, <class 'object'>)\n# 测试“真正的继承”\n>>> Mapping in type(c).__mro__\nFalse\n请注意，大多数程序不会经常用 isinstance() 对用户自定义类进行检测。 如果是自已开发的类，\n更合适的面向对象编程风格应该是在类中定义多种方法，以封装特定的行为，而不是检查对象属于\n什么类再据此干不同的事。假定有如下执行某些操作的函数:\n\n|  |  |  | class C:\ndef meth(self, arg):\nreturn arg * 2 + self.attribute |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | 什么是 self ？\nSelf 只是方法的第一个参数的习惯性名称。假定某个类中有个方法定义为 meth(self, a, b, c) ，\n则其实例 x 应以 x.meth(a, b, c) 的形式进行调用；而被调用的方法则应视其为做了 meth(x, a,\nb, c) 形式的调用。\n另请参阅 为什么必须在方法定义和调用中显式使用“self”？ 。\n如何检查对象是否为给定类或其子类的一个实例？\n使用内置函数 isinstance(obj, cls)。 你可以检测对象是否属于多个类中的某一个的实例，只要\n提供一个元组而非单个类即可，如 isinstance(obj, (class1, class2, ...))，还可以检测对象\n是否属于 Python 的某个内置类型，如 isinstance(obj, str) 或 isinstance(obj, (int,\nfloat, complex))。\n请注意 isinstance() 还会检测派生自 abstract base class 的虚继承。 因此对于已注册的类，即便\n没有直接或间接继承自抽象基类，对抽象基类的检测都将返回 True 。要想检测“真正的继承”，请扫\n描类的 MRO: |  |  |  |  |\n|  |  |  |  |  | meth(x, a, |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | b, c) |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  | isinstance(obj, (int, |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | float, complex)) |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | from collections.abc import Mapping\nclass P:\npass\nclass C(P):\npass\nMapping.register(P) |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  | >>> c = C()\n>>> isinstance(c, C) # 直接\nTrue\n>>> isinstance(c, P) # 间接\nTrue\n>>> isinstance(c, Mapping) # 虚拟\nTrue\n# 实际的继承链\n>>> type(c).__mro__\n(<class 'C'>, <class 'P'>, <class 'object'>)\n# 测试“真正的继承”\n>>> Mapping in type(c).__mro__\nFalse |  |  |  |  |\n|  |  |  | 请注意，大多数程序不会经常用 isinstance() 对用户自定义类进行检测。 如果是自已开发的类，\n更合适的面向对象编程风格应该是在类中定义多种方法，以封装特定的行为，而不是检查对象属于\n什么类再据此干不同的事。假定有如下执行某些操作的函数: |  |  |  |  |\n\ndef search(obj):\nif isinstance(obj, Mailbox):\n... # 搜索邮箱的代码\nelif isinstance(obj, Document):\n... # 搜索文档的代码\nelif ...\n更好的方法是在所有类上定义一个 search() 方法，然后调用它：\nclass Mailbox:\ndef search(self):\n... # 搜索邮箱的代码\nclass Document:\ndef search(self):\n... # 搜索文档的代码\nobj.search()\n什么是委托？\n委托是一种面向对象的技术（也称为设计模式）。假设对象 x 已经存在，现在想要改变其某个方法\n的行为。可以创建一个新类，其中提供了所需修改方法的新实现，而将所有其他方法都委托给 x 的\n对应方法。\nPython 程序员可以轻松实现委托。比如以下实现了一个类似于文件的类，只是会把所有写入的数据\n转换为大写：\nclass UpperOut:\ndef __init__(self, outfile):\nself._outfile = outfile\ndef write(self, s):\nself._outfile.write(s.upper())\ndef __getattr__(self, name):\nreturn getattr(self._outfile, name)\n这里 UpperOut 类重新定义了 write() 方法，在调用下层的 self._outfile.write() 方法之前将\n参数字符串转换为大写形式。 所有其他方法都被委托给下层的 self._outfile 对象。 委托是通过\n__getattr__() 方法完成的；请参阅 语言参考 了解有关控制属性访问的更多信息。\n请注意在更一般的情况下委托可能会变得比较棘手。 当属性即需要被设置又需要被提取时，类还必\n须定义 __setattr__() 方法，而这样做必须十分小心。 __setattr__() 的基本实现大致如下所示:\nclass X:\n...\ndef __setattr__(self, name, value):\nself.__dict__[name] = value\n...\n\n|  | def search(obj):\nif isinstance(obj, Mailbox):\n... # 搜索邮箱的代码\nelif isinstance(obj, Document):\n... # 搜索文档的代码\nelif ... |  |\n| --- | --- | --- |\n|  | 更好的方法是在所有类上定义一个 search() 方法，然后调用它： |  |\n|  | class Mailbox:\ndef search(self):\n... # 搜索邮箱的代码\nclass Document:\ndef search(self):\n... # 搜索文档的代码\nobj.search() |  |\n|  | 什么是委托？\n委托是一种面向对象的技术（也称为设计模式）。假设对象 x 已经存在，现在想要改变其某个方法\n的行为。可以创建一个新类，其中提供了所需修改方法的新实现，而将所有其他方法都委托给 x 的\n对应方法。\nPython 程序员可以轻松实现委托。比如以下实现了一个类似于文件的类，只是会把所有写入的数据\n转换为大写： |  |\n|  | class UpperOut:\ndef __init__(self, outfile):\nself._outfile = outfile\ndef write(self, s):\nself._outfile.write(s.upper())\ndef __getattr__(self, name):\nreturn getattr(self._outfile, name) |  |\n|  | 这里 UpperOut 类重新定义了 write() 方法，在调用下层的 self._outfile.write() 方法之前将\n参数字符串转换为大写形式。 所有其他方法都被委托给下层的 self._outfile 对象。 委托是通过\n__getattr__() 方法完成的；请参阅 语言参考 了解有关控制属性访问的更多信息。\n请注意在更一般的情况下委托可能会变得比较棘手。 当属性即需要被设置又需要被提取时，类还必\n须定义 __setattr__() 方法，而这样做必须十分小心。 __setattr__() 的基本实现大致如下所示: |  |\n|  | class X:\n...\ndef __setattr__(self, name, value):\nself.__dict__[name] = value\n... |  |\n|  |  |  |\n\n许多 __setattr__() 实现都会调用 object.__setattr__() 在 self 上设置属性 ，而不会导致无限\n递归:\nclass X:\ndef __setattr__(self, name, value):\n# 这里添加自定义的逻辑...\nobject.__setattr__(self, name, value)\n另外，也可以通过直接在 self.__dict__ 中插入条目来设置属性 。\n如何在扩展基类的派生类中调用基类中定义的方法？\n使用内置的 super() 函数：\nclass Derived(Base):\ndef meth(self):\nsuper().meth() # 调用 Base.meth\n在下面的例子中，super() 将自动根据它的调用方 (self 值) 来确定实例对象，使用\ntype(self).__mro__ 查找 method resolution order (MRO)，并返回 MRO 中位于 Derived 之后的\n项: Base。\n如何让代码更容易对基类进行修改？\n可以为基类赋一个别名并基于该别名进行派生。这样只要修改赋给该别名的值即可。顺便提一下，\n如要动态地确定（例如根据可用的资源）该使用哪个基类，这个技巧也非常方便。例如：\nclass Base:\n...\nBaseAlias = Base\nclass Derived(BaseAlias):\n...\n如何创建静态类数据和静态类方法？\nPython 支持静态数据和静态方法（以 C++ 或 Java 的定义而言）。\n静态数据只需定义一个类属性即可。若要为属性赋新值，则必须在赋值时显式使用类名：\nclass C:\ncount = 0 # C.__init__ 被调用的次数\ndef __init__(self):\nC.count = C.count + 1\ndef getcount(self):\nreturn C.count # 或返回 self.count\n对于所有符合 isinstance(c, C) 的 c， c.count 也同样指向 C.count ，除非被 c 自身或者被从\nc.__class__ 回溯到基类 C 的搜索路径上的某个类所覆盖。\n\n|  | 许多 __setattr__() 实现都会调用 object.__setattr__() 在 self 上设置属性 ，而不会导致无限\n递归: |  |\n| --- | --- | --- |\n|  | class X:\ndef __setattr__(self, name, value):\n# 这里添加自定义的逻辑...\nobject.__setattr__(self, name, value) |  |\n|  | 另外，也可以通过直接在 self.__dict__ 中插入条目来设置属性 。\n如何在扩展基类的派生类中调用基类中定义的方法？\n使用内置的 super() 函数： |  |\n|  | class Derived(Base):\ndef meth(self):\nsuper().meth() # 调用 Base.meth |  |\n|  | 在下面的例子中，super() 将自动根据它的调用方 (self 值) 来确定实例对象，使用\ntype(self).__mro__ 查找 method resolution order (MRO)，并返回 MRO 中位于 Derived 之后的\n项: Base。\n如何让代码更容易对基类进行修改？\n可以为基类赋一个别名并基于该别名进行派生。这样只要修改赋给该别名的值即可。顺便提一下，\n如要动态地确定（例如根据可用的资源）该使用哪个基类，这个技巧也非常方便。例如： |  |\n|  | class Base:\n...\nBaseAlias = Base\nclass Derived(BaseAlias):\n... |  |\n|  | 如何创建静态类数据和静态类方法？\nPython 支持静态数据和静态方法（以 C++ 或 Java 的定义而言）。\n静态数据只需定义一个类属性即可。若要为属性赋新值，则必须在赋值时显式使用类名： |  |\n|  | class C:\ncount = 0 # C.__init__ 被调用的次数\ndef __init__(self):\nC.count = C.count + 1\ndef getcount(self):\nreturn C.count # 或返回 self.count |  |\n|  | 对于所有符合 isinstance(c, C) 的 c， c.count 也同样指向 C.count ，除非被 c 自身或者被从\nc.__class__ 回溯到基类 C 的搜索路径上的某个类所覆盖。 |  |\n\n注意：在 C 的某个方法内部，像 self.count = 42 这样的赋值将在 self 自身的字典中新建一个名\n为 \"count\" 的不相关实例。 想要重新绑定类静态数据名称就必须总是指明类名，无论是在方法内部\n还是外部:\nC.count = 314\nPython 支持静态方法：\nclass C:\n@staticmethod\ndef static(arg1, arg2, arg3):\n# 没有 'self' 形参！\n...\n不过为了获得静态方法的效果，还有一种做法直接得多，也即使用模块级函数即可：\ndef getcount():\nreturn C.count\n如果代码的结构化比较充分，每个模块只定义了一个类（或者多个类的层次关系密切相关），那就\n具备了应有的封装。\n在 Python 中如何重载构造函数（或方法）？\n这个答案实际上适用于所有方法，但问题通常首先出现于构造函数的应用场景中。\n在 C++ 中，代码会如下所示：\nclass C {\nC() { cout << \"No arguments\\n\"; }\nC(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n}\n在 Python 中，只能编写一个构造函数，并用默认参数捕获所有情况。例如：\nclass C:\ndef __init__(self, i=None):\nif i is None:\nprint(\"No arguments\")\nelse:\nprint(\"Argument is\", i)\n这不完全等同，但在实践中足够接近。\n也可以试试采用变长参数列表，例如：\ndef __init__(self, *args):\n...\n上述做法同样适用于所有方法定义。\n在用 __spam 的时候得到一个类似 _SomeClassName__spam 的错误信息。\n\n|  | 注意：在 C 的某个方法内部，像 self.count = 42 这样的赋值将在 self 自身的字典中新建一个名\n为 \"count\" 的不相关实例。 想要重新绑定类静态数据名称就必须总是指明类名，无论是在方法内部\n还是外部: |  |\n| --- | --- | --- |\n|  | C.count = 314 |  |\n|  | Python 支持静态方法： |  |\n|  | class C:\n@staticmethod\ndef static(arg1, arg2, arg3):\n# 没有 'self' 形参！\n... |  |\n|  | 不过为了获得静态方法的效果，还有一种做法直接得多，也即使用模块级函数即可： |  |\n|  | def getcount():\nreturn C.count |  |\n|  | 如果代码的结构化比较充分，每个模块只定义了一个类（或者多个类的层次关系密切相关），那就\n具备了应有的封装。\n在 Python 中如何重载构造函数（或方法）？\n这个答案实际上适用于所有方法，但问题通常首先出现于构造函数的应用场景中。\n在 C++ 中，代码会如下所示： |  |\n|  | class C {\nC() { cout << \"No arguments\\n\"; }\nC(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n} |  |\n|  | 在 Python 中，只能编写一个构造函数，并用默认参数捕获所有情况。例如： |  |\n|  | class C:\ndef __init__(self, i=None):\nif i is None:\nprint(\"No arguments\")\nelse:\nprint(\"Argument is\", i) |  |\n|  | 这不完全等同，但在实践中足够接近。\n也可以试试采用变长参数列表，例如： |  |\n|  | def __init__(self, *args):\n... |  |\n|  | 上述做法同样适用于所有方法定义。\n在用 __spam 的时候得到一个类似 _SomeClassName__spam 的错误信息。 |  |\n\n以双下划线打头的变量名会被“破坏”，以便以一种简单高效的方式定义类私有变量。任何形式为\n__spam 的标识符（至少前缀两个下划线，至多后缀一个下划线）文本均会被替换为\n_classname__spam，其中 classname 为去除了全部前缀下划线的当前类名称。\n标识符可以在类的内部不加改变地使用，但要在类的外部访问它，就必须使用被混淆的名称：\nclass A:\ndef __one(self):\nreturn 1\ndef two(self):\nreturn 2 * self.__one()\nclass B(A):\ndef three(self):\nreturn 3 * self._A__one()\nfour = 4 * A()._A__one()\n需要特别指出，这并不能保证私密性因为外部用户仍然可以有意地访问私有属性；许多 Python 程序\n员根本就不屑于使用私有变量名。\n参见: 私有名称调整规范说明 了解相关详情和特例。\n类定义了 __del__ 方法，但是删除对象时没有调用它。\n这有几个可能的原因。\ndel 语句不一定要调用 __del__() -- 它只是减少对象的引用计数，如果计数达到零才会调用\n__del__()。\n如果你的数据结构包含循环链接（如树每个子节点都带有父节点的引用，而每个父节点也带有子节\n点的列表），引用计数永远不会回零。 尽管 Python 偶尔会用某种算法检测这种循环引用，但在数\n据结构的最后一条引用消失之后，垃圾收集器可能还要过段时间才会运行，因此 __del__() 方法可\n能会在不方便或随机的时刻被调用。 这对于重现一个问题是非常不方便的。 更糟糕的是，各个对象\n的 __del__() 方法是以随机顺序执行的。 虽然你可以运行 gc.collect() 来强制执行垃圾回收操\n作，但 仍会存在 一些对象永远不会被回收的失控情况。\n尽管有垃圾回收器，但当对象使用完毕时在要调用的对象上定义显式的 close() 方法仍然是个好主\n意。 close() 方法可以随后移除引用子对象的属性。 请不要直接调用 __del__() -- __del__() 应\n当调用 close() 并且 close() 应当确保被可以被同一对象多次调用。\n另一种避免循环引用的做法是利用 weakref 模块，该模块允许指向对象但不增加其引用计数。例\n如，树状数据结构应该对父节点和同级节点使用弱引用（如果真要用的话！）\n最后，如果你的 __del__() 方法引发了异常，会将警告消息打印到 sys.stderr。\n如何获取给定类的所有实例的列表？\n\n|  | 以双下划线打头的变量名会被“破坏”，以便以一种简单高效的方式定义类私有变量。任何形式为\n__spam 的标识符（至少前缀两个下划线，至多后缀一个下划线）文本均会被替换为\n_classname__spam，其中 classname 为去除了全部前缀下划线的当前类名称。\n标识符可以在类的内部不加改变地使用，但要在类的外部访问它，就必须使用被混淆的名称： |  |\n| --- | --- | --- |\n|  | class A:\ndef __one(self):\nreturn 1\ndef two(self):\nreturn 2 * self.__one()\nclass B(A):\ndef three(self):\nreturn 3 * self._A__one()\nfour = 4 * A()._A__one() |  |\n|  | 需要特别指出，这并不能保证私密性因为外部用户仍然可以有意地访问私有属性；许多 Python 程序\n员根本就不屑于使用私有变量名。 |  |\n|  | 参见: 私有名称调整规范说明 了解相关详情和特例。 |  |\n|  | 类定义了 __del__ 方法，但是删除对象时没有调用它。\n这有几个可能的原因。\ndel 语句不一定要调用 __del__() -- 它只是减少对象的引用计数，如果计数达到零才会调用\n__del__()。\n如果你的数据结构包含循环链接（如树每个子节点都带有父节点的引用，而每个父节点也带有子节\n点的列表），引用计数永远不会回零。 尽管 Python 偶尔会用某种算法检测这种循环引用，但在数\n据结构的最后一条引用消失之后，垃圾收集器可能还要过段时间才会运行，因此 __del__() 方法可\n能会在不方便或随机的时刻被调用。 这对于重现一个问题是非常不方便的。 更糟糕的是，各个对象\n的 __del__() 方法是以随机顺序执行的。 虽然你可以运行 gc.collect() 来强制执行垃圾回收操\n作，但 仍会存在 一些对象永远不会被回收的失控情况。\n尽管有垃圾回收器，但当对象使用完毕时在要调用的对象上定义显式的 close() 方法仍然是个好主\n意。 close() 方法可以随后移除引用子对象的属性。 请不要直接调用 __del__() -- __del__() 应\n当调用 close() 并且 close() 应当确保被可以被同一对象多次调用。\n另一种避免循环引用的做法是利用 weakref 模块，该模块允许指向对象但不增加其引用计数。例\n如，树状数据结构应该对父节点和同级节点使用弱引用（如果真要用的话！）\n最后，如果你的 __del__() 方法引发了异常，会将警告消息打印到 sys.stderr。\n如何获取给定类的所有实例的列表？ |  |\n\nPython 不会记录类（或内置类型）的实例。可以在类的构造函数中编写代码，通过保留每个实例的\n弱引用列表来跟踪所有实例。\n为什么 id() 的结果看起来不是唯一的？\nid() 返回一个整数，该整数在对象的生命周期内保证是唯一的。 因为在 CPython 中，这是对象的\n内存地址，所以经常发生在从内存中删除对象之后，下一个新创建的对象被分配在内存中的相同位\n置。 这个例子说明了这一点：\n>>> id(1000)\n13901272\n>>> id(2000)\n13901272\n这两个 id 属于不同的整数对象，之前先创建了对象，执行 id() 调用后又立即被删除了。若要确保\n检测 id 时的对象仍处于活动状态，请再创建一个对该对象的引用：\n>>> a = 1000; b = 2000\n>>> id(a)\n13901272\n>>> id(b)\n13891296\n什么情况下可以依靠 is 运算符进行对象的身份相等性测试？\nis 运算符可用于测试对象的身份相等性。a is b 等价于 id(a) == id(b)。\n身份相等性最重要的特性就是对象总是等同于自身，a is a 一定返回 True。身份相等性测试的速\n度通常比相等性测试要快。而且与相等性测试不一样，身份相等性测试会确保返回布尔值 True 或\nFalse。\n但是，身份相等性测试 只能 在对象身份确定的场景下才可替代相等性测试。一般来说，有以下3种\n情况对象身份是可以确定的：\n1. 赋值操作将创建新的名称但不会改变对象标识号。 在赋值操作 new = old 之后，可以保证\nnew is old。\n2. 将对象放入存储对象引用的容器不会改变对象的标识号。 在列表赋值操作 s[0] = x 之后，\n将可保证 s[0] is x。\n3. 如果一个对象是单例，则意味着该对象只能存在一个实例。 在赋值操作 a = None 和 b =\nNone 之后，可以保证 a is b 因为 None 是单例对象。\n其他大多数情况下，都不建议使用身份相等性测试，而应采用相等性测试。尤其是不应将身份相等\n性测试用于检测常量值，例如 int 和 str，因为他们并不一定是单例对象：\n>>> a = 1000\n>>> b = 500\n>>> c = b + 500\n>>> a is c\nFalse\n\n|  | Python 不会记录类（或内置类型）的实例。可以在类的构造函数中编写代码，通过保留每个实例的\n弱引用列表来跟踪所有实例。\n为什么 id() 的结果看起来不是唯一的？\nid() 返回一个整数，该整数在对象的生命周期内保证是唯一的。 因为在 CPython 中，这是对象的\n内存地址，所以经常发生在从内存中删除对象之后，下一个新创建的对象被分配在内存中的相同位\n置。 这个例子说明了这一点： |  |\n| --- | --- | --- |\n|  | >>> id(1000)\n13901272\n>>> id(2000)\n13901272 |  |\n|  | 这两个 id 属于不同的整数对象，之前先创建了对象，执行 id() 调用后又立即被删除了。若要确保\n检测 id 时的对象仍处于活动状态，请再创建一个对该对象的引用： |  |\n|  | >>> a = 1000; b = 2000\n>>> id(a)\n13901272\n>>> id(b)\n13891296 |  |\n|  | 什么情况下可以依靠 is 运算符进行对象的身份相等性测试？\nis 运算符可用于测试对象的身份相等性。a is b 等价于 id(a) == id(b)。\n身份相等性最重要的特性就是对象总是等同于自身，a is a 一定返回 True。身份相等性测试的速\n度通常比相等性测试要快。而且与相等性测试不一样，身份相等性测试会确保返回布尔值 True 或\nFalse。\n但是，身份相等性测试 只能 在对象身份确定的场景下才可替代相等性测试。一般来说，有以下3种\n情况对象身份是可以确定的：\n1. 赋值操作将创建新的名称但不会改变对象标识号。 在赋值操作 new = old 之后，可以保证\nnew is old。\n2. 将对象放入存储对象引用的容器不会改变对象的标识号。 在列表赋值操作 s[0] = x 之后，\n将可保证 s[0] is x。\n3. 如果一个对象是单例，则意味着该对象只能存在一个实例。 在赋值操作 a = None 和 b =\nNone 之后，可以保证 a is b 因为 None 是单例对象。\n其他大多数情况下，都不建议使用身份相等性测试，而应采用相等性测试。尤其是不应将身份相等\n性测试用于检测常量值，例如 int 和 str，因为他们并不一定是单例对象： |  |\n|  | >>> a = 1000\n>>> b = 500\n>>> c = b + 500\n>>> a is c\nFalse |  |\n\n| b = |  |\n| --- | --- |\n\n>>> a = 'Python'\n>>> b = 'Py'\n>>> c = b + 'thon'\n>>> a is c\nFalse\n同样地，可变容器的新实例，对象身份一定不同：\n>>> a = []\n>>> b = []\n>>> a is b\nFalse\n在标准库代码中，给出了一些正确使用对象身份测试的常见模式：\n1. 正如 PEP 8 所建议的，标识测试是检查 None 的推荐方式。 这样的代码读起来就像直白的英\n语并可避免与具有结果为假的布尔值的对象相混淆。\n2. 当 None 是一个有效的输入值时检查可选参数会有点麻烦。 在这些情况下，你可以创建一个\n保证与其他对象不同的单例哨兵对象。 例如，以下代码演示了如何实现一个行为与\ndict.pop() 类似的方法：\n_sentinel = object()\ndef pop(self, key, default=_sentinel):\nif key in self:\nvalue = self[key]\ndel self[key]\nreturn value\nif default is _sentinel:\nraise KeyError(key)\nreturn default\n3. 容器的实现有时需要用标识测试来增强相等性测试。 这样可以防止代码被 float('NaN') 这\n类不等于自身的对象所干扰。\n例如，以下是 collections.abc.Sequence.__contains__() 的实现代码:\ndef __contains__(self, value):\nfor v in self:\nif v is value or v == value:\nreturn True\nreturn False\n一个子类如何控制哪些数据被存储在一个不可变的实例中？\n当子类化一个不可变类型时，请重写 __new__() 方法而不是 __init__() 方法。 后者只在一个实例\n被创建 之后 运行，这对于改变不可变实例中的数据来说太晚了。\n所有这些不可变的类都有一个与它们的父类不同的签名:\nfrom datetime import date\n\n|  | >>> a = 'Python'\n>>> b = 'Py'\n>>> c = b + 'thon'\n>>> a is c\nFalse |  |\n| --- | --- | --- |\n|  | 同样地，可变容器的新实例，对象身份一定不同： |  |\n|  | >>> a = []\n>>> b = []\n>>> a is b\nFalse |  |\n|  | 在标准库代码中，给出了一些正确使用对象身份测试的常见模式：\n1. 正如 PEP 8 所建议的，标识测试是检查 None 的推荐方式。 这样的代码读起来就像直白的英\n语并可避免与具有结果为假的布尔值的对象相混淆。\n2. 当 None 是一个有效的输入值时检查可选参数会有点麻烦。 在这些情况下，你可以创建一个\n保证与其他对象不同的单例哨兵对象。 例如，以下代码演示了如何实现一个行为与\ndict.pop() 类似的方法：\n_sentinel = object()\ndef pop(self, key, default=_sentinel):\nif key in self:\nvalue = self[key]\ndel self[key]\nreturn value\nif default is _sentinel:\nraise KeyError(key)\nreturn default\n3. 容器的实现有时需要用标识测试来增强相等性测试。 这样可以防止代码被 float('NaN') 这\n类不等于自身的对象所干扰。\n例如，以下是 collections.abc.Sequence.__contains__() 的实现代码: |  |\n|  | def __contains__(self, value):\nfor v in self:\nif v is value or v == value:\nreturn True\nreturn False |  |\n|  | 一个子类如何控制哪些数据被存储在一个不可变的实例中？\n当子类化一个不可变类型时，请重写 __new__() 方法而不是 __init__() 方法。 后者只在一个实例\n被创建 之后 运行，这对于改变不可变实例中的数据来说太晚了。\n所有这些不可变的类都有一个与它们的父类不同的签名: |  |\n|  | from datetime import date |  |\n\nclass FirstOfMonthDate(date):\n\"Always choose the first day of the month\"\ndef __new__(cls, year, month, day):\nreturn super().__new__(cls, year, month, 1)\nclass NamedInt(int):\n\"Allow text names for some numbers\"\nxlat = {'zero': 0, 'one': 1, 'ten': 10}\ndef __new__(cls, value):\nvalue = cls.xlat.get(value, value)\nreturn super().__new__(cls, value)\nclass TitleStr(str):\n\"Convert str to name suitable for a URL path\"\ndef __new__(cls, s):\ns = s.lower().replace(' ', '-')\ns = ''.join([c for c in s if c.isalnum() or c == '-'])\nreturn super().__new__(cls, s)\n这些类可以这样使用:\n>>> FirstOfMonthDate(2012, 2, 14)\nFirstOfMonthDate(2012, 2, 1)\n>>> NamedInt('ten')\n10\n>>> NamedInt(20)\n20\n>>> TitleStr('Blog: Why Python Rocks')\n'blog-why-python-rocks'\n我该如何缓存方法调用？\n缓存方法的两个主要工具是 functools.cached_property() 和 functools.lru_cache()。 前者在\n实例层级上存储结果而后者在类层级上存储结果。\ncached_property 方式仅适用于不接受任何参数的方法。 它不会创建对实例的引用。 被缓存的方法\n结果将仅在实例的生存期内被保留。\n其优点是，当一个实例不再被使用时，缓存的方法结果将被立即释放。缺点是，如果实例累积起\n来，累积的方法结果也会增加。它们可以无限制地增长。\nlru_cache 方式适用于具有 hashable 参数的方法。 它会创建对实例的引用，除非特别设置了传入弱\n引用。\n最少近期使用算法的优点是缓存会受指定的 maxsize 限制。 它的缺点是实例会保持存活，直到其达\n到生存期或者缓存被清空。\n这个例子演示了几种不同的方式:\nclass Weather:\n\"Lookup weather information on a government website\"\ndef __init__(self, station_id):\nself._station_id = station_id\n# The _station_id is private and immutable\n\n|  | class FirstOfMonthDate(date):\n\"Always choose the first day of the month\"\ndef __new__(cls, year, month, day):\nreturn super().__new__(cls, year, month, 1)\nclass NamedInt(int):\n\"Allow text names for some numbers\"\nxlat = {'zero': 0, 'one': 1, 'ten': 10}\ndef __new__(cls, value):\nvalue = cls.xlat.get(value, value)\nreturn super().__new__(cls, value)\nclass TitleStr(str):\n\"Convert str to name suitable for a URL path\"\ndef __new__(cls, s):\ns = s.lower().replace(' ', '-')\ns = ''.join([c for c in s if c.isalnum() or c == '-'])\nreturn super().__new__(cls, s) |  |\n| --- | --- | --- |\n|  | 这些类可以这样使用: |  |\n|  | >>> FirstOfMonthDate(2012, 2, 14)\nFirstOfMonthDate(2012, 2, 1)\n>>> NamedInt('ten')\n10\n>>> NamedInt(20)\n20\n>>> TitleStr('Blog: Why Python Rocks')\n'blog-why-python-rocks' |  |\n|  | 我该如何缓存方法调用？\n缓存方法的两个主要工具是 functools.cached_property() 和 functools.lru_cache()。 前者在\n实例层级上存储结果而后者在类层级上存储结果。\ncached_property 方式仅适用于不接受任何参数的方法。 它不会创建对实例的引用。 被缓存的方法\n结果将仅在实例的生存期内被保留。\n其优点是，当一个实例不再被使用时，缓存的方法结果将被立即释放。缺点是，如果实例累积起\n来，累积的方法结果也会增加。它们可以无限制地增长。\nlru_cache 方式适用于具有 hashable 参数的方法。 它会创建对实例的引用，除非特别设置了传入弱\n引用。\n最少近期使用算法的优点是缓存会受指定的 maxsize 限制。 它的缺点是实例会保持存活，直到其达\n到生存期或者缓存被清空。\n这个例子演示了几种不同的方式: |  |\n|  | class Weather:\n\"Lookup weather information on a government website\"\ndef __init__(self, station_id):\nself._station_id = station_id\n# The _station_id is private and immutable |  |\n\ndef current_temperature(self):\n\"Latest hourly observation\"\n# Do not cache this because old results\n# can be out of date.\n@cached_property\ndef location(self):\n\"Return the longitude/latitude coordinates of the station\"\n# Result only depends on the station_id\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='mm'):\n\"Rainfall on a given date\"\n# 取决于 station_id、date 和 unit\n上面的例子假定 station_id 从不改变。 如果相关实例属性是可变对象，则 cached_property 方式就不\n再适用，因为它无法检测到属性的改变。\n要让 lru_cache 方式在 station_id 可变时仍然适用，类需要定义 __eq__() 和 __hash__() 方法以便\n缓存能检测到相关属性的更新:\nclass Weather:\n\"Example with a mutable station identifier\"\ndef __init__(self, station_id):\nself.station_id = station_id\ndef change_station(self, station_id):\nself.station_id = station_id\ndef __eq__(self, other):\nreturn self.station_id == other.station_id\ndef __hash__(self):\nreturn hash(self.station_id)\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='cm'):\n'Rainfall on a given date'\n# 取决于 station_id、date 和 unit\n模块\n如何创建 .pyc 文件？\n当首次导入模块时（或当前已编译文件创建之后源文件发生了改动），在 .py 文件所在目录的\n__pycache__ 子目录下会创建一个包含已编译代码的 .pyc 文件。该 .pyc 文件的名称开头部分将\n与 .py 文件名相同，并以 .pyc 为后缀，中间部分则依据创建它的 python 版本而各不相同。（详\n见 PEP 3147。）\n.pyc 文件有可能会无法创建，原因之一是源码文件所在的目录存在权限问题，这样就无法创建\n__pycache__ 子目录。假如以某个用户开发程序而以另一用户运行程序，就有可能发生权限问题，\n测试 Web 服务器就属于这种情况。\n\n|  | def current_temperature(self):\n\"Latest hourly observation\"\n# Do not cache this because old results\n# can be out of date.\n@cached_property\ndef location(self):\n\"Return the longitude/latitude coordinates of the station\"\n# Result only depends on the station_id\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='mm'):\n\"Rainfall on a given date\"\n# 取决于 station_id、date 和 unit |  |\n| --- | --- | --- |\n|  | 上面的例子假定 station_id 从不改变。 如果相关实例属性是可变对象，则 cached_property 方式就不\n再适用，因为它无法检测到属性的改变。\n要让 lru_cache 方式在 station_id 可变时仍然适用，类需要定义 __eq__() 和 __hash__() 方法以便\n缓存能检测到相关属性的更新: |  |\n|  | class Weather:\n\"Example with a mutable station identifier\"\ndef __init__(self, station_id):\nself.station_id = station_id\ndef change_station(self, station_id):\nself.station_id = station_id\ndef __eq__(self, other):\nreturn self.station_id == other.station_id\ndef __hash__(self):\nreturn hash(self.station_id)\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='cm'):\n'Rainfall on a given date'\n# 取决于 station_id、date 和 unit |  |\n|  | 模块\n如何创建 .pyc 文件？\n当首次导入模块时（或当前已编译文件创建之后源文件发生了改动），在 .py 文件所在目录的\n__pycache__ 子目录下会创建一个包含已编译代码的 .pyc 文件。该 .pyc 文件的名称开头部分将\n与 .py 文件名相同，并以 .pyc 为后缀，中间部分则依据创建它的 python 版本而各不相同。（详\n见 PEP 3147。）\n.pyc 文件有可能会无法创建，原因之一是源码文件所在的目录存在权限问题，这样就无法创建\n__pycache__ 子目录。假如以某个用户开发程序而以另一用户运行程序，就有可能发生权限问题，\n测试 Web 服务器就属于这种情况。 |  |\n\n除非设置了 PYTHONDONTWRITEBYTECODE 环境变量，否则导入模块并且 Python 能够创建\n__pycache__ 子目录并把已编译模块写入该子目录（权限、存储空间等等）时，.pyc 文件就将自动\n创建。\n在最高层级运行的 Python 脚本不会被视为经过了导入操作，因此不会创建 .pyc 文件。假定有一个\n最高层级的模块文件 foo.py，它导入了另一个模块 xyz.py，当运行 foo 模块（通过输入 shell 命\n令 python foo.py ），则会为 xyz 创建一个 .pyc，因为 xyz 是被导入的，但不会为 foo 创建\n.pyc 文件，因为 foo.py 不是被导入的。\n若要为 foo 创建 .pyc 文件 —— 即为未做导入的模块创建 .pyc 文件 —— 可以利用 py_compile\n和 compileall 模块。\npy_compile 模块能够手动编译任意模块。 一种做法是交互式地使用该模块中的 compile() 函数:\n>>> import py_compile\n>>> py_compile.compile('foo.py')\n这将会将 .pyc 文件写入与 foo.py 相同位置下的 __pycache__ 子目录（或者你也可以通过可选参\n数 cfile 来重写该行为）。\n还可以用 compileall 模块自动编译一个或多个目录下的所有文件。只要在命令行提示符中运行\ncompileall.py 并给出要编译的 Python 文件所在目录路径即可：\npython -m compileall .\n如何找到当前模块名称？\n模块可以查看预定义的全局变量 __name__ 获悉自己的名称。如其值为 '__main__' ，程序将作为\n脚本运行。通常，许多通过导入使用的模块同时也提供命令行接口或自检代码，这些代码只在检测\n到处于 __name__ 之后才会执行：\ndef main():\nprint('Running test...')\n...\nif __name__ == '__main__':\nmain()\n如何让模块相互导入？\n假设有以下模块：\nfoo.py:\nfrom bar import bar_var\nfoo_var = 1\nbar.py:\n\n|  | 除非设置了 PYTHONDONTWRITEBYTECODE 环境变量，否则导入模块并且 Python 能够创建\n__pycache__ 子目录并把已编译模块写入该子目录（权限、存储空间等等）时，.pyc 文件就将自动\n创建。\n在最高层级运行的 Python 脚本不会被视为经过了导入操作，因此不会创建 .pyc 文件。假定有一个\n最高层级的模块文件 foo.py，它导入了另一个模块 xyz.py，当运行 foo 模块（通过输入 shell 命\n令 python foo.py ），则会为 xyz 创建一个 .pyc，因为 xyz 是被导入的，但不会为 foo 创建\n.pyc 文件，因为 foo.py 不是被导入的。\n若要为 foo 创建 .pyc 文件 —— 即为未做导入的模块创建 .pyc 文件 —— 可以利用 py_compile\n和 compileall 模块。\npy_compile 模块能够手动编译任意模块。 一种做法是交互式地使用该模块中的 compile() 函数: |  |\n| --- | --- | --- |\n|  | >>> import py_compile\n>>> py_compile.compile('foo.py') |  |\n|  | 这将会将 .pyc 文件写入与 foo.py 相同位置下的 __pycache__ 子目录（或者你也可以通过可选参\n数 cfile 来重写该行为）。\n还可以用 compileall 模块自动编译一个或多个目录下的所有文件。只要在命令行提示符中运行\ncompileall.py 并给出要编译的 Python 文件所在目录路径即可： |  |\n|  | python -m compileall . |  |\n|  | 如何找到当前模块名称？\n模块可以查看预定义的全局变量 __name__ 获悉自己的名称。如其值为 '__main__' ，程序将作为\n脚本运行。通常，许多通过导入使用的模块同时也提供命令行接口或自检代码，这些代码只在检测\n到处于 __name__ 之后才会执行： |  |\n|  | def main():\nprint('Running test...')\n...\nif __name__ == '__main__':\nmain() |  |\n|  | 如何让模块相互导入？\n假设有以下模块：\nfoo.py: |  |\n|  | from bar import bar_var\nfoo_var = 1 |  |\n|  | bar.py: |  |\n\nfrom foo import foo_var\nbar_var = 2\n问题是解释器将执行以下步骤：\n首先导入 foo\n为 foo 创建空的全局变量\n编译 foo 并开始执行\nfoo 导入 bar\n为 bar 创建空的全局变量\n编译 bar 并开始执行\nbar 导入 foo (该步骤无操作，因为已经有一个名为 foo 的模块)。\n导入机制尝试从 foo_var 全局变量读取 foo，用来设置 bar.foo_var = foo.foo_var\n最后一步失败了，因为 Python 还没有完成对 foo 的解释，foo 的全局符号字典仍然是空的。\n当你使用 import foo ，然后尝试在全局代码中访问 foo.foo_var 时，会发生同样的事情。\n这个问题有（至少）三种可能的解决方法。\nGuido van Rossum 建议完全避免使用 from <module> import ... ，并将所有代码放在函数中。\n全局变量和类变量的初始化只应使用常量或内置函数。这意味着导入模块中的所有内容都以\n<module>.<name> 的形式引用。\nJim Roskind 建议每个模块都应遵循以下顺序：\n导出（全局变量、函数和不需要导入基类的类）\nimport 语句\n本模块的功能代码（包括根据导入值进行初始化的全局变量）。\nVan Rossum 不太喜欢这种方法，因为import出现在一个奇怪的地方，但它确实有效。\nMatthias Urlichs 建议对代码进行重构，使得递归导入根本就没必要发生。\n这些解决方案并不相互排斥。\n__import__('x.y.z') 返回的是 <module 'x'> ；该如何得到 z 呢？\n不妨考虑换用 importlib 中的函数 import_module() ：\nz = importlib.import_module('x.y.z')\n对已导入的模块进行了编辑并重新导入，但变动没有得以体现。这是为什么？\n出于效率和一致性的原因，Python 仅在第一次导入模块时读取模块文件。否则，在一个多模块的程\n序中，每个模块都会导入相同的基础模块，那么基础模块将会被一而再、再而三地解析。如果要强\n行重新读取已更改的模块，请执行以下操作：\n\n|  | from foo import foo_var\nbar_var = 2 |  |\n| --- | --- | --- |\n|  | 问题是解释器将执行以下步骤：\n首先导入 foo\n为 foo 创建空的全局变量\n编译 foo 并开始执行\nfoo 导入 bar\n为 bar 创建空的全局变量\n编译 bar 并开始执行\nbar 导入 foo (该步骤无操作，因为已经有一个名为 foo 的模块)。\n导入机制尝试从 foo_var 全局变量读取 foo，用来设置 bar.foo_var = foo.foo_var\n最后一步失败了，因为 Python 还没有完成对 foo 的解释，foo 的全局符号字典仍然是空的。\n当你使用 import foo ，然后尝试在全局代码中访问 foo.foo_var 时，会发生同样的事情。\n这个问题有（至少）三种可能的解决方法。\nGuido van Rossum 建议完全避免使用 from <module> import ... ，并将所有代码放在函数中。\n全局变量和类变量的初始化只应使用常量或内置函数。这意味着导入模块中的所有内容都以\n<module>.<name> 的形式引用。\nJim Roskind 建议每个模块都应遵循以下顺序：\n导出（全局变量、函数和不需要导入基类的类）\nimport 语句\n本模块的功能代码（包括根据导入值进行初始化的全局变量）。\nVan Rossum 不太喜欢这种方法，因为import出现在一个奇怪的地方，但它确实有效。\nMatthias Urlichs 建议对代码进行重构，使得递归导入根本就没必要发生。\n这些解决方案并不相互排斥。\n__import__('x.y.z') 返回的是 <module 'x'> ；该如何得到 z 呢？\n不妨考虑换用 importlib 中的函数 import_module() ： |  |\n|  | z = importlib.import_module('x.y.z') |  |\n|  | 对已导入的模块进行了编辑并重新导入，但变动没有得以体现。这是为什么？\n出于效率和一致性的原因，Python 仅在第一次导入模块时读取模块文件。否则，在一个多模块的程\n序中，每个模块都会导入相同的基础模块，那么基础模块将会被一而再、再而三地解析。如果要强\n行重新读取已更改的模块，请执行以下操作： |  |\n\nimport importlib\nimport modname\nimportlib.reload(modname)\n警告：这种技术并非万无一失。尤其是模块包含了以下语句时：\nfrom modname import some_objects\n仍将继续使用前一版的导入对象。如果模块包含了类的定义，并 不会 用新的类定义更新现有的类实\n例。这样可能会导致以下矛盾的行为：\n>>> import importlib\n>>> import cls\n>>> c = cls.C() # Create an instance of C\n>>> importlib.reload(cls)\n<module 'cls' from 'cls.py'>\n>>> isinstance(c, cls.C) # isinstance is false?!?\nFalse\n只要把类对象的 id 打印出来，问题的性质就会一目了然：\n>>> hex(id(c.__class__))\n'0x7352a0'\n>>> hex(id(cls.C))\n'0x4198d0'\n\n| import importlib\nimport modname\nimportlib.reload(modname) |\n| --- |\n| 警告：这种技术并非万无一失。尤其是模块包含了以下语句时： |\n| from modname import some_objects |\n| 仍将继续使用前一版的导入对象。如果模块包含了类的定义，并 不会 用新的类定义更新现有的类实\n例。这样可能会导致以下矛盾的行为： |\n| >>> import importlib\n>>> import cls\n>>> c = cls.C() # Create an instance of C\n>>> importlib.reload(cls)\n<module 'cls' from 'cls.py'>\n>>> isinstance(c, cls.C) # isinstance is false?!?\nFalse |\n| 只要把类对象的 id 打印出来，问题的性质就会一目了然： |\n| >>> hex(id(c.__class__))\n'0x7352a0'\n>>> hex(id(cls.C))\n'0x4198d0' |\n|  |", "metadata": {"title": "00_编程常见问题", "source": "md_docs\\python_faq_md\\00_编程常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "90e59fbc"}}
{"doc_id": "19112b03", "content": "设计和历史常见问题\n目录\n设计和历史常见问题\n为什么 Python 使用缩进来分组语句？\n为什么简单的算术运算得到奇怪的结果？\n为什么浮点计算不准确？\n为什么Python字符串是不可变的？\n为什么必须在方法定义和调用中显式使用“self”？\n为什么不能在表达式中赋值？\n为什么Python对某些功能（例如list.index()）使用方法来实现，而其他功能（例如len(List)）\n使用函数实现？\n为什么 join() 是一个字符串方法而不是列表或元组方法？\n异常有多快？\n为什么Python中没有switch或case语句？\n难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实现吗？\n为什么lambda表达式不能包含语句？\n可以将Python编译为机器代码，C或其他语言吗？\nPython如何管理内存？\n为什么CPython不使用更传统的垃圾回收方案？\nCPython退出时为什么不释放所有内存？\n为什么有单独的元组和列表数据类型？\n列表是如何在CPython中实现的？\n字典是如何在CPython中实现的？\n为什么字典key必须是不可变的？\n为什么 list.sort() 没有返回排序列表？\n如何在Python中指定和实施接口规范？\n为什么没有goto？\n为什么原始字符串（r-strings）不能以反斜杠结尾？\n为什么Python没有属性赋值的“with”语句？\n生成器为什么不支持 with 语句？\n为什么 if/while/def/class语句需要冒号？\n为什么Python在列表和元组的末尾允许使用逗号？\n为什么 Python 使用缩进来分组语句？\nGuido van Rossum 认为使用缩进进行分组非常优雅，并且大大提高了普通 Python 程序的清晰度。\n大多数人在一段时间后就会喜欢上这个特性。\n\n| 设计和历史常见问题 |\n| --- |\n| 目录\n设计和历史常见问题\n为什么 Python 使用缩进来分组语句？\n为什么简单的算术运算得到奇怪的结果？\n为什么浮点计算不准确？\n为什么Python字符串是不可变的？\n为什么必须在方法定义和调用中显式使用“self”？\n为什么不能在表达式中赋值？\n为什么Python对某些功能（例如list.index()）使用方法来实现，而其他功能（例如len(List)）\n使用函数实现？\n为什么 join() 是一个字符串方法而不是列表或元组方法？\n异常有多快？\n为什么Python中没有switch或case语句？\n难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实现吗？\n为什么lambda表达式不能包含语句？\n可以将Python编译为机器代码，C或其他语言吗？\nPython如何管理内存？\n为什么CPython不使用更传统的垃圾回收方案？\nCPython退出时为什么不释放所有内存？\n为什么有单独的元组和列表数据类型？\n列表是如何在CPython中实现的？\n字典是如何在CPython中实现的？\n为什么字典key必须是不可变的？\n为什么 list.sort() 没有返回排序列表？\n如何在Python中指定和实施接口规范？\n为什么没有goto？\n为什么原始字符串（r-strings）不能以反斜杠结尾？\n为什么Python没有属性赋值的“with”语句？\n生成器为什么不支持 with 语句？\n为什么 if/while/def/class语句需要冒号？\n为什么Python在列表和元组的末尾允许使用逗号？ |\n| 为什么 Python 使用缩进来分组语句？\nGuido van Rossum 认为使用缩进进行分组非常优雅，并且大大提高了普通 Python 程序的清晰度。\n大多数人在一段时间后就会喜欢上这个特性。 |\n\n由于没有开始/结束括号，因此解析器感知的分组与人类读者之间不会存在分歧。 偶尔 C 程序员会遇\n到像这样的代码片段:\nif (x <= y)\nx++;\ny--;\nz++;\n如果条件为真，则只执行 x++ 语句，但缩进会使你认为情况并非如此。 即使是经验丰富的 C 程序员\n有时也会长久地盯着它发呆，不明白为什么在 x > y 时 y 也会减少。\n因为没有开始/结束花括号，所以 Python 更不容易发生代码风格冲突。 在 C 中有许多不同的放置花\n括号的方式。 在习惯了阅读和编写某种特定风格的代码之后，当阅读（或被要求编写）另一种风格\n的代码时通常都会令人感觉有点不舒服）。\n许多编码风格将开始/结束括号单独放在一行上。这使得程序相当长，浪费了宝贵的屏幕空间，使得\n更难以对程序进行全面的了解。 理想情况下，函数应该适合一个屏幕（例如，20--30行）。 20 行\nPython 可以完成比 20 行 C 更多的工作。 这不仅仅是由于没有开始/结束括号 -- 无需声明以及高层\n级的数据类型也是其中的原因 -- 但基于缩进的语法肯定有帮助。\n为什么简单的算术运算得到奇怪的结果？\n请看下一个问题。\n为什么浮点计算不准确？\n用户经常对这样的结果感到惊讶:\n>>> 1.2 - 1.0\n0.19999999999999996\n并且认为这是 Python 中的一个 bug。其实不是这样。这与 Python 关系不大，而与底层平台如何处\n理浮点数字关系更大。\nCPython 中的 float 类型使用C语言的 double 类型进行存储。 float 对象的值是以固定的精度\n（通常为 53 位）存储的二进制浮点数，由于 Python 使用 C 操作，而后者依赖于处理器中的硬件实\n现来执行浮点运算。 这意味着就浮点运算而言，Python 的行为类似于许多流行的语言，包括 C 和\nJava。\n许多可以轻松地用十进制表示的数字不能用二进制浮点表示。 例如，在输入以下语句后:\n>>> x = 1.2\n为 x 存储的值是与十进制的值 1.2 (非常接近) 的近似值，但不完全等于它。 在典型的机器上，实际\n存储的值是：\n1.0011001100110011001100110011001100110011001100110011 (二进制)\n\n|  | 由于没有开始/结束括号，因此解析器感知的分组与人类读者之间不会存在分歧。 偶尔 C 程序员会遇\n到像这样的代码片段: |  |\n| --- | --- | --- |\n|  | if (x <= y)\nx++;\ny--;\nz++; |  |\n|  | 如果条件为真，则只执行 x++ 语句，但缩进会使你认为情况并非如此。 即使是经验丰富的 C 程序员\n有时也会长久地盯着它发呆，不明白为什么在 x > y 时 y 也会减少。\n因为没有开始/结束花括号，所以 Python 更不容易发生代码风格冲突。 在 C 中有许多不同的放置花\n括号的方式。 在习惯了阅读和编写某种特定风格的代码之后，当阅读（或被要求编写）另一种风格\n的代码时通常都会令人感觉有点不舒服）。\n许多编码风格将开始/结束括号单独放在一行上。这使得程序相当长，浪费了宝贵的屏幕空间，使得\n更难以对程序进行全面的了解。 理想情况下，函数应该适合一个屏幕（例如，20--30行）。 20 行\nPython 可以完成比 20 行 C 更多的工作。 这不仅仅是由于没有开始/结束括号 -- 无需声明以及高层\n级的数据类型也是其中的原因 -- 但基于缩进的语法肯定有帮助。\n为什么简单的算术运算得到奇怪的结果？\n请看下一个问题。\n为什么浮点计算不准确？\n用户经常对这样的结果感到惊讶: |  |\n|  | >>> 1.2 - 1.0\n0.19999999999999996 |  |\n|  | 并且认为这是 Python 中的一个 bug。其实不是这样。这与 Python 关系不大，而与底层平台如何处\n理浮点数字关系更大。\nCPython 中的 float 类型使用C语言的 double 类型进行存储。 float 对象的值是以固定的精度\n（通常为 53 位）存储的二进制浮点数，由于 Python 使用 C 操作，而后者依赖于处理器中的硬件实\n现来执行浮点运算。 这意味着就浮点运算而言，Python 的行为类似于许多流行的语言，包括 C 和\nJava。\n许多可以轻松地用十进制表示的数字不能用二进制浮点表示。 例如，在输入以下语句后: |  |\n|  | >>> x = 1.2 |  |\n|  | 为 x 存储的值是与十进制的值 1.2 (非常接近) 的近似值，但不完全等于它。 在典型的机器上，实际\n存储的值是： |  |\n|  | 1.0011001100110011001100110011001100110011001100110011 (二进制) |  |\n|  |  |  |\n\n它对应于十进制数值:\n1.1999999999999999555910790149937383830547332763671875 (十进制)\n典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。\n要获得更完整的解释，请参阅 Python 教程中的 浮点算术 一章。\n为什么Python字符串是不可变的？\n有几个优点。\n一个是性能：知道字符串是不可变的，意味着我们可以在创建时为它分配空间，并且存储需求是固\n定不变的。这也是元组和列表之间区别的原因之一。\n另一个优点是，Python 中的字符串被视为与数字一样“基本”。 任何动作都不会将值 8 更改为其他\n值，在 Python 中，任何动作都不会将字符串 \"8\" 更改为其他值。\n为什么必须在方法定义和调用中显式使用“self”？\n这个想法借鉴了 Modula-3 语言。 出于多种原因它被证明是非常有用的。\n首先，更明显的显示出，使用的是方法或实例属性而不是局部变量。 阅读 self.x 或 self.meth()\n可以清楚地表明，即使您不知道类的定义，也会使用实例变量或方法。在 C++ 中，可以通过缺少局\n部变量声明来判断（假设全局变量很少见或容易识别） —— 但是在 Python 中没有局部变量声明，\n所以必须查找类定义才能确定。 一些 C++ 和 Java 编码标准要求实例属性具有 m_ 前缀，因此这种\n显式性在这些语言中仍然有用。\n其次，这意味着当要显式引用或从特定类调用该方法时无须特殊语法。 在 C++ 中，如果你想要使用\n在派生类中被重写的基类方法，你必须使用 :: 运算符 -- 在 Python 中你可以写成\nbaseclass.methodname(self, <argument list>)。 这特别适用于 __init__() 方法，并且也适\n用于派生类方法想要扩展同名的基类方法因而必须以某种方式调用基类方法的情况。\n最后，它解决了实例变量赋值的语法问题：由于 Python 中的局部变量（根据定义！）是指在函数体\n内被赋值的变量（并且它没有被明确声明为全局变量），因此必须存在某种方式告诉解释器，某次\n赋值是为了分配一个实例变量而不是一个局部变量，它最好是通过语法实现的（出于效率原因）。\nC++ 通过声明来做到这一点，但是 Python 没有声明，仅仅为了这个目的而引入它们会很可惜。 使\n用显式的 self.var 很好地解决了这个问题。 类似地，对于使用实例变量，必须编写 self.var 意\n味着对方法内部的非限定名称的引用不必搜索实例的目录。 换句话说，局部变量和实例变量存在于\n两个不同的命名空间中，您需要告诉 Python 使用哪个命名空间。\n为什么不能在表达式中赋值？\n自 Python 3.8 开始，你能做到的！\n赋值表达式使用海象运算符 := 在表达式中为变量赋值:\n\n|  | 它对应于十进制数值: |  |\n| --- | --- | --- |\n|  | 1.1999999999999999555910790149937383830547332763671875 (十进制) |  |\n|  | 典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。\n要获得更完整的解释，请参阅 Python 教程中的 浮点算术 一章。\n为什么Python字符串是不可变的？\n有几个优点。\n一个是性能：知道字符串是不可变的，意味着我们可以在创建时为它分配空间，并且存储需求是固\n定不变的。这也是元组和列表之间区别的原因之一。\n另一个优点是，Python 中的字符串被视为与数字一样“基本”。 任何动作都不会将值 8 更改为其他\n值，在 Python 中，任何动作都不会将字符串 \"8\" 更改为其他值。\n为什么必须在方法定义和调用中显式使用“self”？\n这个想法借鉴了 Modula-3 语言。 出于多种原因它被证明是非常有用的。\n首先，更明显的显示出，使用的是方法或实例属性而不是局部变量。 阅读 self.x 或 self.meth()\n可以清楚地表明，即使您不知道类的定义，也会使用实例变量或方法。在 C++ 中，可以通过缺少局\n部变量声明来判断（假设全局变量很少见或容易识别） —— 但是在 Python 中没有局部变量声明，\n所以必须查找类定义才能确定。 一些 C++ 和 Java 编码标准要求实例属性具有 m_ 前缀，因此这种\n显式性在这些语言中仍然有用。\n其次，这意味着当要显式引用或从特定类调用该方法时无须特殊语法。 在 C++ 中，如果你想要使用\n在派生类中被重写的基类方法，你必须使用 :: 运算符 -- 在 Python 中你可以写成\nbaseclass.methodname(self, <argument list>)。 这特别适用于 __init__() 方法，并且也适\n用于派生类方法想要扩展同名的基类方法因而必须以某种方式调用基类方法的情况。\n最后，它解决了实例变量赋值的语法问题：由于 Python 中的局部变量（根据定义！）是指在函数体\n内被赋值的变量（并且它没有被明确声明为全局变量），因此必须存在某种方式告诉解释器，某次\n赋值是为了分配一个实例变量而不是一个局部变量，它最好是通过语法实现的（出于效率原因）。\nC++ 通过声明来做到这一点，但是 Python 没有声明，仅仅为了这个目的而引入它们会很可惜。 使\n用显式的 self.var 很好地解决了这个问题。 类似地，对于使用实例变量，必须编写 self.var 意\n味着对方法内部的非限定名称的引用不必搜索实例的目录。 换句话说，局部变量和实例变量存在于\n两个不同的命名空间中，您需要告诉 Python 使用哪个命名空间。\n为什么不能在表达式中赋值？\n自 Python 3.8 开始，你能做到的！\n赋值表达式使用海象运算符 := 在表达式中为变量赋值: |  |\n\nwhile chunk := fp.read(200):\nprint(chunk)\n请参阅 PEP 572 了解详情。\n为什么Python对某些功能（例如list.index()）使用方法来实现，而其他\n功能（例如len(List)）使用函数实现？\n正如Guido所说：\n(a) 对于某些操作，前缀表示法比后缀更容易阅读 -- 前缀（和中缀！）运算在数学中有着悠久的\n传统，就像在视觉上帮助数学家思考问题的记法。比较一下我们将 x*(a+b) 这样的公式改写为\nx*a+x*b 的容易程度，以及使用原始OO符号做相同事情的笨拙程度。\n(b) 当读到写有len(X)的代码时，就知道它要求的是某件东西的长度。这告诉我们两件事：结果是\n一个整数，参数是某种容器。相反，当阅读x.len()时，必须已经知道x是某种实现接口的容器，或\n者是从具有标准len()的类继承的容器。当没有实现映射的类有get()或key()方法，或者不是文件的\n类有write()方法时，我们偶尔会感到困惑。\n—https://mail.python.org/pipermail/python-3000/2006-November/004643.html\n为什么 join() 是一个字符串方法而不是列表或元组方法？\n从 Python 1.6 开始，字符串变得更像其他标准类型，当添加方法时，这些方法提供的功能与始终使\n用 String 模块的函数时提供的功能相同。这些新方法中的大多数已被广泛接受，但似乎让一些程序\n员感到不舒服的一种方法是：\n\", \".join(['1', '2', '4', '8', '16'])\n结果如下:\n\"1, 2, 4, 8, 16\"\n反对这种用法有两个常见的论点。\n第一条是这样的：“使用字符串文本(String Constant)的方法看起来真的很难看”，答案是也许吧，但\n是字符串文本只是一个固定值。如果在绑定到字符串的名称上允许使用这些方法，则没有逻辑上的\n理由使其在文字上不可用。\n第二个异议通常是这样的：“我实际上是在告诉序列使用字符串常量将其成员连接在一起”。遗憾的是\n并非如此。出于某种原因，把 split() 作为一个字符串方法似乎要容易得多，因为在这种情况下，\n很容易看到:\n\"1, 2, 4, 8, 16\".split(\", \")\n是对字符串文本的指令，用于返回由给定分隔符分隔的子字符串（或在默认情况下，返回任意空\n格）。\n\n|  | while chunk := fp.read(200):\nprint(chunk) |  |\n| --- | --- | --- |\n|  | 请参阅 PEP 572 了解详情。\n为什么Python对某些功能（例如list.index()）使用方法来实现，而其他 |  |\n|  | 功能（例如len(List)）使用函数实现？\n正如Guido所说：\n(a) 对于某些操作，前缀表示法比后缀更容易阅读 -- 前缀（和中缀！）运算在数学中有着悠久的\n传统，就像在视觉上帮助数学家思考问题的记法。比较一下我们将 x*(a+b) 这样的公式改写为\nx*a+x*b 的容易程度，以及使用原始OO符号做相同事情的笨拙程度。\n(b) 当读到写有len(X)的代码时，就知道它要求的是某件东西的长度。这告诉我们两件事：结果是\n一个整数，参数是某种容器。相反，当阅读x.len()时，必须已经知道x是某种实现接口的容器，或\n者是从具有标准len()的类继承的容器。当没有实现映射的类有get()或key()方法，或者不是文件的\n类有write()方法时，我们偶尔会感到困惑。\n—https://mail.python.org/pipermail/python-3000/2006-November/004643.html\n为什么 join() 是一个字符串方法而不是列表或元组方法？\n从 Python 1.6 开始，字符串变得更像其他标准类型，当添加方法时，这些方法提供的功能与始终使\n用 String 模块的函数时提供的功能相同。这些新方法中的大多数已被广泛接受，但似乎让一些程序\n员感到不舒服的一种方法是： |  |\n|  | \", \".join(['1', '2', '4', '8', '16']) |  |\n|  | 结果如下: |  |\n|  | \"1, 2, 4, 8, 16\" |  |\n|  | 反对这种用法有两个常见的论点。\n第一条是这样的：“使用字符串文本(String Constant)的方法看起来真的很难看”，答案是也许吧，但\n是字符串文本只是一个固定值。如果在绑定到字符串的名称上允许使用这些方法，则没有逻辑上的\n理由使其在文字上不可用。\n第二个异议通常是这样的：“我实际上是在告诉序列使用字符串常量将其成员连接在一起”。遗憾的是\n并非如此。出于某种原因，把 split() 作为一个字符串方法似乎要容易得多，因为在这种情况下，\n很容易看到: |  |\n|  | \"1, 2, 4, 8, 16\".split(\", \") |  |\n|  | 是对字符串文本的指令，用于返回由给定分隔符分隔的子字符串（或在默认情况下，返回任意空\n格）。 |  |\n\njoin() 是字符串方法，因为在使用该方法时，您告诉分隔符字符串去迭代一个字符串序列，并在相\n邻元素之间插入自身。此方法的参数可以是任何遵循序列规则的对象，包括您自己定义的任何新的\n类。对于字节和字节数组对象也有类似的方法。\n异常有多快？\n如果没有引发异常则 try/except 代码块是非常高效的。 实际上捕获异常是很消耗性能的。 在 2.0\n之前的 Python 版本中通常使用这例程:\ntry:\nvalue = mydict[key]\nexcept KeyError:\nmydict[key] = getvalue(key)\nvalue = mydict[key]\n只有当你期望dict在任何时候都有key时，这才有意义。如果不是这样的话，你就是应该这样编码：\nif key in mydict:\nvalue = mydict[key]\nelse:\nvalue = mydict[key] = getvalue(key)\n对于这种特定的情况，您还可以使用 value = dict.setdefault(key, getvalue(key))，但前提\n是调用 getvalue() 足够便宜，因为在所有情况下都会对其进行评估。\n为什么Python中没有switch或case语句？\n总的来说，结构化分支语句会在一个表达式具有特定值或值的集合时执行某个代码块。 从 Python\n3.10 开始可以简单地通过 match ... case 语句来匹配字面值，或特定命名空间中的常量。 一种较\n旧的替代方案是通过一系列的 if... elif... elif... else。\n对于需要从大量可能性中进行选择的情况，可以创建一个字典，将case 值映射到要调用的函数。例\n如：\nfunctions = {'a': function_1,\n'b': function_2,\n'c': self.method_1}\nfunc = functions[value]\nfunc()\n对于对象调用方法，可以通过使用 getattr() 内置检索具有特定名称的方法来进一步简化：\nclass MyVisitor:\ndef visit_a(self):\n...\ndef dispatch(self, value):\nmethod_name = 'visit_' + str(value)\nmethod = getattr(self, method_name)\nmethod()\n\n|  | join() 是字符串方法，因为在使用该方法时，您告诉分隔符字符串去迭代一个字符串序列，并在相\n邻元素之间插入自身。此方法的参数可以是任何遵循序列规则的对象，包括您自己定义的任何新的\n类。对于字节和字节数组对象也有类似的方法。\n异常有多快？\n如果没有引发异常则 try/except 代码块是非常高效的。 实际上捕获异常是很消耗性能的。 在 2.0\n之前的 Python 版本中通常使用这例程: |  |\n| --- | --- | --- |\n|  | try:\nvalue = mydict[key]\nexcept KeyError:\nmydict[key] = getvalue(key)\nvalue = mydict[key] |  |\n|  | 只有当你期望dict在任何时候都有key时，这才有意义。如果不是这样的话，你就是应该这样编码： |  |\n|  | if key in mydict:\nvalue = mydict[key]\nelse:\nvalue = mydict[key] = getvalue(key) |  |\n|  | 对于这种特定的情况，您还可以使用 value = dict.setdefault(key, getvalue(key))，但前提\n是调用 getvalue() 足够便宜，因为在所有情况下都会对其进行评估。\n为什么Python中没有switch或case语句？\n总的来说，结构化分支语句会在一个表达式具有特定值或值的集合时执行某个代码块。 从 Python\n3.10 开始可以简单地通过 match ... case 语句来匹配字面值，或特定命名空间中的常量。 一种较\n旧的替代方案是通过一系列的 if... elif... elif... else。\n对于需要从大量可能性中进行选择的情况，可以创建一个字典，将case 值映射到要调用的函数。例\n如： |  |\n|  | functions = {'a': function_1,\n'b': function_2,\n'c': self.method_1}\nfunc = functions[value]\nfunc() |  |\n|  | 对于对象调用方法，可以通过使用 getattr() 内置检索具有特定名称的方法来进一步简化： |  |\n|  | class MyVisitor:\ndef visit_a(self):\n...\ndef dispatch(self, value):\nmethod_name = 'visit_' + str(value)\nmethod = getattr(self, method_name)\nmethod() |  |\n|  |  |  |\n\n建议对方法名使用前缀，例如本例中的 visit_ 。如果没有这样的前缀，如果值来自不受信任的\n源，攻击者将能够调用对象上的任何方法。\n模仿带有穿透方式的分支，就像 C 的 switch-case-default 那样是有可能的，但更为困难，也无甚必\n要。\n难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实\n现吗？\n答案1： 不幸的是，解释器为每个Python堆栈帧推送至少一个C堆栈帧。此外，扩展可以随时回调\nPython。因此，一个完整的线程实现需要对C的线程支持。\n答案2： 幸运的是， Stackless Python 有一个完全重新设计的解释器循环，可以避免C堆栈。\n为什么lambda表达式不能包含语句？\nPython 的 lambda 表达式不能包含语句，因为Python的语法框架不能处理嵌套在表达式内部的语\n句。然而，在 Python 中，这并不是一个严重的问题。 与其他语言中添加功能的 lambda 形式不同，\nPython 的 lambda 只是一种速记符号，如果您懒得定义函数的话。\n函数已经是 Python 中的第一等对象，并且可以在局部作用域中声明。 因此使用 lambda 而非局部定\n义函数的唯一优点是你不需要为函数指定名称 -- 但那只是一个被赋值为函数对象（它的类型与\nlambda 表达式所产生的对象完全相同）的局部变量！\n可以将Python编译为机器代码，C或其他语言吗？\nCython 会将带有可选标注的修改版 Python 编译为 C 扩展。 Nuitka 是一个 Python 转 C++ 代码的\n新兴编译器，其目标是支持完整的 Python 语言。\nPython如何管理内存？\nPython 内存管理的细节取决于实现。 Python 的标准实现 CPython 使用引用计数来检测不可访问的\n对象，并使用另一种机制来收集引用循环，定期执行循环检测算法来查找不可访问的循环并删除所\n涉及的对象。 gc 模块提供了执行垃圾回收、获取调试统计信息和优化收集器参数的函数。\n不过，其他实现 (如 Jython 或 PyPy)，可能会依赖不同的机制，如完全的垃圾回收器。 如果你的\nPython 代码依赖于引用计数实现的行为则这种差异可能会导致某些微妙的移植问题。\n在一些Python实现中，以下代码（在CPython中工作的很好）可能会耗尽文件描述符:\nfor file in very_long_list_of_files:\nf = open(file)\nc = f.read(1)\n实际上，使用 CPython 的引用计数或器方案，每次对 f 的新赋值都会关闭之前的文件。 然而，对于\n传统的 GC，这些文件对象将只能以不同的并且可能很长的间隔被收集（和关闭）。\n\n|  | 建议对方法名使用前缀，例如本例中的 visit_ 。如果没有这样的前缀，如果值来自不受信任的\n源，攻击者将能够调用对象上的任何方法。\n模仿带有穿透方式的分支，就像 C 的 switch-case-default 那样是有可能的，但更为困难，也无甚必\n要。\n难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实\n现吗？\n答案1： 不幸的是，解释器为每个Python堆栈帧推送至少一个C堆栈帧。此外，扩展可以随时回调\nPython。因此，一个完整的线程实现需要对C的线程支持。\n答案2： 幸运的是， Stackless Python 有一个完全重新设计的解释器循环，可以避免C堆栈。\n为什么lambda表达式不能包含语句？\nPython 的 lambda 表达式不能包含语句，因为Python的语法框架不能处理嵌套在表达式内部的语\n句。然而，在 Python 中，这并不是一个严重的问题。 与其他语言中添加功能的 lambda 形式不同，\nPython 的 lambda 只是一种速记符号，如果您懒得定义函数的话。\n函数已经是 Python 中的第一等对象，并且可以在局部作用域中声明。 因此使用 lambda 而非局部定\n义函数的唯一优点是你不需要为函数指定名称 -- 但那只是一个被赋值为函数对象（它的类型与\nlambda 表达式所产生的对象完全相同）的局部变量！\n可以将Python编译为机器代码，C或其他语言吗？\nCython 会将带有可选标注的修改版 Python 编译为 C 扩展。 Nuitka 是一个 Python 转 C++ 代码的\n新兴编译器，其目标是支持完整的 Python 语言。\nPython如何管理内存？\nPython 内存管理的细节取决于实现。 Python 的标准实现 CPython 使用引用计数来检测不可访问的\n对象，并使用另一种机制来收集引用循环，定期执行循环检测算法来查找不可访问的循环并删除所\n涉及的对象。 gc 模块提供了执行垃圾回收、获取调试统计信息和优化收集器参数的函数。\n不过，其他实现 (如 Jython 或 PyPy)，可能会依赖不同的机制，如完全的垃圾回收器。 如果你的\nPython 代码依赖于引用计数实现的行为则这种差异可能会导致某些微妙的移植问题。\n在一些Python实现中，以下代码（在CPython中工作的很好）可能会耗尽文件描述符: |  |\n| --- | --- | --- |\n|  | for file in very_long_list_of_files:\nf = open(file)\nc = f.read(1) |  |\n|  | 实际上，使用 CPython 的引用计数或器方案，每次对 f 的新赋值都会关闭之前的文件。 然而，对于\n传统的 GC，这些文件对象将只能以不同的并且可能很长的间隔被收集（和关闭）。 |  |\n\n如果要编写可用于任何python实现的代码，则应显式关闭该文件或使用 with 语句；无论内存管理\n方案如何，这都有效：\nfor file in very_long_list_of_files:\nwith open(file) as f:\nc = f.read(1)\n为什么CPython不使用更传统的垃圾回收方案？\n首先，这不是C标准特性，因此不能移植。(是的，我们知道Boehm GC库。它包含了 大多数 常见平\n台（但不是所有平台）的汇编代码，尽管它基本上是透明的，但也不是完全透明的; 要让Python使用\n它，需要使用补丁。)\n当 Python 嵌入到其他应用程序中时传统的 GC 也会成为一个问题。 在独立的 Python 中可以用 GC\n库提供的版本来替换标准的 malloc() 和 free()，而嵌入 Python 的应用程序可能想要 自行 替代\nmalloc() 和 free()，并不想要 Python 的版本。 现在，CPython 可以适用于任何正确实现了\nmalloc() 和 free() 的版本。\nCPython退出时为什么不释放所有内存？\n当Python退出时，从全局命名空间或Python模块引用的对象并不总是被释放。 如果存在循环引用，\n则可能发生这种情况 C库分配的某些内存也是不可能释放的（例如像Purify这样的工具会抱怨这些内\n容）。 但是，Python在退出时清理内存并尝试销毁每个对象。\n如果要强制 Python 在释放时删除某些内容，请使用 atexit 模块运行一个函数，强制删除这些内\n容。\n为什么有单独的元组和列表数据类型？\n列表和元组虽然在许多方式都很相似，但它们的使用方式有本质上的不同。 元组可被当作是类似于\nPascal records 或 C structs；它们是由可能具有不同类型但可作为一个分组进行操作的相关数据\n组成的小多项集。 例如，一个笛卡尔坐标可适当地用由两个或三个数字组成的元组来表示。\n另一方面，列表更像其他语言中的数组。 它们倾向于保存可变数量的全都具有相同类型并将被逐个\n操作的对象。 例如，os.listdir('.') 返回一个代表当前目录中文件的字符串列表。 当你向该目\n录添加一两个文件时在此输出上执行操作的函数通常不会中断。\n元组是不可变的，这意味着一旦创建了元组，就不能用新值替换它的任何元素。列表是可变的，这\n意味着您始终可以更改列表的元素。只有不变元素可以用作字典的key，因此只能将元组和非列表用\n作key。\n列表是如何在CPython中实现的？\nCPython的列表实际上是可变长度的数组，而不是lisp风格的链表。该实现使用对其他对象的引用的\n连续数组，并在列表头结构中保留指向该数组和数组长度的指针。\n\n|  | 如果要编写可用于任何python实现的代码，则应显式关闭该文件或使用 with 语句；无论内存管理\n方案如何，这都有效： |  |\n| --- | --- | --- |\n|  | for file in very_long_list_of_files:\nwith open(file) as f:\nc = f.read(1) |  |\n|  | 为什么CPython不使用更传统的垃圾回收方案？\n首先，这不是C标准特性，因此不能移植。(是的，我们知道Boehm GC库。它包含了 大多数 常见平\n台（但不是所有平台）的汇编代码，尽管它基本上是透明的，但也不是完全透明的; 要让Python使用\n它，需要使用补丁。)\n当 Python 嵌入到其他应用程序中时传统的 GC 也会成为一个问题。 在独立的 Python 中可以用 GC\n库提供的版本来替换标准的 malloc() 和 free()，而嵌入 Python 的应用程序可能想要 自行 替代\nmalloc() 和 free()，并不想要 Python 的版本。 现在，CPython 可以适用于任何正确实现了\nmalloc() 和 free() 的版本。\nCPython退出时为什么不释放所有内存？\n当Python退出时，从全局命名空间或Python模块引用的对象并不总是被释放。 如果存在循环引用，\n则可能发生这种情况 C库分配的某些内存也是不可能释放的（例如像Purify这样的工具会抱怨这些内\n容）。 但是，Python在退出时清理内存并尝试销毁每个对象。\n如果要强制 Python 在释放时删除某些内容，请使用 atexit 模块运行一个函数，强制删除这些内\n容。\n为什么有单独的元组和列表数据类型？\n列表和元组虽然在许多方式都很相似，但它们的使用方式有本质上的不同。 元组可被当作是类似于\nPascal records 或 C structs；它们是由可能具有不同类型但可作为一个分组进行操作的相关数据\n组成的小多项集。 例如，一个笛卡尔坐标可适当地用由两个或三个数字组成的元组来表示。\n另一方面，列表更像其他语言中的数组。 它们倾向于保存可变数量的全都具有相同类型并将被逐个\n操作的对象。 例如，os.listdir('.') 返回一个代表当前目录中文件的字符串列表。 当你向该目\n录添加一两个文件时在此输出上执行操作的函数通常不会中断。\n元组是不可变的，这意味着一旦创建了元组，就不能用新值替换它的任何元素。列表是可变的，这\n意味着您始终可以更改列表的元素。只有不变元素可以用作字典的key，因此只能将元组和非列表用\n作key。\n列表是如何在CPython中实现的？\nCPython的列表实际上是可变长度的数组，而不是lisp风格的链表。该实现使用对其他对象的引用的\n连续数组，并在列表头结构中保留指向该数组和数组长度的指针。 |  |\n\n这使得索引列表 a[i] 的操作成本与列表的大小或索引的值无关。\n当添加或插入项时，将调整引用数组的大小。并采用了一些巧妙的方法来提高重复添加项的性能; 当\n数组必须增长时，会分配一些额外的空间，以便在接下来的几次中不需要实际调整大小。\n字典是如何在CPython中实现的？\nCPython的字典实现为可调整大小的哈希表。与B-树相比，这在大多数情况下为查找（目前最常见的\n操作）提供了更好的性能，并且实现更简单。\n字典的工作方式是使用 hash() 内置函数计算字典中存储的每个键的哈希码。 哈希码会根据键和基\n于进程的种子值而大幅改变；例如，'Python' 的哈希码可能为 -539294296 而 'python' 这个只相\n差一丁点的字符串的哈希码却可能为 1142331976。 随后哈希码将被用来计算在一个内部数组中相\n应值的存储位置。 假设你存储的键都具有不同的哈希值，这意味着字典会耗费恒定的时间 -- 即大 O\n表示法的 O(1) -- 要检索一个键。\n为什么字典key必须是不可变的？\n字典的哈希表实现使用从键值计算的哈希值来查找键。如果键是可变对象，则其值可能会发生变\n化，因此其哈希值也会发生变化。但是，由于无论谁更改键对象都无法判断它是否被用作字典键\n值，因此无法在字典中修改条目。然后，当你尝试在字典中查找相同的对象时，将无法找到它，因\n为其哈希值不同。如果你尝试查找旧值，也不会找到它，因为在该哈希表中找到的对象的值会有所\n不同。\n如果你想要一个用列表索引的字典，只需先将列表转换为元组；用函数 tuple(L) 创建一个元组，\n其条目与列表 L 相同。 元组是不可变的，因此可以用作字典键。\n已经提出的一些不可接受的解决方案：\n哈希按其地址（对象ID）列出。这不起作用，因为如果你构造一个具有相同值的新列表，它将无\n法找到；例如:\nmydict = {[1, 2]: '12'}\nprint(mydict[[1, 2]])\n会引发一个 KeyError 异常，因为第二行中使用的 [1, 2] 的 id 与第一行中的 id 不同。换句话\n说，应该使用 == 来比较字典键，而不是使用 is 。\n使用列表作为键时进行复制。这没有用的，因为作为可变对象的列表可以包含对自身的引用，然\n后复制代码将进入无限循环。\n允许列表作为键，但告诉用户不要修改它们。当你意外忘记或修改列表时，这将产生程序中的一\n类难以跟踪的错误。它还使一个重要的字典不变量无效： d.keys() 中的每个值都可用作字典的\n键。\n将列表用作字典键后，应标记为其只读。问题是，它不仅仅是可以改变其值的顶级对象；你可以\n使用包含列表作为键的元组。将任何内容作为键关联到字典中都需要将从那里可到达的所有对象\n\n|  | 这使得索引列表 a[i] 的操作成本与列表的大小或索引的值无关。\n当添加或插入项时，将调整引用数组的大小。并采用了一些巧妙的方法来提高重复添加项的性能; 当\n数组必须增长时，会分配一些额外的空间，以便在接下来的几次中不需要实际调整大小。\n字典是如何在CPython中实现的？\nCPython的字典实现为可调整大小的哈希表。与B-树相比，这在大多数情况下为查找（目前最常见的\n操作）提供了更好的性能，并且实现更简单。\n字典的工作方式是使用 hash() 内置函数计算字典中存储的每个键的哈希码。 哈希码会根据键和基\n于进程的种子值而大幅改变；例如，'Python' 的哈希码可能为 -539294296 而 'python' 这个只相\n差一丁点的字符串的哈希码却可能为 1142331976。 随后哈希码将被用来计算在一个内部数组中相\n应值的存储位置。 假设你存储的键都具有不同的哈希值，这意味着字典会耗费恒定的时间 -- 即大 O\n表示法的 O(1) -- 要检索一个键。\n为什么字典key必须是不可变的？\n字典的哈希表实现使用从键值计算的哈希值来查找键。如果键是可变对象，则其值可能会发生变\n化，因此其哈希值也会发生变化。但是，由于无论谁更改键对象都无法判断它是否被用作字典键\n值，因此无法在字典中修改条目。然后，当你尝试在字典中查找相同的对象时，将无法找到它，因\n为其哈希值不同。如果你尝试查找旧值，也不会找到它，因为在该哈希表中找到的对象的值会有所\n不同。\n如果你想要一个用列表索引的字典，只需先将列表转换为元组；用函数 tuple(L) 创建一个元组，\n其条目与列表 L 相同。 元组是不可变的，因此可以用作字典键。\n已经提出的一些不可接受的解决方案：\n哈希按其地址（对象ID）列出。这不起作用，因为如果你构造一个具有相同值的新列表，它将无\n法找到；例如:\nmydict = {[1, 2]: '12'}\nprint(mydict[[1, 2]])\n会引发一个 KeyError 异常，因为第二行中使用的 [1, 2] 的 id 与第一行中的 id 不同。换句话\n说，应该使用 == 来比较字典键，而不是使用 is 。\n使用列表作为键时进行复制。这没有用的，因为作为可变对象的列表可以包含对自身的引用，然\n后复制代码将进入无限循环。\n允许列表作为键，但告诉用户不要修改它们。当你意外忘记或修改列表时，这将产生程序中的一\n类难以跟踪的错误。它还使一个重要的字典不变量无效： d.keys() 中的每个值都可用作字典的\n键。\n将列表用作字典键后，应标记为其只读。问题是，它不仅仅是可以改变其值的顶级对象；你可以\n使用包含列表作为键的元组。将任何内容作为键关联到字典中都需要将从那里可到达的所有对象 |  |\n| --- | --- | --- |\n\n标记为只读 —— 并且自引用对象可能会导致无限循环。\n如果你有需要，以下技巧可以绕过这个问题，但使用它必须自担风险：你可以将一个可变结构体包\n装在一个同时具有 __eq__() 和 __hash__() 方法的类实例中。 然后你必须确保存放在字典（或其\n他基于哈希值的结构体）中的所有此类包装器对象的哈希值在该字典（或其他结构体）中保持固\n定。\nclass ListWrapper:\ndef __init__(self, the_list):\nself.the_list = the_list\ndef __eq__(self, other):\nreturn self.the_list == other.the_list\ndef __hash__(self):\nl = self.the_list\nresult = 98767 - len(l)*555\nfor i, el in enumerate(l):\ntry:\nresult = result + (hash(el) % 9999999) * 1001 + i\nexcept Exception:\nresult = (result % 7777777) + i * 333\nreturn result\n注意，哈希计算由于列表的某些成员可能不可用以及算术溢出的可能性而变得复杂。\n此外，必须始终如此，如果 o1 == o2 （即 o1.__eq__(o2) is True ）则 hash(o1) == hash(o2)\n（即 o1.__hash__() == o2.__hash__() ），无论对象是否在字典中。 如果你不能满足这些限\n制，字典和其他基于 hash 的结构将会出错。\n对于 ListWrapper 的情况，只要包装器位于字典中那么被包装的列表就不能更改以避免发生意外。\n除非你准备好认真考虑相关要求以及未能正确满足这些要求的后果否则请不要这样做。 你已经收到\n警告了。\n为什么 list.sort() 没有返回排序列表？\n在性能很重要的情况下，仅仅为了排序而复制一份列表将是一种浪费。因此， list.sort() 对列表\n进行了适当的排序。为了提醒您这一事实，它不会返回已排序的列表。这样，当您需要排序的副\n本，但也需要保留未排序的版本时，就不会意外地覆盖列表。\n如果要返回新列表，请使用内置 sorted() 函数。此函数从提供的可迭代列表中创建新列表，对其\n进行排序并返回。例如，下面是如何迭代遍历字典并按keys排序:\nfor key in sorted(mydict):\n... # 对 mydict[key] 做点什么\n如何在Python中指定和实施接口规范？\n由C++和Java等语言提供的模块接口规范描述了模块的方法和函数的原型。许多人认为接口规范的编\n译时强制执行有助于构建大型程序。\n\n|  | 标记为只读 —— 并且自引用对象可能会导致无限循环。\n如果你有需要，以下技巧可以绕过这个问题，但使用它必须自担风险：你可以将一个可变结构体包\n装在一个同时具有 __eq__() 和 __hash__() 方法的类实例中。 然后你必须确保存放在字典（或其\n他基于哈希值的结构体）中的所有此类包装器对象的哈希值在该字典（或其他结构体）中保持固\n定。 |  |\n| --- | --- | --- |\n|  | class ListWrapper:\ndef __init__(self, the_list):\nself.the_list = the_list\ndef __eq__(self, other):\nreturn self.the_list == other.the_list\ndef __hash__(self):\nl = self.the_list\nresult = 98767 - len(l)*555\nfor i, el in enumerate(l):\ntry:\nresult = result + (hash(el) % 9999999) * 1001 + i\nexcept Exception:\nresult = (result % 7777777) + i * 333\nreturn result |  |\n|  | 注意，哈希计算由于列表的某些成员可能不可用以及算术溢出的可能性而变得复杂。\n此外，必须始终如此，如果 o1 == o2 （即 o1.__eq__(o2) is True ）则 hash(o1) == hash(o2)\n（即 o1.__hash__() == o2.__hash__() ），无论对象是否在字典中。 如果你不能满足这些限\n制，字典和其他基于 hash 的结构将会出错。\n对于 ListWrapper 的情况，只要包装器位于字典中那么被包装的列表就不能更改以避免发生意外。\n除非你准备好认真考虑相关要求以及未能正确满足这些要求的后果否则请不要这样做。 你已经收到\n警告了。\n为什么 list.sort() 没有返回排序列表？\n在性能很重要的情况下，仅仅为了排序而复制一份列表将是一种浪费。因此， list.sort() 对列表\n进行了适当的排序。为了提醒您这一事实，它不会返回已排序的列表。这样，当您需要排序的副\n本，但也需要保留未排序的版本时，就不会意外地覆盖列表。\n如果要返回新列表，请使用内置 sorted() 函数。此函数从提供的可迭代列表中创建新列表，对其\n进行排序并返回。例如，下面是如何迭代遍历字典并按keys排序: |  |\n|  | for key in sorted(mydict):\n... # 对 mydict[key] 做点什么 |  |\n|  | 如何在Python中指定和实施接口规范？\n由C++和Java等语言提供的模块接口规范描述了模块的方法和函数的原型。许多人认为接口规范的编\n译时强制执行有助于构建大型程序。 |  |\n\nPython 2.6添加了一个 abc 模块，允许定义抽象基类 (ABCs)。然后可以使用 isinstance() 和\nissubclass() 来检查实例或类是否实现了特定的ABC。 collections.abc 模块定义了一组有用的\nABCs 例如 Iterable ， Container , 和 MutableMapping\n对于 Python，接口规范的许多好处可以通过组件的适当测试规程来获得。\n一个好的模块测试套件既可以提供回归测试，也可以作为模块接口规范和一组示例。许多Python模\n块可以作为脚本运行，以提供简单的“自我测试”。即使是使用复杂外部接口的模块，也常常可以使用\n外部接口的简单“桩代码（stub）”模拟进行隔离测试。可以使用 doctest 和 unittest 模块或第三\n方测试框架来构造详尽的测试套件，以运行模块中的每一行代码。\n适当的测试规程能像完善的接口规范一样帮助在 Python 构建大型的复杂应用程序。 事实上，它能\n做得更好因为接口规范无法测试程序的某些属性。 例如，list.append() 方法被期望向某个内部列\n表的末尾添加新元素；接口规范无法测试你的 list.append() 实现是否真的能正确执行该操作，但\n在测试套件中检查该属性却是很容易的。\n编写测试套件非常有用，并且你可能希望将你的代码设计为易于测试。 一种日益流行的技术是面向\n测试的开发，它要求在编写任何实际代码之前首先编写测试套件的各个部分。 当然 Python 也允许\n你采用更粗率的方式，不必编写任何测试用例。\n为什么没有goto？\n在 1970 年代人们了解到不受限制的 goto 可能导致混乱得像“意大利面”那样难以理解和修改的代\n码。 在高级语言中，它也是不必要的，只需能够执行分支（在 Python 中是使用 if 语句和 or, and\n以及 if/else 表达式）和循环（使用 while 和 for 语句，还可能包含 continue 和 break 语句）\n就足够了。\n人们还可以使用异常来提供甚至能跨函数调用的“结构化 goto”。 许多人觉得异常可以方便地模拟 C,\nFortran 和其他语言中所有合理使用的 go 或 goto 结构:\nclass label(Exception): pass # 声明label\ntry:\n...\nif condition: raise label() # 跳转到 label\n...\nexcept label: # 跳转到哪里\npass\n...\n这并不允许跳到一个循环的中间，但这通常被视为是对 goto 的滥用。 应当谨慎使用。\n为什么原始字符串（r-strings）不能以反斜杠结尾？\n更准确地说，它们不能以奇数个反斜杠结束：结尾处的不成对反斜杠会转义结束引号字符，留下未\n结束的字符串。\n原始字符串的设计是为了方便想要执行自己的反斜杠转义处理的处理器(主要是正则表达式引擎)创建\n输入。此类处理器将不匹配的尾随反斜杠视为错误，因此原始字符串不允许这样做。反过来，允许\n\n|  | Python 2.6添加了一个 abc 模块，允许定义抽象基类 (ABCs)。然后可以使用 isinstance() 和\nissubclass() 来检查实例或类是否实现了特定的ABC。 collections.abc 模块定义了一组有用的\nABCs 例如 Iterable ， Container , 和 MutableMapping\n对于 Python，接口规范的许多好处可以通过组件的适当测试规程来获得。\n一个好的模块测试套件既可以提供回归测试，也可以作为模块接口规范和一组示例。许多Python模\n块可以作为脚本运行，以提供简单的“自我测试”。即使是使用复杂外部接口的模块，也常常可以使用\n外部接口的简单“桩代码（stub）”模拟进行隔离测试。可以使用 doctest 和 unittest 模块或第三\n方测试框架来构造详尽的测试套件，以运行模块中的每一行代码。\n适当的测试规程能像完善的接口规范一样帮助在 Python 构建大型的复杂应用程序。 事实上，它能\n做得更好因为接口规范无法测试程序的某些属性。 例如，list.append() 方法被期望向某个内部列\n表的末尾添加新元素；接口规范无法测试你的 list.append() 实现是否真的能正确执行该操作，但\n在测试套件中检查该属性却是很容易的。\n编写测试套件非常有用，并且你可能希望将你的代码设计为易于测试。 一种日益流行的技术是面向\n测试的开发，它要求在编写任何实际代码之前首先编写测试套件的各个部分。 当然 Python 也允许\n你采用更粗率的方式，不必编写任何测试用例。\n为什么没有goto？\n在 1970 年代人们了解到不受限制的 goto 可能导致混乱得像“意大利面”那样难以理解和修改的代\n码。 在高级语言中，它也是不必要的，只需能够执行分支（在 Python 中是使用 if 语句和 or, and\n以及 if/else 表达式）和循环（使用 while 和 for 语句，还可能包含 continue 和 break 语句）\n就足够了。\n人们还可以使用异常来提供甚至能跨函数调用的“结构化 goto”。 许多人觉得异常可以方便地模拟 C,\nFortran 和其他语言中所有合理使用的 go 或 goto 结构: |  |\n| --- | --- | --- |\n|  | class label(Exception): pass # 声明label\ntry:\n...\nif condition: raise label() # 跳转到 label\n...\nexcept label: # 跳转到哪里\npass\n... |  |\n|  | 这并不允许跳到一个循环的中间，但这通常被视为是对 goto 的滥用。 应当谨慎使用。\n为什么原始字符串（r-strings）不能以反斜杠结尾？\n更准确地说，它们不能以奇数个反斜杠结束：结尾处的不成对反斜杠会转义结束引号字符，留下未\n结束的字符串。\n原始字符串的设计是为了方便想要执行自己的反斜杠转义处理的处理器(主要是正则表达式引擎)创建\n输入。此类处理器将不匹配的尾随反斜杠视为错误，因此原始字符串不允许这样做。反过来，允许 |  |\n\n通过使用引号字符转义反斜杠转义字符串。当r-string用于它们的预期目的时，这些规则工作的很\n好。\n如果您正在尝试构建Windows路径名，请注意所有Windows系统调用都使用正斜杠:\nf = open(\"/mydir/file.txt\") # 效果很好！\n如果您正在尝试为DOS命令构建路径名，请尝试以下示例\ndir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\ndir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\ndir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\"\n为什么Python没有属性赋值的“with”语句？\nPython 有一种 with 语句能将一个代码块的执行包装起来，在进入和退出该代码块时调用特定的代\n码。 某些语言具有类似这样的结构:\nwith obj:\na = 1 # 相当于 to obj.a = 1\ntotal = total + 1 # obj.total = obj.total + 1\n在Python中，这样的结构是不明确的。\n其他语言，如ObjectPascal、Delphi和C++ 使用静态类型，因此可以毫不含糊地知道分配给什么成\n员。这是静态类型的要点 -- 编译器 总是 在编译时知道每个变量的作用域。\nPython使用动态类型。事先不可能知道在运行时引用哪个属性。可以动态地在对象中添加或删除成\n员属性。这使得无法通过简单的阅读就知道引用的是什么属性：局部属性、全局属性还是成员属\n性？\n例如，采用以下不完整的代码段:\ndef foo(a):\nwith a:\nprint(x)\n该代码段假设 a 必须有一个名为 x 的成员属性。 然而，Python 中没有什么能告诉解释器这一点。\n举例来说，如果 a 是一个整数那么会发生什么？ 如果有一个名为 x 的全局变量，它是否会在 with\n代码块内被使用？ 如你所见，Python 的动态特性使得这样的选择更为困难。\n然而，with 及类似语言特性的主要好处（减少代码量）在 Python 中可以通过赋值轻松地实现。 而\n不是使用:\nfunction(args).mydict[index][index].a = 21\nfunction(args).mydict[index][index].b = 42\nfunction(args).mydict[index][index].c = 63\n写成这样:\n\n|  | 通过使用引号字符转义反斜杠转义字符串。当r-string用于它们的预期目的时，这些规则工作的很\n好。\n如果您正在尝试构建Windows路径名，请注意所有Windows系统调用都使用正斜杠: |  |\n| --- | --- | --- |\n|  | f = open(\"/mydir/file.txt\") # 效果很好！ |  |\n|  | 如果您正在尝试为DOS命令构建路径名，请尝试以下示例 |  |\n|  | dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\ndir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\ndir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\" |  |\n|  | 为什么Python没有属性赋值的“with”语句？\nPython 有一种 with 语句能将一个代码块的执行包装起来，在进入和退出该代码块时调用特定的代\n码。 某些语言具有类似这样的结构: |  |\n|  | with obj:\na = 1 # 相当于 to obj.a = 1\ntotal = total + 1 # obj.total = obj.total + 1 |  |\n|  | 在Python中，这样的结构是不明确的。\n其他语言，如ObjectPascal、Delphi和C++ 使用静态类型，因此可以毫不含糊地知道分配给什么成\n员。这是静态类型的要点 -- 编译器 总是 在编译时知道每个变量的作用域。\nPython使用动态类型。事先不可能知道在运行时引用哪个属性。可以动态地在对象中添加或删除成\n员属性。这使得无法通过简单的阅读就知道引用的是什么属性：局部属性、全局属性还是成员属\n性？\n例如，采用以下不完整的代码段: |  |\n|  | def foo(a):\nwith a:\nprint(x) |  |\n|  | 该代码段假设 a 必须有一个名为 x 的成员属性。 然而，Python 中没有什么能告诉解释器这一点。\n举例来说，如果 a 是一个整数那么会发生什么？ 如果有一个名为 x 的全局变量，它是否会在 with\n代码块内被使用？ 如你所见，Python 的动态特性使得这样的选择更为困难。\n然而，with 及类似语言特性的主要好处（减少代码量）在 Python 中可以通过赋值轻松地实现。 而\n不是使用: |  |\n|  | function(args).mydict[index][index].a = 21\nfunction(args).mydict[index][index].b = 42\nfunction(args).mydict[index][index].c = 63 |  |\n|  | 写成这样: |  |\n\nref = function(args).mydict[index][index]\nref.a = 21\nref.b = 42\nref.c = 63\n这也具有提高执行速度的附带效果，因为 Python 在运行时解析名称绑定，而第二个版本只需要执行\n一次解析。\n引入可以进一步减小代码量的类似提议，例如使用“前导点号”，出于明白胜于隐晦的理由而被拒绝了\n(参见 https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)。\n生成器为什么不支持 with 语句？\n由于技术原因，直接作为上下文管理器使用的生成器将无法正常工作。 最常见的情况下，当一个生\n成器被用作迭代器运行到完成时，不需要手动关闭。 如果需要，请在 with 语句中将它包装为\ncontextlib.closing(generator)。\n为什么 if/while/def/class语句需要冒号？\n冒号主要用于增强可读性(ABC语言实验的结果之一)。考虑一下这个:\nif a == b\nprint(a)\n与\nif a == b:\nprint(a)\n注意第二种方法稍微容易一些。请进一步注意，在这个FAQ解答的示例中，冒号是如何设置的；这是\n英语中的标准用法。\n另一个次要原因是冒号使带有语法突出显示的编辑器更容易工作；他们可以寻找冒号来决定何时需\n要增加缩进，而不必对程序文本进行更精细的解析。\n为什么Python在列表和元组的末尾允许使用逗号？\nPython 允许您在列表，元组和字典的末尾添加一个尾随逗号:\n[1, 2, 3,]\n('a', 'b', 'c',)\nd = {\n\"A\":[1, 5],\n\"B\":[6, 7], # 最后的逗号是可选的，但风格很好\n}\n有几个理由允许这样做。\n\n|  | ref = function(args).mydict[index][index]\nref.a = 21\nref.b = 42\nref.c = 63 |  |\n| --- | --- | --- |\n|  | 这也具有提高执行速度的附带效果，因为 Python 在运行时解析名称绑定，而第二个版本只需要执行\n一次解析。\n引入可以进一步减小代码量的类似提议，例如使用“前导点号”，出于明白胜于隐晦的理由而被拒绝了\n(参见 https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)。\n生成器为什么不支持 with 语句？\n由于技术原因，直接作为上下文管理器使用的生成器将无法正常工作。 最常见的情况下，当一个生\n成器被用作迭代器运行到完成时，不需要手动关闭。 如果需要，请在 with 语句中将它包装为\ncontextlib.closing(generator)。\n为什么 if/while/def/class语句需要冒号？\n冒号主要用于增强可读性(ABC语言实验的结果之一)。考虑一下这个: |  |\n|  | if a == b\nprint(a) |  |\n|  | 与 |  |\n|  | if a == b:\nprint(a) |  |\n|  | 注意第二种方法稍微容易一些。请进一步注意，在这个FAQ解答的示例中，冒号是如何设置的；这是\n英语中的标准用法。\n另一个次要原因是冒号使带有语法突出显示的编辑器更容易工作；他们可以寻找冒号来决定何时需\n要增加缩进，而不必对程序文本进行更精细的解析。\n为什么Python在列表和元组的末尾允许使用逗号？\nPython 允许您在列表，元组和字典的末尾添加一个尾随逗号: |  |\n|  | [1, 2, 3,]\n('a', 'b', 'c',)\nd = {\n\"A\":[1, 5],\n\"B\":[6, 7], # 最后的逗号是可选的，但风格很好\n} |  |\n|  | 有几个理由允许这样做。 |  |\n\n如果列表，元组或字典的字面值分布在多行中，则更容易添加更多元素，因为不必记住在上一行中\n添加逗号。这些行也可以重新排序，而不会产生语法错误。\n不小心省略逗号会导致难以诊断的错误。例如:\nx = [\n\"fee\",\n\"fie\"\n\"foo\",\n\"fum\"\n]\n这个列表看起来有四个元素，但实际上包含三个 : \"fee\", \"fiefoo\" 和 \"fum\" 。总是加上逗号可以避免\n这个错误的来源。\n允许尾随逗号也可以使编程代码更容易生成。\n\n| 如果列表，元组或字典的字面值分布在多行中，则更容易添加更多元素，因为不必记住在上一行中\n添加逗号。这些行也可以重新排序，而不会产生语法错误。\n不小心省略逗号会导致难以诊断的错误。例如: |\n| --- |\n| x = [\n\"fee\",\n\"fie\"\n\"foo\",\n\"fum\"\n] |\n| 这个列表看起来有四个元素，但实际上包含三个 : \"fee\", \"fiefoo\" 和 \"fum\" 。总是加上逗号可以避免\n这个错误的来源。\n允许尾随逗号也可以使编程代码更容易生成。 |", "metadata": {"title": "00_设计和历史常见问题", "source": "md_docs\\python_faq_md\\00_设计和历史常见问题.md", "doc_type": "常见问题", "language": "中文", "doc_id": "19112b03"}}
