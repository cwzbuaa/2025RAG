{"doc_id": "c3cf2da9", "content": "1. 概述\n本手册仅描述 Python 编程语言，不宜当作教程。\n我希望尽可能地保证内容精确无误，但还是选择使用自然词句进行描述，正式的规格定义仅用于句\n法和词法解析。这样应该能使文档对于普通人来说更易理解，但也可能导致一些歧义。因此，如果\n你是来自火星并且想凭借这份文档把 Python 重新实现一遍，也许有时需要自行猜测，实际上最终大\n概会得到一个十分不同的语言。而在另一方面，如果你正在使用 Python 并且想了解有关该语言特定\n领域的精确规则，你应该能够在这里找到它们。如果你希望查看对该语言更正式的定义，也许你可\n以花些时间自己写上一份 --- 或者发明一台克隆机器 :-)\n在语言参考文档里加入过多的实现细节是很危险的 --- 具体实现可能发生改变，对同一语言的其他实\n现可能使用不同的方式。而在另一方面，CPython 是得到广泛使用的 Python 实现 (然而其他一些实\n现的拥护者也在增加)，其中的特殊细节有时也值得一提，特别是当其实现方式导致额外的限制时。\n因此，你会发现在正文里不时会跳出来一些简短的 \"实现注释\"。\n每种 Python 实现都带有一些内置和标准的模块。相关的文档可参见 Python 标准库 索引。少数内置\n模块也会在此提及，如果它们同语言描述存在明显的关联。\n1.1. 其他实现\n虽然官方 Python 实现差不多得到最广泛的欢迎，但也有一些其他实现对特定领域的用户来说更具吸\n引力。\n知名的实现包括:\nCPython\n这是最早出现并持续维护的 Python 实现，以 C 语言编写。新的语言特性通常在此率先添加。\nJython\n以 Java 语言编写的 Python 实现。 此实现可以作为 Java 应用的一个脚本语言，或者可以用来\n创建需要 Java 类库支持的应用。 想了解更多信息请访问 Jython 网站。\nPython for .NET\n此实现实际上使用了 CPython 实现，但是属于 .NET 托管应用并且可以引入 .NET 类库。它的创\n造者是 Brian Lloyd。想了解详情可访问 Python for .NET 主页。\nIronPython\n另一个 .NET 版 Python 实现，不同于 Python.NET，这是一个生成 IL 的完整 Python 实现，并会\n将 Python 代码直接编译为 .NET 程序集。 它的创造者就是当初创造 Jython 的 Jim Hugunin。\n想了解更多信息，请参看 IronPython 网站。\nPyPy\n\n一个完全使用 Python 语言编写的 Python 实现。 它支持多个其他实现所没有的高级特性，例如\n非栈式支持和实时编译器等。 此项目的目标之一是通过允许方便地修改解释器（因为它是用\nPython 编写的）来鼓励对语言本身的试验。 更多信息可在 PyPy 项目主页 获取。\n以上这些实现都可能在某些方面与此参考文档手册的描述有所差异，或是引入了超出标准 Python 文\n档范围的特定信息。请参考它们各自的专门文档，以确定你正在使用的这个实现有哪些你需要了解\n的东西。\n1.2. 标注\n词法分析和语法的描述采用混合了 EBNF 与 PEG 的语法标记形式。 例如：\nname: letter (letter | digit | \"_\")*\nletter: \"a\"...\"z\" | \"A\"...\"Z\"\ndigit: \"0\"...\"9\"\n在这个示例中，第一行是说 name 是一个 letter 后面跟由零个或多个 letter, digit 和下划线组成\n的序列。 而 letter 则是从 'a' 到 'z' 以及从 A 到 Z 的任意单个字符；digit 是从 0 到 9 的任意\n单个字符。\n每条规则以一个名称打头（它用来标识所定义的规则）后面跟一个冒号 :。 冒号右边的定义使用下\n列语法元素：\nname: 一个指向其他规则的名称。 如果可能，它将是一个指向规则定义的链接。\nTOKEN: 一个指向特定 token 的大写形式的名称。 对于语法定义的场景，token 与规则是一回\n事。\n\"text\", 'text': 单引号或双引号内的文本必须在字面上匹配（不带引号）。 引号的类型将根据\ntext 的含义来选择：\n'if': 单引号内的名称标记了一个 关键字。\n\"case\"：双引号内的名称表示一个 软关键字。\n'@': 单引号中的一个非字母符号表示一个 OP 记号，即 定界符 或 运算符。\ne1 e2：仅用空格分隔的项表示一个序列。在这里，e1``后面必须跟着``e2。\ne1 | e2: 竖条用于分隔选项。它表示 PEG 的“有序选择”: 如果匹配 e1，则不考虑 e2。 在传统的\nPEG 语法中，它被写成斜杠 /，而不是竖条。 有关更多背景和详细信息，请参阅 PEP 617。\ne*：星号表示前一项重复零次或多次。\ne+：同样，加号表示一次或多次重复。\n[e]：用方括号括起来的短语表示出现零次或一次。换句话说，所包含的短语是可选的。\ne?：问号与方括号的含义完全相同：前一项为可选项。\n(e)：括号用于分组。\n以下符号表示法仅在 词法定义 中使用。\n\"a\"...\"z\": 由三个点分隔的两个字面值字符表示在给定（包括）ASCII 字符范围内选择任何单个\n字符。\n<...>：尖括号之间的短语给出了匹配符号的非正式描述（例如，<any ASCII character\nexcept \"\\\">），或者在附近文本中定义的缩写（例如，<Lu>）。\n\n|  |  | 一个完全使用 Python 语言编写的 Python 实现。 它支持多个其他实现所没有的高级特性，例如\n非栈式支持和实时编译器等。 此项目的目标之一是通过允许方便地修改解释器（因为它是用\nPython 编写的）来鼓励对语言本身的试验。 更多信息可在 PyPy 项目主页 获取。\n以上这些实现都可能在某些方面与此参考文档手册的描述有所差异，或是引入了超出标准 Python 文\n档范围的特定信息。请参考它们各自的专门文档，以确定你正在使用的这个实现有哪些你需要了解\n的东西。\n1.2. 标注\n词法分析和语法的描述采用混合了 EBNF 与 PEG 的语法标记形式。 例如： |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | name: letter (letter | digit | \"_\")*\nletter: \"a\"...\"z\" | \"A\"...\"Z\"\ndigit: \"0\"...\"9\" |  |  |  |\n|  |  | 在这个示例中，第一行是说 name 是一个 letter 后面跟由零个或多个 letter, digit 和下划线组成\n的序列。 而 letter 则是从 'a' 到 'z' 以及从 A 到 Z 的任意单个字符；digit 是从 0 到 9 的任意\n单个字符。\n每条规则以一个名称打头（它用来标识所定义的规则）后面跟一个冒号 :。 冒号右边的定义使用下\n列语法元素：\nname: 一个指向其他规则的名称。 如果可能，它将是一个指向规则定义的链接。\nTOKEN: 一个指向特定 token 的大写形式的名称。 对于语法定义的场景，token 与规则是一回\n事。\n\"text\", 'text': 单引号或双引号内的文本必须在字面上匹配（不带引号）。 引号的类型将根据\ntext 的含义来选择：\n'if': 单引号内的名称标记了一个 关键字。\n\"case\"：双引号内的名称表示一个 软关键字。\n'@': 单引号中的一个非字母符号表示一个 OP 记号，即 定界符 或 运算符。\ne1 e2：仅用空格分隔的项表示一个序列。在这里，e1``后面必须跟着``e2。\ne1 | e2: 竖条用于分隔选项。它表示 PEG 的“有序选择”: 如果匹配 e1，则不考虑 e2。 在传统的\nPEG 语法中，它被写成斜杠 /，而不是竖条。 有关更多背景和详细信息，请参阅 PEP 617。\ne*：星号表示前一项重复零次或多次。\ne+：同样，加号表示一次或多次重复。\n[e]：用方括号括起来的短语表示出现零次或一次。换句话说，所包含的短语是可选的。\ne?：问号与方括号的含义完全相同：前一项为可选项。\n(e)：括号用于分组。\n以下符号表示法仅在 词法定义 中使用。\n\"a\"...\"z\": 由三个点分隔的两个字面值字符表示在给定（包括）ASCII 字符范围内选择任何单个\n字符。\n<...>：尖括号之间的短语给出了匹配符号的非正式描述（例如，<any ASCII character\nexcept \"\\\">），或者在附近文本中定义的缩写（例如，<Lu>）。 |  |  |  |\n|  |  |  | <any ASCII character |  |  |\n|  |  |  |  |  |  |\n|  |  | except \"\\\"> |  |  |  |\n|  |  |  |  |  |  |\n\n部分定义还使用了*前瞻断言*（lookaheads），这类断言用于指示某个元素必须在（或不能在）特\n定位置匹配，但不会消耗任何输入内容。\n&e：正向肯定前瞻断言（即要求必须匹配 e）\n!e：负向否定前瞻断言（即要求 e 必须不匹配）\n一元运算符（*、+、?）尽可能紧密地绑定；竖条（|）绑定最松散。\n空格只对分隔记号有意义。\n规则通常包含在一行中，但太长的规则可能会被换行：\nliteral: stringliteral | bytesliteral\n| integer | floatnumber | imagnumber\n或者，规则可以格式化为第一行以冒号结束，其余每一行以竖线开始。例如：\nliteral:\n| stringliteral\n| bytesliteral\n| integer\n| floatnumber\n| imagnumber\n这并不意味着第一个选项是空的。\n1.2.1. 词法和语法定义\n词法分析 和 语法分析 之间有一些区别: lexical analyzer 对输入源的单个字符进行操作，而 解析器\n(语法分析器) 对词法分析生成的 词元 流进行操作。 然而，在某些情况下，这两个阶段之间的确切界\n限是 CPython 的实现细节。\n两者之间的实际区别在于，在 词法 定义中，所有空白符都是重要的。 词法分析器会 丢弃 所有未转\n换为 token.INDENT 或 NEWLINE 等记号的空白符。 语法 定义随后使用这些记号，而不是源字符。\n本文档对两种定义样式使用相同的BNF语法。下一章（词法分析）中BNF的所有用法都是词法上的定\n义；后面章节中的用法是语法定义。\n\n| 部分定义还使用了*前瞻断言*（lookaheads），这类断言用于指示某个元素必须在（或不能在）特\n定位置匹配，但不会消耗任何输入内容。\n&e：正向肯定前瞻断言（即要求必须匹配 e）\n!e：负向否定前瞻断言（即要求 e 必须不匹配）\n一元运算符（*、+、?）尽可能紧密地绑定；竖条（|）绑定最松散。\n空格只对分隔记号有意义。\n规则通常包含在一行中，但太长的规则可能会被换行： |\n| --- |\n| literal: stringliteral | bytesliteral\n| integer | floatnumber | imagnumber |\n| 或者，规则可以格式化为第一行以冒号结束，其余每一行以竖线开始。例如： |\n| literal:\n| stringliteral\n| bytesliteral\n| integer\n| floatnumber\n| imagnumber |\n| 这并不意味着第一个选项是空的。\n1.2.1. 词法和语法定义\n词法分析 和 语法分析 之间有一些区别: lexical analyzer 对输入源的单个字符进行操作，而 解析器\n(语法分析器) 对词法分析生成的 词元 流进行操作。 然而，在某些情况下，这两个阶段之间的确切界\n限是 CPython 的实现细节。\n两者之间的实际区别在于，在 词法 定义中，所有空白符都是重要的。 词法分析器会 丢弃 所有未转\n换为 token.INDENT 或 NEWLINE 等记号的空白符。 语法 定义随后使用这些记号，而不是源字符。\n本文档对两种定义样式使用相同的BNF语法。下一章（词法分析）中BNF的所有用法都是词法上的定\n义；后面章节中的用法是语法定义。 |", "metadata": {"title": "01_概述", "source": "md_docs\\python_reference_md\\01_概述.md", "doc_type": "语言参考", "language": "中文", "doc_id": "c3cf2da9"}}
{"doc_id": "074c839b", "content": "2. 词法分析\nA Python program is read by a parser. Input to the parser is a stream of tokens, generated by the\nlexical analyzer (also known as the tokenizer). This chapter describes how the lexical analyzer\nproduces these tokens.\nThe lexical analyzer determines the program text's encoding (UTF-8 by default), and decodes the\ntext into source characters. If the text cannot be decoded, a SyntaxError is raised.\nNext, the lexical analyzer uses the source characters to generate a stream of tokens. The type of a\ngenerated token generally depends on the next source character to be processed. Similarly, other\nspecial behavior of the analyzer depends on the first source character that hasn't yet been\nprocessed. The following table gives a quick summary of these source characters, with links to\nsections that contain more information.\n字符 下一词元（或其他相关文档）\nspace\ntab 空格\nformfeed\n换行\nCR, LF\n缩进\nExplicit line joining\nbackslash (\\)\n(Also significant in string escape sequences)\nhash (#) Comment\nquote (', \") String literal\nASCII letter (a-z, A-Z) Name\nnon-ASCII character Prefixed string or bytes literal\nName\nunderscore (_)\n(Can also be part of numeric literals)\nnumber (0-9) Numeric literal\nNumeric literal\ndot (.)\nOperator\nquestion mark (?)\ndollar ($)\nError (outside string literals and comments)\nbackquote ( ` )\ncontrol character\n\n| 字符 | 下一词元（或其他相关文档） |\n| --- | --- |\n| space\ntab\nformfeed | 空格 |\n| CR, LF | 换行\n缩进 |\n| backslash (\\) | Explicit line joining\n(Also significant in string escape sequences) |\n| hash (#) | Comment |\n| quote (', \") | String literal |\n| ASCII letter (a-z, A-Z)\nnon-ASCII character | Name\nPrefixed string or bytes literal |\n| underscore (_) | Name\n(Can also be part of numeric literals) |\n| number (0-9) | Numeric literal |\n| dot (.) | Numeric literal\nOperator |\n| question mark (?)\ndollar ($)\nbackquote ( ` )\ncontrol character | Error (outside string literals and comments) |\n\n字符 下一词元（或其他相关文档）\nother printing character Operator or delimiter\nend of file End marker\n2.1. 行结构\nPython 程序可以拆分为多个 逻辑行。\n2.1.1. 逻辑行\n逻辑行的结束由词元 NEWLINE 表示。 除非语法允许 NEWLINE (举例来说，在复合语句中的多个语句\n之前) 否则语句不能跨越逻辑行边界。 逻辑行由一条或多条 物理行 根据 显示 或 隐式 的 行连接 规\n则构造而成。\n2.1.2. 物理行\n物理行是由使用下列行结束符序列中的一个作为终结的字符序列：\n使用 ASCII LF (linefeed) 的 Unix 形式，\n使用 ASCII 序列 CR LF (return 加 linefeed) 的 Windows 形式，\n使用 ASCII CR (return) 字符的 'Classic Mac OS' 形式。\n无论平台如何，这些序列中的每一个都会被替换为单个ASCII LF（换行）字符。（即使在 字符串字面\n量 中也是如此。）每一行可以使用这些序列中的任何一个；它们在文件内部不需要保持一致。\n输入的结束也作为最后一个物理行的隐式终止符。\n形式上：\nnewline: <ASCII LF> | <ASCII CR> <ASCII LF> | <ASCII CR>\n2.1.3. 注释\n注释以井号 （#） 开头，在物理行末尾截止。注意，井号不是字符串字面量。除非应用隐式行拼接\n规则，否则，注释代表逻辑行结束。句法不解析注释。\n2.1.4. 编码声明\nPython 脚本第一或第二行的注释匹配正则表达式 coding[=:]\\s*([-\\w.]+) 时，该注释会被当作编\n码声明；这个表达式的第一组指定了源码文件的编码。编码声明必须独占一行，在第二行时，则第\n一行必须也是注释。编码表达式的形式如下：\n# -*- coding: <encoding-name> -*-\n这也是 GNU Emacs 认可的形式，此外，还支持如下形式：\n\n|  | 字符 下一词元（或其他相关文档）\nother printing character Operator or delimiter\nend of file End marker\n2.1. 行结构\nPython 程序可以拆分为多个 逻辑行。\n2.1.1. 逻辑行\n逻辑行的结束由词元 NEWLINE 表示。 除非语法允许 NEWLINE (举例来说，在复合语句中的多个语句\n之前) 否则语句不能跨越逻辑行边界。 逻辑行由一条或多条 物理行 根据 显示 或 隐式 的 行连接 规\n则构造而成。\n2.1.2. 物理行\n物理行是由使用下列行结束符序列中的一个作为终结的字符序列：\n使用 ASCII LF (linefeed) 的 Unix 形式，\n使用 ASCII 序列 CR LF (return 加 linefeed) 的 Windows 形式，\n使用 ASCII CR (return) 字符的 'Classic Mac OS' 形式。\n无论平台如何，这些序列中的每一个都会被替换为单个ASCII LF（换行）字符。（即使在 字符串字面\n量 中也是如此。）每一行可以使用这些序列中的任何一个；它们在文件内部不需要保持一致。\n输入的结束也作为最后一个物理行的隐式终止符。\n形式上： |  |\n| --- | --- | --- |\n|  | newline: <ASCII LF> | <ASCII CR> <ASCII LF> | <ASCII CR> |  |\n|  | 2.1.3. 注释\n注释以井号 （#） 开头，在物理行末尾截止。注意，井号不是字符串字面量。除非应用隐式行拼接\n规则，否则，注释代表逻辑行结束。句法不解析注释。\n2.1.4. 编码声明\nPython 脚本第一或第二行的注释匹配正则表达式 coding[=:]\\s*([-\\w.]+) 时，该注释会被当作编\n码声明；这个表达式的第一组指定了源码文件的编码。编码声明必须独占一行，在第二行时，则第\n一行必须也是注释。编码表达式的形式如下： |  |\n|  | # -*- coding: <encoding-name> -*- |  |\n|  | 这也是 GNU Emacs 认可的形式，此外，还支持如下形式： |  |\n\n| 字符 | 下一词元（或其他相关文档） |\n| --- | --- |\n| other printing character | Operator or delimiter |\n| end of file | End marker |\n\n# vim:fileencoding=<encoding-name>\n这是 Bram Moolenaar 的 VIM 认可的形式。\n如果没有找到编码格式声明，则默认编码格式为 UTF-8。 如果文件的隐式或显式编码格式为 UTF-\n8，则初始的 UTF-8 字节顺序标记 (b'\\xef\\xbb\\xbf') 会被忽略，而不是成为语法错误。\n如果声明了编码格式，该编码格式的名称必须是 Python 可识别的 (参见 标准编码)。 编码格式会被\n用于所有的词法分析，包括字符串字面量、注释和标识符等。\n所有词法分析，包括字符串字面量、注释和标识符，都作用于使用源编码解码的Unicode文本。除了\nNUL 控制字符以外的任何Unicode码点都可以出现在Python源代码中。\nsource_character: <any Unicode code point, except NUL>\n2.1.5. 显式拼接行\n两个及两个以上的物理行可用反斜杠（\\）拼接为一个逻辑行，规则如下：以不在字符串或注释内的\n反斜杠结尾时，物理行将与下一行拼接成一个逻辑行，并删除反斜杠及其后的换行符。例如：\nif 1900 < year < 2100 and 1 <= month <= 12 \\\nand 1 <= day <= 31 and 0 <= hour < 24 \\\nand 0 <= minute < 60 and 0 <= second < 60: # 看来是个有效的日期\nreturn 1\n以反斜杠结尾的行不能包含注释。反斜杠不能用于延续注释内容。除字符串字面量之外，反斜杠不\n能用于延续标记（即非字符串字面量的标记不能通过反斜杠拆分到物理行的下一行）。在字符串字\n面量之外的行中，反斜杠出现在其他位置是非法的。\n2.1.6. 隐式拼接行\n圆括号、方括号、花括号内的表达式可以分成多个物理行，不必使用反斜杠。例如：\nmonth_names = ['Januari', 'Februari', 'Maart', # 这些是\n'April', 'Mei', 'Juni', # 一年之中\n'Juli', 'Augustus', 'September', # 各个月份的\n'Oktober', 'November', 'December'] # 荷兰语名称\n隐式行拼接可含注释；后续行的缩进并不重要；还支持空的后续行。隐式拼接行之间没有 NEWLINE\n标记。三引号字符串支持隐式拼接行（见下文），但不支持注释。\n2.1.7. 空白行\n仅包含空格、制表符、换页符以及可能的注释的逻辑行将被忽略（即不会生成 NEWLINE 标记）。在\n交互式输入语句时，空行的处理方式可能因读取-求值-打印循环的实现而异。在标准交互式解释器\n中，完全空白的逻辑行（即不包含任何空白符或注释）会终止多行语句。\n2.1.8. 缩进\n\n|  | # vim:fileencoding=<encoding-name> |  |\n| --- | --- | --- |\n|  | 这是 Bram Moolenaar 的 VIM 认可的形式。\n如果没有找到编码格式声明，则默认编码格式为 UTF-8。 如果文件的隐式或显式编码格式为 UTF-\n8，则初始的 UTF-8 字节顺序标记 (b'\\xef\\xbb\\xbf') 会被忽略，而不是成为语法错误。\n如果声明了编码格式，该编码格式的名称必须是 Python 可识别的 (参见 标准编码)。 编码格式会被\n用于所有的词法分析，包括字符串字面量、注释和标识符等。\n所有词法分析，包括字符串字面量、注释和标识符，都作用于使用源编码解码的Unicode文本。除了\nNUL 控制字符以外的任何Unicode码点都可以出现在Python源代码中。 |  |\n|  | source_character: <any Unicode code point, except NUL> |  |\n|  | 2.1.5. 显式拼接行\n两个及两个以上的物理行可用反斜杠（\\）拼接为一个逻辑行，规则如下：以不在字符串或注释内的\n反斜杠结尾时，物理行将与下一行拼接成一个逻辑行，并删除反斜杠及其后的换行符。例如： |  |\n|  | if 1900 < year < 2100 and 1 <= month <= 12 \\\nand 1 <= day <= 31 and 0 <= hour < 24 \\\nand 0 <= minute < 60 and 0 <= second < 60: # 看来是个有效的日期\nreturn 1 |  |\n|  | 以反斜杠结尾的行不能包含注释。反斜杠不能用于延续注释内容。除字符串字面量之外，反斜杠不\n能用于延续标记（即非字符串字面量的标记不能通过反斜杠拆分到物理行的下一行）。在字符串字\n面量之外的行中，反斜杠出现在其他位置是非法的。\n2.1.6. 隐式拼接行\n圆括号、方括号、花括号内的表达式可以分成多个物理行，不必使用反斜杠。例如： |  |\n|  | month_names = ['Januari', 'Februari', 'Maart', # 这些是\n'April', 'Mei', 'Juni', # 一年之中\n'Juli', 'Augustus', 'September', # 各个月份的\n'Oktober', 'November', 'December'] # 荷兰语名称 |  |\n|  | 隐式行拼接可含注释；后续行的缩进并不重要；还支持空的后续行。隐式拼接行之间没有 NEWLINE\n标记。三引号字符串支持隐式拼接行（见下文），但不支持注释。\n2.1.7. 空白行\n仅包含空格、制表符、换页符以及可能的注释的逻辑行将被忽略（即不会生成 NEWLINE 标记）。在\n交互式输入语句时，空行的处理方式可能因读取-求值-打印循环的实现而异。在标准交互式解释器\n中，完全空白的逻辑行（即不包含任何空白符或注释）会终止多行语句。\n2.1.8. 缩进 |  |\n\n逻辑行开头的空白符（空格符和制表符）用于计算该行的缩进层级，决定语句组块。\n制表符（从左至右）被替换为一至八个空格，缩进空格的总数是八的倍数（与 Unix 的规则保持一\n致）。首个非空字符前的空格数决定了该行的缩进层次。缩进不能用反斜杠进行多行拼接；首个反\n斜杠之前的空白符决定了缩进的层次。\n源文件混用制表符和空格符缩进时，因空格数量与制表符相关，由此产生的不一致将导致不能正常\n识别缩进层次，从而触发 TabError。\n跨平台兼容性说明： 鉴于非 UNIX 平台文本编辑器本身的特性，请勿在源文件中混用制表符和空格\n符。另外也请注意，不同平台有可能会显式限制最大缩进层级。\n行首含换页符时，缩进计算将忽略该换页符。换页符在行首空白符内其他位置的效果未定义（例\n如，可能导致空格计数重置为零）。\n连续行的缩进级别使用一个栈来生成 INDENT 和 DEDENT 标记，规则如下。\nBefore the first line of the file is read, a single zero is pushed on the stack; this will never be popped\noff again. The numbers pushed on the stack will always be strictly increasing from bottom to top.\nAt the beginning of each logical line, the line's indentation level is compared to the top of the\nstack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token\nis generated. If it is smaller, it must be one of the numbers occurring on the stack; all numbers on\nthe stack that are larger are popped off, and for each number popped off a DEDENT token is\ngenerated. At the end of the file, a DEDENT token is generated for each number remaining on the\nstack that is larger than zero.\n下面的 Python 代码缩进示例虽然正确，但含混不清：\ndef perm(l):\n# 计算由 l 的所有排列组成的列表\nif len(l) <= 1:\nreturn [l]\nr = []\nfor i in range(len(l)):\ns = l[:i] + l[i+1:]\np = perm(s)\nfor x in p:\nr.append(l[i:i+1] + x)\nreturn r\n下例展示了多种缩进错误：\ndef perm(l): # 错误：第一行有缩进\nfor i in range(len(l)): # 错误：没有缩进\ns = l[:i] + l[i+1:]\np = perm(l[:i] + l[i+1:]) # 错误：非预期的缩进\nfor x in p:\nr.append(l[i:i+1] + x)\nreturn r # 错误：不一致的缩进\n\n|  | 逻辑行开头的空白符（空格符和制表符）用于计算该行的缩进层级，决定语句组块。\n制表符（从左至右）被替换为一至八个空格，缩进空格的总数是八的倍数（与 Unix 的规则保持一\n致）。首个非空字符前的空格数决定了该行的缩进层次。缩进不能用反斜杠进行多行拼接；首个反\n斜杠之前的空白符决定了缩进的层次。\n源文件混用制表符和空格符缩进时，因空格数量与制表符相关，由此产生的不一致将导致不能正常\n识别缩进层次，从而触发 TabError。\n跨平台兼容性说明： 鉴于非 UNIX 平台文本编辑器本身的特性，请勿在源文件中混用制表符和空格\n符。另外也请注意，不同平台有可能会显式限制最大缩进层级。\n行首含换页符时，缩进计算将忽略该换页符。换页符在行首空白符内其他位置的效果未定义（例\n如，可能导致空格计数重置为零）。\n连续行的缩进级别使用一个栈来生成 INDENT 和 DEDENT 标记，规则如下。\nBefore the first line of the file is read, a single zero is pushed on the stack; this will never be popped\noff again. The numbers pushed on the stack will always be strictly increasing from bottom to top.\nAt the beginning of each logical line, the line's indentation level is compared to the top of the\nstack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token\nis generated. If it is smaller, it must be one of the numbers occurring on the stack; all numbers on\nthe stack that are larger are popped off, and for each number popped off a DEDENT token is\ngenerated. At the end of the file, a DEDENT token is generated for each number remaining on the\nstack that is larger than zero.\n下面的 Python 代码缩进示例虽然正确，但含混不清： |  |\n| --- | --- | --- |\n|  | def perm(l):\n# 计算由 l 的所有排列组成的列表\nif len(l) <= 1:\nreturn [l]\nr = []\nfor i in range(len(l)):\ns = l[:i] + l[i+1:]\np = perm(s)\nfor x in p:\nr.append(l[i:i+1] + x)\nreturn r |  |\n|  | 下例展示了多种缩进错误： |  |\n|  | def perm(l): # 错误：第一行有缩进\nfor i in range(len(l)): # 错误：没有缩进\ns = l[:i] + l[i+1:]\np = perm(l[:i] + l[i+1:]) # 错误：非预期的缩进\nfor x in p:\nr.append(l[i:i+1] + x)\nreturn r # 错误：不一致的缩进 |  |\n|  |  |  |\n\n（实际上，解析器可以识别前三个错误；只有最后一个错误由词法分析器识别 --- return r 的缩进\n无法匹配从栈里移除的缩进层级。）\n2.1.9. 标记间的空白字符\n除了在逻辑行的开头或字符串字面量中，空白符（空格、制表符和换页符）可以互换使用以分隔标\n记。仅当两个标记的拼接可能被解释为不同的标记时，才需要在它们之间使用空白符。例如，ab 是\n一个标记，而 a b 是两个标记。然而，+a 和 + a 都产生两个标记，即 + 和 a，因为 +a 不是有效\n的标记。\n2.1.10. 结束标记\n在非交互输入结束时，词法分析器将生成一个 ENDMARKER 词元。\n2.2. 其他标记\n除了 NEWLINE、INDENT 和 DEDENT 之外，还存在以下几类词元: 标识符 和 关键字 (NAME)、字面量\n(如 NUMBER 和 STRING)，以及其他符号 (运算符 和 分隔符, OP)。 空白字符（除了前面讨论的逻辑行\n终止符）不是词元，而是用于分隔词元。 在有歧义的情况下，词元由从左到右读取时能形成合法词\n元的最长可能字符串组成。\n2.3. 名称（标识符和关键字）\nNAME 标记表示 标识符、关键字 和 软关键字。\n在 ASCII 范围（U+0001..U+007F）内，名称的有效字符包括大小写字母（A-Z 和 a-z）、下划线\n_，并且除了首字符外，还可以包含数字 0 到 9。\n名称必须至少包含一个字符，但没有长度上限。大小写敏感。\n除了 A-Z、a-z、_ 和 0-9 之外，名称还可以使用 ASCII 范围之外的“类字母”和“类数字”字符，具体\n如下所述。\n所有标识符在解析时都会转换为 规范化形式 NFKC；标识符的比较基于 NFKC。\n形式上，规范化标识符的首字符必须属于集合 id_start，该集合是以下各项的并集：\nUnicode 类别 <Lu> - 大写字母 (包括 A 到 Z)\nUnicode 类别 <Ll> - 小写字母 (包括 a 到 z)\nUnicode 类别 <Lt> - 标题大小写字母\nUnicode 类别 <Lm> - 修饰字母\nUnicode category <Lo> - 其他字母\nUnicode 类别 <Nl> - 数字字母\n{\"_\"} - 下划线\n<Other_ID_Start> - 在 PropList.txt 中显式定义的用于支持向下兼容的字符集合\n其余字母必须归属于 id_continue 集合，它是以下字符的并集：\n\n|  | （实际上，解析器可以识别前三个错误；只有最后一个错误由词法分析器识别 --- return r 的缩进\n无法匹配从栈里移除的缩进层级。）\n2.1.9. 标记间的空白字符\n除了在逻辑行的开头或字符串字面量中，空白符（空格、制表符和换页符）可以互换使用以分隔标\n记。仅当两个标记的拼接可能被解释为不同的标记时，才需要在它们之间使用空白符。例如，ab 是\n一个标记，而 a b 是两个标记。然而，+a 和 + a 都产生两个标记，即 + 和 a，因为 +a 不是有效\n的标记。\n2.1.10. 结束标记\n在非交互输入结束时，词法分析器将生成一个 ENDMARKER 词元。\n2.2. 其他标记\n除了 NEWLINE、INDENT 和 DEDENT 之外，还存在以下几类词元: 标识符 和 关键字 (NAME)、字面量\n(如 NUMBER 和 STRING)，以及其他符号 (运算符 和 分隔符, OP)。 空白字符（除了前面讨论的逻辑行\n终止符）不是词元，而是用于分隔词元。 在有歧义的情况下，词元由从左到右读取时能形成合法词\n元的最长可能字符串组成。\n2.3. 名称（标识符和关键字）\nNAME 标记表示 标识符、关键字 和 软关键字。\n在 ASCII 范围（U+0001..U+007F）内，名称的有效字符包括大小写字母（A-Z 和 a-z）、下划线\n_，并且除了首字符外，还可以包含数字 0 到 9。\n名称必须至少包含一个字符，但没有长度上限。大小写敏感。\n除了 A-Z、a-z、_ 和 0-9 之外，名称还可以使用 ASCII 范围之外的“类字母”和“类数字”字符，具体\n如下所述。\n所有标识符在解析时都会转换为 规范化形式 NFKC；标识符的比较基于 NFKC。\n形式上，规范化标识符的首字符必须属于集合 id_start，该集合是以下各项的并集：\nUnicode 类别 <Lu> - 大写字母 (包括 A 到 Z)\nUnicode 类别 <Ll> - 小写字母 (包括 a 到 z)\nUnicode 类别 <Lt> - 标题大小写字母\nUnicode 类别 <Lm> - 修饰字母\nUnicode category <Lo> - 其他字母\nUnicode 类别 <Nl> - 数字字母\n{\"_\"} - 下划线\n<Other_ID_Start> - 在 PropList.txt 中显式定义的用于支持向下兼容的字符集合\n其余字母必须归属于 id_continue 集合，它是以下字符的并集： |  |\n| --- | --- | --- |\n\nid_start 中的所有字符\nUnicode 类别 <Nd> - 十进制数字（包括 0 到 9）\nUnicode 类别 <Pc> - 连接标点符号\nUnicode 类别 <Mn> - 非间距标记\nUnicode 类别 <Mc> - 间距组合标记\n<Other_ID_Continue> - 为支持向下兼容性在 PropList.txt 中另一组显式列出的字符集合\nUnicode 类别使用的是 unicodedata 模块中所包含的 Unicode 字符数据库版本。\n这些集合基于 Unicode 标准附录 UAX-31。有关更多详细信息，另请参阅 PEP 3131。\n更形式化地说，名称由以下词法定义描述：\nNAME: xid_start xid_continue*\nid_start: <Lu> | <Ll> | <Lt> | <Lm> | <Lo> | <Nl> | \"_\" | <Other_ID_Start>\nid_continue: id_start | <Nd> | <Pc> | <Mn> | <Mc> | <Other_ID_Continue>\nxid_start: <all characters in id_start whose NFKC normalization is\nin (id_start xid_continue*)\">\nxid_continue: <all characters in id_continue whose NFKC normalization is\nin (id_continue*)\">\nidentifier: <NAME, except keywords>\nUnicode 字符数据库中的 DerivedCoreProperties.txt 文件提供了一份非规范性的列表，包含了所有符\n合 Unicode 定义的有效标识符字符。\n2.3.1. 关键字\n以下名称被用作该语言的保留字或 关键字，不能用作普通标识符。它们的拼写必须与此处完全一\n致：\nFalse await else import pass\nNone break except in raise\nTrue class finally is return\nand continue for lambda try\nas def from nonlocal while\nassert del global not with\nasync elif if or yield\n2.3.2. 软关键字\nAdded in version 3.10.\n某些名称仅在特定上下文中保留。这些被称为 软关键字：\nmatch、case 和 _ 在 match 语句中使用时属于软关键字。\ntype 在 type 语句中使用时属于软关键字。\n这些标识符在特定上下文中语法上作为关键字使用，但这种区分是在解析器层面完成的，而非词法\n分析（分词）阶段。\n作为软关键字，它们能够在用于相应语法的同时仍然保持与用作标识符名称的现有代码的兼容性。\n\n|  | id_start 中的所有字符\nUnicode 类别 <Nd> - 十进制数字（包括 0 到 9）\nUnicode 类别 <Pc> - 连接标点符号\nUnicode 类别 <Mn> - 非间距标记\nUnicode 类别 <Mc> - 间距组合标记\n<Other_ID_Continue> - 为支持向下兼容性在 PropList.txt 中另一组显式列出的字符集合\nUnicode 类别使用的是 unicodedata 模块中所包含的 Unicode 字符数据库版本。\n这些集合基于 Unicode 标准附录 UAX-31。有关更多详细信息，另请参阅 PEP 3131。\n更形式化地说，名称由以下词法定义描述： |  |\n| --- | --- | --- |\n|  | NAME: xid_start xid_continue*\nid_start: <Lu> | <Ll> | <Lt> | <Lm> | <Lo> | <Nl> | \"_\" | <Other_ID_Start>\nid_continue: id_start | <Nd> | <Pc> | <Mn> | <Mc> | <Other_ID_Continue>\nxid_start: <all characters in id_start whose NFKC normalization is\nin (id_start xid_continue*)\">\nxid_continue: <all characters in id_continue whose NFKC normalization is\nin (id_continue*)\">\nidentifier: <NAME, except keywords> |  |\n|  | Unicode 字符数据库中的 DerivedCoreProperties.txt 文件提供了一份非规范性的列表，包含了所有符\n合 Unicode 定义的有效标识符字符。\n2.3.1. 关键字\n以下名称被用作该语言的保留字或 关键字，不能用作普通标识符。它们的拼写必须与此处完全一\n致： |  |\n|  | False await else import pass\nNone break except in raise\nTrue class finally is return\nand continue for lambda try\nas def from nonlocal while\nassert del global not with\nasync elif if or yield |  |\n|  | 2.3.2. 软关键字\nAdded in version 3.10.\n某些名称仅在特定上下文中保留。这些被称为 软关键字：\nmatch、case 和 _ 在 match 语句中使用时属于软关键字。\ntype 在 type 语句中使用时属于软关键字。\n这些标识符在特定上下文中语法上作为关键字使用，但这种区分是在解析器层面完成的，而非词法\n分析（分词）阶段。\n作为软关键字，它们能够在用于相应语法的同时仍然保持与用作标识符名称的现有代码的兼容性。 |  |\n\n在 3.12 版本发生变更: type 现在是一个软关键字。\n2.3.3. 保留的标识符类\n某些标识符类（除了关键字）具有特殊含义。这些类的命名模式以下划线字符开头，并以下划线结\n尾：\n_*\n不会被 from module import * 所导入。\n_\n在 match 语句内部的 case 模式中，_ 是一个 软关键字，它表示 通配符。\n在此之外，交互式解释器会将最后一次求值的结果放到变量 _ 中。 （它与 print 等内置函数\n一起被存储于 builtins 模块。）\n在其他地方，_ 是一个常规标识符。 它常常被用来命名 \"特殊\" 条目，但对 Python 本身来说毫\n无特殊之处。\n备注: _ 常用于连接国际化文本；详见 gettext 模块文档。\n它还经常被用来命名无需使用的变量。\n__*__\n系统定义的名称，通常简称为 \"dunder\" 。这些名称由解释器及其实现（包括标准库）定义。现\n有系统定义名称相关的论述详见 特殊方法名称 等章节。Python 未来版本中还将定义更多此类\n名称。任何情况下，任何 不显式遵从 __*__ 名称的文档用法，都可能导致无警告提示的错误。\n__*\n类的私有名称。类定义时，此类名称以一种混合形式重写，以避免基类及派生类的 \"私有\" 属性\n之间产生名称冲突。详见 标识符（名称）。\n2.4. 字面量\n字面量是内置类型常量值的表示法。\n在词法分析方面，Python有 字符串、字节 和 数值 字面量。\n其他“字面量”通过 关键字 (None、True、False) 和特殊的 省略号标记 (...) 进行词法表示。\n2.5. 字符串与字节串字面量\n字符串字面量是用单引号（'）或双引号（\"）括起来的文本。例如：\n\"spam\"\n'eggs'\n用于开始字面量的引号也用于终止它，因此字符串字面量只能包含另一个引号（除非使用转义序\n列，见下文）。例如：\n\n|  | 在 3.12 版本发生变更: type 现在是一个软关键字。\n2.3.3. 保留的标识符类\n某些标识符类（除了关键字）具有特殊含义。这些类的命名模式以下划线字符开头，并以下划线结\n尾：\n_*\n不会被 from module import * 所导入。\n_\n在 match 语句内部的 case 模式中，_ 是一个 软关键字，它表示 通配符。\n在此之外，交互式解释器会将最后一次求值的结果放到变量 _ 中。 （它与 print 等内置函数\n一起被存储于 builtins 模块。）\n在其他地方，_ 是一个常规标识符。 它常常被用来命名 \"特殊\" 条目，但对 Python 本身来说毫\n无特殊之处。\n备注: _ 常用于连接国际化文本；详见 gettext 模块文档。\n它还经常被用来命名无需使用的变量。\n__*__\n系统定义的名称，通常简称为 \"dunder\" 。这些名称由解释器及其实现（包括标准库）定义。现\n有系统定义名称相关的论述详见 特殊方法名称 等章节。Python 未来版本中还将定义更多此类\n名称。任何情况下，任何 不显式遵从 __*__ 名称的文档用法，都可能导致无警告提示的错误。\n__*\n类的私有名称。类定义时，此类名称以一种混合形式重写，以避免基类及派生类的 \"私有\" 属性\n之间产生名称冲突。详见 标识符（名称）。\n2.4. 字面量\n字面量是内置类型常量值的表示法。\n在词法分析方面，Python有 字符串、字节 和 数值 字面量。\n其他“字面量”通过 关键字 (None、True、False) 和特殊的 省略号标记 (...) 进行词法表示。\n2.5. 字符串与字节串字面量\n字符串字面量是用单引号（'）或双引号（\"）括起来的文本。例如： |  |\n| --- | --- | --- |\n|  | \"spam\"\n'eggs' |  |\n|  | 用于开始字面量的引号也用于终止它，因此字符串字面量只能包含另一个引号（除非使用转义序\n列，见下文）。例如： |  |\n\n'Say \"Hello\", please.'\n\"Don't do that!\"\n除了这个限制外，引号字符（' 或 \"）的选择不影响字面量的解析方式。\n在字符串字面量内部，反斜杠（\\）字符引入了一个 转义序列，其特殊含义取决于反斜杠后面的字\n符。例如，\\\" 表示双引号字符，并且 不 结束字符串：\n>>> print(\"Say \\\"Hello\\\" to everyone!\")\nSay \"Hello\" to everyone!\n有关此类序列的完整列表和更多详细信息，请参见下文的 转义序列。\n2.5.1. 三引号字符串\n字符串也可以用三组匹配的单引号或双引号括起来。这些通常被称为 三引号字符串:\n\"\"\"这是一个三引号字符串。\"\"\"\n在三引号字面量中，允许使用未转义的引号（并且会保留），但与起始引号相同的三个连续未转义\n引号（' 或 \"）会终止字面量:\n\"\"\"这个字符串内有 \"引号\"。\"\"\"\n也允许使用未转义的新行，并且会保留:\n'''这个三引号字符串\n在下一行继续。'''\n2.5.2. 字符串前缀\n字符串字面量可以有一个可选的 前缀，该前缀会影响字面量内容的解析方式，例如:\nb\"data\"\nf'{result=}'\n允许的前缀有:\nb: 字节串字面量\nr: 原始字符串\nf: 格式字符串字面量 (\"f-string\")\nt: 模板字符串字面量 (\"t-string\")\nu: 无效果（为向后兼容而允许）\n详细信息请参见链接部分。\n前缀不区分大小写（例如，'B' 与 'b' 效果相同）。 'r' 前缀可以与 'f', 't' 或 'b' 组合使用，因此\n'fr', 'rf', 'tr', 'rt', 'br' 和 'rb' 也是有效的前缀。\n\n|  | 'Say \"Hello\", please.'\n\"Don't do that!\" |  |\n| --- | --- | --- |\n|  | 除了这个限制外，引号字符（' 或 \"）的选择不影响字面量的解析方式。\n在字符串字面量内部，反斜杠（\\）字符引入了一个 转义序列，其特殊含义取决于反斜杠后面的字\n符。例如，\\\" 表示双引号字符，并且 不 结束字符串： |  |\n|  | >>> print(\"Say \\\"Hello\\\" to everyone!\")\nSay \"Hello\" to everyone! |  |\n|  | 有关此类序列的完整列表和更多详细信息，请参见下文的 转义序列。\n2.5.1. 三引号字符串\n字符串也可以用三组匹配的单引号或双引号括起来。这些通常被称为 三引号字符串: |  |\n|  | \"\"\"这是一个三引号字符串。\"\"\" |  |\n|  | 在三引号字面量中，允许使用未转义的引号（并且会保留），但与起始引号相同的三个连续未转义\n引号（' 或 \"）会终止字面量: |  |\n|  | \"\"\"这个字符串内有 \"引号\"。\"\"\" |  |\n|  | 也允许使用未转义的新行，并且会保留: |  |\n|  | '''这个三引号字符串\n在下一行继续。''' |  |\n|  | 2.5.2. 字符串前缀\n字符串字面量可以有一个可选的 前缀，该前缀会影响字面量内容的解析方式，例如: |  |\n|  | b\"data\"\nf'{result=}' |  |\n|  | 允许的前缀有:\nb: 字节串字面量\nr: 原始字符串\nf: 格式字符串字面量 (\"f-string\")\nt: 模板字符串字面量 (\"t-string\")\nu: 无效果（为向后兼容而允许）\n详细信息请参见链接部分。\n前缀不区分大小写（例如，'B' 与 'b' 效果相同）。 'r' 前缀可以与 'f', 't' 或 'b' 组合使用，因此\n'fr', 'rf', 'tr', 'rt', 'br' 和 'rb' 也是有效的前缀。 |  |\n\nAdded in version 3.3: 新增原始字节串 'rb' 前缀，是 'br' 的同义词。\n为简化 Python 2.x 和 3.x 双版本代码库的维护工作，重新引入了对 Unicode 传统字面量\n（u'value'）的支持。更多信息请参阅 PEP 414。\n2.5.3. 正式语法\n除了 \"f-字符串\" 和 \"t-字符串\" 之外，字符串字面量由以下词法定义描述。\n这些定义使用 负向否定前瞻 (!) 来指示结束引号会终止字面量。\nSTRING: [stringprefix] (stringcontent)\nstringprefix: <(\"r\" | \"u\" | \"b\" | \"br\" | \"rb\"), case-insensitive>\nstringcontent:\n| \"'''\" ( !\"'''\" longstringitem)* \"'''\"\n| '\"\"\"' ( !'\"\"\"' longstringitem)* '\"\"\"'\n| \"'\" ( !\"'\" stringitem)* \"'\"\n| '\"' ( !'\"' stringitem)* '\"'\nstringitem: stringchar | stringescapeseq\nstringchar: <any source_character, except backslash and newline>\nlongstringitem: stringitem | newline\nstringescapeseq: \"\\\" <any source_character>\n请注意，与所有词法定义一样，空白符是重要的。特别是，前缀（如果有）必须紧接起始引号。\n2.5.4. 转义序列\n除非存在 'r' 或 'R' 前缀，在字符串和字节串字面值中的转义序列将按照类似于标准 C 所使用的规则\n进行解读。 可用的转义序列有：\n转义序列 含意\n\\<newline> 字符串转义 - 忽略模式\n\\\\ 反斜杠\n\\' 单引号\n\\\" 双引号\n\\a ASCII 响铃（BEL）\n\\b ASCII 退格符（BS）\n\\f ASCII 换页符（FF）\n\\n ASCII 换行符（LF）\n\\r ASCII 回车符（CR）\n\\t ASCII 水平制表符（TAB）\n\\v ASCII 垂直制表符（VT）\n\\ooo 字符串转义 - 八进制\n\n|  | Added in version 3.3: 新增原始字节串 'rb' 前缀，是 'br' 的同义词。\n为简化 Python 2.x 和 3.x 双版本代码库的维护工作，重新引入了对 Unicode 传统字面量\n（u'value'）的支持。更多信息请参阅 PEP 414。\n2.5.3. 正式语法\n除了 \"f-字符串\" 和 \"t-字符串\" 之外，字符串字面量由以下词法定义描述。\n这些定义使用 负向否定前瞻 (!) 来指示结束引号会终止字面量。 |  |\n| --- | --- | --- |\n|  | STRING: [stringprefix] (stringcontent)\nstringprefix: <(\"r\" | \"u\" | \"b\" | \"br\" | \"rb\"), case-insensitive>\nstringcontent:\n| \"'''\" ( !\"'''\" longstringitem)* \"'''\"\n| '\"\"\"' ( !'\"\"\"' longstringitem)* '\"\"\"'\n| \"'\" ( !\"'\" stringitem)* \"'\"\n| '\"' ( !'\"' stringitem)* '\"'\nstringitem: stringchar | stringescapeseq\nstringchar: <any source_character, except backslash and newline>\nlongstringitem: stringitem | newline\nstringescapeseq: \"\\\" <any source_character> |  |\n|  | 请注意，与所有词法定义一样，空白符是重要的。特别是，前缀（如果有）必须紧接起始引号。\n2.5.4. 转义序列\n除非存在 'r' 或 'R' 前缀，在字符串和字节串字面值中的转义序列将按照类似于标准 C 所使用的规则\n进行解读。 可用的转义序列有：\n转义序列 含意\n\\<newline> 字符串转义 - 忽略模式\n\\\\ 反斜杠\n\\' 单引号\n\\\" 双引号\n\\a ASCII 响铃（BEL）\n\\b ASCII 退格符（BS）\n\\f ASCII 换页符（FF）\n\\n ASCII 换行符（LF）\n\\r ASCII 回车符（CR）\n\\t ASCII 水平制表符（TAB）\n\\v ASCII 垂直制表符（VT）\n\\ooo 字符串转义 - 八进制 |  |\n\n| 转义序列 | 含意 |\n| --- | --- |\n| \\<newline> | 字符串转义 - 忽略模式 |\n| \\\\ | 反斜杠 |\n| \\' | 单引号 |\n| \\\" | 双引号 |\n| \\a | ASCII 响铃（BEL） |\n| \\b | ASCII 退格符（BS） |\n| \\f | ASCII 换页符（FF） |\n| \\n | ASCII 换行符（LF） |\n| \\r | ASCII 回车符（CR） |\n| \\t | ASCII 水平制表符（TAB） |\n| \\v | ASCII 垂直制表符（VT） |\n| \\ooo | 字符串转义 - 八进制 |\n\n转义序列 含意\n\\xhh 字符串转义 - 十六进制\n\\N{name} 字符串转义 - 命名字符\n\\uxxxx 十六进制 Unicode 字符\n\\Uxxxxxxxx 十六进制 Unicode 字符\n2.5.4.1. 忽略行尾\n可以在行尾添加一个反斜杠来忽略换行符:\n>>> 'This string will not include \\\n... backslashes or newline characters.'\n'This string will not include backslashes or newline characters.'\n同样的效果也可以使用 三重引号字符串，或者圆括号和 字符串字面量拼接 来达成。\n2.5.4.2. 转义字符\n要在非 原始 Python 字符串字面量中包含反斜杠，必须将其加倍。\\\\ 转义序列表示单个反斜杠字符:\n>>> print('C:\\\\Program Files')\nC:\\Program Files\n同样，序列 \\' 和 \\\" 分别表示单引号和双引号字符:\n>>> print('\\' and \\\"')\n' and \"\n2.5.4.3. 八进制字符\n序列 \\ooo 表示一个八进制（基数为8）值为 ooo 的*字符*:\n>>> '\\120'\n'P'\n最多接受三个八进制数字（0到7）。\n在字节串字面量中，字符 表示具有给定值的 字节。在字符串字面量中，它表示具有给定值的\nUnicode字符。\n在 3.11 版本发生变更: 值大于 0o377 (255) 的八进制转义会产生一个 DeprecationWarning。\n在 3.12 版本发生变更: 值大于 0o377 (255) 的八进制转义会产生一个 SyntaxWarning。在未来\n的Python版本中，它们将引发一个 SyntaxError。\n2.5.4.4. 十六进制字符\n\n|  | 转义序列 含意\n\\xhh 字符串转义 - 十六进制\n\\N{name} 字符串转义 - 命名字符\n\\uxxxx 十六进制 Unicode 字符\n\\Uxxxxxxxx 十六进制 Unicode 字符\n2.5.4.1. 忽略行尾\n可以在行尾添加一个反斜杠来忽略换行符: |  |\n| --- | --- | --- |\n|  | >>> 'This string will not include \\\n... backslashes or newline characters.'\n'This string will not include backslashes or newline characters.' |  |\n|  | 同样的效果也可以使用 三重引号字符串，或者圆括号和 字符串字面量拼接 来达成。\n2.5.4.2. 转义字符\n要在非 原始 Python 字符串字面量中包含反斜杠，必须将其加倍。\\\\ 转义序列表示单个反斜杠字符: |  |\n|  | >>> print('C:\\\\Program Files')\nC:\\Program Files |  |\n|  | 同样，序列 \\' 和 \\\" 分别表示单引号和双引号字符: |  |\n|  | >>> print('\\' and \\\"')\n' and \" |  |\n|  | 2.5.4.3. 八进制字符\n序列 \\ooo 表示一个八进制（基数为8）值为 ooo 的*字符*: |  |\n|  | >>> '\\120'\n'P' |  |\n|  | 最多接受三个八进制数字（0到7）。\n在字节串字面量中，字符 表示具有给定值的 字节。在字符串字面量中，它表示具有给定值的\nUnicode字符。\n在 3.11 版本发生变更: 值大于 0o377 (255) 的八进制转义会产生一个 DeprecationWarning。\n在 3.12 版本发生变更: 值大于 0o377 (255) 的八进制转义会产生一个 SyntaxWarning。在未来\n的Python版本中，它们将引发一个 SyntaxError。\n2.5.4.4. 十六进制字符 |  |\n\n| 转义序列 | 含意 |\n| --- | --- |\n| \\xhh | 字符串转义 - 十六进制 |\n| \\N{name} | 字符串转义 - 命名字符 |\n| \\uxxxx | 十六进制 Unicode 字符 |\n| \\Uxxxxxxxx | 十六进制 Unicode 字符 |\n\n序列 \\xhh 表示一个十六进制（基数为16）值为 hh 的*字符*:\n>>> '\\x50'\n'P'\n与 C 标准不同，必须为两个十六进制数字。\n在字节串字面量中，字符 表示具有给定值的 字节。在字符串字面量中，它表示具有给定值的\nUnicode字符。\n2.5.4.5. 命名Unicode字符\n序列 \\N{name} 表示具有给定 name 的Unicode字符:\n>>> '\\N{LATIN CAPITAL LETTER P}'\n'P'\n>>> '\\N{SNAKE}'\n'🐍'\n此序列不能出现在 字节串字面量 中。\n在 3.3 版本发生变更: 已添加对 名称别名 的支持。\n2.5.4.6. 十六进制Unicode字符\n这些序列 \\uxxxx 和 \\Uxxxxxxxx 表示具有给定十六进制（基数为16）值的Unicode字符。\\u 需要\n正好四个数字；\\U 需要正好八个数字。后者可以编码任何Unicode字符。\n>>> '\\u1234'\n'ሴ'\n>>> '\\U0001f40d'\n'🐍'\n这些序列不能出现在 字节串字面量 中。\n2.5.4.7. 未识别的转义序列\n与标准C不同，所有未识别的转义序列在字符串中保持不变，即 反斜杠保留在结果中:\n>>> print('\\q')\n\\q\n>>> list('\\q')\n['\\\\', 'q']\n请注意，对于字节串字面量，仅在字符串字面量中识别的转义序列（\\N...，\\u...，\\U...）属于\n未识别的转义类别。\n在 3.6 版本发生变更: 未识别的转义序列会产生 DeprecationWarning。\n在 3.12 版本发生变更: 未识别的转义序列会产生一个 SyntaxWarning。在未来的Python版本\n中，它们将引发一个 SyntaxError。\n\n|  | 序列 \\xhh 表示一个十六进制（基数为16）值为 hh 的*字符*: |  |\n| --- | --- | --- |\n|  | >>> '\\x50'\n'P' |  |\n|  | 与 C 标准不同，必须为两个十六进制数字。\n在字节串字面量中，字符 表示具有给定值的 字节。在字符串字面量中，它表示具有给定值的\nUnicode字符。\n2.5.4.5. 命名Unicode字符\n序列 \\N{name} 表示具有给定 name 的Unicode字符: |  |\n|  | >>> '\\N{LATIN CAPITAL LETTER P}'\n'P'\n>>> '\\N{SNAKE}'\n'🐍' |  |\n|  | 此序列不能出现在 字节串字面量 中。\n在 3.3 版本发生变更: 已添加对 名称别名 的支持。\n2.5.4.6. 十六进制Unicode字符\n这些序列 \\uxxxx 和 \\Uxxxxxxxx 表示具有给定十六进制（基数为16）值的Unicode字符。\\u 需要\n正好四个数字；\\U 需要正好八个数字。后者可以编码任何Unicode字符。 |  |\n|  | >>> '\\u1234'\n'ሴ'\n>>> '\\U0001f40d'\n'🐍' |  |\n|  | 这些序列不能出现在 字节串字面量 中。\n2.5.4.7. 未识别的转义序列\n与标准C不同，所有未识别的转义序列在字符串中保持不变，即 反斜杠保留在结果中: |  |\n|  | >>> print('\\q')\n\\q\n>>> list('\\q')\n['\\\\', 'q'] |  |\n|  | 请注意，对于字节串字面量，仅在字符串字面量中识别的转义序列（\\N...，\\u...，\\U...）属于\n未识别的转义类别。\n在 3.6 版本发生变更: 未识别的转义序列会产生 DeprecationWarning。\n在 3.12 版本发生变更: 未识别的转义序列会产生一个 SyntaxWarning。在未来的Python版本\n中，它们将引发一个 SyntaxError。 |  |\n\n2.5.5. 字节串字面量\n字节串字面值 总是带有 'b' 或 'B' 前缀；它们会产生 bytes 类型而不是 str 类型的实例。 它们只能\n包含 ASCII 字符；数值为 128 或以上的字节必须使用转义序列来表示 (通常为 十六进制字符 或 八进\n制字符)：\n>>> b'\\x89PNG\\r\\n\\x1a\\n'\nb'\\x89PNG\\r\\n\\x1a\\n'\n>>> list(b'\\x89PNG\\r\\n\\x1a\\n')\n[137, 80, 78, 71, 13, 10, 26, 10]\n同样，零字节必须使用转义序列表示（通常是 \\0 或 \\x00）。\n2.5.6. 原始字符串字面量\n字符串和字节串字面值都可以选择带有字符 'r' 或 'R' 作为前缀；这样的构造分别称为 原始字符串字\n面值 和 原始字节串字面值 并会将反斜杠视为字面字符。 因此，在原始字符串字面值中，转义序列\n不会被特殊对待：are not treated specially:\n>>> r'\\d{4}-\\d{2}-\\d{2}'\n'\\\\d{4}-\\\\d{2}-\\\\d{2}'\n即使在原始字面量中，引号也可以用反斜杠转义，但反斜杠会保留在输出结果里；例如 r\"\\\"\" 是由\n两个字符组成的有效字符串字面量：反斜杠和双引号；r\"\\\" 则不是有效字符串字面量（原始字符串\n也不能以奇数个反斜杠结尾）。尤其是，原始字面量不能以单个反斜杠结尾 （反斜杠会转义其后的\n引号)。还要注意，反斜杠加换行在字面量中被解释为两个字符，而 不是 连续行。\n2.5.7. f-字符串\nAdded in version 3.6.\n一个 格式字符串字面值 或 f-字符串 是一个以 'f' 或 'F' 为前缀的字符串字面值。这些字符串可以包\n含替换字段，这些字段是用花括号 {} 分隔的表达式。尽管其他字符串字面量总是具有常量值，格式\n字符串实际上是运行时评估的表达式。\n除非字面量标记为原始字符串，否则，与在普通字符串字面量中一样，转义序列也会被解码。解码\n后，用于字符串内容的语法如下：\nf_string: (literal_char | \"{{\" | \"}}\" | replacement_field)*\nreplacement_field: \"{\" f_expression [\"=\"] [\"!\" conversion] [\":\" format_spec] \"}\"\nf_expression: (conditional_expression | \"*\" or_expr)\n(\",\" conditional_expression | \",\" \"*\" or_expr)* [\",\"]\n| yield_expression\nconversion: \"s\" | \"r\" | \"a\"\nformat_spec: (literal_char | replacement_field)*\nliteral_char: <any code point except \"{\", \"}\" or NULL>\n双花括号 '{{' 或 '}}' 被替换为单花括号，花括号外的字符串仍按字面量处理。单左花括号 '{'\n标记以 Python 表达式开头的替换字段。在表达式后加等于号 '='，可在求值后，同时显示表达式文\n\n|  | 2.5.5. 字节串字面量\n字节串字面值 总是带有 'b' 或 'B' 前缀；它们会产生 bytes 类型而不是 str 类型的实例。 它们只能\n包含 ASCII 字符；数值为 128 或以上的字节必须使用转义序列来表示 (通常为 十六进制字符 或 八进\n制字符)： |  |\n| --- | --- | --- |\n|  | >>> b'\\x89PNG\\r\\n\\x1a\\n'\nb'\\x89PNG\\r\\n\\x1a\\n'\n>>> list(b'\\x89PNG\\r\\n\\x1a\\n')\n[137, 80, 78, 71, 13, 10, 26, 10] |  |\n|  | 同样，零字节必须使用转义序列表示（通常是 \\0 或 \\x00）。\n2.5.6. 原始字符串字面量\n字符串和字节串字面值都可以选择带有字符 'r' 或 'R' 作为前缀；这样的构造分别称为 原始字符串字\n面值 和 原始字节串字面值 并会将反斜杠视为字面字符。 因此，在原始字符串字面值中，转义序列\n不会被特殊对待：are not treated specially: |  |\n|  | >>> r'\\d{4}-\\d{2}-\\d{2}'\n'\\\\d{4}-\\\\d{2}-\\\\d{2}' |  |\n|  | 即使在原始字面量中，引号也可以用反斜杠转义，但反斜杠会保留在输出结果里；例如 r\"\\\"\" 是由\n两个字符组成的有效字符串字面量：反斜杠和双引号；r\"\\\" 则不是有效字符串字面量（原始字符串\n也不能以奇数个反斜杠结尾）。尤其是，原始字面量不能以单个反斜杠结尾 （反斜杠会转义其后的\n引号)。还要注意，反斜杠加换行在字面量中被解释为两个字符，而 不是 连续行。\n2.5.7. f-字符串\nAdded in version 3.6.\n一个 格式字符串字面值 或 f-字符串 是一个以 'f' 或 'F' 为前缀的字符串字面值。这些字符串可以包\n含替换字段，这些字段是用花括号 {} 分隔的表达式。尽管其他字符串字面量总是具有常量值，格式\n字符串实际上是运行时评估的表达式。\n除非字面量标记为原始字符串，否则，与在普通字符串字面量中一样，转义序列也会被解码。解码\n后，用于字符串内容的语法如下： |  |\n|  | f_string: (literal_char | \"{{\" | \"}}\" | replacement_field)*\nreplacement_field: \"{\" f_expression [\"=\"] [\"!\" conversion] [\":\" format_spec] \"}\"\nf_expression: (conditional_expression | \"*\" or_expr)\n(\",\" conditional_expression | \",\" \"*\" or_expr)* [\",\"]\n| yield_expression\nconversion: \"s\" | \"r\" | \"a\"\nformat_spec: (literal_char | replacement_field)*\nliteral_char: <any code point except \"{\", \"}\" or NULL> |  |\n|  | 双花括号 '{{' 或 '}}' 被替换为单花括号，花括号外的字符串仍按字面量处理。单左花括号 '{'\n标记以 Python 表达式开头的替换字段。在表达式后加等于号 '='，可在求值后，同时显示表达式文 |  |\n\n本及其结果（用于调试）。 随后是用叹号 '!' 标记的转换字段。还可以在冒号 ':' 后附加格式说明\n符。替换字段以右花括号 '}' 为结尾。\n格式字符串字面量中的表达式会与用圆括号包围的常规 Python 表达式一样处理，但有少量例外。\n空表达式是不被允许的，而 lambda 和赋值表达式 := 都必须显式地用括号包围。 每个表达式都将\n在格式字符串字面量出现的上下文中按从左到右的顺序进行求值。 替换表达式可在单引号和三引号\nf-字符串中包含换行符并可包含注释。 替换字段内 # 后面的所有内容都是注释（即使结尾花括号和\n引号也是）。 在这种情况下，替换字段必须在另一行中结束。\n>>> f\"abc{a # This is a comment }\"\n... + 3}\"\n'abc5'\n在 3.7 版本发生变更: Python 3.7 以前， 因为实现的问题，不允许在格式字符串字面量表达式\n中使用 await 表达式与包含 async for 子句的推导式。\n在 3.12 版本发生变更: 在 Python 3.12 之前，不允许在 f-字符串的替换字段中使用注释。\n表达式里含等号 '=' 时，输出内容包括表达式文本、'=' 、求值结果。输出内容可以保留表达式中\n左花括号 '{' 后，及 '=' 后的空格。没有指定格式时，'=' 默认调用表达式的 repr()。指定了格\n式时，默认调用表达式的 str()，除非声明了转换字段 '!r'。\nAdded in version 3.8: 等号 '='。\n指定了转换符时，表达式求值的结果会先转换，再格式化。转换符 '!s' 调用 str() 转换求值结\n果，'!r' 调用 repr()，'!a' 调用 ascii()。\n然后使用 format() 协议对结果进行格式化。 格式说明符将传给表达式或转换结果的\n__format__() 方法。 如果省略格式说明符则将传入空字符串。 格式化后的结果将包括在整个字符\n串的最终值中。\n最高层级的格式说明符可以包括嵌套的替换字段。 这些嵌套字段也可以包括它们自己的转换字段和\n格式说明符，但是不可再包括更深层嵌套的替换字段。 这里的 格式说明符微语言 与 str.format()\n方法所使用的相同。\n格式字符串字面量可以拼接，但是一个替换字段不能拆分到多个字面量。\n格式字符串字面量示例如下：\n>>> name = \"Fred\"\n>>> f\"He said his name is {name!r}.\"\n\"He said his name is 'Fred'.\"\n>>> f\"He said his name is {repr(name)}.\" # repr() is equivalent to !r\n\"He said his name is 'Fred'.\"\n>>> width = 10\n>>> precision = 4\n>>> value = decimal.Decimal(\"12.34567\")\n>>> f\"result: {value:{width}.{precision}}\" # nested fields\n'result: 12.35'\n>>> today = datetime(year=2017, month=1, day=27)\n>>> f\"{today:%B %d, %Y}\" # using date format specifier\n\n|  | 本及其结果（用于调试）。 随后是用叹号 '!' 标记的转换字段。还可以在冒号 ':' 后附加格式说明\n符。替换字段以右花括号 '}' 为结尾。\n格式字符串字面量中的表达式会与用圆括号包围的常规 Python 表达式一样处理，但有少量例外。\n空表达式是不被允许的，而 lambda 和赋值表达式 := 都必须显式地用括号包围。 每个表达式都将\n在格式字符串字面量出现的上下文中按从左到右的顺序进行求值。 替换表达式可在单引号和三引号\nf-字符串中包含换行符并可包含注释。 替换字段内 # 后面的所有内容都是注释（即使结尾花括号和\n引号也是）。 在这种情况下，替换字段必须在另一行中结束。 |  |\n| --- | --- | --- |\n|  | >>> f\"abc{a # This is a comment }\"\n... + 3}\"\n'abc5' |  |\n|  | 在 3.7 版本发生变更: Python 3.7 以前， 因为实现的问题，不允许在格式字符串字面量表达式\n中使用 await 表达式与包含 async for 子句的推导式。\n在 3.12 版本发生变更: 在 Python 3.12 之前，不允许在 f-字符串的替换字段中使用注释。\n表达式里含等号 '=' 时，输出内容包括表达式文本、'=' 、求值结果。输出内容可以保留表达式中\n左花括号 '{' 后，及 '=' 后的空格。没有指定格式时，'=' 默认调用表达式的 repr()。指定了格\n式时，默认调用表达式的 str()，除非声明了转换字段 '!r'。\nAdded in version 3.8: 等号 '='。\n指定了转换符时，表达式求值的结果会先转换，再格式化。转换符 '!s' 调用 str() 转换求值结\n果，'!r' 调用 repr()，'!a' 调用 ascii()。\n然后使用 format() 协议对结果进行格式化。 格式说明符将传给表达式或转换结果的\n__format__() 方法。 如果省略格式说明符则将传入空字符串。 格式化后的结果将包括在整个字符\n串的最终值中。\n最高层级的格式说明符可以包括嵌套的替换字段。 这些嵌套字段也可以包括它们自己的转换字段和\n格式说明符，但是不可再包括更深层嵌套的替换字段。 这里的 格式说明符微语言 与 str.format()\n方法所使用的相同。\n格式字符串字面量可以拼接，但是一个替换字段不能拆分到多个字面量。\n格式字符串字面量示例如下： |  |\n|  | >>> name = \"Fred\"\n>>> f\"He said his name is {name!r}.\"\n\"He said his name is 'Fred'.\"\n>>> f\"He said his name is {repr(name)}.\" # repr() is equivalent to !r\n\"He said his name is 'Fred'.\"\n>>> width = 10\n>>> precision = 4\n>>> value = decimal.Decimal(\"12.34567\")\n>>> f\"result: {value:{width}.{precision}}\" # nested fields\n'result: 12.35'\n>>> today = datetime(year=2017, month=1, day=27)\n>>> f\"{today:%B %d, %Y}\" # using date format specifier |  |\n\n'January 27, 2017'\n>>> f\"{today=:%B %d, %Y}\" # using date format specifier and debugging\n'today=January 27, 2017'\n>>> number = 1024\n>>> f\"{number:#0x}\" # using integer format specifier\n'0x400'\n>>> foo = \"bar\"\n>>> f\"{ foo = }\" # preserves whitespace\n\" foo = 'bar'\"\n>>> line = \"The mill's closed\"\n>>> f\"{line = }\"\n'line = \"The mill\\'s closed\"'\n>>> f\"{line = :20}\"\n\"line = The mill's closed \"\n>>> f\"{line = !r:20}\"\n'line = \"The mill\\'s closed\" '\n允许在替换字段中重用外层 f-字符串的引号类型:\n>>> a = dict(x=2)\n>>> f\"abc {a[\"x\"]} def\"\n'abc 2 def'\n在 3.12 版本发生变更: 在 Python 3.12 之前不允许在替换字段中重用与外层 f-字符串相同的引\n号类型。\n替换字段中也允许使用反斜杠并会以与在其他场景下相同的方式求值:\n>>> a = [\"a\", \"b\", \"c\"]\n>>> print(f\"List a contains:\\n{\"\\n\".join(a)}\")\nList a contains:\na\nb\nc\n在 3.12 版本发生变更: 在 Python 3.12 之前，f-字符串的替换字段内不允许使用反斜杠。\n即便未包含表达式，格式字符串字面量也不能用作文档字符串。\n>>> def foo():\n... f\"Not a docstring\"\n...\n>>> foo.__doc__ is None\nTrue\n参阅 PEP 498，了解格式字符串字面量的提案，以及与格式字符串机制相关的 str.format()。\n2.5.8. t-strings\nAdded in version 3.14.\n一个 模板字符串字面值 或 t-字符串 是一个以 't' 或 'T' 为前缀的字符串字面值。这些字符串遵循与\n格式字符串字面值 相同的语法和求值规则，但有以下区别：\n\n|  | 'January 27, 2017'\n>>> f\"{today=:%B %d, %Y}\" # using date format specifier and debugging\n'today=January 27, 2017'\n>>> number = 1024\n>>> f\"{number:#0x}\" # using integer format specifier\n'0x400'\n>>> foo = \"bar\"\n>>> f\"{ foo = }\" # preserves whitespace\n\" foo = 'bar'\"\n>>> line = \"The mill's closed\"\n>>> f\"{line = }\"\n'line = \"The mill\\'s closed\"'\n>>> f\"{line = :20}\"\n\"line = The mill's closed \"\n>>> f\"{line = !r:20}\"\n'line = \"The mill\\'s closed\" ' |  |\n| --- | --- | --- |\n|  | 允许在替换字段中重用外层 f-字符串的引号类型: |  |\n|  | >>> a = dict(x=2)\n>>> f\"abc {a[\"x\"]} def\"\n'abc 2 def' |  |\n|  | 在 3.12 版本发生变更: 在 Python 3.12 之前不允许在替换字段中重用与外层 f-字符串相同的引\n号类型。\n替换字段中也允许使用反斜杠并会以与在其他场景下相同的方式求值: |  |\n|  | >>> a = [\"a\", \"b\", \"c\"]\n>>> print(f\"List a contains:\\n{\"\\n\".join(a)}\")\nList a contains:\na\nb\nc |  |\n|  | 在 3.12 版本发生变更: 在 Python 3.12 之前，f-字符串的替换字段内不允许使用反斜杠。\n即便未包含表达式，格式字符串字面量也不能用作文档字符串。 |  |\n|  | >>> def foo():\n... f\"Not a docstring\"\n...\n>>> foo.__doc__ is None\nTrue |  |\n|  | 参阅 PEP 498，了解格式字符串字面量的提案，以及与格式字符串机制相关的 str.format()。\n2.5.8. t-strings\nAdded in version 3.14.\n一个 模板字符串字面值 或 t-字符串 是一个以 't' 或 'T' 为前缀的字符串字面值。这些字符串遵循与\n格式字符串字面值 相同的语法和求值规则，但有以下区别： |  |\n\n模板字符串字面值不会求值为 str 对象，而是会求值为一个 string.templatelib.Template 对\n象。\nformat() 协议未被使用。相反，格式说明符和转换（如果有）将被传递给为每个评估表达式创建\n的新的 Interpolation 对象。处理生成的 Template 对象的代码将决定如何处理格式说明符和转\n换。\n包含嵌套替换字段的格式说明符会在传递给 Interpolation 对象之前进行急切求值。例如，形如\n{amount:.{precision}f} 的插值表达式会先计算内部表达式 {precision} 以确定\nformat_spec 属性的值。若 precision 的值为 2，则最终的格式说明符将是 '.2f'。\n当插值表达式中包含等号 '=' 时，该表达式的文本（包括等号本身及其周围的空白符）会被追加\n到相关插值位置之前的字面值字符串之后。该表达式对应的 Interpolation 实例会按常规方式创\n建，只不过其 conversion 属性默认会被设为 'r'（即使用 repr() 函数）。如果提供了显式的转\n换说明符或格式说明符，将会覆盖这一默认行为。\n2.6. 数值字面量\nNUMBER 标记表示数字字面量，共有三种类型：整数、浮点数和虚数。\nNUMBER: integer | floatnumber | imagnumber\n数字字面量的数值等价于将其作为字符串传递给 int、float 或 complex 类构造函数时的值。注\n意，这些构造函数的有效输入并不都属于合法的字面量格式。\n数字字面量不包含符号；像 -1 这样的短语实际上是由一元运算符 '-' 和字面量 1 组成的表达式。\n2.6.1. 整数字面量\n整数字面量表示整数。例如：\n7\n3\n2147483647\n整数字面量的长度没有限制，仅受可用内存的存储能力限制：\n7922816251426433759354395033679228162514264337593543950336\n下划线可用于对数字进行分组以增强可读性，且在确定字面量的数值时会被忽略。例如，以下字面\n量是等价的：\n100_000_000_000\n100000000000\n1_00_00_00_00_000\n下划线只能出现在数字之间。例如，_123、321_ 和 123__321 均 不是 有效的字面量。\n整数可以分别使用前缀 0b、0o 和 0x 指定为二进制（基数 2）、八进制（基数 8）或十六进制（基\n数 16）。十六进制数字 10 到 15 用字母 A-F 表示，大小写不敏感。例如：\n\n|  | 模板字符串字面值不会求值为 str 对象，而是会求值为一个 string.templatelib.Template 对\n象。\nformat() 协议未被使用。相反，格式说明符和转换（如果有）将被传递给为每个评估表达式创建\n的新的 Interpolation 对象。处理生成的 Template 对象的代码将决定如何处理格式说明符和转\n换。\n包含嵌套替换字段的格式说明符会在传递给 Interpolation 对象之前进行急切求值。例如，形如\n{amount:.{precision}f} 的插值表达式会先计算内部表达式 {precision} 以确定\nformat_spec 属性的值。若 precision 的值为 2，则最终的格式说明符将是 '.2f'。\n当插值表达式中包含等号 '=' 时，该表达式的文本（包括等号本身及其周围的空白符）会被追加\n到相关插值位置之前的字面值字符串之后。该表达式对应的 Interpolation 实例会按常规方式创\n建，只不过其 conversion 属性默认会被设为 'r'（即使用 repr() 函数）。如果提供了显式的转\n换说明符或格式说明符，将会覆盖这一默认行为。\n2.6. 数值字面量\nNUMBER 标记表示数字字面量，共有三种类型：整数、浮点数和虚数。 |  |\n| --- | --- | --- |\n|  | NUMBER: integer | floatnumber | imagnumber |  |\n|  | 数字字面量的数值等价于将其作为字符串传递给 int、float 或 complex 类构造函数时的值。注\n意，这些构造函数的有效输入并不都属于合法的字面量格式。\n数字字面量不包含符号；像 -1 这样的短语实际上是由一元运算符 '-' 和字面量 1 组成的表达式。\n2.6.1. 整数字面量\n整数字面量表示整数。例如： |  |\n|  | 7\n3\n2147483647 |  |\n|  | 整数字面量的长度没有限制，仅受可用内存的存储能力限制： |  |\n|  | 7922816251426433759354395033679228162514264337593543950336 |  |\n|  | 下划线可用于对数字进行分组以增强可读性，且在确定字面量的数值时会被忽略。例如，以下字面\n量是等价的： |  |\n|  | 100_000_000_000\n100000000000\n1_00_00_00_00_000 |  |\n|  | 下划线只能出现在数字之间。例如，_123、321_ 和 123__321 均 不是 有效的字面量。\n整数可以分别使用前缀 0b、0o 和 0x 指定为二进制（基数 2）、八进制（基数 8）或十六进制（基\n数 16）。十六进制数字 10 到 15 用字母 A-F 表示，大小写不敏感。例如： |  |\n\n0b100110111\n0b_1110_0101\n0o177\n0o377\n0xdeadbeef\n0xDead_Beef\n下划线可以紧跟在进制前缀之后。例如，0x_1f 是有效的字面量，但 0_x1f 和 0x__1f 不是。\n非零十进制数中不允许有前导零。例如，0123 不是有效的字面量。这是为了与 C 风格的八进制字面\n量区分开，Python 在 3.0 版本之前曾使用这种风格。\n形式上，整数字面量由以下词法定义描述：\ninteger: decinteger | bininteger | octinteger | hexinteger | zerointeger\ndecinteger: nonzerodigit ([\"_\"] digit)*\nbininteger: \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\noctinteger: \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\nhexinteger: \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\nzerointeger: \"0\"+ ([\"_\"] \"0\")*\nnonzerodigit: \"1\"...\"9\"\ndigit: \"0\"...\"9\"\nbindigit: \"0\" | \"1\"\noctdigit: \"0\"...\"7\"\nhexdigit: digit | \"a\"...\"f\" | \"A\"...\"F\"\n在 3.6 版本发生变更: 现已支持在字面量中，用下划线分组数字。\n2.6.2. 浮点数字面量\n浮点（float）字面量，例如 3.14 或 1.5，表示 实数的近似值。\n它们由 整数 部分和 小数 部分组成，每个部分均由十进制数字构成。两部分由小数点 . 分隔。:\n2.71828\n4.0\nUnlike in integer literals, leading zeros are allowed. For example, 077.010 is legal, and denotes the\nsame number as 77.01.\n与整数字面量一样，浮点字面量中的数字之间可以使用单个下划线来提高可读性。:\n96_485.332_123\n3.14_15_93\n整数部分或小数部分可以为空，但不能同时为空。例如：\n10. # (等同于 10.0)\n.001 # (等同于 0.001)\n整数部分和小数部分之后可以选择性地跟随一个 指数部分：字母 e 或 E，后面跟一个可选的符号\n（+ 或 -），以及一个格式与整数和小数部分相同的数字。这里的 e 或 E 表示\"乘以10的...次幂\":\n\n|  | 0b100110111\n0b_1110_0101\n0o177\n0o377\n0xdeadbeef\n0xDead_Beef |  |\n| --- | --- | --- |\n|  | 下划线可以紧跟在进制前缀之后。例如，0x_1f 是有效的字面量，但 0_x1f 和 0x__1f 不是。\n非零十进制数中不允许有前导零。例如，0123 不是有效的字面量。这是为了与 C 风格的八进制字面\n量区分开，Python 在 3.0 版本之前曾使用这种风格。\n形式上，整数字面量由以下词法定义描述： |  |\n|  | integer: decinteger | bininteger | octinteger | hexinteger | zerointeger\ndecinteger: nonzerodigit ([\"_\"] digit)*\nbininteger: \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\noctinteger: \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\nhexinteger: \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\nzerointeger: \"0\"+ ([\"_\"] \"0\")*\nnonzerodigit: \"1\"...\"9\"\ndigit: \"0\"...\"9\"\nbindigit: \"0\" | \"1\"\noctdigit: \"0\"...\"7\"\nhexdigit: digit | \"a\"...\"f\" | \"A\"...\"F\" |  |\n|  | 在 3.6 版本发生变更: 现已支持在字面量中，用下划线分组数字。\n2.6.2. 浮点数字面量\n浮点（float）字面量，例如 3.14 或 1.5，表示 实数的近似值。\n它们由 整数 部分和 小数 部分组成，每个部分均由十进制数字构成。两部分由小数点 . 分隔。: |  |\n|  | 2.71828\n4.0 |  |\n|  | Unlike in integer literals, leading zeros are allowed. For example, 077.010 is legal, and denotes the\nsame number as 77.01.\n与整数字面量一样，浮点字面量中的数字之间可以使用单个下划线来提高可读性。: |  |\n|  | 96_485.332_123\n3.14_15_93 |  |\n|  | 整数部分或小数部分可以为空，但不能同时为空。例如： |  |\n|  | 10. # (等同于 10.0)\n.001 # (等同于 0.001) |  |\n|  | 整数部分和小数部分之后可以选择性地跟随一个 指数部分：字母 e 或 E，后面跟一个可选的符号\n（+ 或 -），以及一个格式与整数和小数部分相同的数字。这里的 e 或 E 表示\"乘以10的...次幂\": |  |\n\n1.0e3 # (代表 1.0×10³, or 1000.0)\n1.166e-5 # (代表 1.166×10⁻⁵, or 0.00001166)\n6.02214076e+23 # (代表 6.02214076×10²³ 或 602214076000000000000000)\n对于仅包含整数部分和指数部分的浮点字面量，小数点可以省略:\n1e3 # (等同于 1.e3 和 1.0e3)\n0e0 # (等同于 0)\n形式上，浮点字面量由以下词法定义描述：\nfloatnumber:\n| digitpart \".\" [digitpart] [exponent]\n| \".\" digitpart [exponent]\n| digitpart exponent\ndigitpart: digit ([\"_\"] digit)*\nexponent: (\"e\" | \"E\") [\"+\" | \"-\"] digitpart\n在 3.6 版本发生变更: 现已支持在字面量中，用下划线分组数字。\n2.6.3. 虚数字面量\nPython 拥有 复数 对象，但没有直接的复数字面量。相反，虚数字面量 表示实部为零的复数。\n例如，在数学中，复数 3+4.2i 被写作实数 3 加上虚数 4.2i。Python 使用类似的语法，只是虚数单位\n写作 j 而非 i:\n3+4.2j\n这是一个由 整数字面量 3、 运算符 '+' 和 虚数字面量 4.2j 组成的表达式。由于这是三个独立的词\n法单元，它们之间允许存在空白符:\n3 + 4.2j\n每个词法单元内部不允许有空白符。特别地，j 后缀不能与其前面的数字分隔开。\nj 前面的数字部分与浮点字面量的语法规则相同。因此，以下是有效的虚数字面量：\n4.2j\n3.14j\n10.j\n.001j\n1e100j\n3.14e-10j\n3.14_15_93j\n与浮点字面量不同，如果虚数部分仅包含整数部分，则小数点可以省略。该数值仍会被计算为浮点\n数，而非整数:\n10j\n0j\n1000000000000000000000000j # 等同于 1e+24j\n\n|  | 1.0e3 # (代表 1.0×10³, or 1000.0)\n1.166e-5 # (代表 1.166×10⁻⁵, or 0.00001166)\n6.02214076e+23 # (代表 6.02214076×10²³ 或 602214076000000000000000) |  |\n| --- | --- | --- |\n|  | 对于仅包含整数部分和指数部分的浮点字面量，小数点可以省略: |  |\n|  | 1e3 # (等同于 1.e3 和 1.0e3)\n0e0 # (等同于 0) |  |\n|  | 形式上，浮点字面量由以下词法定义描述： |  |\n|  | floatnumber:\n| digitpart \".\" [digitpart] [exponent]\n| \".\" digitpart [exponent]\n| digitpart exponent\ndigitpart: digit ([\"_\"] digit)*\nexponent: (\"e\" | \"E\") [\"+\" | \"-\"] digitpart |  |\n|  | 在 3.6 版本发生变更: 现已支持在字面量中，用下划线分组数字。\n2.6.3. 虚数字面量\nPython 拥有 复数 对象，但没有直接的复数字面量。相反，虚数字面量 表示实部为零的复数。\n例如，在数学中，复数 3+4.2i 被写作实数 3 加上虚数 4.2i。Python 使用类似的语法，只是虚数单位\n写作 j 而非 i: |  |\n|  | 3+4.2j |  |\n|  | 这是一个由 整数字面量 3、 运算符 '+' 和 虚数字面量 4.2j 组成的表达式。由于这是三个独立的词\n法单元，它们之间允许存在空白符: |  |\n|  | 3 + 4.2j |  |\n|  | 每个词法单元内部不允许有空白符。特别地，j 后缀不能与其前面的数字分隔开。\nj 前面的数字部分与浮点字面量的语法规则相同。因此，以下是有效的虚数字面量： |  |\n|  | 4.2j\n3.14j\n10.j\n.001j\n1e100j\n3.14e-10j\n3.14_15_93j |  |\n|  | 与浮点字面量不同，如果虚数部分仅包含整数部分，则小数点可以省略。该数值仍会被计算为浮点\n数，而非整数: |  |\n|  | 10j\n0j\n1000000000000000000000000j # 等同于 1e+24j |  |\n|  |  |  |\n\nj 后缀在语法上是大小写不敏感的。这意味着你可以使用 J 替代:\n3.14J # 等同于 3.14j\n形式上，虚数字面量由以下词法定义描述：\nimagnumber: (floatnumber | digitpart) (\"j\" | \"J\")\n2.7. 运算符与定界符\n以下语法定义了 运算符 和 定界符 标记，即通用的 OP 标记类型。 这些标记及其名称的列表 也可在\ntoken 模块文档中找到。\nOP:\n| assignment_operator\n| bitwise_operator\n| comparison_operator\n| enclosing_delimiter\n| other_delimiter\n| arithmetic_operator\n| \"...\"\n| other_op\nassignment_operator: \"+=\" | \"-=\" | \"*=\" | \"**=\" | \"/=\" | \"//=\" | \"%=\" |\n\"&=\" | \"|=\" | \"^=\" | \"<<=\" | \">>=\" | \"@=\" | \":=\"\nbitwise_operator: \"&\" | \"|\" | \"^\" | \"~\" | \"<<\" | \">>\"\ncomparison_operator: \"<=\" | \">=\" | \"<\" | \">\" | \"==\" | \"!=\"\nenclosing_delimiter: \"(\" | \")\" | \"[\" | \"]\" | \"{\" | \"}\"\nother_delimiter: \",\" | \":\" | \"!\" | \";\" | \"=\" | \"->\"\narithmetic_operator: \"+\" | \"-\" | \"**\" | \"*\" | \"//\" | \"/\" | \"%\"\nother_op: \".\" | \"@\"\n备注: 通常，运算符 用于组合 表达式，而 定界符 则用于其他用途。然而，这两类标记之间并没\n有明确、正式的区分标准。\n某些记号既可用作运算符也可用作定界符，具体取决于使用场景。例如，* 既是乘法运算符，也\n是用于序列解包的定界符；而 @ 既是矩阵乘法运算符，也是引入装饰器的定界符。\n对于某些记号而言，其分类界限并不明确。例如，有些人认为 .、( 和 ) 是定界符，而另一些人\n则将其视为 getattr() 运算符和函数调用运算符。\nPython 中的部分运算符（如 and、or 和 not in）使用 关键字 记号而非\"符号\"（运算符记号）\n实现。\n连续三个点号的序列 (...) 具有表示一个 Ellipsis 字面值的特殊含义。\n\n| j 后缀在语法上是大小写不敏感的。这意味着你可以使用 J 替代: |\n| --- |\n| 3.14J # 等同于 3.14j |\n| 形式上，虚数字面量由以下词法定义描述： |\n| imagnumber: (floatnumber | digitpart) (\"j\" | \"J\") |\n| 2.7. 运算符与定界符\n以下语法定义了 运算符 和 定界符 标记，即通用的 OP 标记类型。 这些标记及其名称的列表 也可在\ntoken 模块文档中找到。 |\n| OP:\n| assignment_operator\n| bitwise_operator\n| comparison_operator\n| enclosing_delimiter\n| other_delimiter\n| arithmetic_operator\n| \"...\"\n| other_op\nassignment_operator: \"+=\" | \"-=\" | \"*=\" | \"**=\" | \"/=\" | \"//=\" | \"%=\" |\n\"&=\" | \"|=\" | \"^=\" | \"<<=\" | \">>=\" | \"@=\" | \":=\"\nbitwise_operator: \"&\" | \"|\" | \"^\" | \"~\" | \"<<\" | \">>\"\ncomparison_operator: \"<=\" | \">=\" | \"<\" | \">\" | \"==\" | \"!=\"\nenclosing_delimiter: \"(\" | \")\" | \"[\" | \"]\" | \"{\" | \"}\"\nother_delimiter: \",\" | \":\" | \"!\" | \";\" | \"=\" | \"->\"\narithmetic_operator: \"+\" | \"-\" | \"**\" | \"*\" | \"//\" | \"/\" | \"%\"\nother_op: \".\" | \"@\" |\n|  |\n| 备注: 通常，运算符 用于组合 表达式，而 定界符 则用于其他用途。然而，这两类标记之间并没\n有明确、正式的区分标准。\n某些记号既可用作运算符也可用作定界符，具体取决于使用场景。例如，* 既是乘法运算符，也\n是用于序列解包的定界符；而 @ 既是矩阵乘法运算符，也是引入装饰器的定界符。\n对于某些记号而言，其分类界限并不明确。例如，有些人认为 .、( 和 ) 是定界符，而另一些人\n则将其视为 getattr() 运算符和函数调用运算符。\nPython 中的部分运算符（如 and、or 和 not in）使用 关键字 记号而非\"符号\"（运算符记号）\n实现。 |\n| 连续三个点号的序列 (...) 具有表示一个 Ellipsis 字面值的特殊含义。 |", "metadata": {"title": "02_词法分析", "source": "md_docs\\python_reference_md\\02_词法分析.md", "doc_type": "语言参考", "language": "中文", "doc_id": "074c839b"}}
{"doc_id": "5b55d4e0", "content": "3. 数据模型\n3.1. 对象、值与类型\n对象 是 Python 中对数据的抽象。 Python 程序中的所有数据都是由对象或对象间关系来表示的。\n（从某种意义上说，按照冯·诺依曼的“存储程序计算机”模型，代码本身也是由对象来表示的。）\n每个对象都有相应的标识号、类型和值。 一个对象被创建后它的 标识号 就绝不会改变；你可以将其\n理解为该对象在内存中的地址。 is 运算符比较两个对象的标识号是否相同；id() 函数返回一个代\n表其标识号的整数。\n在 CPython 中，id(x) 就是存放 x 的内存的地址。\n对象的类型决定该对象所支持的操作 (例如 \"对象是否有长度属性？\") 并且定义了该类型的对象可能\n的取值。type() 函数能返回一个对象的类型 (类型本身也是对象)。与编号一样，一个对象的 类型\n也是不可改变的。[1]\n有些对象的 值 可以改变。值可以改变的对象被称为 可变对象；值不可以改变的对象就被称为 不可\n变对象。(一个不可变容器对象如果包含对可变对象的引用，当后者的值改变时，前者的值也会改\n变；但是该容器仍属于不可变对象，因为它所包含的对象集是不会改变的。因此，不可变并不严格\n等同于值不能改变，实际含义要更微妙。) 一个对象的可变性是由其类型决定的；例如，数字、字符\n串和元组是不可变的，而字典和列表是可变的。\n对象绝不会被显式地销毁；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟\n垃圾回收或完全省略此机制 --- 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收\n即可。\nCPython 目前使用带有 (可选) 延迟检测循环链接垃圾的引用计数方案，会在对象不可访问时立即回\n收其中的大部分，但不保证回收包含循环引用的垃圾。请查看 gc 模块的文档了解如何控制循环垃圾\n的收集相关信息。其他实现会有不同的行为方式，CPython 现有方式也可能改变。不要依赖不可访\n问对象的立即终结机制 (所以你应当总是显式地关闭文件)。\n注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。还要注意通过\ntry...except 语句捕捉异常也可能令对象保持存活。\n有些对象包含对“外部”资源如打开的文件或窗口的引用。 当对象被作为垃圾回收时这些资源也应该\n会被释放，但由于垃圾回收并不确保发生，这些对象还提供了明确地释放外部资源的操作，通常为\n一个 close() 方法。 强烈推荐在程序中显式关闭此类对象。 try...finally 语句和 with 语句提供\n了进行此种操作的更便捷方式。\n有些对象包含对其他对象的引用；它们被称为 容器。容器的例子有元组、列表和字典等。这些引用\n是容器对象值的组成部分。在多数情况下，当谈论一个容器的值时，我们是指所包含对象的值而不\n是其编号；但是，当我们谈论一个容器的可变性时，则仅指其直接包含的对象的编号。因此，如果\n\n一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改\n变。\n类型会影响对象行为的几乎所有方面。 甚至对象标识号的重要性也在某种程度上受到影响：对于不\n可变类型，计算新值的操作实际上可能返回一个指向具有相同类型和值的任何现存对象的引用，而\n对于可变对象来说这是不允许的。 例如在 a = 1; b = 1 之后，a 和 b 可能会也可能不会指向同一\n个值为一的对象。 这是因为 int 是不可变对象，因此对 1 的引用可以被重用。 此行为依赖于所使\n用的具体实现，因此不应该依赖它，而在使用对象标识测试时需要注意。 不过，在 c = []; d =\n[] 之后，c 和 d 保证会指向两个不同的、独特的、新创建的空列表。 (注意 e = f = [] 会将 同一\n个 对象同时赋值给 e 和 f。)\n3.2. 标准类型层级结构\n以下是 Python 内置类型的列表。扩展模块 (具体实现会以 C, Java 或其他语言编写) 可以定义更多的\n类型。未来版本的 Python 可能会加入更多的类型 (例如有理数、高效存储的整型数组等等)，不过新\n增类型往往都是通过标准库来提供的。\n以下部分类型的描述中包含有 '特殊属性列表' 段落。这些属性提供对具体实现的访问而非通常使\n用。它们的定义在未来可能会改变。\n3.2.1. None\n此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 None 访问。在许多情况下\n它被用来表示空值，例如未显式指明返回值的函数将返回 None。它的逻辑值为假。\n3.2.2. NotImplemented\n此类型只有一种取值。 是一个具有该值的单独对象。 此对象通过内置名称 NotImplemented 访问。\n数值方法和丰富比较方法如未实现指定运算符表示的运算则应返回该值。 （解释器会根据具体运算\n符继续尝试反向运算或其他回退操作。） 它不应被解读为布尔值。\n详情参见 实现算术运算。\n在 3.9 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值的做法已被弃用。\n在 3.14 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值现在会引发 TypeError。\n在之前版本中它会被求值为 True 并将从 Python 3.9 起发出 DeprecationWarning。\n3.2.3. Ellipsis\n此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 ... 或内置名称 Ellipsis\n访问。它的逻辑值为真。\n3.2.4. numbers.Number\n此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可\n变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机\n\n|  |  | 一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改\n变。\n类型会影响对象行为的几乎所有方面。 甚至对象标识号的重要性也在某种程度上受到影响：对于不\n可变类型，计算新值的操作实际上可能返回一个指向具有相同类型和值的任何现存对象的引用，而\n对于可变对象来说这是不允许的。 例如在 a = 1; b = 1 之后，a 和 b 可能会也可能不会指向同一\n个值为一的对象。 这是因为 int 是不可变对象，因此对 1 的引用可以被重用。 此行为依赖于所使\n用的具体实现，因此不应该依赖它，而在使用对象标识测试时需要注意。 不过，在 c = []; d =\n[] 之后，c 和 d 保证会指向两个不同的、独特的、新创建的空列表。 (注意 e = f = [] 会将 同一\n个 对象同时赋值给 e 和 f。)\n3.2. 标准类型层级结构\n以下是 Python 内置类型的列表。扩展模块 (具体实现会以 C, Java 或其他语言编写) 可以定义更多的\n类型。未来版本的 Python 可能会加入更多的类型 (例如有理数、高效存储的整型数组等等)，不过新\n增类型往往都是通过标准库来提供的。\n以下部分类型的描述中包含有 '特殊属性列表' 段落。这些属性提供对具体实现的访问而非通常使\n用。它们的定义在未来可能会改变。\n3.2.1. None\n此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 None 访问。在许多情况下\n它被用来表示空值，例如未显式指明返回值的函数将返回 None。它的逻辑值为假。\n3.2.2. NotImplemented\n此类型只有一种取值。 是一个具有该值的单独对象。 此对象通过内置名称 NotImplemented 访问。\n数值方法和丰富比较方法如未实现指定运算符表示的运算则应返回该值。 （解释器会根据具体运算\n符继续尝试反向运算或其他回退操作。） 它不应被解读为布尔值。\n详情参见 实现算术运算。\n在 3.9 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值的做法已被弃用。\n在 3.14 版本发生变更: 在布尔运算上下文中对 NotImplemented 求值现在会引发 TypeError。\n在之前版本中它会被求值为 True 并将从 Python 3.9 起发出 DeprecationWarning。\n3.2.3. Ellipsis\n此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 ... 或内置名称 Ellipsis\n访问。它的逻辑值为真。\n3.2.4. numbers.Number\n此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可\n变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机 |  |\n| --- | --- | --- | --- |\n|  |  | [] |  |\n|  |  |  |  |\n\n中的数字表示方法。\n数字类的字符串表示形式，由 __repr__() 和 __str__() 算出，具有以下特征属性:\n它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。\n表示形式会在可能的情况下采用 10 进制。\n开头的零，除小数点前可能存在的单个零之外，将不会被显示。\n末尾的零，除小数点后可能存在的单个零之外，将不会被显示。\n正负号仅在当数字为负值时会被显示。\nPython 区分整型数、浮点型数和复数：\n3.2.4.1. numbers.Integral\n此类对象表示数学中整数集合的成员 (包括正数和负数)。\n备注: 整型数表示规则的目的是在涉及负整型数的变换和掩码运算时提供最为合理的解释。\n整型数可细分为两种类型:\n整型 (int)\n此类对象表示任意大小的数字，仅受限于可用的内存 (包括虚拟内存)。在变换和掩码运算中会\n以二进制表示，负数会以 2 的补码表示，看起来像是符号位向左延伸补满空位。\n布尔型 (bool)\n此类对象表示逻辑值 False 和 True。代表 False 和 True 值的两个对象是唯二的布尔对象。布\n尔类型是整型的子类型，两个布尔值在各种场合的行为分别类似于数值 0 和 1，例外情况只有\n在转换为字符串时分别返回字符串 \"False\" 或 \"True\"。\n3.2.4.2. numbers.Real (float)\n此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以\n及 C 或 Java 实现)。Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，\n但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而\n令该语言变得复杂。\n3.2.4.3. numbers.Complex (complex)\n此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。一个\n复数值 z 的实部和虚部可通过只读属性 z.real 和 z.imag 来获取。\n3.2.5. 序列\n这些代表以非负数为索引的有限有序集合。 内置函数 len() 将返回序列的项数。 当序列 的长度为\nn 时，索引集合将包含数字 0, 1, ..., n-1。 a[i] 是选择序列 a 中的第 i 项。 某些序列，包括内置的序\n列，可通过加上序列长度来解读负下标值。 例如，a[-2] 等价于 a[n-2]，即长度为 n 的 a 序列的\n倒数第二项。\n\n|  | 中的数字表示方法。\n数字类的字符串表示形式，由 __repr__() 和 __str__() 算出，具有以下特征属性:\n它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。\n表示形式会在可能的情况下采用 10 进制。\n开头的零，除小数点前可能存在的单个零之外，将不会被显示。\n末尾的零，除小数点后可能存在的单个零之外，将不会被显示。\n正负号仅在当数字为负值时会被显示。\nPython 区分整型数、浮点型数和复数：\n3.2.4.1. numbers.Integral\n此类对象表示数学中整数集合的成员 (包括正数和负数)。 |  |\n| --- | --- | --- |\n|  | 备注: 整型数表示规则的目的是在涉及负整型数的变换和掩码运算时提供最为合理的解释。 |  |\n|  | 整型数可细分为两种类型:\n整型 (int)\n此类对象表示任意大小的数字，仅受限于可用的内存 (包括虚拟内存)。在变换和掩码运算中会\n以二进制表示，负数会以 2 的补码表示，看起来像是符号位向左延伸补满空位。\n布尔型 (bool)\n此类对象表示逻辑值 False 和 True。代表 False 和 True 值的两个对象是唯二的布尔对象。布\n尔类型是整型的子类型，两个布尔值在各种场合的行为分别类似于数值 0 和 1，例外情况只有\n在转换为字符串时分别返回字符串 \"False\" 或 \"True\"。\n3.2.4.2. numbers.Real (float)\n此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以\n及 C 或 Java 实现)。Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，\n但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而\n令该语言变得复杂。\n3.2.4.3. numbers.Complex (complex)\n此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。一个\n复数值 z 的实部和虚部可通过只读属性 z.real 和 z.imag 来获取。\n3.2.5. 序列\n这些代表以非负数为索引的有限有序集合。 内置函数 len() 将返回序列的项数。 当序列 的长度为\nn 时，索引集合将包含数字 0, 1, ..., n-1。 a[i] 是选择序列 a 中的第 i 项。 某些序列，包括内置的序\n列，可通过加上序列长度来解读负下标值。 例如，a[-2] 等价于 a[n-2]，即长度为 n 的 a 序列的\n倒数第二项。 |  |\n\n序列还支持切片: a[i:j] 是选择索引为 k 使得 i <= k < j 的所有条目。 当用作表达式时，切片就是\n一个相同类型的新序列。 以上有关负索引的注释也适用于切片位置的负值。\n有些序列还支持带有第三个 \"step\" 形参的 \"扩展切片\": a[i:j:k] 选择 a 中索引号为 x 的所有条目，\nx = i + n*k, n >= 0 且 i <= x < j。\n序列可根据其可变性来加以区分:\n3.2.5.1. 不可变序列\n不可变序列类型的对象一旦创建就不能再改变。(如果对象包含对其他对象的引用，其中的可变对象\n就是可以改变的；但是，一个不可变对象所直接引用的对象集是不能改变的。)\n以下类型属于不可变对象:\n字符串\n字符串是由代表 Unicode 码位的值组成的序列。 取值范围在 U+0000 - U+10FFFF 之内的所有\n码位都可在字符串中使用。 Python 没有 char 类型；而是将字符串中的每个码位表示为一个长\n度为 1 的字符串对象。 内置函数 ord() 可将一个码位由字符串形式转换为取值范围在 0 -\n10FFFF 之内的整数；chr() 可将一个取值范围在 0 - 10FFFF 之内的整数转换为长度为 1 的\n对应字符串对象。 str.encode() 可以使用给定的文本编码格式将 str 转换为 bytes，而\nbytes.decode() 则可以被用来实现相反的解码操作。\n元组\n一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构\n成。只有一个条目的元组 ('单项元组') 可通过在表达式后加一个逗号来构成 (一个表达式本身不\n能创建为元组，因为圆括号要用来设置表达式分组)。一个空元组可通过一对内容为空的圆括号\n创建。\n字节串\n字节串对象是不可变的数组。 其中的条目是 8 比特位的字节，以取值范围 0 <= x < 256 内的整\n数表示。 字节串字面值 (如 b'abc') 和内置的 bytes() 构造器可被用来创建字节串对象。 并\n且，字节串对象还可通过 decode() 方法被解码为字符串。\n3.2.5.2. 可变序列\n可变序列在被创建后仍可被改变。下标和切片标注可被用作赋值和 del (删除) 语句的目标。\n备注: collections 和 array 模块提供了可变序列类型的更多例子。\n目前有两种内生可变序列类型:\n列表\n列表中的条目可以是任意 Python 对象。列表由用方括号括起并由逗号分隔的多个表达式构成。\n(注意创建长度为 0 或 1 的列表无需使用特殊规则。)\n字节数组\n\n|  | 序列还支持切片: a[i:j] 是选择索引为 k 使得 i <= k < j 的所有条目。 当用作表达式时，切片就是\n一个相同类型的新序列。 以上有关负索引的注释也适用于切片位置的负值。\n有些序列还支持带有第三个 \"step\" 形参的 \"扩展切片\": a[i:j:k] 选择 a 中索引号为 x 的所有条目，\nx = i + n*k, n >= 0 且 i <= x < j。\n序列可根据其可变性来加以区分:\n3.2.5.1. 不可变序列\n不可变序列类型的对象一旦创建就不能再改变。(如果对象包含对其他对象的引用，其中的可变对象\n就是可以改变的；但是，一个不可变对象所直接引用的对象集是不能改变的。)\n以下类型属于不可变对象:\n字符串\n字符串是由代表 Unicode 码位的值组成的序列。 取值范围在 U+0000 - U+10FFFF 之内的所有\n码位都可在字符串中使用。 Python 没有 char 类型；而是将字符串中的每个码位表示为一个长\n度为 1 的字符串对象。 内置函数 ord() 可将一个码位由字符串形式转换为取值范围在 0 -\n10FFFF 之内的整数；chr() 可将一个取值范围在 0 - 10FFFF 之内的整数转换为长度为 1 的\n对应字符串对象。 str.encode() 可以使用给定的文本编码格式将 str 转换为 bytes，而\nbytes.decode() 则可以被用来实现相反的解码操作。\n元组\n一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构\n成。只有一个条目的元组 ('单项元组') 可通过在表达式后加一个逗号来构成 (一个表达式本身不\n能创建为元组，因为圆括号要用来设置表达式分组)。一个空元组可通过一对内容为空的圆括号\n创建。\n字节串\n字节串对象是不可变的数组。 其中的条目是 8 比特位的字节，以取值范围 0 <= x < 256 内的整\n数表示。 字节串字面值 (如 b'abc') 和内置的 bytes() 构造器可被用来创建字节串对象。 并\n且，字节串对象还可通过 decode() 方法被解码为字符串。\n3.2.5.2. 可变序列\n可变序列在被创建后仍可被改变。下标和切片标注可被用作赋值和 del (删除) 语句的目标。 |  |  |\n| --- | --- | --- | --- |\n|  |  | 0 - |  |\n|  |  |  |  |\n|  | 备注: collections 和 array 模块提供了可变序列类型的更多例子。 |  |  |\n|  | 目前有两种内生可变序列类型:\n列表\n列表中的条目可以是任意 Python 对象。列表由用方括号括起并由逗号分隔的多个表达式构成。\n(注意创建长度为 0 或 1 的列表无需使用特殊规则。)\n字节数组 |  |  |\n\n字节数组对象属于可变数组。可以通过内置的 bytearray() 构造器来创建。除了是可变的 (因\n而也是不可哈希的)，在其他方面字节数组提供的接口和功能都与不可变的 bytes 对象一致。\n3.2.6. 集合类型\n此类对象表示由不重复且不可变对象组成的无序且有限的集合。因此它们不能通过下标来索引。但\n是它们可被迭代，也可用内置函数 len() 返回集合中的条目数。集合常见的用处是快速成员检测，\n去除序列中的重复项，以及进行交、并、差和对称差等数学运算。\n对于集合元素所采用的不可变规则与字典的键相同。注意数字类型遵循正常的数字比较规则: 如果两\n个数字相等 (例如 1 和 1.0)，则同一集合中只能包含其中一个。\n目前有两种内生集合类型:\n集合\n这些对象代表可变集合。 它们可通过内置 set() 构造器创建并且在此之后可通过某些方法来修\n改，例如 add。\n冻结集合\n此类对象表示不可变集合。它们可通过内置的 frozenset() 构造器创建。由于 frozenset 对象\n不可变且 hashable，它可以被用作另一个集合的元素或是字典的键。\n3.2.7. 映射\n此类对象表示由任意索引集合所索引的对象的集合。通过下标 a[k] 可在映射 a 中选择索引为 k 的\n条目；这可以在表达式中使用，也可作为赋值或 del 语句的目标。内置函数 len() 可返回一个映射\n中的条目数。\n目前只有一种内生映射类型:\n3.2.7.1. 字典\n此类对象表示由几乎任意值作为索引的有限个对象的集合。不可作为键的值类型只有包含列表或字\n典或其他可变类型，通过值而非对象编号进行比较的值，其原因在于高效的字典实现需要使用键的\n哈希值以保持一致性。用作键的数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 1 和\n1.0) 则它们均可来用来索引同一个字典条目。\n字典会保留插入顺序，这意味着键将以它们被添加的顺序在字典中依次产生。 替换某个现有的键不\n会改变其顺序，但是移除某个键再重新插入则会将其添加到末尾而不会保留其原有位置。\n字典是可变对象；它们可通过 {} 标注方式来创建（参见 字典显示 一节）。\n扩展模块 dbm.ndbm 和 dbm.gnu 提供了额外的映射类型示例，collections 模块也是如此。\n在 3.7 版本发生变更: 在 Python 3.6 版之前字典不会保留插入顺序。 在 CPython 3.6 中插入顺\n序会被保留，但这在当时被当作是一个实现细节而非确定的语言特性。\n3.2.8. 可调用类型\n\n|  | 字节数组对象属于可变数组。可以通过内置的 bytearray() 构造器来创建。除了是可变的 (因\n而也是不可哈希的)，在其他方面字节数组提供的接口和功能都与不可变的 bytes 对象一致。\n3.2.6. 集合类型\n此类对象表示由不重复且不可变对象组成的无序且有限的集合。因此它们不能通过下标来索引。但\n是它们可被迭代，也可用内置函数 len() 返回集合中的条目数。集合常见的用处是快速成员检测，\n去除序列中的重复项，以及进行交、并、差和对称差等数学运算。\n对于集合元素所采用的不可变规则与字典的键相同。注意数字类型遵循正常的数字比较规则: 如果两\n个数字相等 (例如 1 和 1.0)，则同一集合中只能包含其中一个。\n目前有两种内生集合类型:\n集合\n这些对象代表可变集合。 它们可通过内置 set() 构造器创建并且在此之后可通过某些方法来修\n改，例如 add。\n冻结集合\n此类对象表示不可变集合。它们可通过内置的 frozenset() 构造器创建。由于 frozenset 对象\n不可变且 hashable，它可以被用作另一个集合的元素或是字典的键。\n3.2.7. 映射\n此类对象表示由任意索引集合所索引的对象的集合。通过下标 a[k] 可在映射 a 中选择索引为 k 的\n条目；这可以在表达式中使用，也可作为赋值或 del 语句的目标。内置函数 len() 可返回一个映射\n中的条目数。\n目前只有一种内生映射类型:\n3.2.7.1. 字典\n此类对象表示由几乎任意值作为索引的有限个对象的集合。不可作为键的值类型只有包含列表或字\n典或其他可变类型，通过值而非对象编号进行比较的值，其原因在于高效的字典实现需要使用键的\n哈希值以保持一致性。用作键的数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 1 和\n1.0) 则它们均可来用来索引同一个字典条目。\n字典会保留插入顺序，这意味着键将以它们被添加的顺序在字典中依次产生。 替换某个现有的键不\n会改变其顺序，但是移除某个键再重新插入则会将其添加到末尾而不会保留其原有位置。\n字典是可变对象；它们可通过 {} 标注方式来创建（参见 字典显示 一节）。\n扩展模块 dbm.ndbm 和 dbm.gnu 提供了额外的映射类型示例，collections 模块也是如此。\n在 3.7 版本发生变更: 在 Python 3.6 版之前字典不会保留插入顺序。 在 CPython 3.6 中插入顺\n序会被保留，但这在当时被当作是一个实现细节而非确定的语言特性。\n3.2.8. 可调用类型 |  |\n| --- | --- | --- |\n\n此类型可以被应用于函数调用操作 (参见 调用 小节):\n3.2.8.1. 用户定义函数\n用户定义函数对象可通过函数定义来创建 (参见 函数定义 小节)。它被调用时应附带一个参数列表，\n其中包含的条目应与函数所定义的形参列表一致。\n3.2.8.1.1. 特殊的只读属性\n属性 含意\n对存放该函数中 全局变量 的 字典 的引用 —— 函数定义所在模块\nfunction.__globals__\n的全局命名空间。\nNone 或单元的 tuple，其中包含了名称在函数的 代码对象 的\nco_freevars 中对指定名称的绑定。\nfunction.__closure__\n单元对象具有 cell_contents 属性。这可被用来获取以及设置单\n元的值。\n3.2.8.1.2. 特殊的可写属性\n这些属性大多会检查赋值的类型：\n属性 含意\nfunction.__doc__ 函数的文档字符串，或者如果不可用则为 None。\nfunction.__name__ 函数的名称。 另请参阅: __name__ 属性。\n函数的 qualified name。 另请参阅: __qualname__ 属性。\nfunction.__qualname__\nAdded in version 3.3.\nfunction.__module__ 该函数所属模块的名称，没有则为 None。\n由具有默认值的形参的默认 parameter 值组成的 tuple，或\nfunction.__defaults__\n者如果无任何形参具有默认值则为 None。\nfunction.__code__ 代表已编译的函数体的 代码对象。\nfunction.__dict__ 命名空间支持任意函数属性。 另请参阅: __dict__ 属性。\n一个包含 形参 标注的 字典。 该字典的键是形参名称，以及\n表示返回标注的 'return'，如有提供的话。 另请参阅:\nobject.__annotations__。\nfunction.__annotations__\n在 3.14 版本发生变更: 标记现在将被 惰性求值。 参见\nPEP 649。\n\n|  | 此类型可以被应用于函数调用操作 (参见 调用 小节):\n3.2.8.1. 用户定义函数\n用户定义函数对象可通过函数定义来创建 (参见 函数定义 小节)。它被调用时应附带一个参数列表，\n其中包含的条目应与函数所定义的形参列表一致。\n3.2.8.1.1. 特殊的只读属性 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | 属性 | 含意 |  |  |\n|  | function.__globals__ | 对存放该函数中 全局变量 的 字典 的引用 —— 函数定义所在模块\n的全局命名空间。 |  |  |\n|  | function.__closure__ | None 或单元的 tuple，其中包含了名称在函数的 代码对象 的\nco_freevars 中对指定名称的绑定。\n单元对象具有 cell_contents 属性。这可被用来获取以及设置单\n元的值。 |  |  |\n|  | 3.2.8.1.2. 特殊的可写属性\n这些属性大多会检查赋值的类型： |  |  |  |\n|  | 属性 |  | 含意 |  |\n|  | function.__doc__ |  | 函数的文档字符串，或者如果不可用则为 None。 |  |\n|  | function.__name__ |  | 函数的名称。 另请参阅: __name__ 属性。 |  |\n|  | function.__qualname__ |  | 函数的 qualified name。 另请参阅: __qualname__ 属性。\nAdded in version 3.3. |  |\n|  | function.__module__ |  | 该函数所属模块的名称，没有则为 None。 |  |\n|  | function.__defaults__ |  | 由具有默认值的形参的默认 parameter 值组成的 tuple，或\n者如果无任何形参具有默认值则为 None。 |  |\n|  | function.__code__ |  | 代表已编译的函数体的 代码对象。 |  |\n|  | function.__dict__ |  | 命名空间支持任意函数属性。 另请参阅: __dict__ 属性。 |  |\n|  | function.__annotations__ |  | 一个包含 形参 标注的 字典。 该字典的键是形参名称，以及\n表示返回标注的 'return'，如有提供的话。 另请参阅:\nobject.__annotations__。\n在 3.14 版本发生变更: 标记现在将被 惰性求值。 参见\nPEP 649。 |  |\n|  |  |  |  |  |\n\n属性 含意\n针对该函数的 annotate function，或者如果函数没有标注则\n为 None。 参见 object.__annotate__。\nfunction.__annotate__\nAdded in version 3.14.\nfunction.__kwdefaults__ 包含仅限关键字 形参 默认值的 字典。\n包含 泛型函数 类型形参 的 tuple。\nfunction.__type_params__\nAdded in version 3.12.\n函数对象也支持获取和设置任意属性，举例来说，这可被用于将元数据关联到函数。 通常使用带点\n号的属性标注来获取和设置这样的属性。\nCPython 目前的实现仅支持用户自定义函数上的函数属性。 未来可能会支持 内置函数 上的函数属\n性。\n有关函数定义的额外信息可以从其 代码对象 中提取（可通过 __code__ 属性来访问）。\n3.2.8.2. 实例方法\n实例方法用于结合类、类实例和任何可调用对象 (通常为用户定义函数)。\n特殊的只读属性：\nmethod.__self__ 指向方法所 绑定 的类实例对象。\nmethod.__func__ 指向原本的 函数对象\n方法的文档 (等同于 method.__func__.__doc__)。 如果原始函数具\nmethod.__doc__\n有文档字符串则为一个 字符串，否则为 None。\nmethod.__name__ 方法名称（与 method.__func__.__name__ 相同）\nmethod.__module__ 方法定义所在模块的名称，如不可用则为 None。\n方法还支持读取（但不能设置）下层 函数对象 的任意函数属性。\n用户自定义方法对象可在获取一个类的属性（可能是通过该类的实例）时被创建，如果该属性是一\n个用户自定义 函数对象 或 classmethod 对象的话。\n当通过从类的实例获取一个用户自定义 函数对象 的方式创建一个实例方法对象时，该方法对象的\n__self__ 属性即为该实例，而该方法对象将被称作已 绑定。 该新建方法的 __func__ 属性将是原\n来的函数对象。\n当通过从类或实例获取一个 classmethod 对象的方式创建一个实例方法对象时，该对象的\n__self__ 属性即为该类本身，而其 __func__ 属性将是类方法对应的下层函数对象。\n\n|  | 属性 |  | 含意 |  |\n| --- | --- | --- | --- | --- |\n|  | function.__annotate__ |  | 针对该函数的 annotate function，或者如果函数没有标注则\n为 None。 参见 object.__annotate__。\nAdded in version 3.14. |  |\n|  | function.__kwdefaults__ |  | 包含仅限关键字 形参 默认值的 字典。 |  |\n|  | function.__type_params__ |  | 包含 泛型函数 类型形参 的 tuple。\nAdded in version 3.12. |  |\n|  | 函数对象也支持获取和设置任意属性，举例来说，这可被用于将元数据关联到函数。 通常使用带点\n号的属性标注来获取和设置这样的属性。\nCPython 目前的实现仅支持用户自定义函数上的函数属性。 未来可能会支持 内置函数 上的函数属\n性。\n有关函数定义的额外信息可以从其 代码对象 中提取（可通过 __code__ 属性来访问）。\n3.2.8.2. 实例方法\n实例方法用于结合类、类实例和任何可调用对象 (通常为用户定义函数)。\n特殊的只读属性： |  |  |  |\n|  | method.__self__ | 指向方法所 绑定 的类实例对象。 |  |  |\n|  | method.__func__ | 指向原本的 函数对象 |  |  |\n|  | method.__doc__ | 方法的文档 (等同于 method.__func__.__doc__)。 如果原始函数具\n有文档字符串则为一个 字符串，否则为 None。 |  |  |\n|  | method.__name__ | 方法名称（与 method.__func__.__name__ 相同） |  |  |\n|  | method.__module__ | 方法定义所在模块的名称，如不可用则为 None。 |  |  |\n|  | 方法还支持读取（但不能设置）下层 函数对象 的任意函数属性。\n用户自定义方法对象可在获取一个类的属性（可能是通过该类的实例）时被创建，如果该属性是一\n个用户自定义 函数对象 或 classmethod 对象的话。\n当通过从类的实例获取一个用户自定义 函数对象 的方式创建一个实例方法对象时，该方法对象的\n__self__ 属性即为该实例，而该方法对象将被称作已 绑定。 该新建方法的 __func__ 属性将是原\n来的函数对象。\n当通过从类或实例获取一个 classmethod 对象的方式创建一个实例方法对象时，该对象的\n__self__ 属性即为该类本身，而其 __func__ 属性将是类方法对应的下层函数对象。 |  |  |  |\n\n当一个实例方法被调用时，会调用对应的下层函数 (__func__)，并将类实例 (__self__) 插入参数列\n表的开头。 例如，当 C 是一个包含 f() 函数定义的类，而 x 是 C 的一个实例，则调用 x.f(1) 就\n等价于调用 C.f(x, 1)。\n当一个实例方法对象是派生自一个 classmethod 对象时，保存在 __self__ 中的“类实例”实际上会\n是该类本身，因此无论是调用 x.f(1) 还是 C.f(1) 都等同于调用 f(C,1)，其中 f 为对应的下层函\n数。\n需要重点关注的是作为类实例的属性的用户自定义函数不会被转换为绑定方法；这 只会 在函数是类\n的属性时才会发生。\n3.2.8.3. 生成器函数\n一个使用 yield 语句（见 yield 语句 章节）的函数或方法被称为 生成器函数。 这样的函数在被调用\n时，总是返回一个可以执行该函数体的 iterator 对象：调用该迭代器的 iterator.__next__() 方法\n将导致这个函数一直运行到它使用 yield 语句提供一个值。 当这个函数执行 return 语句或到达函\n数体末尾时，将引发 StopIteration 异常并且该迭代器将到达所返回的值集合的末尾。\n3.2.8.4. 协程函数\n使用 async def 来定义的函数或方法就被称为 协程函数。这样的函数在被调用时会返回一个\ncoroutine 对象。它可能包含 await 表达式以及 async with 和 async for 语句。详情可参见 协程\n对象 一节。\n3.2.8.5. 异步生成器函数\n使用 async def 来定义并使用了 yield 语句的函数或方法被称为 异步生成器函数。 这样的函数在\n被调用时，将返回一个 asynchronous iterator 对象，该对象可在 async for 语句中被用来执行函数\n体。\n调用异步迭代器的 aiterator.__anext__ 方法将返回一个 awaitable，此对象会在被等待时执行直\n到使用 yield 产生一个值。 当函数执行到空的 return 语句或函数末尾时，将会引发\nStopAsyncIteration 异常并且异步迭代器也将到达要产生的值集合的末尾。\n3.2.8.6. 内置函数\n内置函数是针对特定 C 函数的包装器。 内置函数的例子包括 len() 和 math.sin() 等 (math 是一\n个标准内置模块)。 参数的数量和类型是由 C 函数确定的。 特殊的只读属性：\n__doc__ 是函数的文档字符串，或者如果不可用则为 None。 参见 function.__doc__。\n__name__ 是函数的名称。 参见 function.__name__。\n__self__ 被设为 None (但请参见下一项)。\n__module__ 是函数定义所在模块的名称，或者如果不可用则为 None。 参见\nfunction.__module__。\n3.2.8.7. 内置方法\n\n|  | 当一个实例方法被调用时，会调用对应的下层函数 (__func__)，并将类实例 (__self__) 插入参数列\n表的开头。 例如，当 C 是一个包含 f() 函数定义的类，而 x 是 C 的一个实例，则调用 x.f(1) 就\n等价于调用 C.f(x, 1)。\n当一个实例方法对象是派生自一个 classmethod 对象时，保存在 __self__ 中的“类实例”实际上会\n是该类本身，因此无论是调用 x.f(1) 还是 C.f(1) 都等同于调用 f(C,1)，其中 f 为对应的下层函\n数。\n需要重点关注的是作为类实例的属性的用户自定义函数不会被转换为绑定方法；这 只会 在函数是类\n的属性时才会发生。\n3.2.8.3. 生成器函数\n一个使用 yield 语句（见 yield 语句 章节）的函数或方法被称为 生成器函数。 这样的函数在被调用\n时，总是返回一个可以执行该函数体的 iterator 对象：调用该迭代器的 iterator.__next__() 方法\n将导致这个函数一直运行到它使用 yield 语句提供一个值。 当这个函数执行 return 语句或到达函\n数体末尾时，将引发 StopIteration 异常并且该迭代器将到达所返回的值集合的末尾。\n3.2.8.4. 协程函数\n使用 async def 来定义的函数或方法就被称为 协程函数。这样的函数在被调用时会返回一个\ncoroutine 对象。它可能包含 await 表达式以及 async with 和 async for 语句。详情可参见 协程\n对象 一节。\n3.2.8.5. 异步生成器函数\n使用 async def 来定义并使用了 yield 语句的函数或方法被称为 异步生成器函数。 这样的函数在\n被调用时，将返回一个 asynchronous iterator 对象，该对象可在 async for 语句中被用来执行函数\n体。\n调用异步迭代器的 aiterator.__anext__ 方法将返回一个 awaitable，此对象会在被等待时执行直\n到使用 yield 产生一个值。 当函数执行到空的 return 语句或函数末尾时，将会引发\nStopAsyncIteration 异常并且异步迭代器也将到达要产生的值集合的末尾。\n3.2.8.6. 内置函数\n内置函数是针对特定 C 函数的包装器。 内置函数的例子包括 len() 和 math.sin() 等 (math 是一\n个标准内置模块)。 参数的数量和类型是由 C 函数确定的。 特殊的只读属性：\n__doc__ 是函数的文档字符串，或者如果不可用则为 None。 参见 function.__doc__。\n__name__ 是函数的名称。 参见 function.__name__。\n__self__ 被设为 None (但请参见下一项)。\n__module__ 是函数定义所在模块的名称，或者如果不可用则为 None。 参见\nfunction.__module__。\n3.2.8.7. 内置方法 |  |\n| --- | --- | --- |\n\n此类型实际上是内置函数的另一种形式，只不过还包含了一个转入 C 函数的对象作为隐式的额外参\n数。 内置方法的一个例子是 alist.append()，其中 alist 是一个列表对象。 在此示例中，特殊的只\n读属性 __self__ 会被设为 alist 所标记的对象。 （该属性的语义与 其他实例方法 的相同。）\n3.2.8.8. 类\n类是可调用对象。 这些对象通常是用作创建自身实例的“工厂”，但类也可以有重载 __new__() 的变\n体类型。 调用的参数会传递给 __new__()，并且在通常情况下，也会传递给 __init__() 来初始化\n新的实例。\n3.2.8.9. 类实例\n任意类的实例可以通过在其所属类中定义 __call__() 方法变成可调用对象。\n3.2.9. 模块\n模块是 Python 代码的基本组织单元，由 导入系统 创建，它或是通过 import 语句，或是通过调用\nimportlib.import_module() 和内置的 __import__() 等函数来唤起。 模块对象具有通过 字典 对\n象实现的命名空间（就是被定义在模块中的函数的 __globals__ 属性所引用的字典）。 属性引用将\n被转换为在该字典中的查找操作，例如 m.x 就等价于 m.__dict__[\"x\"]。 模块对象不包含用于初\n始化模块的代码对象（因为初始化完成后已不再需要它）。\n属性赋值会更新模块的命名空间字典，例如 m.x = 1 等同于 m.__dict__[\"x\"] = 1。\n3.2.9.1. 模块对象上与导入相关的属性\n模块对象具有下列与 导入系统 相关的属性。 当使用关联到导入系统的机制创建模块时，这些属性将\n在 loader 执行和加载模块之前基于模块的 规格 来填充。\n要动态创建模块而非使用导入系统创建，建议使用 importlib.util.module_from_spec()，它会\n将各种由导入控制的属性设置为适当的值。也可以使用 types.ModuleType 构造器直接创建模块，\n但这种方法更容易出错，因为在使用这种方法时，必须在创建模块对象后手动设置其大部分属性。\n小心: 对 __name__ 以外的用例，强烈 建议使用 __spec__ 及其属性，而非此处列出的其他单独\n属性。请注意更新 __spec__ 上的属性时不会连带更新模块本身的同名属性。\n>>> import typing\n>>> typing.__name__, typing.__spec__.name\n('typing', 'typing')\n>>> typing.__spec__.name = 'spelling'\n>>> typing.__name__, typing.__spec__.name\n('typing', 'spelling')\n>>> typing.__name__ = 'keyboard_smashing'\n>>> typing.__name__, typing.__spec__.name\n('keyboard_smashing', 'spelling')\nmodule.__name__\n用于在导入系统中唯一地标识模块的名称。 对于直接执行的模块，这将被设为 \"__main__\"。\n\n|  | 此类型实际上是内置函数的另一种形式，只不过还包含了一个转入 C 函数的对象作为隐式的额外参\n数。 内置方法的一个例子是 alist.append()，其中 alist 是一个列表对象。 在此示例中，特殊的只\n读属性 __self__ 会被设为 alist 所标记的对象。 （该属性的语义与 其他实例方法 的相同。）\n3.2.8.8. 类\n类是可调用对象。 这些对象通常是用作创建自身实例的“工厂”，但类也可以有重载 __new__() 的变\n体类型。 调用的参数会传递给 __new__()，并且在通常情况下，也会传递给 __init__() 来初始化\n新的实例。\n3.2.8.9. 类实例\n任意类的实例可以通过在其所属类中定义 __call__() 方法变成可调用对象。\n3.2.9. 模块\n模块是 Python 代码的基本组织单元，由 导入系统 创建，它或是通过 import 语句，或是通过调用\nimportlib.import_module() 和内置的 __import__() 等函数来唤起。 模块对象具有通过 字典 对\n象实现的命名空间（就是被定义在模块中的函数的 __globals__ 属性所引用的字典）。 属性引用将\n被转换为在该字典中的查找操作，例如 m.x 就等价于 m.__dict__[\"x\"]。 模块对象不包含用于初\n始化模块的代码对象（因为初始化完成后已不再需要它）。\n属性赋值会更新模块的命名空间字典，例如 m.x = 1 等同于 m.__dict__[\"x\"] = 1。\n3.2.9.1. 模块对象上与导入相关的属性\n模块对象具有下列与 导入系统 相关的属性。 当使用关联到导入系统的机制创建模块时，这些属性将\n在 loader 执行和加载模块之前基于模块的 规格 来填充。\n要动态创建模块而非使用导入系统创建，建议使用 importlib.util.module_from_spec()，它会\n将各种由导入控制的属性设置为适当的值。也可以使用 types.ModuleType 构造器直接创建模块，\n但这种方法更容易出错，因为在使用这种方法时，必须在创建模块对象后手动设置其大部分属性。 |  |\n| --- | --- | --- |\n|  | 小心: 对 __name__ 以外的用例，强烈 建议使用 __spec__ 及其属性，而非此处列出的其他单独\n属性。请注意更新 __spec__ 上的属性时不会连带更新模块本身的同名属性。\n>>> import typing\n>>> typing.__name__, typing.__spec__.name\n('typing', 'typing')\n>>> typing.__spec__.name = 'spelling'\n>>> typing.__name__, typing.__spec__.name\n('typing', 'spelling')\n>>> typing.__name__ = 'keyboard_smashing'\n>>> typing.__name__, typing.__spec__.name\n('keyboard_smashing', 'spelling') |  |\n|  | module.__name__\n用于在导入系统中唯一地标识模块的名称。 对于直接执行的模块，这将被设为 \"__main__\"。 |  |\n\n该属性必须被设为模块的完整限定名称。 它应当与 module.__spec__.name 的值相匹配。\nmodule.__spec__\n模块与导入系统相关联的状态的记录。\n设置为导入模块时使用的 模块规格。 请参阅 模块规格说明 了解详情。\nAdded in version 3.4.\nmodule.__package__\n模块所属的 package。\n如果一个模块是顶层模块（不是任何包的一部分），该属性应被设置为空字符串 ''。否则，它\n应被设置为模块所属包的名字（如果模块本身是一个包，它可以是 module.__name__ 的值）。\n详见 PEP 366。\n在为主模块计算显式相对导入时，这个属性而非 __name__ 被使用。在使用\ntypes.ModuleType 构造器动态创建模块时会被默认设为 None。要确保这个属性是 str，请使\n用 importlib.util.module_from_spec()。\n强烈 建议使用 module.__spec__.parent 而非 module.__package__。 __package__ 现在仅\n作 __spec__.parent 未被设置时的回退路径，且这条回退路径已被弃用。\n在 3.4 版本发生变更: 对于使用 types.ModuleType 构造器动态创建的模块，该属性现在\n默认为 None。先前该属性是可选的。\n在 3.6 版本发生变更: __package__ 的值应与 __spec__.parent 相同。__package__ 现\n在仅作导入解析期间 __spec__.parent 未被定义时的回退值。\n在 3.10 版本发生变更: 如果导入解析回退到 __package__ 而非 __spec__.parent，会引\n发 ImportWarning。\n在 3.12 版本发生变更: 在导入解析期间回退到 __package__ 时会引发\nDeprecationWarning 而非 ImportWarning。\nDeprecated since version 3.13, will be removed in version 3.15: __package__ 将不再被设\n置或者被导入系统或标准库纳入考量。\nmodule.__loader__\n导入系统用来加载模块的 loader 对象。\n该属性主要适用于内省，但也可用于额外的加载器专属功能，例如获取与加载器相关联的数\n据。\n对于使用 types.ModuleType 构造器动态创建的模块 __loader__ 默认为 None；请改用\nimportlib.util.module_from_spec() 来确保将该属性设为 loader 对象。\n强烈 建议你使用 module.__spec__.loader 来代替 module.__loader__。\n\n|  | 该属性必须被设为模块的完整限定名称。 它应当与 module.__spec__.name 的值相匹配。\nmodule.__spec__\n模块与导入系统相关联的状态的记录。\n设置为导入模块时使用的 模块规格。 请参阅 模块规格说明 了解详情。\nAdded in version 3.4.\nmodule.__package__\n模块所属的 package。\n如果一个模块是顶层模块（不是任何包的一部分），该属性应被设置为空字符串 ''。否则，它\n应被设置为模块所属包的名字（如果模块本身是一个包，它可以是 module.__name__ 的值）。\n详见 PEP 366。\n在为主模块计算显式相对导入时，这个属性而非 __name__ 被使用。在使用\ntypes.ModuleType 构造器动态创建模块时会被默认设为 None。要确保这个属性是 str，请使\n用 importlib.util.module_from_spec()。\n强烈 建议使用 module.__spec__.parent 而非 module.__package__。 __package__ 现在仅\n作 __spec__.parent 未被设置时的回退路径，且这条回退路径已被弃用。\n在 3.4 版本发生变更: 对于使用 types.ModuleType 构造器动态创建的模块，该属性现在\n默认为 None。先前该属性是可选的。\n在 3.6 版本发生变更: __package__ 的值应与 __spec__.parent 相同。__package__ 现\n在仅作导入解析期间 __spec__.parent 未被定义时的回退值。\n在 3.10 版本发生变更: 如果导入解析回退到 __package__ 而非 __spec__.parent，会引\n发 ImportWarning。\n在 3.12 版本发生变更: 在导入解析期间回退到 __package__ 时会引发\nDeprecationWarning 而非 ImportWarning。\nDeprecated since version 3.13, will be removed in version 3.15: __package__ 将不再被设\n置或者被导入系统或标准库纳入考量。\nmodule.__loader__\n导入系统用来加载模块的 loader 对象。\n该属性主要适用于内省，但也可用于额外的加载器专属功能，例如获取与加载器相关联的数\n据。\n对于使用 types.ModuleType 构造器动态创建的模块 __loader__ 默认为 None；请改用\nimportlib.util.module_from_spec() 来确保将该属性设为 loader 对象。\n强烈 建议你使用 module.__spec__.loader 来代替 module.__loader__。 |  |\n| --- | --- | --- |\n\n在 3.4 版本发生变更: 对于使用 types.ModuleType 构造器动态创建的模块，该属性现在\n默认为 None。先前该属性是可选的。\nDeprecated since version 3.12, will be removed in version 3.16: 当设置 __spec__.loader\n失败时在模块上设置 __loader__ 的做法已被弃用。 在 Python 3.16 中，__loader__ 将\n不会再被设置或被导入系统或标准库纳入考虑。\nmodule.__path__\n一个（可能为空的）枚举用于查找包的子模块的位置的由字符串组成的 sequence。 非包模块\n应当没有 __path__ 属性。 详情参见 模块的 __path__ 属性。\n强烈 建议你使用 module.__spec__.submodule_search_locations 来代替\nmodule.__path__。\nmodule.__file__\nmodule.__cached__\n__file__ 和 __cached__ 都是可设也可不设的可选属性。 两个属性在可用时都应当为 str。\n__file__ 指明要载入的模块所在文件的路径名（如果是从文件载入），或者对于从共享库动态\n载入的扩展模块来说则是共享库文件的路径名。 它对于特定类型的模块来说可能是缺失的，例\n如静态链接到解释器中的 C 模块，并且 导入系统 也可能会在它没有语法意义时选择不设置它\n（例如，当一个模块是从数据库导入时）。\n如果设置了 __file__ 则 __cached__ 属性也可能会被设置，它是指向任何代码的已编译版本\n的路径（例如，一个字节码文件）。 设置此属性并不需要存在相应的路径；该路径可以简单地\n指向已编译文件 将要 存在的位置 (参见 PEP 3147)。\n请注意 __cached__ 即使在未设置 __file__ 时也可能会被设置。 不过，那样的场景是非典型\n的。 最终，loader 会是 finder (from which __file__ 和 __cached__ 也是自它派生的) 所提供\n的模块规格的使用方。 因此如果一个加载器可以从缓存加载模块但是不能从文件加载，那样的\n非典型场景就是适当的。\n强烈 建议你使用 module.__spec__.cached 来代替 module.__cached__。\nDeprecated since version 3.13, will be removed in version 3.15: 当设置 __spec__.cached\n失败时在模块上设置 __cached__ 的做法已被弃用。 在 Python 3.15 中，__cached__ 将\n不会再被设置或被导入系统或标准库纳入考虑。\n3.2.9.2. 模块对象上的其他可写属性\n除了上面列出的导入相关属性，模块对象还具有下列可写属性：\nmodule.__doc__\n模块的文档字符串，或者如果不可用则为 None。 另请参阅: __doc__ 属性。\nmodule.__annotations__\n一个包含在模块体执行期间收集的 变量标注 的字典。 有关使用 __annotations__ 的最佳实\n践，请参阅 annotationlib。\n\n|  | 在 3.4 版本发生变更: 对于使用 types.ModuleType 构造器动态创建的模块，该属性现在\n默认为 None。先前该属性是可选的。\nDeprecated since version 3.12, will be removed in version 3.16: 当设置 __spec__.loader\n失败时在模块上设置 __loader__ 的做法已被弃用。 在 Python 3.16 中，__loader__ 将\n不会再被设置或被导入系统或标准库纳入考虑。\nmodule.__path__\n一个（可能为空的）枚举用于查找包的子模块的位置的由字符串组成的 sequence。 非包模块\n应当没有 __path__ 属性。 详情参见 模块的 __path__ 属性。\n强烈 建议你使用 module.__spec__.submodule_search_locations 来代替\nmodule.__path__。\nmodule.__file__\nmodule.__cached__\n__file__ 和 __cached__ 都是可设也可不设的可选属性。 两个属性在可用时都应当为 str。\n__file__ 指明要载入的模块所在文件的路径名（如果是从文件载入），或者对于从共享库动态\n载入的扩展模块来说则是共享库文件的路径名。 它对于特定类型的模块来说可能是缺失的，例\n如静态链接到解释器中的 C 模块，并且 导入系统 也可能会在它没有语法意义时选择不设置它\n（例如，当一个模块是从数据库导入时）。\n如果设置了 __file__ 则 __cached__ 属性也可能会被设置，它是指向任何代码的已编译版本\n的路径（例如，一个字节码文件）。 设置此属性并不需要存在相应的路径；该路径可以简单地\n指向已编译文件 将要 存在的位置 (参见 PEP 3147)。\n请注意 __cached__ 即使在未设置 __file__ 时也可能会被设置。 不过，那样的场景是非典型\n的。 最终，loader 会是 finder (from which __file__ 和 __cached__ 也是自它派生的) 所提供\n的模块规格的使用方。 因此如果一个加载器可以从缓存加载模块但是不能从文件加载，那样的\n非典型场景就是适当的。\n强烈 建议你使用 module.__spec__.cached 来代替 module.__cached__。\nDeprecated since version 3.13, will be removed in version 3.15: 当设置 __spec__.cached\n失败时在模块上设置 __cached__ 的做法已被弃用。 在 Python 3.15 中，__cached__ 将\n不会再被设置或被导入系统或标准库纳入考虑。\n3.2.9.2. 模块对象上的其他可写属性\n除了上面列出的导入相关属性，模块对象还具有下列可写属性：\nmodule.__doc__\n模块的文档字符串，或者如果不可用则为 None。 另请参阅: __doc__ 属性。\nmodule.__annotations__\n一个包含在模块体执行期间收集的 变量标注 的字典。 有关使用 __annotations__ 的最佳实\n践，请参阅 annotationlib。 |  |\n| --- | --- | --- |\n\n在 3.14 版本发生变更: 标记现在将被 惰性求值。 参见 PEP 649。\nmodule.__annotate__\n针对该模块的 annotate function，或者如果模块没有标注则为 None。 另请参阅:\n__annotate__ 属性。\nAdded in version 3.14.\n3.2.9.3. 模块字典\n模块对象还具有以下特殊的只读属性：Module objects also have the following special read-only\nattribute:\nmodule.__dict__\n以字典对象表示的模块命名空间。 在此处列出的属性中它很特别，__dict__ 不能从模块内部\n作为全局变量来访问；它只能作为模块对象上的属性来访问。\n由于 CPython 清理模块字典的设定，当模块离开作用域时模块字典将会被清理，即使该字典还\n有活动的引用。想避免此问题，可复制该字典或保持模块状态以直接使用其字典。\n3.2.10. 自定义类\n自定义类这种类型一般是通过类定义来创建 (参见 类定义 一节)。 每个类都有一个通过字典对象实现\n的命名空间。 类属性引用会被转化为在此字典中查找，例如，C.x 会被转化为 C.__dict__[\"x\"]\n(不过也存在一些钩子对象允许其他定位属性的方式)。 当未在其中找到某个属性名称时，会继续在\n基类中查找。这种基类搜索使用 C3 方法解析顺序，即使存在 '钻石形' 继承结构既有多条继承路径连\n到一个共同祖先也能保持正确的行为。 有关 Python 使用的 C3 MRO 的详情可在 Python 2.3 方法解\n析顺序 查看。\n当一个类属性引用 (假设类名为 C) 会产生一个类方法对象时，它将转化为一个 __self__ 属性为 C\n的实例方法对象。 当它会产生一个 staticmethod 对象时，它将转换为该静态方法对象所包装的对\n象。 有关有类的 __dict__ 实际包含内容以外获取属性的其他方式请参阅 实现描述器 一节。\n类属性赋值会更新类的字典，但不会更新基类的字典。\n类对象可被调用 (见上文) 以产生一个类实例 (见下文)。\n3.2.10.1. 特殊属性\n属性 含意\ntype.__name__ 类的名称。 另请参阅: __name__ 属性。\ntype.__qualname__ 类的 qualified name。 另请参阅: __qualname__ 属性。\ntype.__module__ 类定义所在模块的名称。\n一个提供类的命名空间的只读视图的 映射代理。 另请参\ntype.__dict__\n阅: __dict__ 属性。\n\n|  | 在 3.14 版本发生变更: 标记现在将被 惰性求值。 参见 PEP 649。\nmodule.__annotate__\n针对该模块的 annotate function，或者如果模块没有标注则为 None。 另请参阅:\n__annotate__ 属性。\nAdded in version 3.14.\n3.2.9.3. 模块字典\n模块对象还具有以下特殊的只读属性：Module objects also have the following special read-only\nattribute:\nmodule.__dict__\n以字典对象表示的模块命名空间。 在此处列出的属性中它很特别，__dict__ 不能从模块内部\n作为全局变量来访问；它只能作为模块对象上的属性来访问。\n由于 CPython 清理模块字典的设定，当模块离开作用域时模块字典将会被清理，即使该字典还\n有活动的引用。想避免此问题，可复制该字典或保持模块状态以直接使用其字典。\n3.2.10. 自定义类\n自定义类这种类型一般是通过类定义来创建 (参见 类定义 一节)。 每个类都有一个通过字典对象实现\n的命名空间。 类属性引用会被转化为在此字典中查找，例如，C.x 会被转化为 C.__dict__[\"x\"]\n(不过也存在一些钩子对象允许其他定位属性的方式)。 当未在其中找到某个属性名称时，会继续在\n基类中查找。这种基类搜索使用 C3 方法解析顺序，即使存在 '钻石形' 继承结构既有多条继承路径连\n到一个共同祖先也能保持正确的行为。 有关 Python 使用的 C3 MRO 的详情可在 Python 2.3 方法解\n析顺序 查看。\n当一个类属性引用 (假设类名为 C) 会产生一个类方法对象时，它将转化为一个 __self__ 属性为 C\n的实例方法对象。 当它会产生一个 staticmethod 对象时，它将转换为该静态方法对象所包装的对\n象。 有关有类的 __dict__ 实际包含内容以外获取属性的其他方式请参阅 实现描述器 一节。\n类属性赋值会更新类的字典，但不会更新基类的字典。\n类对象可被调用 (见上文) 以产生一个类实例 (见下文)。\n3.2.10.1. 特殊属性 |  |  |\n| --- | --- | --- | --- |\n|  | 属性 | 含意 |  |\n|  | type.__name__ | 类的名称。 另请参阅: __name__ 属性。 |  |\n|  | type.__qualname__ | 类的 qualified name。 另请参阅: __qualname__ 属性。 |  |\n|  | type.__module__ | 类定义所在模块的名称。 |  |\n|  | type.__dict__ | 一个提供类的命名空间的只读视图的 映射代理。 另请参\n阅: __dict__ 属性。 |  |\n|  |  |  |  |\n\n属性 含意\n一个包含类的基类的 tuple，对于定义为 class X(A,\ntype.__bases__\nB, C) 的类，X.__bases__ 将等于 (A, B, C)。\n继承链中负责实例的内存布局的单独基类。 该属性对应\ntype.__base__\n于 C 层级上的 tp_base。\n类的文档字符串，如果未定义则为 None。 不会被子类继\ntype.__doc__\n承。 if undefined. Not inherited by subclasses.\n一个包含在类体执行期间收集的 变量标注 的字典。 另请\n参阅: __annotations__ attributes。\n有关使用 __annotations__ 的最佳实践，请参阅\nannotationlib。 请使用\nannotationlib.get_annotations() 而不是直接该该属\n性。\n警告: 直接在类对象上访问 __annotations__ 属性可\ntype.__annotations__ 能会返回错误类的注解，特别是在某些情况下，类、它\n的基类或元类是在``from __future__ import\nannotations``下定义的。详细信息请参见\n<749#pep749-metaclasses>`。\n此属性在某些内置类中不存在。对于不带\n``__annotations__``的用户定义类，它是一个空字典。\n在 3.14 版本发生变更: 标记现在将被 惰性求值。 参\n见 PEP 649。\n针对该类的 annotate function，或者如果类没有标注则为\nNone。 另请参阅: __annotate__ 属性。\ntype.__annotate__()\nAdded in version 3.14.\n一个包含 泛型类 的 类型形参 的 tuple。\ntype.__type_params__\nAdded in version 3.12.\n一个包含由通过 self.X 赋值为该类语句体中任何函数的\n类属性名称组成的 tuple。\ntype.__static_attributes__\nAdded in version 3.13.\ntype.__firstlineno__ 类定义的第一行的行号，包括装饰器。 设置 __module__\n属性将从类型的字典中移除 __firstlineno__ 条目。\n\n|  | 属性 | 含意 |  |\n| --- | --- | --- | --- |\n|  | type.__bases__ | 一个包含类的基类的 tuple，对于定义为 class X(A,\nB, C) 的类，X.__bases__ 将等于 (A, B, C)。 |  |\n|  | type.__base__ | 继承链中负责实例的内存布局的单独基类。 该属性对应\n于 C 层级上的 tp_base。 |  |\n|  | type.__doc__ | 类的文档字符串，如果未定义则为 None。 不会被子类继\n承。 if undefined. Not inherited by subclasses. |  |\n|  | type.__annotations__ | 一个包含在类体执行期间收集的 变量标注 的字典。 另请\n参阅: __annotations__ attributes。\n有关使用 __annotations__ 的最佳实践，请参阅\nannotationlib。 请使用\nannotationlib.get_annotations() 而不是直接该该属\n性。\n警告: 直接在类对象上访问 __annotations__ 属性可\n能会返回错误类的注解，特别是在某些情况下，类、它\n的基类或元类是在``from __future__ import\nannotations``下定义的。详细信息请参见\n<749#pep749-metaclasses>`。\n此属性在某些内置类中不存在。对于不带\n``__annotations__``的用户定义类，它是一个空字典。\n在 3.14 版本发生变更: 标记现在将被 惰性求值。 参\n见 PEP 649。 |  |\n|  | type.__annotate__() | 针对该类的 annotate function，或者如果类没有标注则为\nNone。 另请参阅: __annotate__ 属性。\nAdded in version 3.14. |  |\n|  | type.__type_params__ | 一个包含 泛型类 的 类型形参 的 tuple。\nAdded in version 3.12. |  |\n|  | type.__static_attributes__ | 一个包含由通过 self.X 赋值为该类语句体中任何函数的\n类属性名称组成的 tuple。\nAdded in version 3.13. |  |\n|  | type.__firstlineno__ | 类定义的第一行的行号，包括装饰器。 设置 __module__\n属性将从类型的字典中移除 __firstlineno__ 条目。 |  |\n\n| class X(A, |  |\n| --- | --- |\n\n|  | B, C) |\n| --- | --- |\n\n属性 含意\nAdded in version 3.13.\n由在方法解析期间当查找基类时将被纳入考虑的类组成的\ntype.__mro__\ntuple。\n3.2.10.2. 特殊方法\n除了上面介绍的特殊属性，所有的 Python 类还具有以下两个方法：\ntype.mro()\n此方法可由一个元类来重写以便为其实例定制方法解析顺序。 它会在类实例化时被调用，其结\n果将存储在 __mro__ 中。\ntype.__subclasses__()\n每个类都会保存一个由指向其直接子类的弱引用组成的列表。 此方法将返回一个由所有仍然存\n在的这种引用组成的列表。 列表项将按定义顺序排列。 例如：\n>>> class A: pass\n>>> class B(A): pass\n>>> A.__subclasses__()\n[<class 'B'>]\n3.2.11. 类实例\n类实例可通过调用类对象来创建（见上文）。 每个类实例都有通过一个字典对象实现的独立命名空\n间，属性引用会首先在此字典中进行查找。 当未在其中发现某个属性，而实例对应的类中有该属性\n时，会继续在类属性中查找。 如果找到的类属性是一个用户自定义函数对象，它会被转化为实例方\n法对象，其 __self__ 属性即该实例。 静态方法和类方法对象也会被转化；参见上文的“类”小节。\n要了解其他通过类实例来获取相应类属性的方式请参阅 实现描述器 小节，这样得到的属性可能与实\n际存放在类的 __dict__ 中的对象不同。 如果未找到类属性，而对象所属的类具有 __getattr__()\n方法，则会调用该方法来满足查找要求。\n属性赋值和删除会更新实例的字典，但绝不会更新类的字典。 如果类具有 __setattr__() 或\n__delattr__() 方法，则将调用该方法而不再直接更新实例的字典。\n如果类实例具有某些特殊名称的方法，就可以伪装为数字、序列或映射。参见 特殊方法名称 一节。\n3.2.11.1. 特殊属性\nobject.__class__\n类实例所属的类。\nobject.__dict__\n一个用于存储对象的（可写）属性的字典或其他映射对象。 并非所有实例都具有 __dict__ 属\n性；请参阅 __slots__ 章节了解详情。\n\n|  | 属性 | 含意 |  |\n| --- | --- | --- | --- |\n|  |  | Added in version 3.13. |  |\n|  | type.__mro__ | 由在方法解析期间当查找基类时将被纳入考虑的类组成的\ntuple。 |  |\n|  | 3.2.10.2. 特殊方法\n除了上面介绍的特殊属性，所有的 Python 类还具有以下两个方法：\ntype.mro()\n此方法可由一个元类来重写以便为其实例定制方法解析顺序。 它会在类实例化时被调用，其结\n果将存储在 __mro__ 中。\ntype.__subclasses__()\n每个类都会保存一个由指向其直接子类的弱引用组成的列表。 此方法将返回一个由所有仍然存\n在的这种引用组成的列表。 列表项将按定义顺序排列。 例如：\n>>> class A: pass\n>>> class B(A): pass\n>>> A.__subclasses__()\n[<class 'B'>]\n3.2.11. 类实例\n类实例可通过调用类对象来创建（见上文）。 每个类实例都有通过一个字典对象实现的独立命名空\n间，属性引用会首先在此字典中进行查找。 当未在其中发现某个属性，而实例对应的类中有该属性\n时，会继续在类属性中查找。 如果找到的类属性是一个用户自定义函数对象，它会被转化为实例方\n法对象，其 __self__ 属性即该实例。 静态方法和类方法对象也会被转化；参见上文的“类”小节。\n要了解其他通过类实例来获取相应类属性的方式请参阅 实现描述器 小节，这样得到的属性可能与实\n际存放在类的 __dict__ 中的对象不同。 如果未找到类属性，而对象所属的类具有 __getattr__()\n方法，则会调用该方法来满足查找要求。\n属性赋值和删除会更新实例的字典，但绝不会更新类的字典。 如果类具有 __setattr__() 或\n__delattr__() 方法，则将调用该方法而不再直接更新实例的字典。\n如果类实例具有某些特殊名称的方法，就可以伪装为数字、序列或映射。参见 特殊方法名称 一节。\n3.2.11.1. 特殊属性\nobject.__class__\n类实例所属的类。\nobject.__dict__\n一个用于存储对象的（可写）属性的字典或其他映射对象。 并非所有实例都具有 __dict__ 属\n性；请参阅 __slots__ 章节了解详情。 |  |  |\n\n3.2.12. I/O 对象 (或称文件对象)\nfile object 表示一个打开的文件。有多种快捷方式可用来创建文件对象: open() 内置函数，以及\nos.popen(), os.fdopen() 和 socket 对象的 makefile() 方法 (还可能使用某些扩展模块所提供的\n其他函数或方法)。\nsys.stdin, sys.stdout 和 sys.stderr 会初始化为对应于解释器标准输入、输出和错误流的文件\n对象；它们都会以文本模式打开，因此都遵循 io.TextIOBase 抽象类所定义的接口。\n3.2.13. 内部类型\n某些由解释器内部使用的类型也被暴露给用户。它们的定义可能随未来解释器版本的更新而变化，\n为内容完整起见在此处一并介绍。\n3.2.13.1. 代码对象\n代码对象表示 编译为字节的 可执行 Python 代码，或称 bytecode。代码对象和函数对象的区别在于\n函数对象包含对函数全局对象 (函数所属的模块) 的显式引用，而代码对象不包含上下文；而且默认\n参数值会存放于函数对象而不是代码对象内 (因为它们表示在运行时算出的值)。与函数对象不同，\n代码对象不可变，也不包含对可变对象的引用 (不论是直接还是间接)。\n3.2.13.1.1. 特殊的只读属性\ncodeobject.co_name 函数名\n完整限定函数名\ncodeobject.co_qualname\nAdded in version 3.11.\n函数的位置 形参 的总数（包括仅限位置形参和具有默\ncodeobject.co_argcount\n认值的形参）\n函数的仅限位置 形参 的总数（包括具有默认值的参\ncodeobject.co_posonlyargcount\n数）\n函数的仅限关键字 形参 的数量（包括具有默认值的参\ncodeobject.co_kwonlyargcount\n数）\ncodeobject.co_nlocals 函数使用的 局部变量 的数量（包括形参）\n一个 tuple，其中包含函数中局部变量的名称（从形\ncodeobject.co_varnames\n参名称开始）\n包含被函数内至少一个 nested scope 所引用的 局部变\ncodeobject.co_cellvars\n量 的名称的 tuple。\ncodeobject.co_freevars 一个 tuple，其中包含某个 nested scope 引用在外部\n作用域中引用的 containing the names of 自由（闭\n\n|  | 3.2.12. I/O 对象 (或称文件对象)\nfile object 表示一个打开的文件。有多种快捷方式可用来创建文件对象: open() 内置函数，以及\nos.popen(), os.fdopen() 和 socket 对象的 makefile() 方法 (还可能使用某些扩展模块所提供的\n其他函数或方法)。\nsys.stdin, sys.stdout 和 sys.stderr 会初始化为对应于解释器标准输入、输出和错误流的文件\n对象；它们都会以文本模式打开，因此都遵循 io.TextIOBase 抽象类所定义的接口。\n3.2.13. 内部类型\n某些由解释器内部使用的类型也被暴露给用户。它们的定义可能随未来解释器版本的更新而变化，\n为内容完整起见在此处一并介绍。\n3.2.13.1. 代码对象\n代码对象表示 编译为字节的 可执行 Python 代码，或称 bytecode。代码对象和函数对象的区别在于\n函数对象包含对函数全局对象 (函数所属的模块) 的显式引用，而代码对象不包含上下文；而且默认\n参数值会存放于函数对象而不是代码对象内 (因为它们表示在运行时算出的值)。与函数对象不同，\n代码对象不可变，也不包含对可变对象的引用 (不论是直接还是间接)。\n3.2.13.1.1. 特殊的只读属性 |  |  |\n| --- | --- | --- | --- |\n|  | codeobject.co_name | 函数名 |  |\n|  | codeobject.co_qualname | 完整限定函数名\nAdded in version 3.11. |  |\n|  | codeobject.co_argcount | 函数的位置 形参 的总数（包括仅限位置形参和具有默\n认值的形参） |  |\n|  | codeobject.co_posonlyargcount | 函数的仅限位置 形参 的总数（包括具有默认值的参\n数） |  |\n|  | codeobject.co_kwonlyargcount | 函数的仅限关键字 形参 的数量（包括具有默认值的参\n数） |  |\n|  | codeobject.co_nlocals | 函数使用的 局部变量 的数量（包括形参） |  |\n|  | codeobject.co_varnames | 一个 tuple，其中包含函数中局部变量的名称（从形\n参名称开始） |  |\n|  | codeobject.co_cellvars | 包含被函数内至少一个 nested scope 所引用的 局部变\n量 的名称的 tuple。 |  |\n|  | codeobject.co_freevars | 一个 tuple，其中包含某个 nested scope 引用在外部\n作用域中引用的 containing the names of 自由（闭 |  |\n\n包）变量 的名称。 另请参阅\nfunction.__closure__。\n注意：对全局和内置名称的引用 不会 被包括在内。\ncodeobject.co_code 一个表示函数中的 bytecode 指令序列的字符串\n一个包含函数中的 bytecode 所使用的字面值的\ncodeobject.co_consts\ntuple\ncodeobject.co_names 一个包含函数中的 bytecode 所使用的名称的 tuple\ncodeobject.co_filename 被编译代码所在文件的名称\ncodeobject.co_firstlineno 函数第一行所对应的行号\n一个编码了从 bytecode 偏移量到行号的映射的字符\n串。 要获取更多细节，请查看解释器的源代码。\ncodeobject.co_lnotab\n自 3.12 版本弃用: 代码对象的这个属性已被弃\n用，并可能在 Python 3.15 中移除。\ncodeobject.co_stacksize 需要的代码对象栈大小\ncodeobject.co_flags 用于对一系列解释器旗标进行编码的 整数。\n以下是针对 co_flags 定义的旗标位：如果函数使用 *arguments 语法来接受任意数量的位置参数\n则设置 0x04 位；如果函数使用 **keywords 语法来接受任意数量的关键字参数则设置 0x08 位；如\n果函数是一个生成器则设置 0x20 位。 请参阅 代码对象位标志 可能出现的每个旗标的语义详情。\n未来特性声明 (例如 from __future__ import division) 也使用 co_flags 中的比特位来指明代\n码对象在编译时是否启用了某个特性。 参见 compiler_flag。\nco_flags 中的其他位被保留供内部使用。\n如果一个代码对象代表函数并且具有文档字符串，则会在 co_flags 中设置 CO_HAS_DOCSTRING 比\n特位并且 co_consts 中的第一个条目将是该函数的文档字符串。\n3.2.13.1.2. 代码对象的方法\ncodeobject.co_positions()\n返回一个包含代码对象中每条 bytecode 指令的源代码位置的可迭代对象。\n此迭代器返回包含 (start_line, end_line, start_column, end_column) 的 tuple。 其中\n第 i 个元组冲锋衣官方编译为第 i 个代码单元的源代码的位置。 列信息是给定源代码行从 0 开\n始索引的 utf-8 字节偏移量。\n此位置信息可能会丢失。 可能发生这种情况下非详尽列表如下:\n附带 -X no_debug_ranges 运行解释器。\n在使用 -X no_debug_ranges 时加载一个已编译的 pyc 文件。\n\n|  |  | 包）变量 的名称。 另请参阅\nfunction.__closure__。\n注意：对全局和内置名称的引用 不会 被包括在内。 |  |\n| --- | --- | --- | --- |\n|  | codeobject.co_code | 一个表示函数中的 bytecode 指令序列的字符串 |  |\n|  | codeobject.co_consts | 一个包含函数中的 bytecode 所使用的字面值的\ntuple |  |\n|  | codeobject.co_names | 一个包含函数中的 bytecode 所使用的名称的 tuple |  |\n|  | codeobject.co_filename | 被编译代码所在文件的名称 |  |\n|  | codeobject.co_firstlineno | 函数第一行所对应的行号 |  |\n|  | codeobject.co_lnotab | 一个编码了从 bytecode 偏移量到行号的映射的字符\n串。 要获取更多细节，请查看解释器的源代码。\n自 3.12 版本弃用: 代码对象的这个属性已被弃\n用，并可能在 Python 3.15 中移除。 |  |\n|  | codeobject.co_stacksize | 需要的代码对象栈大小 |  |\n|  | codeobject.co_flags | 用于对一系列解释器旗标进行编码的 整数。 |  |\n|  | 以下是针对 co_flags 定义的旗标位：如果函数使用 *arguments 语法来接受任意数量的位置参数\n则设置 0x04 位；如果函数使用 **keywords 语法来接受任意数量的关键字参数则设置 0x08 位；如\n果函数是一个生成器则设置 0x20 位。 请参阅 代码对象位标志 可能出现的每个旗标的语义详情。\n未来特性声明 (例如 from __future__ import division) 也使用 co_flags 中的比特位来指明代\n码对象在编译时是否启用了某个特性。 参见 compiler_flag。\nco_flags 中的其他位被保留供内部使用。\n如果一个代码对象代表函数并且具有文档字符串，则会在 co_flags 中设置 CO_HAS_DOCSTRING 比\n特位并且 co_consts 中的第一个条目将是该函数的文档字符串。\n3.2.13.1.2. 代码对象的方法\ncodeobject.co_positions()\n返回一个包含代码对象中每条 bytecode 指令的源代码位置的可迭代对象。\n此迭代器返回包含 (start_line, end_line, start_column, end_column) 的 tuple。 其中\n第 i 个元组冲锋衣官方编译为第 i 个代码单元的源代码的位置。 列信息是给定源代码行从 0 开\n始索引的 utf-8 字节偏移量。\n此位置信息可能会丢失。 可能发生这种情况下非详尽列表如下:\n附带 -X no_debug_ranges 运行解释器。\n在使用 -X no_debug_ranges 时加载一个已编译的 pyc 文件。 |  |  |\n\n与人工指令相对应的位置元组。\n由于具体实现专属的限制而无法表示的行号和列号。\n当发生此情况时，元组的部分或全部元素可以为 None。\nAdded in version 3.11.\n备注: 此特性需要在代码对象中存储列位置，这可能会导致编译的 which may result in a\nsmall increase of disk usage of compiled Python 文件占用的磁盘空间或解释器占用的内存略\n有增加。 要避免存储额外信息和/或取消打印额外的回溯信息，可以使用 -X\nno_debug_ranges 命令行旗标或 PYTHONNODEBUGRANGES 环境变量。\ncodeobject.co_lines()\n返回一个产生有关 bytecode 的连续范围的信息的迭代器。 其产生的每一项都是一个 (start,\nend, lineno) tuple:\nstart (一个 int) 代表相对于 bytecode 范围开始位置的偏移量 (不包括该位置)。\nend (int 值) 代表相对于 bytecode 范围末尾位置的偏移量（不包括该位置）。\nlineno 是一个代表 bytecode 范围内的行号的 int，或者如果给定范围内的字节码没有行号\n则为 None。\n产生的条目将具有下列特征属性：\n产出的第一个范围将以 0 作为 start。\n(start, end) 范围将是非递减和连续的。 也就是说，对于任何一对 tuple，第二个的\nstart 将等于第一个的 end。\n任何范围都不会是反向的：对于所有三元组均有 end >= start。\n产生的最后一个 tuple 的 end 将等于 bytecode 的大小。\n零宽度范围，即 start == end 也是允许的。 零宽度范围的使用场景是源代码中存在，但被\nbytecode 编译器所去除的那些行。\nAdded in version 3.10.\n参见:\nPEP 626 - 在调试和其他工具中使用精确的行号。\n引入 co_lines() 方法的 PEP。\ncodeobject.replace(**kwargs)\n返回代码对象的一个副本，使用指定的新字段值。\n代码对象也被泛型函数 copy.replace() 所支持。\nAdded in version 3.8.\n3.2.13.2. 帧对象\n\n|  |  | 与人工指令相对应的位置元组。\n由于具体实现专属的限制而无法表示的行号和列号。\n当发生此情况时，元组的部分或全部元素可以为 None。\nAdded in version 3.11.\n备注: 此特性需要在代码对象中存储列位置，这可能会导致编译的 which may result in a\nsmall increase of disk usage of compiled Python 文件占用的磁盘空间或解释器占用的内存略\n有增加。 要避免存储额外信息和/或取消打印额外的回溯信息，可以使用 -X\nno_debug_ranges 命令行旗标或 PYTHONNODEBUGRANGES 环境变量。\ncodeobject.co_lines()\n返回一个产生有关 bytecode 的连续范围的信息的迭代器。 其产生的每一项都是一个 (start,\nend, lineno) tuple:\nstart (一个 int) 代表相对于 bytecode 范围开始位置的偏移量 (不包括该位置)。\nend (int 值) 代表相对于 bytecode 范围末尾位置的偏移量（不包括该位置）。\nlineno 是一个代表 bytecode 范围内的行号的 int，或者如果给定范围内的字节码没有行号\n则为 None。\n产生的条目将具有下列特征属性：\n产出的第一个范围将以 0 作为 start。\n(start, end) 范围将是非递减和连续的。 也就是说，对于任何一对 tuple，第二个的\nstart 将等于第一个的 end。\n任何范围都不会是反向的：对于所有三元组均有 end >= start。\n产生的最后一个 tuple 的 end 将等于 bytecode 的大小。\n零宽度范围，即 start == end 也是允许的。 零宽度范围的使用场景是源代码中存在，但被\nbytecode 编译器所去除的那些行。\nAdded in version 3.10.\n参见:\nPEP 626 - 在调试和其他工具中使用精确的行号。\n引入 co_lines() 方法的 PEP。\ncodeobject.replace(**kwargs)\n返回代码对象的一个副本，使用指定的新字段值。\n代码对象也被泛型函数 copy.replace() 所支持。\nAdded in version 3.8.\n3.2.13.2. 帧对象 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | (start, |  |  |\n|  |  |  |  |  |  |\n|  |  | end, lineno) |  |  |  |\n|  |  |  |  |  |  |\n\n帧对象表示执行帧。 它们可能出现在 回溯对象 中，还会被传递给已注册的跟踪函数。\n3.2.13.2.1. 特殊的只读属性\n指向前一个栈帧（对于调用方而言），或者如果这是最底部的栈帧则\nframe.f_back\n为 None\n该帧中正在执行的 代码对象。 访问该属性将引发一个 审计事件\nframe.f_code\nobject.__getattr__，附带参数 obj 和 \"f_code\"。\n被该帧用来查找 局部变量 的映射。 如果该帧指向一个 optimized\nscope，这可能返回一个直通写入代理对象。\nframe.f_locals\n在 3.13 版本发生变更: 返回一个已优化作用域的代理。\nframe.f_globals 被帧用于查找 全局变量 的字典\nframe.f_builtins 被帧用于查找 内置（内建）名称 的字典\nframe.f_lasti 帧对象的“准确指令”（这是 代码对象 的 bytecode 字符串的索引）\n拥有该帧的 generator 或 coroutine，或者如果该帧属于常规函数则为\nNone。\nframe.f_generator\nAdded in version 3.14.\n3.2.13.2.2. 特殊的可写属性\n如果不为 None，则是在代码执行期间调用各类事件的函数 (由调\nframe.f_trace 试器使用)。 通常每个新的源代码行会触发一个事件 (参见\nf_trace_lines)。\nframe.f_trace_lines 将该属性设为 False 以禁用为每个源代码行触发跟踪事件。\n将该属性设为 True 以允许请求每个操作码事件。 请注意如果跟\nframe.f_trace_opcodes 踪函数引发的异常逃逸到被跟踪的函数中这可能会导致未定义的\n解释器行为。\n该帧的当前行号 -- 在这里写入从一个跟踪函数内部跳转到的给\nframe.f_lineno 定行（仅用于最底层的帧）。 调试器可以通过写入该属性实现\n一个 Jump 命令（即设置下一条语句）。\n3.2.13.2.3. 帧对象方法\n帧对象支持一个方法:\nframe.clear()\n此方法将清除该帧持有的全部对 局部变量 的引用。 并且，如果该帧归属于一个 generator，此\n生成器将被终结。 这有助于打破涉及帧对象的循环引用（例如当捕获一个 异常 并保存其 回溯\n\n|  | 帧对象表示执行帧。 它们可能出现在 回溯对象 中，还会被传递给已注册的跟踪函数。\n3.2.13.2.1. 特殊的只读属性 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | frame.f_back | 指向前一个栈帧（对于调用方而言），或者如果这是最底部的栈帧则\n为 None |  |  |\n|  | frame.f_code | 该帧中正在执行的 代码对象。 访问该属性将引发一个 审计事件\nobject.__getattr__，附带参数 obj 和 \"f_code\"。 |  |  |\n|  | frame.f_locals | 被该帧用来查找 局部变量 的映射。 如果该帧指向一个 optimized\nscope，这可能返回一个直通写入代理对象。\n在 3.13 版本发生变更: 返回一个已优化作用域的代理。 |  |  |\n|  | frame.f_globals | 被帧用于查找 全局变量 的字典 |  |  |\n|  | frame.f_builtins | 被帧用于查找 内置（内建）名称 的字典 |  |  |\n|  | frame.f_lasti | 帧对象的“准确指令”（这是 代码对象 的 bytecode 字符串的索引） |  |  |\n|  | frame.f_generator | 拥有该帧的 generator 或 coroutine，或者如果该帧属于常规函数则为\nNone。\nAdded in version 3.14. |  |  |\n|  | 3.2.13.2.2. 特殊的可写属性 |  |  |  |\n|  | frame.f_trace |  | 如果不为 None，则是在代码执行期间调用各类事件的函数 (由调\n试器使用)。 通常每个新的源代码行会触发一个事件 (参见\nf_trace_lines)。 |  |\n|  | frame.f_trace_lines |  | 将该属性设为 False 以禁用为每个源代码行触发跟踪事件。 |  |\n|  | frame.f_trace_opcodes |  | 将该属性设为 True 以允许请求每个操作码事件。 请注意如果跟\n踪函数引发的异常逃逸到被跟踪的函数中这可能会导致未定义的\n解释器行为。 |  |\n|  | frame.f_lineno |  | 该帧的当前行号 -- 在这里写入从一个跟踪函数内部跳转到的给\n定行（仅用于最底层的帧）。 调试器可以通过写入该属性实现\n一个 Jump 命令（即设置下一条语句）。 |  |\n|  | 3.2.13.2.3. 帧对象方法\n帧对象支持一个方法:\nframe.clear()\n此方法将清除该帧持有的全部对 局部变量 的引用。 并且，如果该帧归属于一个 generator，此\n生成器将被终结。 这有助于打破涉及帧对象的循环引用（例如当捕获一个 异常 并保存其 回溯 |  |  |  |\n\n供以后使用）。\n如果该帧当前正在执行或已挂起则会引发 RuntimeError。\nAdded in version 3.4.\n在 3.13 版本发生变更: 尝试清除已挂起的帧将引发 RuntimeError (执行帧的情况将总是\n如此)。\n3.2.13.3. 回溯对象\n回溯对象代表一个 异常 的栈跟踪信息。 当异常发生时会隐式地创建一个回溯对象，也可以通过调用\ntypes.TracebackType 显式地创建。\n在 3.7 版本发生变更: 现在回溯对象可以通过 Python 代码显式地实例化。\n对于隐式地创建的回溯对象，当查找异常处理器使得执行栈展开时，会在每个展开层级的当前回溯\n之前插入一个回溯对象。 当进入一个异常处理器时，程序将可以使用栈跟踪。 （参见 try 语句 一\n节。） 它可作为 sys.exc_info() 所返回的元组的第三项，以及所捕获异常的 __traceback__ 属\n性被获取。\n当程序不包含适用的处理器时，栈跟踪会（以良好的格式）写入到标准错误流；如果解释器处于交\n互模式，它也将作为 sys.last_traceback 供用户使用。\n对于显式地创建的回溯对象，则由回溯对象的创建者来决定应该如何连接 tb_next 属性以构成完整\n的线跟踪。\n特殊的只读属性：\n指向当前层级的执行 帧对象。\ntraceback.tb_frame\n访问该属性将引发一个 审计事件 object.__getattr__，附带参数\nobj 和 \"tb_frame\"。\ntraceback.tb_lineno 给出异常发生所在的行号\ntraceback.tb_lasti 表示“精确指令”。\n回溯中的行号和最后一条指令可能与其 帧对象 的行号不同，如果异常发生在 try 语句中且没有匹配\n的 except 子句或是有 finally 子句的话。\ntraceback.tb_next\n特殊的可写属性 tb_next 是栈跟踪中的下一层级（通往发生异常的帧），如果没有下一层级则\n为 None。\n在 3.7 版本发生变更: 该属性现在是可写的。\n3.2.13.4. 切片对象\n\n|  | 供以后使用）。\n如果该帧当前正在执行或已挂起则会引发 RuntimeError。\nAdded in version 3.4.\n在 3.13 版本发生变更: 尝试清除已挂起的帧将引发 RuntimeError (执行帧的情况将总是\n如此)。\n3.2.13.3. 回溯对象\n回溯对象代表一个 异常 的栈跟踪信息。 当异常发生时会隐式地创建一个回溯对象，也可以通过调用\ntypes.TracebackType 显式地创建。\n在 3.7 版本发生变更: 现在回溯对象可以通过 Python 代码显式地实例化。\n对于隐式地创建的回溯对象，当查找异常处理器使得执行栈展开时，会在每个展开层级的当前回溯\n之前插入一个回溯对象。 当进入一个异常处理器时，程序将可以使用栈跟踪。 （参见 try 语句 一\n节。） 它可作为 sys.exc_info() 所返回的元组的第三项，以及所捕获异常的 __traceback__ 属\n性被获取。\n当程序不包含适用的处理器时，栈跟踪会（以良好的格式）写入到标准错误流；如果解释器处于交\n互模式，它也将作为 sys.last_traceback 供用户使用。\n对于显式地创建的回溯对象，则由回溯对象的创建者来决定应该如何连接 tb_next 属性以构成完整\n的线跟踪。\n特殊的只读属性： |  |  |\n| --- | --- | --- | --- |\n|  | traceback.tb_frame | 指向当前层级的执行 帧对象。\n访问该属性将引发一个 审计事件 object.__getattr__，附带参数\nobj 和 \"tb_frame\"。 |  |\n|  | traceback.tb_lineno | 给出异常发生所在的行号 |  |\n|  | traceback.tb_lasti | 表示“精确指令”。 |  |\n|  | 回溯中的行号和最后一条指令可能与其 帧对象 的行号不同，如果异常发生在 try 语句中且没有匹配\n的 except 子句或是有 finally 子句的话。\ntraceback.tb_next\n特殊的可写属性 tb_next 是栈跟踪中的下一层级（通往发生异常的帧），如果没有下一层级则\n为 None。\n在 3.7 版本发生变更: 该属性现在是可写的。\n3.2.13.4. 切片对象 |  |  |\n\n切片对象被用来表示 __getitem__() 方法所使用的切片。 该对象也可使用内置的 slice() 函数来\n创建。\n特殊的只读属性: start 为下界; stop 为上界; step 为步长值; 各值如省略则为 None。这些属性可具\n有任意类型。\n切片对象支持一个方法:\nslice.indices(self, length)\n此方法接受一个整型参数 length 并计算在切片对象被应用到 length 指定长度的条目序列时切片\n的相关信息应如何描述。 其返回值为三个整型数组成的元组；这些数分别为切片的 start 和\nstop 索引号以及 step 步长值。索引号缺失或越界则按照与正规切片相一致的方式处理。\n3.2.13.5. 静态方法对象\n静态方法对象提供了一种胜过上文所述将函数对象转换为方法对象的方式。 静态方法对象是对任意\n其他对象的包装器，通常用来包装用户自定义的方法对象。 当从类或类实例获取一个静态方法对象\n时，实际返回的是经过包装的对象，它不会被进一步转换。 静态方法对象也是可调用对象。 静态方\n法对象可通过内置的 staticmethod() 构造器来创建。\n3.2.13.6. 类方法对象\n类方法对象与静态方法类似，是对其他对象的包装器，会改变从类或类实例获取该对象的方式。 类\n方法对象在这种获取操作中的行为已在上文中描述，见 \"实例方法\" 一节。 类方法对象是通过内置\nclassmethod() 构造器创建的。\n3.3. 特殊方法名称\n一个类可以通过定义具有特殊名称的方法来实现由特殊语法来唤起的特定操作（例如算术运算或抽\n取与切片）。 这是 Python 实现 运算符重载 的方式，允许每个类自行定义基于该语言运算符的特定\n行为。 举例来说，如果一个类定义了名为 __getitem__() 的方法，并且 x 是该类的一个实例，则\nx[i] 基本就等价于 type(x).__getitem__(x, i)。 除非有说明例外情况，在没有定义适当方法的\n时候尝试执行某种操作将引发一个异常 (通常为 AttributeError 或 TypeError)。\n将一个特殊方法设为 None 表示对应的操作不可用。 例如，如果一个类将 __iter__() 设为 None，\n则该类就是不可迭代的，因此对其实例调用 iter() 将引发一个 TypeError (而不会回退至\n__getitem__())。 [2]\n在实现模拟任何内置类型的类时，很重要的一点是模拟的实现程度对于被模拟对象来说应当是有意\n义的。例如，提取单个元素的操作对于某些序列来说是适宜的，但提取切片可能就没有意义。(这种\n情况的一个实例是 W3C 的文档对象模型中的 NodeList 接口。)\n3.3.1. 基本定制\nobject.__new__(cls[, ...])\n调用以创建一个 cls 类的新实例。__new__() 是一个静态方法 (因为是特例所以你不需要显式地\n声明)，它会将所请求实例所属的类作为第一个参数。其余的参数会被传递给对象构造器表达式\n\n|  | 切片对象被用来表示 __getitem__() 方法所使用的切片。 该对象也可使用内置的 slice() 函数来\n创建。\n特殊的只读属性: start 为下界; stop 为上界; step 为步长值; 各值如省略则为 None。这些属性可具\n有任意类型。\n切片对象支持一个方法:\nslice.indices(self, length)\n此方法接受一个整型参数 length 并计算在切片对象被应用到 length 指定长度的条目序列时切片\n的相关信息应如何描述。 其返回值为三个整型数组成的元组；这些数分别为切片的 start 和\nstop 索引号以及 step 步长值。索引号缺失或越界则按照与正规切片相一致的方式处理。\n3.2.13.5. 静态方法对象\n静态方法对象提供了一种胜过上文所述将函数对象转换为方法对象的方式。 静态方法对象是对任意\n其他对象的包装器，通常用来包装用户自定义的方法对象。 当从类或类实例获取一个静态方法对象\n时，实际返回的是经过包装的对象，它不会被进一步转换。 静态方法对象也是可调用对象。 静态方\n法对象可通过内置的 staticmethod() 构造器来创建。\n3.2.13.6. 类方法对象\n类方法对象与静态方法类似，是对其他对象的包装器，会改变从类或类实例获取该对象的方式。 类\n方法对象在这种获取操作中的行为已在上文中描述，见 \"实例方法\" 一节。 类方法对象是通过内置\nclassmethod() 构造器创建的。\n3.3. 特殊方法名称\n一个类可以通过定义具有特殊名称的方法来实现由特殊语法来唤起的特定操作（例如算术运算或抽\n取与切片）。 这是 Python 实现 运算符重载 的方式，允许每个类自行定义基于该语言运算符的特定\n行为。 举例来说，如果一个类定义了名为 __getitem__() 的方法，并且 x 是该类的一个实例，则\nx[i] 基本就等价于 type(x).__getitem__(x, i)。 除非有说明例外情况，在没有定义适当方法的\n时候尝试执行某种操作将引发一个异常 (通常为 AttributeError 或 TypeError)。\n将一个特殊方法设为 None 表示对应的操作不可用。 例如，如果一个类将 __iter__() 设为 None，\n则该类就是不可迭代的，因此对其实例调用 iter() 将引发一个 TypeError (而不会回退至\n__getitem__())。 [2]\n在实现模拟任何内置类型的类时，很重要的一点是模拟的实现程度对于被模拟对象来说应当是有意\n义的。例如，提取单个元素的操作对于某些序列来说是适宜的，但提取切片可能就没有意义。(这种\n情况的一个实例是 W3C 的文档对象模型中的 NodeList 接口。)\n3.3.1. 基本定制\nobject.__new__(cls[, ...])\n调用以创建一个 cls 类的新实例。__new__() 是一个静态方法 (因为是特例所以你不需要显式地\n声明)，它会将所请求实例所属的类作为第一个参数。其余的参数会被传递给对象构造器表达式 |  |\n| --- | --- | --- |\n\n(对类的调用)。__new__() 的返回值应为新对象实例 (通常是 cls 的实例)。\n典型的实现会附带适当的参数使用 super().__new__(cls[, ...]) 通过唤起超类的\n__new__() 方法来创建一个新的类实例然后在返回它之前根据需要修改新创建的实例。\n如果 __new__() 在构造对象期间被唤起并且它返回了一个 cls 的实例，则新实例的\n__init__() 方法将以 __init__(self[, ...]) 的形式被唤起，其中 self 为新实例而其余的参\n数与被传给对象构造器的参数相同。\n如果 __new__() 未返回一个 cls 的实例，则新实例的 __init__() 方法就不会被执行。\n__new__() 的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它\n也常会在自定义元类中被重载以便定制类创建过程。\nobject.__init__(self[, ...])\n在实例 (通过 __new__()) 被创建之后，返回调用者之前调用。其参数与传递给类构造器表达式\n的参数相同。一个基类如果有 __init__() 方法，则其所派生的类如果也有 __init__() 方\n法，就必须显式地调用它以确保实例基类部分的正确初始化；例如:\nsuper().__init__([args...]).\n因为对象是由 __new__() 和 __init__() 协作构造完成的 (由 __new__() 创建，并由\n__init__() 定制)，所以 __init__() 返回的值只能是 None，否则会在运行时引发\nTypeError。\nobject.__del__(self)\n在实例将被销毁时调用。 这还被称为终结器或析构器（不适当）。 如果一个基类具有\n__del__() 方法，则其所派生的类如果也有 __del__() 方法，就必须显式地调用它以确保实例\n基类部分的正确清除。\n__del__() 方法可以 (但不推荐!) 通过创建一个该实例的新引用来推迟其销毁。这被称为对象\n重生。__del__() 是否会在重生的对象将被销毁时再次被调用是由具体实现决定的 ；当前的\nCPython 实现只会调用一次。\n当解释器退出时并不保证会为仍然存在的对象调用 __del__() 方法。 weakref.finalize 提供\n了一种直观的方式来注册当对象被作为垃圾回收时要调用的清理函数。\n备注: del x 并不直接调用 x.__del__() --- 前者会将 x 的引用计数减一，而后者仅会在 x\n的引用计数变为零时被调用。\n一个引用循环可以阻止对象的引用计数归零。 在这种情况下，循环将稍后被检测到并被 循环垃\n圾回收器 删除。 导致引用循环的一个常见原因是当一个异常在局部变量中被捕获。 帧的局部\n变量将会引用该异常，这将引用它自己的回溯信息，它会又引用在回溯中捕获的所有帧的局部\n变量。\n参见: gc 模块的文档。\n\n|  | (对类的调用)。__new__() 的返回值应为新对象实例 (通常是 cls 的实例)。\n典型的实现会附带适当的参数使用 super().__new__(cls[, ...]) 通过唤起超类的\n__new__() 方法来创建一个新的类实例然后在返回它之前根据需要修改新创建的实例。\n如果 __new__() 在构造对象期间被唤起并且它返回了一个 cls 的实例，则新实例的\n__init__() 方法将以 __init__(self[, ...]) 的形式被唤起，其中 self 为新实例而其余的参\n数与被传给对象构造器的参数相同。\n如果 __new__() 未返回一个 cls 的实例，则新实例的 __init__() 方法就不会被执行。\n__new__() 的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它\n也常会在自定义元类中被重载以便定制类创建过程。\nobject.__init__(self[, ...])\n在实例 (通过 __new__()) 被创建之后，返回调用者之前调用。其参数与传递给类构造器表达式\n的参数相同。一个基类如果有 __init__() 方法，则其所派生的类如果也有 __init__() 方\n法，就必须显式地调用它以确保实例基类部分的正确初始化；例如:\nsuper().__init__([args...]).\n因为对象是由 __new__() 和 __init__() 协作构造完成的 (由 __new__() 创建，并由\n__init__() 定制)，所以 __init__() 返回的值只能是 None，否则会在运行时引发\nTypeError。\nobject.__del__(self)\n在实例将被销毁时调用。 这还被称为终结器或析构器（不适当）。 如果一个基类具有\n__del__() 方法，则其所派生的类如果也有 __del__() 方法，就必须显式地调用它以确保实例\n基类部分的正确清除。\n__del__() 方法可以 (但不推荐!) 通过创建一个该实例的新引用来推迟其销毁。这被称为对象\n重生。__del__() 是否会在重生的对象将被销毁时再次被调用是由具体实现决定的 ；当前的\nCPython 实现只会调用一次。\n当解释器退出时并不保证会为仍然存在的对象调用 __del__() 方法。 weakref.finalize 提供\n了一种直观的方式来注册当对象被作为垃圾回收时要调用的清理函数。\n备注: del x 并不直接调用 x.__del__() --- 前者会将 x 的引用计数减一，而后者仅会在 x\n的引用计数变为零时被调用。\n一个引用循环可以阻止对象的引用计数归零。 在这种情况下，循环将稍后被检测到并被 循环垃\n圾回收器 删除。 导致引用循环的一个常见原因是当一个异常在局部变量中被捕获。 帧的局部\n变量将会引用该异常，这将引用它自己的回溯信息，它会又引用在回溯中捕获的所有帧的局部\n变量。\n参见: gc 模块的文档。 |  |\n| --- | --- | --- |\n\n警告: 由于调用 __del__() 方法时周边状况已不确定，在其执行期间发生的异常将被忽\n略，改为打印一个警告到 sys.stderr。特别地：\n__del__() 可在任意代码被执行时启用，包括来自任意线程的代码。如果 __del__() 需\n要接受锁或启用其他阻塞资源，可能会发生死锁，例如该资源已被为执行 __del__() 而\n中断的代码所获取。\n__del__() 可以在解释器关闭阶段被执行。因此，它需要访问的全局变量（包含其他模\n块）可能已被删除或设为 None。Python 会保证先删除模块中名称以单个下划线打头的全\n局变量再删除其他全局变量；如果已不存在其他对此类全局变量的引用，这有助于确保导\n入的模块在 __del__() 方法被调用时仍然可用。\nobject.__repr__(self)\n由 repr() 内置函数调用以输出一个对象的“官方”字符串表示。如果可能，这应类似一个有效的\nPython 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。如果这不可能，则\n应返回形式如 <...some useful description...> 的字符串。返回值必须是一个字符串对\n象。如果一个类定义了 __repr__() 但未定义 __str__()，则在需要该类的实例的“非正式”字\n符串表示时也会使用 __repr__()。\n此方法通常被用于调试，因此确保其表示的内容包含丰富信息且无歧义是很重要的。 object\n类本身提供了一个默认实现。\nobject.__str__(self)\n由 str(object), 默认的 __format__() 实现以及内置函数 print() 调用，以生成一个对象的\n“非正式”或适合打印的字符串表示形式。 返回值必须为一个 str 对象。\n此方法与 object.__repr__() 的不同点在于 __str__() 并不预期返回一个有效的 Python 表\n达式：可以使用更方便或更准确的描述信息。\n内置类型 object 所定义的默认实现会调用 object.__repr__()。\nobject.__bytes__(self)\n由 bytes 调用以生成一个对象的字节串表示形式。 这应当返回一个 bytes 对象。 object 类本\n身不提供此方法。\nobject.__format__(self, format_spec)\n通过 format() 内置函数、扩展、格式化字符串字面值 的求值以及 str.format() 方法调用以\n生成一个对象的“格式化”字符串表示。 format_spec 参数为包含所需格式选项描述的字符串。\nformat_spec 参数的解读是由实现 __format__() 的类型决定的，不过大多数类或是将格式化委\n托给某个内置类型，或是使用相似的格式化选项语法。\n请参看 格式规格迷你语言 了解标准格式化语法的描述。\n返回值必须为一个字符串对象。\n应当为由 object 类提供的默认实现给出一个空的 format_spec 字符串。 它将委托给\n__str__()。\n\n|  | 警告: 由于调用 __del__() 方法时周边状况已不确定，在其执行期间发生的异常将被忽\n略，改为打印一个警告到 sys.stderr。特别地：\n__del__() 可在任意代码被执行时启用，包括来自任意线程的代码。如果 __del__() 需\n要接受锁或启用其他阻塞资源，可能会发生死锁，例如该资源已被为执行 __del__() 而\n中断的代码所获取。\n__del__() 可以在解释器关闭阶段被执行。因此，它需要访问的全局变量（包含其他模\n块）可能已被删除或设为 None。Python 会保证先删除模块中名称以单个下划线打头的全\n局变量再删除其他全局变量；如果已不存在其他对此类全局变量的引用，这有助于确保导\n入的模块在 __del__() 方法被调用时仍然可用。\nobject.__repr__(self)\n由 repr() 内置函数调用以输出一个对象的“官方”字符串表示。如果可能，这应类似一个有效的\nPython 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。如果这不可能，则\n应返回形式如 <...some useful description...> 的字符串。返回值必须是一个字符串对\n象。如果一个类定义了 __repr__() 但未定义 __str__()，则在需要该类的实例的“非正式”字\n符串表示时也会使用 __repr__()。\n此方法通常被用于调试，因此确保其表示的内容包含丰富信息且无歧义是很重要的。 object\n类本身提供了一个默认实现。\nobject.__str__(self)\n由 str(object), 默认的 __format__() 实现以及内置函数 print() 调用，以生成一个对象的\n“非正式”或适合打印的字符串表示形式。 返回值必须为一个 str 对象。\n此方法与 object.__repr__() 的不同点在于 __str__() 并不预期返回一个有效的 Python 表\n达式：可以使用更方便或更准确的描述信息。\n内置类型 object 所定义的默认实现会调用 object.__repr__()。\nobject.__bytes__(self)\n由 bytes 调用以生成一个对象的字节串表示形式。 这应当返回一个 bytes 对象。 object 类本\n身不提供此方法。\nobject.__format__(self, format_spec)\n通过 format() 内置函数、扩展、格式化字符串字面值 的求值以及 str.format() 方法调用以\n生成一个对象的“格式化”字符串表示。 format_spec 参数为包含所需格式选项描述的字符串。\nformat_spec 参数的解读是由实现 __format__() 的类型决定的，不过大多数类或是将格式化委\n托给某个内置类型，或是使用相似的格式化选项语法。\n请参看 格式规格迷你语言 了解标准格式化语法的描述。\n返回值必须为一个字符串对象。\n应当为由 object 类提供的默认实现给出一个空的 format_spec 字符串。 它将委托给\n__str__()。 | 警告: 由于调用 __del__() 方法时周边状况已不确定，在其执行期间发生的异常将被忽\n略，改为打印一个警告到 sys.stderr。特别地：\n__del__() 可在任意代码被执行时启用，包括来自任意线程的代码。如果 __del__() 需\n要接受锁或启用其他阻塞资源，可能会发生死锁，例如该资源已被为执行 __del__() 而\n中断的代码所获取。\n__del__() 可以在解释器关闭阶段被执行。因此，它需要访问的全局变量（包含其他模\n块）可能已被删除或设为 None。Python 会保证先删除模块中名称以单个下划线打头的全\n局变量再删除其他全局变量；如果已不存在其他对此类全局变量的引用，这有助于确保导\n入的模块在 __del__() 方法被调用时仍然可用。 |  |\n| --- | --- | --- | --- |\n\n在 3.4 版本发生变更: object 本身的 __format__ 方法如果被传入任何非空字符，将会引发\n一个 TypeError。\n在 3.7 版本发生变更: object.__format__(x, '') 现在等同于 str(x) 而不再是\nformat(str(x), '')。\nobject.__lt__(self, other)\nobject.__le__(self, other)\nobject.__eq__(self, other)\nobject.__ne__(self, other)\nobject.__gt__(self, other)\nobject.__ge__(self, other)\n以上这些被称为“富比较”方法。运算符号与方法名称的对应关系如下：x<y 调用\nx.__lt__(y)、x<=y 调用 x.__le__(y)、x==y 调用 x.__eq__(y)、x!=y 调用\nx.__ne__(y)、x>y 调用 x.__gt__(y)、x>=y 调用 x.__ge__(y)。\n如果指定的参数对没有相应的实现，富比较方法可能会返回单例对象 NotImplemented 。按照\n惯例，成功的比较会返回 False 或 True。不过实际上这些方法可以返回任意值，因此如果比\n较运算符是要用于布尔值判断（例如作为 if 语句的条件），Python 会对返回值调用 bool()\n以确定结果为真还是假。\n在默认情况下，object 通过使用 is 来实现 __eq__() ，并在比较结果为假值时返回\nNotImplemented : True if x is y else NotImplemented 。 对于 __ne__() ，默认会委托\n给 __eq__() 并对结果取反，除非结果为 NotImplemented 。 比较运算符之间没有其他隐含关\n系或默认实现；例如， (x<y or x==y) 为真并不意味着 x<=y 。 要根据单根运算自动生成排序\n操作，请参看 functools.total_ordering() 。\n在默认情况下，object 类提供与 值比较 一致的实现：相等比较是根据对象标识号，而顺序比\n较会引发 TypeError。 每个默认方法都可能直接生成这样的结果，但也可能返回\nNotImplemented。\n请查看 __hash__() 的相关段落，了解创建可支持自定义比较运算并可用作字典键的 hashable\n对象时要注意的一些事项。\n这些方法都没有对调参数版本（在左边参数不支持该操作但右边参数支持时使用）；而是\n__lt__() 和 __gt__() 互为对方的反向，__le__() 和 __ge__() 互为对方的反射，而\n__eq__() 和 __ne__() 则是它们自己的反射。 如果两个操作数的类型不同，且右操作数的类\n型是左操作数类型的直接或间接子类，则优先选择右操作数的反射方法，在其他情况下优先选\n择左操作数的方法。 虚拟子类化不会被考虑。\n当没有合适的方法返回任何 NotImplemented 以外的值时，== 和 != 运算符将分别回退至 is\n和 is not。\nobject.__hash__(self)\n通过内置函数 hash() 调用以对哈希集的成员进行操作，属于哈希集的类型包括 set、\nfrozenset 以及 dict。__hash__() 应该返回一个整数。对象比较结果相同所需的唯一特征属\n\n|  | 在 3.4 版本发生变更: object 本身的 __format__ 方法如果被传入任何非空字符，将会引发\n一个 TypeError。\n在 3.7 版本发生变更: object.__format__(x, '') 现在等同于 str(x) 而不再是\nformat(str(x), '')。\nobject.__lt__(self, other)\nobject.__le__(self, other)\nobject.__eq__(self, other)\nobject.__ne__(self, other)\nobject.__gt__(self, other)\nobject.__ge__(self, other)\n以上这些被称为“富比较”方法。运算符号与方法名称的对应关系如下：x<y 调用\nx.__lt__(y)、x<=y 调用 x.__le__(y)、x==y 调用 x.__eq__(y)、x!=y 调用\nx.__ne__(y)、x>y 调用 x.__gt__(y)、x>=y 调用 x.__ge__(y)。\n如果指定的参数对没有相应的实现，富比较方法可能会返回单例对象 NotImplemented 。按照\n惯例，成功的比较会返回 False 或 True。不过实际上这些方法可以返回任意值，因此如果比\n较运算符是要用于布尔值判断（例如作为 if 语句的条件），Python 会对返回值调用 bool()\n以确定结果为真还是假。\n在默认情况下，object 通过使用 is 来实现 __eq__() ，并在比较结果为假值时返回\nNotImplemented : True if x is y else NotImplemented 。 对于 __ne__() ，默认会委托\n给 __eq__() 并对结果取反，除非结果为 NotImplemented 。 比较运算符之间没有其他隐含关\n系或默认实现；例如， (x<y or x==y) 为真并不意味着 x<=y 。 要根据单根运算自动生成排序\n操作，请参看 functools.total_ordering() 。\n在默认情况下，object 类提供与 值比较 一致的实现：相等比较是根据对象标识号，而顺序比\n较会引发 TypeError。 每个默认方法都可能直接生成这样的结果，但也可能返回\nNotImplemented。\n请查看 __hash__() 的相关段落，了解创建可支持自定义比较运算并可用作字典键的 hashable\n对象时要注意的一些事项。\n这些方法都没有对调参数版本（在左边参数不支持该操作但右边参数支持时使用）；而是\n__lt__() 和 __gt__() 互为对方的反向，__le__() 和 __ge__() 互为对方的反射，而\n__eq__() 和 __ne__() 则是它们自己的反射。 如果两个操作数的类型不同，且右操作数的类\n型是左操作数类型的直接或间接子类，则优先选择右操作数的反射方法，在其他情况下优先选\n择左操作数的方法。 虚拟子类化不会被考虑。\n当没有合适的方法返回任何 NotImplemented 以外的值时，== 和 != 运算符将分别回退至 is\n和 is not。\nobject.__hash__(self)\n通过内置函数 hash() 调用以对哈希集的成员进行操作，属于哈希集的类型包括 set、\nfrozenset 以及 dict。__hash__() 应该返回一个整数。对象比较结果相同所需的唯一特征属 |  |\n| --- | --- | --- |\n\n性是其具有相同的哈希值；建议的做法是把参与比较的对象全部组件的哈希值混在一起，即将\n它们打包为一个元组并对该元组做哈希运算。例如:\ndef __hash__(self):\nreturn hash((self.name, self.nick, self.color))\n备注: hash() 会从一个对象自定义的 __hash__() 方法返回值中截断为 Py_ssize_t 的大\n小。通常对 64 位构建为 8 字节，对 32 位构建为 4 字节。如果一个对象的 __hash__() 必须\n在不同位大小的构建上进行互操作，请确保检查全部所支持构建的宽度。做到这一点的简单\n方法是使用 python -c \"import sys; print(sys.hash_info.width)\"。\n如果一个类没有定义 __eq__() 方法，那么它也不应该定义 __hash__() 操作；如果它定义了\n__eq__() 但没有定义 __hash__()，则其实例将不可被用作可哈希多项集的条目。 如果一个类\n定义了可变对象并实现了 __eq__() 方法，则它不应该实现 __hash__()，因为 hashable 多项\n集的实现要求键的哈希值是不可变的（如果对象的哈希值发生改变，它将位于错误的哈希桶\n中）。\n用户自定义的类默认带有 __eq__() 和 __hash__() 方法（继承自 object 类）；因为它们的\n存在，所有对象（自己除外）相互比较必定不相等并且 x.__hash__() 将返回一个恰当的值以\n使得 x == y 同时意味着 x is y 且 hash(x) == hash(y)。\n一个类如果重载了 __eq__() 且没有定义 __hash__() 则会将其 __hash__() 隐式地设为\nNone。当一个类的 __hash__() 方法为 None 时，该类的实例将在一个程序尝试获取其哈希值\n时正确地引发 TypeError，并会在检测 isinstance(obj, collections.abc.Hashable) 时被\n正确地识别为不可哈希对象。\n如果一个重载了 __eq__() 的类需要保留来自父类的 __hash__() 实现，则必须通过设置\n__hash__ = <ParentClass>.__hash__ 来显式地告知解释器。\n如果一个没有重载 __eq__() 的类需要去掉哈希支持，则应该在类定义中包含 __hash__ =\nNone。一个自定义了 __hash__() 以显式地引发 TypeError 的类会被 isinstance(obj,\ncollections.abc.Hashable) 调用错误地识别为可哈希对象。\n备注: 在默认情况下，str 和 bytes 对象的 __hash__() 值会使用一个不可预知的随机值“加\n盐”。 虽然它们在一个单独 Python 进程中会保持不变，但它们的值在重复运行的 Python 间\n是不可预测的。\n这是为了防止通过精心选择输入来利用字典插入操作在最坏情况下的执行效率即\nO(n2)\n复杂\n度制度的拒绝服务攻击。 请参阅 http://ocert.org/advisories/ocert-2011-003.html 了解详\n情。\n改变哈希值会影响集合的迭代次序。Python 也从不保证这个次序不会被改变（通常它在 32\n位和 64 位构建上是不一致的）。\n另见 PYTHONHASHSEED.\n\n|  |  |  | 性是其具有相同的哈希值；建议的做法是把参与比较的对象全部组件的哈希值混在一起，即将\n它们打包为一个元组并对该元组做哈希运算。例如:\ndef __hash__(self):\nreturn hash((self.name, self.nick, self.color))\n备注: hash() 会从一个对象自定义的 __hash__() 方法返回值中截断为 Py_ssize_t 的大\n小。通常对 64 位构建为 8 字节，对 32 位构建为 4 字节。如果一个对象的 __hash__() 必须\n在不同位大小的构建上进行互操作，请确保检查全部所支持构建的宽度。做到这一点的简单\n方法是使用 python -c \"import sys; print(sys.hash_info.width)\"。\n如果一个类没有定义 __eq__() 方法，那么它也不应该定义 __hash__() 操作；如果它定义了\n__eq__() 但没有定义 __hash__()，则其实例将不可被用作可哈希多项集的条目。 如果一个类\n定义了可变对象并实现了 __eq__() 方法，则它不应该实现 __hash__()，因为 hashable 多项\n集的实现要求键的哈希值是不可变的（如果对象的哈希值发生改变，它将位于错误的哈希桶\n中）。\n用户自定义的类默认带有 __eq__() 和 __hash__() 方法（继承自 object 类）；因为它们的\n存在，所有对象（自己除外）相互比较必定不相等并且 x.__hash__() 将返回一个恰当的值以\n使得 x == y 同时意味着 x is y 且 hash(x) == hash(y)。\n一个类如果重载了 __eq__() 且没有定义 __hash__() 则会将其 __hash__() 隐式地设为\nNone。当一个类的 __hash__() 方法为 None 时，该类的实例将在一个程序尝试获取其哈希值\n时正确地引发 TypeError，并会在检测 isinstance(obj, collections.abc.Hashable) 时被\n正确地识别为不可哈希对象。\n如果一个重载了 __eq__() 的类需要保留来自父类的 __hash__() 实现，则必须通过设置\n__hash__ = <ParentClass>.__hash__ 来显式地告知解释器。\n如果一个没有重载 __eq__() 的类需要去掉哈希支持，则应该在类定义中包含 __hash__ =\nNone。一个自定义了 __hash__() 以显式地引发 TypeError 的类会被 isinstance(obj,\ncollections.abc.Hashable) 调用错误地识别为可哈希对象。\n备注: 在默认情况下，str 和 bytes 对象的 __hash__() 值会使用一个不可预知的随机值“加\n盐”。 虽然它们在一个单独 Python 进程中会保持不变，但它们的值在重复运行的 Python 间\n是不可预测的。\nO(n2)\n这是为了防止通过精心选择输入来利用字典插入操作在最坏情况下的执行效率即 复杂\n度制度的拒绝服务攻击。 请参阅 http://ocert.org/advisories/ocert-2011-003.html 了解详\n情。\n改变哈希值会影响集合的迭代次序。Python 也从不保证这个次序不会被改变（通常它在 32\n位和 64 位构建上是不一致的）。\n另见 PYTHONHASHSEED. |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | None | isinstance(obj, |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | collections.abc.Hashable) |  |  |  |\n|  |  |  |  |  |  |  |\n\n在 3.3 版本发生变更: 默认启用哈希随机化。\nobject.__bool__(self)\n调用此方法以实现真值检测以及内置的 bool() 操作；应当返回 False 或 True。 当未定义此\n方法时，则会在定义了 __len__() 的情况下调用它，如果其结果不为零则该对象将被视为具有\n真值。 如果一个类的 __len__() 和 __bool__() 均未定义（这也是 object 类本身的情况），\n则其所有实例都将被视为具有真值。\n3.3.2. 自定义属性访问\n可以定义下列方法来自定义对类实例属性访问（x.name 的使用、赋值或删除）的具体含义.\nobject.__getattr__(self, name)\n当默认属性访问因引发 AttributeError 而失败时被调用 (可能是调用 __getattribute__()\n时由于 name 不是一个实例属性或 self 的类层级树中的属性而引发了 AttributeError；或者\n是由于 name 特征属性的 __get__() 引发了 AttributeError)。 此方法应当返回（找到的）\n属性值或是引发一个 AttributeError 异常。 object 类本身没有提供此方法。\n请注意如果属性是通过正常机制找到的，则 __getattr__() 不会被调用。 （这是在\n__getattr__() 和 __setattr__() 之间故意设置的不对称性。） 这既是出于执行效率理由也\n是因为不这样做的话 __getattr__() 将无法访问实例的其他属性。 要注意至少对于实例变量\n来说，你不必在实例属性字典中插入任何值（而是通过插入到其他对象）就可以实现对它的完\n全控制。 请参阅下面的 __getattribute__() 方法了解真正获取对属性访问的完全控制权的办\n法。\nobject.__getattribute__(self, name)\n此方法会无条件地被调用以实现对类实例属性的访问。如果类还定义了 __getattr__()，则后\n者不会被调用，除非 __getattribute__() 显式地调用它或是引发了 AttributeError。此方\n法应当返回（找到的）属性值或是引发一个 AttributeError 异常。为了避免此方法中的无限\n递归，其实现应该总是调用具有相同名称的基类方法来访问它所需要的任何属性，例如\nobject.__getattribute__(self, name)。\n备注: 此方法在作为通过特定语法或 内置函数 隐式地调用的结果的情况下查找特殊方法时\n仍可能会被跳过。 参见 特殊方法查找。\n对于特定的敏感属性访问，引发一个 审计事件 object.__getattr__，附带参数 obj 和\nname。\nobject.__setattr__(self, name, value)\n此方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字\n典）。 name 为属性名称， value 为要赋给属性的值。\n如果 __setattr__() 想要赋值给一个实例属性，它应该调用同名的基类方法，例如\nobject.__setattr__(self, name, value)。\n\n|  | 在 3.3 版本发生变更: 默认启用哈希随机化。\nobject.__bool__(self)\n调用此方法以实现真值检测以及内置的 bool() 操作；应当返回 False 或 True。 当未定义此\n方法时，则会在定义了 __len__() 的情况下调用它，如果其结果不为零则该对象将被视为具有\n真值。 如果一个类的 __len__() 和 __bool__() 均未定义（这也是 object 类本身的情况），\n则其所有实例都将被视为具有真值。\n3.3.2. 自定义属性访问\n可以定义下列方法来自定义对类实例属性访问（x.name 的使用、赋值或删除）的具体含义.\nobject.__getattr__(self, name)\n当默认属性访问因引发 AttributeError 而失败时被调用 (可能是调用 __getattribute__()\n时由于 name 不是一个实例属性或 self 的类层级树中的属性而引发了 AttributeError；或者\n是由于 name 特征属性的 __get__() 引发了 AttributeError)。 此方法应当返回（找到的）\n属性值或是引发一个 AttributeError 异常。 object 类本身没有提供此方法。\n请注意如果属性是通过正常机制找到的，则 __getattr__() 不会被调用。 （这是在\n__getattr__() 和 __setattr__() 之间故意设置的不对称性。） 这既是出于执行效率理由也\n是因为不这样做的话 __getattr__() 将无法访问实例的其他属性。 要注意至少对于实例变量\n来说，你不必在实例属性字典中插入任何值（而是通过插入到其他对象）就可以实现对它的完\n全控制。 请参阅下面的 __getattribute__() 方法了解真正获取对属性访问的完全控制权的办\n法。\nobject.__getattribute__(self, name)\n此方法会无条件地被调用以实现对类实例属性的访问。如果类还定义了 __getattr__()，则后\n者不会被调用，除非 __getattribute__() 显式地调用它或是引发了 AttributeError。此方\n法应当返回（找到的）属性值或是引发一个 AttributeError 异常。为了避免此方法中的无限\n递归，其实现应该总是调用具有相同名称的基类方法来访问它所需要的任何属性，例如\nobject.__getattribute__(self, name)。\n备注: 此方法在作为通过特定语法或 内置函数 隐式地调用的结果的情况下查找特殊方法时\n仍可能会被跳过。 参见 特殊方法查找。\n对于特定的敏感属性访问，引发一个 审计事件 object.__getattr__，附带参数 obj 和\nname。\nobject.__setattr__(self, name, value)\n此方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字\n典）。 name 为属性名称， value 为要赋给属性的值。\n如果 __setattr__() 想要赋值给一个实例属性，它应该调用同名的基类方法，例如\nobject.__setattr__(self, name, value)。 |  |\n| --- | --- | --- |\n\n对特定敏感属性的赋值，会引发一个 审计事件 object.__setattr__，附带参数 obj, name,\nvalue。\nobject.__delattr__(self, name)\n类似于 __setattr__() 但其作用为删除而非赋值。此方法应该仅在 del obj.name 对于该对象\n有意义时才被实现。\n对于特定的敏感属性删除，引发一个 审计事件 object.__delattr__，附带参数 obj 和\nname。\nobject.__dir__(self)\n此方法会在针对相应对象调用 dir() 时被调用。 返回值必须为一个可迭代对象。 dir() 会把\n返回的可迭代对象转换为列表并对其排序。\n3.3.2.1. 自定义模块属性访问\nmodule.__getattr__()\nmodule.__dir__()\n特殊名称 __getattr__ 和 __dir__ 还可被用来自定义对模块属性的访问。模块层级的\n__getattr__ 函数应当接受一个参数，其名称为一个属性名，并返回计算结果值或引发一个\nAttributeError。如果通过正常查找即 object.__getattribute__() 未在模块对象中找到某个属\n性，则 __getattr__ 会在模块的 __dict__ 中查找，未找到时会引发一个 AttributeError。如果\n找到，它会以属性名被调用并返回结果值。\n__dir__ 函数应当不接受任何参数，并且返回一个表示模块中可访问名称的字符串可迭代对象。 此\n函数如果存在，将会重写一个模块中的标准 dir() 搜索操作。\nmodule.__class__\n想要更细致地自定义模块的行为（设置属性和特性属性等待），可以将模块对象的 __class__ 属性\n设置为一个 types.ModuleType 的子类。例如:\nimport sys\nfrom types import ModuleType\nclass VerboseModule(ModuleType):\ndef __repr__(self):\nreturn f'Verbose {self.__name__}'\ndef __setattr__(self, attr, value):\nprint(f'Setting {attr}...')\nsuper().__setattr__(attr, value)\nsys.modules[__name__].__class__ = VerboseModule\n备注: 定义模块的 __getattr__ 和设置模块的 __class__ 只会影响使用属性访问语法进行的查\n找 -- 直接访问模块全局变量（不论是通过模块内的代码还是通过对模块全局字典的引用）是不受\n影响的。\n\n|  | 对特定敏感属性的赋值，会引发一个 审计事件 object.__setattr__，附带参数 obj, name,\nvalue。\nobject.__delattr__(self, name)\n类似于 __setattr__() 但其作用为删除而非赋值。此方法应该仅在 del obj.name 对于该对象\n有意义时才被实现。\n对于特定的敏感属性删除，引发一个 审计事件 object.__delattr__，附带参数 obj 和\nname。\nobject.__dir__(self)\n此方法会在针对相应对象调用 dir() 时被调用。 返回值必须为一个可迭代对象。 dir() 会把\n返回的可迭代对象转换为列表并对其排序。\n3.3.2.1. 自定义模块属性访问\nmodule.__getattr__()\nmodule.__dir__()\n特殊名称 __getattr__ 和 __dir__ 还可被用来自定义对模块属性的访问。模块层级的\n__getattr__ 函数应当接受一个参数，其名称为一个属性名，并返回计算结果值或引发一个\nAttributeError。如果通过正常查找即 object.__getattribute__() 未在模块对象中找到某个属\n性，则 __getattr__ 会在模块的 __dict__ 中查找，未找到时会引发一个 AttributeError。如果\n找到，它会以属性名被调用并返回结果值。\n__dir__ 函数应当不接受任何参数，并且返回一个表示模块中可访问名称的字符串可迭代对象。 此\n函数如果存在，将会重写一个模块中的标准 dir() 搜索操作。\nmodule.__class__\n想要更细致地自定义模块的行为（设置属性和特性属性等待），可以将模块对象的 __class__ 属性\n设置为一个 types.ModuleType 的子类。例如: |  |\n| --- | --- | --- |\n|  | import sys\nfrom types import ModuleType\nclass VerboseModule(ModuleType):\ndef __repr__(self):\nreturn f'Verbose {self.__name__}'\ndef __setattr__(self, attr, value):\nprint(f'Setting {attr}...')\nsuper().__setattr__(attr, value)\nsys.modules[__name__].__class__ = VerboseModule |  |\n|  |  |  |\n|  | 备注: 定义模块的 __getattr__ 和设置模块的 __class__ 只会影响使用属性访问语法进行的查\n找 -- 直接访问模块全局变量（不论是通过模块内的代码还是通过对模块全局字典的引用）是不受\n影响的。 |  |\n|  |  |  |\n\n在 3.5 版本发生变更: __class__ 模块属性改为可写。\nAdded in version 3.7: __getattr__ 和 __dir__ 模块属性。\n参见:\nPEP 562 - 模块 __getattr__ 和 __dir__\n描述用于模块的 __getattr__ 和 __dir__ 函数。\n3.3.2.2. 实现描述器\n下列方法仅当一个包含该方法的类（即所谓 描述器 类）的实例出现在一个 所有者 类之中的时候才\n会起作用（该描述器必须在所有者类或它的某个上级类的类字典中）。 在下面的例子中，“属性”是\n指名称为所有者类的 __dict__ 中的特征属性的键名的属性。 object 类本身没有实现这些协议。\nobject.__get__(self, instance, owner=None)\n调用此方法以获取所有者类的属性（类属性访问）或该类的实例的属性（实例属性访问）。 可\n选的 owner 参数是所有者类而 instance 是被用来访问属性的实例，如果通过 owner 来访问属性\n则返回 None。\n此方法应当返回计算得到的属性值或是引发 AttributeError 异常。\nPEP 252 指明 __get__() 为带有一至二个参数的可调用对象。 Python 自身内置的描述器支持\n此规格定义；但是，某些第三方工具可能要求必须带两个参数。 Python 自身的\n__getattribute__() 实现总是会传入两个参数，无论它们是否被要求提供。\nobject.__set__(self, instance, value)\n调用此方法以设置 instance 指定的所有者类的实例的属性为新值 value。\n请注意，添加 __set__() 或 __delete__() 会将描述器变成“数据描述器”。 更多细节请参阅\n调用描述器。\nobject.__delete__(self, instance)\n调用此方法以删除 instance 指定的所有者类的实例的属性。\n描述器的实例也可能存在 __objclass__ 属性：\nobject.__objclass__\n属性 __objclass__ 会被 inspect 模块解读为指定此对象定义所在的类（正确设置此属性有助\n于动态类属性的运行时内省）。 对于可调用对象来说，它可以指明预期或要求提供一个特定类\n型（或子类）的实例作为第一个位置参数（例如，CPython 会为在 C 中实现的未绑定方法设置\n此属性）。\n3.3.2.3. 调用描述器\n总的说来，描述器就是具有“绑定行为”的对象属性，其属性访问已被描述器协议中的方法所重载:\n__get__(), __set__() 和 __delete__()。 如果一个对象定义了以上方法中的任意一个，它就被称\n为描述器。\n\n|  | 在 3.5 版本发生变更: __class__ 模块属性改为可写。\nAdded in version 3.7: __getattr__ 和 __dir__ 模块属性。 |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 562 - 模块 __getattr__ 和 __dir__\n描述用于模块的 __getattr__ 和 __dir__ 函数。 |  |\n|  | 3.3.2.2. 实现描述器\n下列方法仅当一个包含该方法的类（即所谓 描述器 类）的实例出现在一个 所有者 类之中的时候才\n会起作用（该描述器必须在所有者类或它的某个上级类的类字典中）。 在下面的例子中，“属性”是\n指名称为所有者类的 __dict__ 中的特征属性的键名的属性。 object 类本身没有实现这些协议。\nobject.__get__(self, instance, owner=None)\n调用此方法以获取所有者类的属性（类属性访问）或该类的实例的属性（实例属性访问）。 可\n选的 owner 参数是所有者类而 instance 是被用来访问属性的实例，如果通过 owner 来访问属性\n则返回 None。\n此方法应当返回计算得到的属性值或是引发 AttributeError 异常。\nPEP 252 指明 __get__() 为带有一至二个参数的可调用对象。 Python 自身内置的描述器支持\n此规格定义；但是，某些第三方工具可能要求必须带两个参数。 Python 自身的\n__getattribute__() 实现总是会传入两个参数，无论它们是否被要求提供。\nobject.__set__(self, instance, value)\n调用此方法以设置 instance 指定的所有者类的实例的属性为新值 value。\n请注意，添加 __set__() 或 __delete__() 会将描述器变成“数据描述器”。 更多细节请参阅\n调用描述器。\nobject.__delete__(self, instance)\n调用此方法以删除 instance 指定的所有者类的实例的属性。\n描述器的实例也可能存在 __objclass__ 属性：\nobject.__objclass__\n属性 __objclass__ 会被 inspect 模块解读为指定此对象定义所在的类（正确设置此属性有助\n于动态类属性的运行时内省）。 对于可调用对象来说，它可以指明预期或要求提供一个特定类\n型（或子类）的实例作为第一个位置参数（例如，CPython 会为在 C 中实现的未绑定方法设置\n此属性）。\n3.3.2.3. 调用描述器\n总的说来，描述器就是具有“绑定行为”的对象属性，其属性访问已被描述器协议中的方法所重载:\n__get__(), __set__() 和 __delete__()。 如果一个对象定义了以上方法中的任意一个，它就被称\n为描述器。 |  |\n\n属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，a.x 的查找顺序会从\na.__dict__['x'] 开始，然后是 type(a).__dict__['x']，接下来依次查找 type(a) 的上级基\n类，不包括元类。\n但是，如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而唤起描\n述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决\n定。\n描述器唤起的开始点是一个绑定 a.x。参数的组合方式依 a 而定:\n直接调用\n最简单但最不常见的调用方式是用户代码直接唤起一个描述器方法: x.__get__(a)。\n实例绑定\n如果绑定到一个对象实例，a.x 会被转换为调用: type(a).__dict__['x'].__get__(a,\ntype(a))。\n类绑定\n如果绑定到一个类，A.x 会被转换为调用: A.__dict__['x'].__get__(None, A)。\n超绑定\n类似 super(A, a).x 这样的带点号查找将在 a.__class__.__mro__ 中搜索紧接在 A 之后的基\n类 B 并返回 B.__dict__['x'].__get__(a, A)。 如果 x 不是描述器，则不加改变地返回它。\n对于实例绑定，发起描述器调用的优先级取决于定义了哪些描述器方法。 一个描述器可以定义\n__get__(), __set__() 和 __delete__() 的任意组合。 如果它没有定义 __get__()，则访问属性\n将返回描述器对象自身，除非对象的实例字典中有相应的属性值。 如果描述器定义了 __set__()\n和/或 __delete__()，则它是一个数据描述器；如果两者均未定义，则它是一个非数据描述器。 通\n常，数据描述器会同时定义 __get__() 和 __set__()，而非数据描述器则只有 __get__() 方法。\n定义了 __get__() 和 __set__() (和/或 __delete__()) 的数据描述器总是会重载实例字典中的定\n义。 与之相对地，非数据描述器则可被实例所重载。\nPython 方法（包括用 @staticmethod 和 @classmethod 装饰的方法）都是作为非数据描述器来实\n现的。 因而，实例可以重定义和重写方法。 这允许单个实例获得与相同类的其他实例不一样的行\n为。\nproperty() 函数是作为数据描述器来实现的。因此实例不能重载特性属性的行为。\n3.3.2.4. __slots__\n__slots__ 允许我们显式地声明数据成员（如特征属性）并禁止创建 __dict__ 和 __weakref__ (除非是\n在 __slots__ 中显式地声明或是在父类中可用。)\n相比使用 __dict__ 可以显著节省空间。 属性查找速度也可得到显著的提升。\nobject.__slots__\n这个类变量可赋值为字符串、可迭代对象或由实例使用的变量名组成的字符串序列。 __slots__\n会为已声明的变量保留空间并阻止自动为每个实例创建 __dict__ 和 __weakref__。\n\n|  |  | 属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，a.x 的查找顺序会从\na.__dict__['x'] 开始，然后是 type(a).__dict__['x']，接下来依次查找 type(a) 的上级基\n类，不包括元类。\n但是，如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而唤起描\n述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决\n定。\n描述器唤起的开始点是一个绑定 a.x。参数的组合方式依 a 而定:\n直接调用\n最简单但最不常见的调用方式是用户代码直接唤起一个描述器方法: x.__get__(a)。\n实例绑定\n如果绑定到一个对象实例，a.x 会被转换为调用: type(a).__dict__['x'].__get__(a,\ntype(a))。\n类绑定\n如果绑定到一个类，A.x 会被转换为调用: A.__dict__['x'].__get__(None, A)。\n超绑定\n类似 super(A, a).x 这样的带点号查找将在 a.__class__.__mro__ 中搜索紧接在 A 之后的基\n类 B 并返回 B.__dict__['x'].__get__(a, A)。 如果 x 不是描述器，则不加改变地返回它。\n对于实例绑定，发起描述器调用的优先级取决于定义了哪些描述器方法。 一个描述器可以定义\n__get__(), __set__() 和 __delete__() 的任意组合。 如果它没有定义 __get__()，则访问属性\n将返回描述器对象自身，除非对象的实例字典中有相应的属性值。 如果描述器定义了 __set__()\n和/或 __delete__()，则它是一个数据描述器；如果两者均未定义，则它是一个非数据描述器。 通\n常，数据描述器会同时定义 __get__() 和 __set__()，而非数据描述器则只有 __get__() 方法。\n定义了 __get__() 和 __set__() (和/或 __delete__()) 的数据描述器总是会重载实例字典中的定\n义。 与之相对地，非数据描述器则可被实例所重载。\nPython 方法（包括用 @staticmethod 和 @classmethod 装饰的方法）都是作为非数据描述器来实\n现的。 因而，实例可以重定义和重写方法。 这允许单个实例获得与相同类的其他实例不一样的行\n为。\nproperty() 函数是作为数据描述器来实现的。因此实例不能重载特性属性的行为。\n3.3.2.4. __slots__\n__slots__ 允许我们显式地声明数据成员（如特征属性）并禁止创建 __dict__ 和 __weakref__ (除非是\n在 __slots__ 中显式地声明或是在父类中可用。)\n相比使用 __dict__ 可以显著节省空间。 属性查找速度也可得到显著的提升。\nobject.__slots__\n这个类变量可赋值为字符串、可迭代对象或由实例使用的变量名组成的字符串序列。 __slots__\n会为已声明的变量保留空间并阻止自动为每个实例创建 __dict__ 和 __weakref__。 |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  | type(a).__dict__['x'].__get__(a, |  |\n|  |  |  |  |  |\n|  |  | type(a)) |  |  |\n|  |  |  |  |  |\n\n使用 __slots__ 的注意事项:\n当继承自一个没有 __slots__ 的类时，实例的 __dict__ 和 __weakref__ 属性将总是可访问的。\n没有 __dict__ 变量，实例就不能给未在 __slots__ 定义中列出的新变量赋值。 尝试给一个未列出\n的变量名赋值将引发 AttributeError。 如果需要动态地给新变量赋值，则要将 '__dict__' 加\n入到在 __slots__ 中声明的字符串序列中。\n如果未给每个实例设置 __weakref__ 变量，则定义了 __slots__ 的类就不支持对其实例的 弱引用。\n如果需要支持弱引用，则要将 '__weakref__' 加入到在 __slots__ 中声明的字符串序列中。\n__slots__ 是通过为每个变量名创建 描述器 在类层级上实现的。 因此，类属性不能被用来为通过\n__slots__ 定义的实例变量设置默认值；否则，类属性将会覆盖描述器赋值。\n__slots__ 声明的作用不只限于定义它的类。 在父类中声明的 __slots__ 在其子类中同样可用。 不\n过，子类的实例将会获得 __dict__ 和 __weakref__，除非子类也定义了 __slots__ (它应当只包含\n附加 槽位的名称）。\n如果一个类定义的位置在某个基类中也有定义，则由基类位置定义的实例变量将不可访问（除非\n通过直接从基类获取其描述器的方式）。这会使得程序的含义变成未定义。未来可能会添加一个\n防止此情况的检查。\n如果为派生自 \"variable-length\" 内置类型 如 int, bytes 和 tuple 的类定义了非空的\n*__slots__* 则将引发 TypeError。\n任何非字符串的 iterable 都可以被赋值给 __slots__。\n如果是使用一个 字典 来给 __slots__ 赋值，则该字典的键将被用作槽位名称。 字典的值可被用来\n为每个属性提供将被 inspect.getdoc() 识别并在and displayed in the output of help() 的输出\n中显示的文档字符串。\n__class__ 赋值仅在两个类具有相同的 __slots__ 时才会起作用。\n带有多槽位父类的 多重继承 也是可用的，但仅允许一个父类具有由槽位创建的属性（其他基类必\n须具有空的槽位布局） —— 违反此规则将引发 TypeError。\n如果将 iterator 用于 __slots__ 则会为该迭代器的每个值创建一个 descriptor。 但是，__slots__ 属\n性将为一个空迭代器。\n3.3.3. 自定义类创建\n当一个类继承另一个类时，会在这个父类上调用 __init_subclass__()。 这样，就使得编写改变子\n类行为的类成为可能。 这与类装饰器有很密切的关联，但类装饰器只能影响它们所应用的特定类，\n而 __init_subclass__ 则只作用于定义了该方法的类在未来的子类。\nclassmethod object.__init_subclass__(cls)\n当所在类派生子类时此方法就会被调用。cls 将指向新的子类。如果定义为一个普通实例方法，\n此方法将被隐式地转换为类方法。\n传给一个新类的关键字参数会被传给上级类的 __init_subclass__。 为了与其他使用\n__init_subclass__ 的类兼容，应当去掉需要的关键字参数再将其他参数传给基类，例如:\nclass Philosopher:\ndef __init_subclass__(cls, /, default_name, **kwargs):\nsuper().__init_subclass__(**kwargs)\ncls.default_name = default_name\n\n|  | 使用 __slots__ 的注意事项:\n当继承自一个没有 __slots__ 的类时，实例的 __dict__ 和 __weakref__ 属性将总是可访问的。\n没有 __dict__ 变量，实例就不能给未在 __slots__ 定义中列出的新变量赋值。 尝试给一个未列出\n的变量名赋值将引发 AttributeError。 如果需要动态地给新变量赋值，则要将 '__dict__' 加\n入到在 __slots__ 中声明的字符串序列中。\n如果未给每个实例设置 __weakref__ 变量，则定义了 __slots__ 的类就不支持对其实例的 弱引用。\n如果需要支持弱引用，则要将 '__weakref__' 加入到在 __slots__ 中声明的字符串序列中。\n__slots__ 是通过为每个变量名创建 描述器 在类层级上实现的。 因此，类属性不能被用来为通过\n__slots__ 定义的实例变量设置默认值；否则，类属性将会覆盖描述器赋值。\n__slots__ 声明的作用不只限于定义它的类。 在父类中声明的 __slots__ 在其子类中同样可用。 不\n过，子类的实例将会获得 __dict__ 和 __weakref__，除非子类也定义了 __slots__ (它应当只包含\n附加 槽位的名称）。\n如果一个类定义的位置在某个基类中也有定义，则由基类位置定义的实例变量将不可访问（除非\n通过直接从基类获取其描述器的方式）。这会使得程序的含义变成未定义。未来可能会添加一个\n防止此情况的检查。\n如果为派生自 \"variable-length\" 内置类型 如 int, bytes 和 tuple 的类定义了非空的\n*__slots__* 则将引发 TypeError。\n任何非字符串的 iterable 都可以被赋值给 __slots__。\n如果是使用一个 字典 来给 __slots__ 赋值，则该字典的键将被用作槽位名称。 字典的值可被用来\n为每个属性提供将被 inspect.getdoc() 识别并在and displayed in the output of help() 的输出\n中显示的文档字符串。\n__class__ 赋值仅在两个类具有相同的 __slots__ 时才会起作用。\n带有多槽位父类的 多重继承 也是可用的，但仅允许一个父类具有由槽位创建的属性（其他基类必\n须具有空的槽位布局） —— 违反此规则将引发 TypeError。\n如果将 iterator 用于 __slots__ 则会为该迭代器的每个值创建一个 descriptor。 但是，__slots__ 属\n性将为一个空迭代器。\n3.3.3. 自定义类创建\n当一个类继承另一个类时，会在这个父类上调用 __init_subclass__()。 这样，就使得编写改变子\n类行为的类成为可能。 这与类装饰器有很密切的关联，但类装饰器只能影响它们所应用的特定类，\n而 __init_subclass__ 则只作用于定义了该方法的类在未来的子类。\nclassmethod object.__init_subclass__(cls)\n当所在类派生子类时此方法就会被调用。cls 将指向新的子类。如果定义为一个普通实例方法，\n此方法将被隐式地转换为类方法。\n传给一个新类的关键字参数会被传给上级类的 __init_subclass__。 为了与其他使用\n__init_subclass__ 的类兼容，应当去掉需要的关键字参数再将其他参数传给基类，例如:\nclass Philosopher:\ndef __init_subclass__(cls, /, default_name, **kwargs):\nsuper().__init_subclass__(**kwargs)\ncls.default_name = default_name |  |  |\n| --- | --- | --- | --- |\n|  |  | class Philosopher:\ndef __init_subclass__(cls, /, default_name, **kwargs):\nsuper().__init_subclass__(**kwargs)\ncls.default_name = default_name |  |\n\nclass AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\npass\nobject.__init_subclass__ 的默认实现什么都不做，只在带任意参数调用时引发一个错误。\n备注: 元类提示 metaclass 将被其它类型机制消耗掉，并不会被传给 __init_subclass__\n的实现。实际的元类（而非显式的提示）可通过 type(cls) 访问。\nAdded in version 3.6.\n当一个类被创建时，type.__new__() 会扫描类变量并对其中带有 __set_name__() 钩子的对象执\n行回调。\nobject.__set_name__(self, owner, name)\n在所有者类 owner 被创建时自动调用。 此对象已被赋值给该类中的 name:\nclass A:\nx = C() # 自动调用: x.__set_name__(A, 'x')\n如果类变量赋值是在类被创建之后进行的，__set_name__() 将不会被自动调用。 如有必要，\n可以直接调用 __set_name__():\nclass A:\npass\nc = C()\nA.x = c # 钩子未被调用\nc.__set_name__(A, 'x') # 手动唤起钩子\n详情参见 创建类对象。\nAdded in version 3.6.\n3.3.3.1. 元类\n默认情况下，类是使用 type() 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定\n到 type(name, bases, namespace) 的结果。\n类创建过程可通过在定义行传入 metaclass 关键字参数，或是通过继承一个包含此参数的现有类来\n进行定制。在以下示例中，MyClass 和 MySubclass 都是 Meta 的实例:\nclass Meta(type):\npass\nclass MyClass(metaclass=Meta):\npass\nclass MySubclass(MyClass):\npass\n\n|  | class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\npass\nobject.__init_subclass__ 的默认实现什么都不做，只在带任意参数调用时引发一个错误。\n备注: 元类提示 metaclass 将被其它类型机制消耗掉，并不会被传给 __init_subclass__\n的实现。实际的元类（而非显式的提示）可通过 type(cls) 访问。\nAdded in version 3.6.\n当一个类被创建时，type.__new__() 会扫描类变量并对其中带有 __set_name__() 钩子的对象执\n行回调。\nobject.__set_name__(self, owner, name)\n在所有者类 owner 被创建时自动调用。 此对象已被赋值给该类中的 name:\nclass A:\nx = C() # 自动调用: x.__set_name__(A, 'x')\n如果类变量赋值是在类被创建之后进行的，__set_name__() 将不会被自动调用。 如有必要，\n可以直接调用 __set_name__():\nclass A:\npass\nc = C()\nA.x = c # 钩子未被调用\nc.__set_name__(A, 'x') # 手动唤起钩子\n详情参见 创建类对象。\nAdded in version 3.6.\n3.3.3.1. 元类\n默认情况下，类是使用 type() 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定\n到 type(name, bases, namespace) 的结果。\n类创建过程可通过在定义行传入 metaclass 关键字参数，或是通过继承一个包含此参数的现有类来\n进行定制。在以下示例中，MyClass 和 MySubclass 都是 Meta 的实例: | class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\npass |  |\n| --- | --- | --- | --- |\n|  | class Meta(type):\npass\nclass MyClass(metaclass=Meta):\npass\nclass MySubclass(MyClass):\npass |  |  |\n|  |  |  |  |\n\n在类定义内指定的任何其他关键字参数都会在下面所描述的所有元类操作中进行传递。\n当一个类定义被执行时，将发生以下步骤:\n解析 MRO 条目；\n确定适当的元类；\n准备类命名空间；\n执行类主体；\n创建类对象。\n3.3.3.2. 解析 MRO 条目\nobject.__mro_entries__(self, bases)\n如果一个出现在类定义中的基类不是 type 的实例，则会在该基类中搜索 __mro_entries__()\n方法。 如果找到了 __mro_entries__() 方法，则在创建类时该基类会被替换为调用\n__mro_entries__() 的结果。 该方法被调用时将附带传给 bases 形参的原始基类元组，并且必\n须返回一个由将被用来替代该基类的类组成的元组。 返回的元组可能为空：在此情况下，原始\n基类将被忽略。\n参见:\ntypes.resolve_bases()\n动态地解析不属于 type 实例的基类。\ntypes.get_original_bases()\n在类被 __mro_entries__() 修改之前提取其“原始基类”。\nPEP 560\n对 typing 模块和泛用类型的核心支持。\n3.3.3.3. 确定适当的元类\n为一个类定义确定适当的元类是根据以下规则:\n如果没有基类且没有显式指定元类，则使用 type()；\n如果给出一个显式元类而且 不是 type() 的实例，则其会被直接用作元类；\n如果给出一个 type() 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。\n最近派生的元类会从显式指定的元类（如果有）以及所有指定的基类的元类（即 type(cls)）中选\n取。最近派生的元类应为 所有 这些候选元类的一个子类型。如果没有一个候选元类符合该条件，则\n类定义将失败并抛出 TypeError。\n3.3.3.4. 准备类命名空间\n一旦确定了适当的元类，就开始准备类的命名空间。 如果元类具有 __prepare__ 属性，它将以\nnamespace = metaclass.__prepare__(name, bases, **kwds) 的形式被调用（其中如果存在任\n何额外关键字参数，则应来自类定义）。 __prepare__ 方法应当被实现为 类方法。 __prepare__\n\n|  | 在类定义内指定的任何其他关键字参数都会在下面所描述的所有元类操作中进行传递。\n当一个类定义被执行时，将发生以下步骤:\n解析 MRO 条目；\n确定适当的元类；\n准备类命名空间；\n执行类主体；\n创建类对象。\n3.3.3.2. 解析 MRO 条目\nobject.__mro_entries__(self, bases)\n如果一个出现在类定义中的基类不是 type 的实例，则会在该基类中搜索 __mro_entries__()\n方法。 如果找到了 __mro_entries__() 方法，则在创建类时该基类会被替换为调用\n__mro_entries__() 的结果。 该方法被调用时将附带传给 bases 形参的原始基类元组，并且必\n须返回一个由将被用来替代该基类的类组成的元组。 返回的元组可能为空：在此情况下，原始\n基类将被忽略。 |  |\n| --- | --- | --- |\n|  | 参见:\ntypes.resolve_bases()\n动态地解析不属于 type 实例的基类。\ntypes.get_original_bases()\n在类被 __mro_entries__() 修改之前提取其“原始基类”。\nPEP 560\n对 typing 模块和泛用类型的核心支持。 |  |\n|  | 3.3.3.3. 确定适当的元类\n为一个类定义确定适当的元类是根据以下规则:\n如果没有基类且没有显式指定元类，则使用 type()；\n如果给出一个显式元类而且 不是 type() 的实例，则其会被直接用作元类；\n如果给出一个 type() 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。\n最近派生的元类会从显式指定的元类（如果有）以及所有指定的基类的元类（即 type(cls)）中选\n取。最近派生的元类应为 所有 这些候选元类的一个子类型。如果没有一个候选元类符合该条件，则\n类定义将失败并抛出 TypeError。\n3.3.3.4. 准备类命名空间\n一旦确定了适当的元类，就开始准备类的命名空间。 如果元类具有 __prepare__ 属性，它将以\nnamespace = metaclass.__prepare__(name, bases, **kwds) 的形式被调用（其中如果存在任\n何额外关键字参数，则应来自类定义）。 __prepare__ 方法应当被实现为 类方法。 __prepare__ |  |\n\n所返回的命名空间会被传入 __new__，但是当最终的类对象被创建时该命名空间会被拷贝到一个新\n的 dict 中。\n如果元类没有 __prepare__ 属性，则类命名空间将初始化为一个空的有序映射。\n参见:\nPEP 3115 - Python 3000 中的元类\n引入 __prepare__ 命名空间钩子\n3.3.3.5. 执行类主体\n类主体会以（类似于） exec(body, globals(), namespace) 的形式被执行。普通调用与 exec()\n的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当\n前和外部作用域的名称。\n但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义\n的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过下一节中描述的隐式词法\n作用域的 __class__ 引用。\n3.3.3.6. 创建类对象\n一旦执行类主体完成填充类命名空间，将通过调用 metaclass(name, bases, namespace,\n**kwds) 创建类对象（此处的附加关键字参数与传入 __prepare__ 的相同）。\n如果类主体中有任何方法引用了 __class__ 或 super，这个类对象会通过零参数形式的 super().\n__class__ 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 super() 能够正确\n标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第\n一个参数来标识的。\n在 CPython 3.6 及之后的版本中，__class__ 单元会作为类命名空间中的 __classcell__ 条目被传\n给元类。 如果存在，它必须被向上传播给 type.__new__ 调用，以便能正确地初始化该类。 如果不\n这样做，在 Python 3.8 中将引发 RuntimeError。\n当使用默认的元类 type，或者任何最终会调用 type.__new__ 的元类时，以下额外的自定义步骤将\n在创建类对象之后被唤起：\n1. type.__new__ 方法会收集类命名空间中所有定义了 __set_name__() 方法的属性;\n2. 这些 __set_name__ 方法将附带所定义的类和指定的属性所赋的名称进行调用;\n3. 在新类基于方法解析顺序所确定的直接父类上调用 __init_subclass__() 钩子。\n在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已\n定义的类绑定到局部命名空间。\n当通过 type.__new__ 创建新类时，作为命令空间形参提供的对象会被拷贝到一个新的有序映射并\n丢弃原始对象。 这个新拷贝包装在一个只读代理中，该代理会成为类对象的 __dict__ 属性。\n\n|  |  | 所返回的命名空间会被传入 __new__，但是当最终的类对象被创建时该命名空间会被拷贝到一个新\n的 dict 中。\n如果元类没有 __prepare__ 属性，则类命名空间将初始化为一个空的有序映射。 |  |\n| --- | --- | --- | --- |\n|  |  | 参见:\nPEP 3115 - Python 3000 中的元类\n引入 __prepare__ 命名空间钩子 |  |\n|  |  | 3.3.3.5. 执行类主体\n类主体会以（类似于） exec(body, globals(), namespace) 的形式被执行。普通调用与 exec()\n的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当\n前和外部作用域的名称。\n但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义\n的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过下一节中描述的隐式词法\n作用域的 __class__ 引用。\n3.3.3.6. 创建类对象\n一旦执行类主体完成填充类命名空间，将通过调用 metaclass(name, bases, namespace,\n**kwds) 创建类对象（此处的附加关键字参数与传入 __prepare__ 的相同）。\n如果类主体中有任何方法引用了 __class__ 或 super，这个类对象会通过零参数形式的 super().\n__class__ 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 super() 能够正确\n标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第\n一个参数来标识的。\n在 CPython 3.6 及之后的版本中，__class__ 单元会作为类命名空间中的 __classcell__ 条目被传\n给元类。 如果存在，它必须被向上传播给 type.__new__ 调用，以便能正确地初始化该类。 如果不\n这样做，在 Python 3.8 中将引发 RuntimeError。\n当使用默认的元类 type，或者任何最终会调用 type.__new__ 的元类时，以下额外的自定义步骤将\n在创建类对象之后被唤起：\n1. type.__new__ 方法会收集类命名空间中所有定义了 __set_name__() 方法的属性;\n2. 这些 __set_name__ 方法将附带所定义的类和指定的属性所赋的名称进行调用;\n3. 在新类基于方法解析顺序所确定的直接父类上调用 __init_subclass__() 钩子。\n在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已\n定义的类绑定到局部命名空间。\n当通过 type.__new__ 创建新类时，作为命令空间形参提供的对象会被拷贝到一个新的有序映射并\n丢弃原始对象。 这个新拷贝包装在一个只读代理中，该代理会成为类对象的 __dict__ 属性。 |  |\n|  |  | **kwds) |  |\n|  |  |  |  |\n\n参见:\nPEP 3135 - 新的超类型\n描述隐式的 __class__ 闭包引用\n3.3.3.7. 元类的作用\n元类的潜在作用非常广泛。已经过尝试的设想包括枚举、日志、接口检查、自动委托、自动特征属\n性创建、代理、框架以及自动资源锁定/同步等等。\n3.3.4. 自定义实例及子类检查\n以下方法被用来重载 isinstance() 和 issubclass() 内置函数的默认行为。\n特别地，元类 abc.ABCMeta 实现了这些方法以便允许将抽象基类（ABC）作为“虚拟基类”添加到任\n何类或类型（包括内置类型），包括其他 ABC 之中。\ntype.__instancecheck__(self, instance)\n如果 instance 应被视为 class 的一个（直接或间接）实例则返回真值。如果定义了此方法，则会\n被调用以实现 isinstance(instance, class)。\ntype.__subclasscheck__(self, subclass)\nReturn true 如果 subclass 应被视为 class 的一个（直接或间接）子类则返回真值。如果定义了\n此方法，则会被调用以实现 issubclass(subclass, class)。\n请注意这些方法的查找是基于类的类型（元类）。它们不能作为类方法在实际的类中被定义。这与\n基于实例被调用的特殊方法的查找是一致的，只有在此情况下实例本身被当作是类。\n参见:\nPEP 3119 - 引入抽象基类\n包括通过 __instancecheck__() 和 __subclasscheck__() 来定制 isinstance() 和\nissubclass() 行为的说明，加入此功能的动机是出于向语言添加抽象基类的场景（参见\nabc 模块）。\n3.3.5. 模拟泛型类型\n当使用 类型标注 时，使用 Python 的方括号标记来 形参化 一个 generic type 往往会很有用处。 例\n如，list[int] 这样的标注可以被用来表示一个 list 中的所有元素均为 int 类型。\n参见:\nPEP 484 —— 类型注解\n介绍 Python 中用于类型标注的框架\n泛用别名类型\n代表形参化泛用类的对象的文档\n\n|  | 参见:\nPEP 3135 - 新的超类型\n描述隐式的 __class__ 闭包引用 |  |\n| --- | --- | --- |\n|  | 3.3.3.7. 元类的作用\n元类的潜在作用非常广泛。已经过尝试的设想包括枚举、日志、接口检查、自动委托、自动特征属\n性创建、代理、框架以及自动资源锁定/同步等等。\n3.3.4. 自定义实例及子类检查\n以下方法被用来重载 isinstance() 和 issubclass() 内置函数的默认行为。\n特别地，元类 abc.ABCMeta 实现了这些方法以便允许将抽象基类（ABC）作为“虚拟基类”添加到任\n何类或类型（包括内置类型），包括其他 ABC 之中。\ntype.__instancecheck__(self, instance)\n如果 instance 应被视为 class 的一个（直接或间接）实例则返回真值。如果定义了此方法，则会\n被调用以实现 isinstance(instance, class)。\ntype.__subclasscheck__(self, subclass)\nReturn true 如果 subclass 应被视为 class 的一个（直接或间接）子类则返回真值。如果定义了\n此方法，则会被调用以实现 issubclass(subclass, class)。\n请注意这些方法的查找是基于类的类型（元类）。它们不能作为类方法在实际的类中被定义。这与\n基于实例被调用的特殊方法的查找是一致的，只有在此情况下实例本身被当作是类。 |  |\n|  | 参见:\nPEP 3119 - 引入抽象基类\n包括通过 __instancecheck__() 和 __subclasscheck__() 来定制 isinstance() 和\nissubclass() 行为的说明，加入此功能的动机是出于向语言添加抽象基类的场景（参见\nabc 模块）。 |  |\n|  | 3.3.5. 模拟泛型类型\n当使用 类型标注 时，使用 Python 的方括号标记来 形参化 一个 generic type 往往会很有用处。 例\n如，list[int] 这样的标注可以被用来表示一个 list 中的所有元素均为 int 类型。 |  |\n|  | 参见:\nPEP 484 —— 类型注解\n介绍 Python 中用于类型标注的框架\n泛用别名类型\n代表形参化泛用类的对象的文档 |  |\n\n泛型（Generic）, 用户自定义泛型 和 typing.Generic\n有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。\n一个类 通常 只有在定义了特殊的类方法 __class_getitem__() 时才能被形参化。\nclassmethod object.__class_getitem__(cls, key)\n按照 key 参数指定的类型返回一个表示泛型类的专门化对象。\n当在类上定义时，__class_getitem__() 会自动成为类方法。 因此，当它被定义时没有必要\n使用 @classmethod 来装饰。\n3.3.5.1. __class_getitem__ 的目的\n__class_getitem__() 的目的是允许标准库泛型类的运行时形参化以更方便地对这些类应用 类型提\n示。\n要实现可以在运行时被形参化并可被静态类型检查所理解的自定义泛型类，用户应当从已经实现了\n__class_getitem__() 的标准库类继承，或是从 typing.Generic 继承，这个类拥有自己的\n__class_getitem__() 实现。\n标准库以外的类上的 __class_getitem__() 自定义实现可能无法被第三方类型检查器如 mypy 所理\n解。 不建议在任何类上出于类型提示以外的目的使用 __class_getitem__()。\n3.3.5.2. __class_getitem__ 与 __getitem__\n通常，使用方括号语法 抽取 一个对象将会调用在该对象的类上定义的 __getitem__() 实例方法。\n不过，如果被拟抽取的对象本身是一个类，则可能会调用 __class_getitem__() 类方法。\n__class_getitem__() 如果被正确地定义，则应当返回一个 GenericAlias 对象。\n使用 表达式 obj[x] 来呈现，Python 解释器会遵循下面这样的过程来确定应当调用 __getitem__()\n还是 __class_getitem__():\nfrom inspect import isclass\ndef subscribe(obj, x):\n\"\"\"返回表达式 'obj[x]' 的结果\"\"\"\nclass_of_obj = type(obj)\n# 如果 obj 所属的类定义了 __getitem__，\n# 则调用 class_of_obj.__getitem__(obj, x)\nif hasattr(class_of_obj, '__getitem__'):\nreturn class_of_obj.__getitem__(obj, x)\n# 否则，如果 obj 是一个类并且定义了 __class_getitem__，\n# 则调用 obj.__class_getitem__(x)\nelif isclass(obj) and hasattr(obj, '__class_getitem__'):\nreturn obj.__class_getitem__(x)\n# 否则，引发一个异常\nelse:\n\n|  | 泛型（Generic）, 用户自定义泛型 和 typing.Generic\n有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。 |  |\n| --- | --- | --- |\n|  | 一个类 通常 只有在定义了特殊的类方法 __class_getitem__() 时才能被形参化。\nclassmethod object.__class_getitem__(cls, key)\n按照 key 参数指定的类型返回一个表示泛型类的专门化对象。\n当在类上定义时，__class_getitem__() 会自动成为类方法。 因此，当它被定义时没有必要\n使用 @classmethod 来装饰。\n3.3.5.1. __class_getitem__ 的目的\n__class_getitem__() 的目的是允许标准库泛型类的运行时形参化以更方便地对这些类应用 类型提\n示。\n要实现可以在运行时被形参化并可被静态类型检查所理解的自定义泛型类，用户应当从已经实现了\n__class_getitem__() 的标准库类继承，或是从 typing.Generic 继承，这个类拥有自己的\n__class_getitem__() 实现。\n标准库以外的类上的 __class_getitem__() 自定义实现可能无法被第三方类型检查器如 mypy 所理\n解。 不建议在任何类上出于类型提示以外的目的使用 __class_getitem__()。\n3.3.5.2. __class_getitem__ 与 __getitem__\n通常，使用方括号语法 抽取 一个对象将会调用在该对象的类上定义的 __getitem__() 实例方法。\n不过，如果被拟抽取的对象本身是一个类，则可能会调用 __class_getitem__() 类方法。\n__class_getitem__() 如果被正确地定义，则应当返回一个 GenericAlias 对象。\n使用 表达式 obj[x] 来呈现，Python 解释器会遵循下面这样的过程来确定应当调用 __getitem__()\n还是 __class_getitem__(): |  |\n|  | from inspect import isclass\ndef subscribe(obj, x):\n\"\"\"返回表达式 'obj[x]' 的结果\"\"\"\nclass_of_obj = type(obj)\n# 如果 obj 所属的类定义了 __getitem__，\n# 则调用 class_of_obj.__getitem__(obj, x)\nif hasattr(class_of_obj, '__getitem__'):\nreturn class_of_obj.__getitem__(obj, x)\n# 否则，如果 obj 是一个类并且定义了 __class_getitem__，\n# 则调用 obj.__class_getitem__(x)\nelif isclass(obj) and hasattr(obj, '__class_getitem__'):\nreturn obj.__class_getitem__(x)\n# 否则，引发一个异常\nelse: |  |\n\nraise TypeError(\nf\"'{class_of_obj.__name__}' object is not subscriptable\"\n)\n在 Python 中，所有的类自身也是其他类的实例。 一个类所属的类被称为该类的 metaclass，并且大\n多数类都将 type 类作为它们的元类。 type 没有定义 __getitem__()，这意味着 list[int],\ndict[str, float] 和 tuple[str, bytes] 这样的表达式都将导致 __class_getitem__() 被调用:\n>>> # list 以 \"type\" 类作为其元类，与大多数类一样：\n>>> type(list)\n<class 'type'>\n>>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\nTrue\n>>> # \"list[int]\" 将调用 \"list.__class_getitem__(int)\"\n>>> list[int]\nlist[int]\n>>> # list.__class_getitem__ 将返回一个 GenericAlias 对象：\n>>> type(list[int])\n<class 'types.GenericAlias'>\n然而，如果一个类属于定义了 __getitem__() 的自定义元类，则抽取该类可能导致不同的行为。\n这方面的一个例子可以在 enum 模块中找到:\n>>> from enum import Enum\n>>> class Menu(Enum):\n... \"\"\"A breakfast menu\"\"\"\n... SPAM = 'spam'\n... BACON = 'bacon'\n...\n>>> # 枚举类有一个自定义元类：\n>>> type(Menu)\n<class 'enum.EnumMeta'>\n>>> # EnumMeta 定义了 __getitem__，\n>>> # 因此 __class_getitem__ 不会被调用，\n>>> # 并且结果不是一个 GenericAlias 对象：\n>>> Menu['SPAM']\n<Menu.SPAM: 'spam'>\n>>> type(Menu['SPAM'])\n<enum 'Menu'>\n参见:\nPEP 560 - 对 typing 模块和泛型的核心支持\n介绍 __class_getitem__()，并指明 抽取 在何时会导致 __class_getitem__() 而不是\n__getitem__() 被调用\n3.3.6. 模拟可调用对象\nobject.__call__(self[, args...])\n此方法会在实例作为一个函数被“调用”时被调用；如果定义了此方法，则 x(arg1, arg2,\n...) 大致可以被转写为 type(x).__call__(x, arg1, ...)。 object 类本身没有提供此方\n法。\n\n|  |  | raise TypeError(\nf\"'{class_of_obj.__name__}' object is not subscriptable\"\n) |  |\n| --- | --- | --- | --- |\n|  |  | 在 Python 中，所有的类自身也是其他类的实例。 一个类所属的类被称为该类的 metaclass，并且大\n多数类都将 type 类作为它们的元类。 type 没有定义 __getitem__()，这意味着 list[int],\ndict[str, float] 和 tuple[str, bytes] 这样的表达式都将导致 __class_getitem__() 被调用: |  |\n|  |  | >>> # list 以 \"type\" 类作为其元类，与大多数类一样：\n>>> type(list)\n<class 'type'>\n>>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\nTrue\n>>> # \"list[int]\" 将调用 \"list.__class_getitem__(int)\"\n>>> list[int]\nlist[int]\n>>> # list.__class_getitem__ 将返回一个 GenericAlias 对象：\n>>> type(list[int])\n<class 'types.GenericAlias'> |  |\n|  |  | 然而，如果一个类属于定义了 __getitem__() 的自定义元类，则抽取该类可能导致不同的行为。\n这方面的一个例子可以在 enum 模块中找到: |  |\n|  |  | >>> from enum import Enum\n>>> class Menu(Enum):\n... \"\"\"A breakfast menu\"\"\"\n... SPAM = 'spam'\n... BACON = 'bacon'\n...\n>>> # 枚举类有一个自定义元类：\n>>> type(Menu)\n<class 'enum.EnumMeta'>\n>>> # EnumMeta 定义了 __getitem__，\n>>> # 因此 __class_getitem__ 不会被调用，\n>>> # 并且结果不是一个 GenericAlias 对象：\n>>> Menu['SPAM']\n<Menu.SPAM: 'spam'>\n>>> type(Menu['SPAM'])\n<enum 'Menu'> |  |\n|  |  |  |  |\n|  |  | 参见:\nPEP 560 - 对 typing 模块和泛型的核心支持\n介绍 __class_getitem__()，并指明 抽取 在何时会导致 __class_getitem__() 而不是\n__getitem__() 被调用 |  |\n|  |  | 3.3.6. 模拟可调用对象\nobject.__call__(self[, args...])\n此方法会在实例作为一个函数被“调用”时被调用；如果定义了此方法，则 x(arg1, arg2,\n...) 大致可以被转写为 type(x).__call__(x, arg1, ...)。 object 类本身没有提供此方\n法。 |  |\n|  |  | ...) |  |\n|  |  |  |  |\n\n3.3.7. 模拟容器类型\n以下方法可被定义以实现容器对象。这些方法均不由 object 类本身提供。容器通常是 序列 (如 列\n表 或 元组) 或 映射 (如 字典)，但也可表示其他容器类型。 第一组方法用于模拟序列或映射；区别\n在于对于序列，允许的键应为满足 0 <= k < N 的整数 k (其中 N 为序列长度) 或定义项目范围的\nslice 对象。 还建议映射提供以下方法：行为类似于 Python 标准 字典 对象的 keys()、\nvalues()、items()、get()、clear()、setdefault()、pop()、popitem()、copy() 和\nupdate()。collections.abc 模块提供了一个 MutableMapping abstract base class，用于基于一\n组基础方法 (__getitem__()、__setitem__()、__delitem__() 和 keys()) 帮助创建这些方法。\n可变序列应提供以下方法：append()、clear()、count()、extend()、index()、insert()、\npop()、remove() 和 reverse()，与 Python 标准 list 对象类似。最后，序列类型应通过定义以\n下方法实现加法（表示拼接）和乘法（表示重复）：__add__()、__radd__()、__iadd__()、\n__mul__()、__rmul__() 和 __imul__()；不应定义其他数值运算符。\n建议映射和序列都实现 __contains__() 方法以支持高效的 in 运算符使用：对于映射，in 应搜索\n映射的键；对于序列，则应搜索值。还建议映射和序列都实现 __iter__() 方法以支持对容器的高\n效迭代：对于映射，__iter__() 应迭代对象的键；对于序列，则应迭代值。\nobject.__len__(self)\n调用此方法以实现内置函数 len()。 应该返回对象的长度，以一个 >= 0 的整数表示。 此外，\n如果一个对象未定义 __bool__() 方法而其 __len__() 方法返回值为零则它在布尔运算中将被\n视为具有假值。\n在 CPython 中，要求长度最大只能为 sys.maxsize。 如果长度大于 sys.maxsize 则某些特性\n(如 len()) 可能会引发 OverflowError。 要防止真值测试引发 OverflowError，对象必须定\n义 __bool__() 方法。\nobject.__length_hint__(self)\n调用此方法以实现 operator.length_hint()。 应该返回对象长度的估计值（可能大于或小于\n实际长度）。 此长度应为一个 >= 0 的整数。 返回值也可以为 NotImplemented ，这会被视作\n与 __length_hint__ 方法完全不存在时一样处理。 此方法纯粹是为了优化性能，并不要求正\n确无误。\nAdded in version 3.4.\n备注: 切片是通过下述三个专门方法完成的。以下形式的调用\na[1:2] = b\n会为转写为\na[slice(1, 2, None)] = b\n其他形式以此类推。略去的切片项总是以 None 补全。\n\n|  | 3.3.7. 模拟容器类型\n以下方法可被定义以实现容器对象。这些方法均不由 object 类本身提供。容器通常是 序列 (如 列\n表 或 元组) 或 映射 (如 字典)，但也可表示其他容器类型。 第一组方法用于模拟序列或映射；区别\n在于对于序列，允许的键应为满足 0 <= k < N 的整数 k (其中 N 为序列长度) 或定义项目范围的\nslice 对象。 还建议映射提供以下方法：行为类似于 Python 标准 字典 对象的 keys()、\nvalues()、items()、get()、clear()、setdefault()、pop()、popitem()、copy() 和\nupdate()。collections.abc 模块提供了一个 MutableMapping abstract base class，用于基于一\n组基础方法 (__getitem__()、__setitem__()、__delitem__() 和 keys()) 帮助创建这些方法。\n可变序列应提供以下方法：append()、clear()、count()、extend()、index()、insert()、\npop()、remove() 和 reverse()，与 Python 标准 list 对象类似。最后，序列类型应通过定义以\n下方法实现加法（表示拼接）和乘法（表示重复）：__add__()、__radd__()、__iadd__()、\n__mul__()、__rmul__() 和 __imul__()；不应定义其他数值运算符。\n建议映射和序列都实现 __contains__() 方法以支持高效的 in 运算符使用：对于映射，in 应搜索\n映射的键；对于序列，则应搜索值。还建议映射和序列都实现 __iter__() 方法以支持对容器的高\n效迭代：对于映射，__iter__() 应迭代对象的键；对于序列，则应迭代值。\nobject.__len__(self)\n调用此方法以实现内置函数 len()。 应该返回对象的长度，以一个 >= 0 的整数表示。 此外，\n如果一个对象未定义 __bool__() 方法而其 __len__() 方法返回值为零则它在布尔运算中将被\n视为具有假值。\n在 CPython 中，要求长度最大只能为 sys.maxsize。 如果长度大于 sys.maxsize 则某些特性\n(如 len()) 可能会引发 OverflowError。 要防止真值测试引发 OverflowError，对象必须定\n义 __bool__() 方法。\nobject.__length_hint__(self)\n调用此方法以实现 operator.length_hint()。 应该返回对象长度的估计值（可能大于或小于\n实际长度）。 此长度应为一个 >= 0 的整数。 返回值也可以为 NotImplemented ，这会被视作\n与 __length_hint__ 方法完全不存在时一样处理。 此方法纯粹是为了优化性能，并不要求正\n确无误。\nAdded in version 3.4. |  |\n| --- | --- | --- |\n|  | 备注: 切片是通过下述三个专门方法完成的。以下形式的调用\na[1:2] = b\n会为转写为\na[slice(1, 2, None)] = b\n其他形式以此类推。略去的切片项总是以 None 补全。 |  |\n|  |  |  |\n\nobject.__getitem__(self, key)\n调用此方法以实现 self[key] 的求值。 对于 sequence 类型，接受的键应为整数。 作为可选\n项，它们也可能支持 slice 对象。 对负数索引的支持也是可选项。 如果 key 的类型不正确，\n则可能引发 TypeError。 如果 key 为序列索引集合范围以外的值（在进行任何负数索引的特殊\n解读之后），则应当引发 IndexError。 对于 mapping 类型，如果 key 找不到（不在容器\n中），则应当引发 KeyError。\n备注: for 循环在有不合法索引时会期待捕获 IndexError 以便正确地检测到序列的结束。\n备注: 当 抽取 一个 class 时，可能会调用特殊类方法 __class_getitem__() 而不是\n__getitem__()。 请参阅 __class_getitem__ 与 __getitem__ 了解详情。\nobject.__setitem__(self, key, value)\n调用此方法以实现向 self[key] 赋值。注意事项与 __getitem__() 相同。为对象实现此方法\n应该仅限于需要映射允许基于键修改值或添加键，或是序列允许元素被替换时。不正确的 key\n值所引发的异常应与 __getitem__() 方法的情况相同。\nobject.__delitem__(self, key)\n调用此方法以实现 self[key] 的删除。注意事项与 __getitem__() 相同。为对象实现此方法\n应该权限于需要映射允许移除键，或是序列允许移除元素时。不正确的 key 值所引发的异常应\n与 __getitem__() 方法的情况相同。\nobject.__missing__(self, key)\n此方法由 dict.__getitem__() 在找不到字典中的键时调用以实现 dict 子类的 self[key]。\nobject.__iter__(self)\n此方法会在需要为一个容器创建 iterator 时被调用。 此方法应当返回一个新的迭代器对象，它\n可以对容器中的所有对象执行迭代。 对于映射，它应当对窗口中的键执行迭代。\nobject.__reversed__(self)\n此方法（如果存在）会被 reversed() 内置函数调用以实现逆向迭代。它应当返回一个新的以\n逆序逐个迭代容器内所有对象的迭代器对象。\n如果未提供 __reversed__() 方法，则 reversed() 内置函数将回退到使用序列协议\n(__len__() 和 __getitem__())。支持序列协议的对象应当仅在能够提供比 reversed() 所提\n供的实现更高效的实现时才提供 __reversed__() 方法。\n成员检测运算符 (in 和 not in) 通常以对容器进行逐个迭代的方式来实现。 不过，容器对象可以提\n供以下特殊方法并采用更有效率的实现，这样也不要求对象必须为可迭代对象。\nobject.__contains__(self, item)\n调用此方法以实现成员检测运算符。如果 item 是 self 的成员则应返回真，否则返回假。对于映\n射类型，此检测应基于映射的键而不是值或者键值对。\n对于未定义 __contains__() 的对象，成员检测将首先尝试通过 __iter__() 进行迭代，然后\n再使用 __getitem__() 的旧式序列迭代协议，参看 语言参考中的相应部分。\n\n|  | object.__getitem__(self, key)\n调用此方法以实现 self[key] 的求值。 对于 sequence 类型，接受的键应为整数。 作为可选\n项，它们也可能支持 slice 对象。 对负数索引的支持也是可选项。 如果 key 的类型不正确，\n则可能引发 TypeError。 如果 key 为序列索引集合范围以外的值（在进行任何负数索引的特殊\n解读之后），则应当引发 IndexError。 对于 mapping 类型，如果 key 找不到（不在容器\n中），则应当引发 KeyError。\n备注: for 循环在有不合法索引时会期待捕获 IndexError 以便正确地检测到序列的结束。\n备注: 当 抽取 一个 class 时，可能会调用特殊类方法 __class_getitem__() 而不是\n__getitem__()。 请参阅 __class_getitem__ 与 __getitem__ 了解详情。\nobject.__setitem__(self, key, value)\n调用此方法以实现向 self[key] 赋值。注意事项与 __getitem__() 相同。为对象实现此方法\n应该仅限于需要映射允许基于键修改值或添加键，或是序列允许元素被替换时。不正确的 key\n值所引发的异常应与 __getitem__() 方法的情况相同。\nobject.__delitem__(self, key)\n调用此方法以实现 self[key] 的删除。注意事项与 __getitem__() 相同。为对象实现此方法\n应该权限于需要映射允许移除键，或是序列允许移除元素时。不正确的 key 值所引发的异常应\n与 __getitem__() 方法的情况相同。\nobject.__missing__(self, key)\n此方法由 dict.__getitem__() 在找不到字典中的键时调用以实现 dict 子类的 self[key]。\nobject.__iter__(self)\n此方法会在需要为一个容器创建 iterator 时被调用。 此方法应当返回一个新的迭代器对象，它\n可以对容器中的所有对象执行迭代。 对于映射，它应当对窗口中的键执行迭代。\nobject.__reversed__(self)\n此方法（如果存在）会被 reversed() 内置函数调用以实现逆向迭代。它应当返回一个新的以\n逆序逐个迭代容器内所有对象的迭代器对象。\n如果未提供 __reversed__() 方法，则 reversed() 内置函数将回退到使用序列协议\n(__len__() 和 __getitem__())。支持序列协议的对象应当仅在能够提供比 reversed() 所提\n供的实现更高效的实现时才提供 __reversed__() 方法。\n成员检测运算符 (in 和 not in) 通常以对容器进行逐个迭代的方式来实现。 不过，容器对象可以提\n供以下特殊方法并采用更有效率的实现，这样也不要求对象必须为可迭代对象。\nobject.__contains__(self, item)\n调用此方法以实现成员检测运算符。如果 item 是 self 的成员则应返回真，否则返回假。对于映\n射类型，此检测应基于映射的键而不是值或者键值对。\n对于未定义 __contains__() 的对象，成员检测将首先尝试通过 __iter__() 进行迭代，然后\n再使用 __getitem__() 的旧式序列迭代协议，参看 语言参考中的相应部分。 |  |\n| --- | --- | --- |\n\n3.3.8. 模拟数字类型\n定义以下方法即可模拟数字类型。特定种类的数字不支持的运算（例如非整数不能进行位运算）所\n对应的方法应当保持未定义状态。\nobject.__add__(self, other)\nobject.__sub__(self, other)\nobject.__mul__(self, other)\nobject.__matmul__(self, other)\nobject.__truediv__(self, other)\nobject.__floordiv__(self, other)\nobject.__mod__(self, other)\nobject.__divmod__(self, other)\nobject.__pow__(self, other[, modulo])\nobject.__lshift__(self, other)\nobject.__rshift__(self, other)\nobject.__and__(self, other)\nobject.__xor__(self, other)\nobject.__or__(self, other)\n调用这些方法来实现双目算术运算 (+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^,\n|)。 例如，求表达式 x + y 的值，其中 x 是具有 __add__() 方法的类的一个实例，则会调用\ntype(x).__add__(x, y)。 __divmod__() 方法应该等价于使用 __floordiv__() 和\n__mod__()；它不应该被关联到 __truediv__()。 注意，如果要支持内置 pow() 函数的三个\n参数版本， __pow__() 应该定义为接受可选的第三个参数。\n如果这些方法中的某一个不支持与所提供参数进行运算，它应该返回 NotImplemented 。\nobject.__radd__(self, other)\nobject.__rsub__(self, other)\nobject.__rmul__(self, other)\nobject.__rmatmul__(self, other)\nobject.__rtruediv__(self, other)\nobject.__rfloordiv__(self, other)\nobject.__rmod__(self, other)\nobject.__rdivmod__(self, other)\nobject.__rpow__(self, other[, modulo])\nobject.__rlshift__(self, other)\nobject.__rrshift__(self, other)\nobject.__rand__(self, other)\nobject.__rxor__(self, other)\nobject.__ror__(self, other)\n调用这些方法来实现具有反射（交换）操作数的双目算术运算 ( +, -, *, @, /, //, %, divmod(),\npow(), **, <<, >>, &, ^, |)。 只有当操作数的类型不同、左操作数不支持相应的操作 [3]，或者\n右操作数的类派生自左操作数的类时，才调用这些函数。 [4] 例如，求表达式 x - y 的值，其\n中 y 是具有 __rsub__() 方法的类的一个实例，则当 type(x).__sub__(x, y) 返回\nNotImplemented 或``type(y)``是``type(x)``的子类时调用 type(y).__rsub__(y, x)。[5]\n\n|  | 3.3.8. 模拟数字类型\n定义以下方法即可模拟数字类型。特定种类的数字不支持的运算（例如非整数不能进行位运算）所\n对应的方法应当保持未定义状态。\nobject.__add__(self, other)\nobject.__sub__(self, other)\nobject.__mul__(self, other)\nobject.__matmul__(self, other)\nobject.__truediv__(self, other)\nobject.__floordiv__(self, other)\nobject.__mod__(self, other)\nobject.__divmod__(self, other)\nobject.__pow__(self, other[, modulo])\nobject.__lshift__(self, other)\nobject.__rshift__(self, other)\nobject.__and__(self, other)\nobject.__xor__(self, other)\nobject.__or__(self, other)\n调用这些方法来实现双目算术运算 (+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^,\n|)。 例如，求表达式 x + y 的值，其中 x 是具有 __add__() 方法的类的一个实例，则会调用\ntype(x).__add__(x, y)。 __divmod__() 方法应该等价于使用 __floordiv__() 和\n__mod__()；它不应该被关联到 __truediv__()。 注意，如果要支持内置 pow() 函数的三个\n参数版本， __pow__() 应该定义为接受可选的第三个参数。\n如果这些方法中的某一个不支持与所提供参数进行运算，它应该返回 NotImplemented 。\nobject.__radd__(self, other)\nobject.__rsub__(self, other)\nobject.__rmul__(self, other)\nobject.__rmatmul__(self, other)\nobject.__rtruediv__(self, other)\nobject.__rfloordiv__(self, other)\nobject.__rmod__(self, other)\nobject.__rdivmod__(self, other)\nobject.__rpow__(self, other[, modulo])\nobject.__rlshift__(self, other)\nobject.__rrshift__(self, other)\nobject.__rand__(self, other)\nobject.__rxor__(self, other)\nobject.__ror__(self, other)\n调用这些方法来实现具有反射（交换）操作数的双目算术运算 ( +, -, *, @, /, //, %, divmod(),\npow(), **, <<, >>, &, ^, |)。 只有当操作数的类型不同、左操作数不支持相应的操作 [3]，或者\n右操作数的类派生自左操作数的类时，才调用这些函数。 [4] 例如，求表达式 x - y 的值，其\n中 y 是具有 __rsub__() 方法的类的一个实例，则当 type(x).__sub__(x, y) 返回\nNotImplemented 或``type(y)``是``type(x)``的子类时调用 type(y).__rsub__(y, x)。[5] |  |\n| --- | --- | --- |\n\n请注意应当定义 __rpow__() 以在需要支持内置 pow() 函数的三参数版本时接受可选的第三个\n参数。\n在 3.14 版本发生变更: 三参数的 pow() 现在会在必要时尝试调用 __rpow__()。 在之前\n版本中它只会在二参数的 pow() 和二元幂运算符中被调用。\n备注: 如果右操作数类型为左操作数类型的一个子类，且该子类提供了指定运算的反射方\n法，则此方法将先于左操作数的非反射方法被调用。 此行为可允许子类重载其祖先类的运算\n符。\nobject.__iadd__(self, other)\nobject.__isub__(self, other)\nobject.__imul__(self, other)\nobject.__imatmul__(self, other)\nobject.__itruediv__(self, other)\nobject.__ifloordiv__(self, other)\nobject.__imod__(self, other)\nobject.__ipow__(self, other[, modulo])\nobject.__ilshift__(self, other)\nobject.__irshift__(self, other)\nobject.__iand__(self, other)\nobject.__ixor__(self, other)\nobject.__ior__(self, other)\n调用这些方法来实现增强算术赋值 (+=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=)。\n这些方法应当尝试原地执行操作 (对 self 进行修改) 并返回结果 (结果可以为 self 但这并非必\n须)。 如果某个方法未被定义，或者如果该方法返回 NotImplemented，则相应的增强赋值将回\n退到普通方法。 举例来说，如果 x 是一个具有 __iadd__() 方法的类的实例，则 x += y 就等\n价于 x = x.__iadd__(y)。 如果 __iadd__() 不存在，或者如果 x.__iadd__(y) 返回\nNotImplemented，则将使用 x.__add__(y) 和 y.__radd__(x)，如同对 x + y 求值一样。 在\n某些情况下，增强赋值可能导致未预期的错误 (参见 为什么 a_tuple[i] += ['item'] 会引发异\n常？)，但此行为实际上是数据模型的一部分。\nobject.__neg__(self)\nobject.__pos__(self)\nobject.__abs__(self)\nobject.__invert__(self)\n调用此方法以实现一元算术运算 (-, +, abs() 和 ~)。\nobject.__complex__(self)\nobject.__int__(self)\nobject.__float__(self)\n调用这些方法以实现内置函数 complex(), int() 和 float()。应当返回一个相应类型的值。\nobject.__index__(self)\n调用此方法以实现 operator.index() 以及 Python 需要无损地将数字对象转换为整数对象的\n场合（例如切片或是内置的 bin(), hex() 和 oct() 函数)。 存在此方法表明数字对象属于整数\n类型。 必须返回一个整数。\n\n|  | 请注意应当定义 __rpow__() 以在需要支持内置 pow() 函数的三参数版本时接受可选的第三个\n参数。\n在 3.14 版本发生变更: 三参数的 pow() 现在会在必要时尝试调用 __rpow__()。 在之前\n版本中它只会在二参数的 pow() 和二元幂运算符中被调用。\n备注: 如果右操作数类型为左操作数类型的一个子类，且该子类提供了指定运算的反射方\n法，则此方法将先于左操作数的非反射方法被调用。 此行为可允许子类重载其祖先类的运算\n符。\nobject.__iadd__(self, other)\nobject.__isub__(self, other)\nobject.__imul__(self, other)\nobject.__imatmul__(self, other)\nobject.__itruediv__(self, other)\nobject.__ifloordiv__(self, other)\nobject.__imod__(self, other)\nobject.__ipow__(self, other[, modulo])\nobject.__ilshift__(self, other)\nobject.__irshift__(self, other)\nobject.__iand__(self, other)\nobject.__ixor__(self, other)\nobject.__ior__(self, other)\n调用这些方法来实现增强算术赋值 (+=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=)。\n这些方法应当尝试原地执行操作 (对 self 进行修改) 并返回结果 (结果可以为 self 但这并非必\n须)。 如果某个方法未被定义，或者如果该方法返回 NotImplemented，则相应的增强赋值将回\n退到普通方法。 举例来说，如果 x 是一个具有 __iadd__() 方法的类的实例，则 x += y 就等\n价于 x = x.__iadd__(y)。 如果 __iadd__() 不存在，或者如果 x.__iadd__(y) 返回\nNotImplemented，则将使用 x.__add__(y) 和 y.__radd__(x)，如同对 x + y 求值一样。 在\n某些情况下，增强赋值可能导致未预期的错误 (参见 为什么 a_tuple[i] += ['item'] 会引发异\n常？)，但此行为实际上是数据模型的一部分。\nobject.__neg__(self)\nobject.__pos__(self)\nobject.__abs__(self)\nobject.__invert__(self)\n调用此方法以实现一元算术运算 (-, +, abs() 和 ~)。\nobject.__complex__(self)\nobject.__int__(self)\nobject.__float__(self)\n调用这些方法以实现内置函数 complex(), int() 和 float()。应当返回一个相应类型的值。\nobject.__index__(self)\n调用此方法以实现 operator.index() 以及 Python 需要无损地将数字对象转换为整数对象的\n场合（例如切片或是内置的 bin(), hex() 和 oct() 函数)。 存在此方法表明数字对象属于整数\n类型。 必须返回一个整数。 |  |\n| --- | --- | --- |\n\n如果未定义 __int__(), __float__() 和 __complex__() 则相应的内置函数 int(), float()\n和 complex() 将回退为 __index__()。\nobject.__round__(self[, ndigits])\nobject.__trunc__(self)\nobject.__floor__(self)\nobject.__ceil__(self)\n调用这些方法以实现内置函数 round() 以及 math 函数 trunc(), floor() 和 ceil()。 除了\n将 ndigits 传给 __round__() 的情况之外这些方法的返回值都应当是原对象截断为 Integral\n(通常为 int)。\n在 3.14 版本发生变更: int() 不再委托 __trunc__() 方法\n3.3.9. with 语句上下文管理器\n上下文管理器 是一个对象，它定义了在执行 with 语句时要建立的运行时上下文。 上下文管理器处\n理进入和退出所需运行时上下文以执行代码块。 通常使用 with 语句（在 with 语句 中描述），但是\n也可以通过直接调用它们的方法来使用。\n上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。\n有关上下文管理器的更多信息，请参阅 上下文管理器类型。 object 类本身不提供上下文管理器方\n法。\nobject.__enter__(self)\n进入与此对象相关的运行时上下文。 with 语句将会绑定这个方法的返回值到 as 子句中指定的\n目标，如果有的话。\nobject.__exit__(self, exc_type, exc_value, traceback)\n退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无\n异常地退出的，三个参数都将为 None。\n如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的\n话，异常将在退出此方法时按正常流程处理。\n请注意 __exit__() 方法不应该重新引发被传入的异常，这是调用者的责任。\n参见:\nPEP 343 - \"with\" 语句\nPython with 语句的规范描述、背景和示例。\n3.3.10. 定制类模式匹配中的位置参数\n当在模式中使用类名称时，默认不允许模式中出现位置参数，例如在 MyClass 没有特别支持的情况\n下 case MyClass(x, y) 通常是无效的。 要能使用这样的模式，类必须定义一个 __match_args__ 属\n性。\n\n|  | 如果未定义 __int__(), __float__() 和 __complex__() 则相应的内置函数 int(), float()\n和 complex() 将回退为 __index__()。\nobject.__round__(self[, ndigits])\nobject.__trunc__(self)\nobject.__floor__(self)\nobject.__ceil__(self)\n调用这些方法以实现内置函数 round() 以及 math 函数 trunc(), floor() 和 ceil()。 除了\n将 ndigits 传给 __round__() 的情况之外这些方法的返回值都应当是原对象截断为 Integral\n(通常为 int)。\n在 3.14 版本发生变更: int() 不再委托 __trunc__() 方法\n3.3.9. with 语句上下文管理器\n上下文管理器 是一个对象，它定义了在执行 with 语句时要建立的运行时上下文。 上下文管理器处\n理进入和退出所需运行时上下文以执行代码块。 通常使用 with 语句（在 with 语句 中描述），但是\n也可以通过直接调用它们的方法来使用。\n上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。\n有关上下文管理器的更多信息，请参阅 上下文管理器类型。 object 类本身不提供上下文管理器方\n法。\nobject.__enter__(self)\n进入与此对象相关的运行时上下文。 with 语句将会绑定这个方法的返回值到 as 子句中指定的\n目标，如果有的话。\nobject.__exit__(self, exc_type, exc_value, traceback)\n退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无\n异常地退出的，三个参数都将为 None。\n如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的\n话，异常将在退出此方法时按正常流程处理。\n请注意 __exit__() 方法不应该重新引发被传入的异常，这是调用者的责任。 |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 343 - \"with\" 语句\nPython with 语句的规范描述、背景和示例。 |  |\n|  | 3.3.10. 定制类模式匹配中的位置参数\n当在模式中使用类名称时，默认不允许模式中出现位置参数，例如在 MyClass 没有特别支持的情况\n下 case MyClass(x, y) 通常是无效的。 要能使用这样的模式，类必须定义一个 __match_args__ 属\n性。 |  |\n\nobject.__match_args__\n该类变量可以被赋值为一个字符串元组。 当该类被用于带位置参数的类模式时，每个位置参数\n都将被转换为关键字参数，并使用 __match_args__ 中的对应值作为关键字。 缺失此属性就等价\n于将其设为 ()。\n举例来说，如果 MyClass.__match_args__ 为 (\"left\", \"center\", \"right\") 则意味着 case\nMyClass(x, y) 就等价于 case MyClass(left=x, center=y)。 请注意模式中参数的数量必须小于\n等于 __match_args__ 中元素的数量；如果前者大于后者，则尝试模式匹配时将引发 TypeError。\nAdded in version 3.10.\n参见:\nPEP 634 - 结构化模式匹配\n有关 Python match 语句的规范说明。\n3.3.11. 模拟缓冲区类型\n缓冲区协议 为 Python 对象提供了一种向低层级内存数组暴露高效访问的方式。 该协议是通过内置\n类型如 bytes 和 memoryview 实现的，还可能由第三方库定义额外的缓冲区类型。\n虽然缓冲区类型通常都是用 C 实现的，但用 Python 来实现该协议也是可能的。\nobject.__buffer__(self, flags)\n当从 self 请求一个缓冲区时将被调用（例如，从 memoryview 构造器）。 flags 参数是代表所请\n求缓冲区的类别的整数，例如这会影响返回的缓冲区是只读还是可写。 inspect.BufferFlags\n提供了解读旗标的便利方式。 此方法必须返回一个 memoryview 对象。\nobject.__release_buffer__(self, buffer)\n当一个缓冲区不再需要时将被调用。 buffer 参数是在此之前由 __buffer__() 返回的\nmemoryview 对象。 此方法必须释放任何关联到该缓冲区的资源。 此方法应当返回 None。 不\n需要执行任何清理的缓冲区对象不要求实现此方法。\nAdded in version 3.12.\n参见:\nPEP 688 - 使缓冲区协议在 Python 中可访问\n引入 Python __buffer__ 和 __release_buffer__ 方法。\ncollections.abc.Buffer\n缓冲区类型的 ABC。\n3.3.12. 标注\n函数、类和模块可能包含 注解，这是一种将信息（通常是 类型注解）与符号关联起来的方法。\nobject.__annotations__\n\n|  |  | object.__match_args__\n该类变量可以被赋值为一个字符串元组。 当该类被用于带位置参数的类模式时，每个位置参数\n都将被转换为关键字参数，并使用 __match_args__ 中的对应值作为关键字。 缺失此属性就等价\n于将其设为 ()。\n举例来说，如果 MyClass.__match_args__ 为 (\"left\", \"center\", \"right\") 则意味着 case\nMyClass(x, y) 就等价于 case MyClass(left=x, center=y)。 请注意模式中参数的数量必须小于\n等于 __match_args__ 中元素的数量；如果前者大于后者，则尝试模式匹配时将引发 TypeError。\nAdded in version 3.10. |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | case |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  | 参见:\nPEP 634 - 结构化模式匹配\n有关 Python match 语句的规范说明。 |  |  |  |\n|  |  | 3.3.11. 模拟缓冲区类型\n缓冲区协议 为 Python 对象提供了一种向低层级内存数组暴露高效访问的方式。 该协议是通过内置\n类型如 bytes 和 memoryview 实现的，还可能由第三方库定义额外的缓冲区类型。\n虽然缓冲区类型通常都是用 C 实现的，但用 Python 来实现该协议也是可能的。\nobject.__buffer__(self, flags)\n当从 self 请求一个缓冲区时将被调用（例如，从 memoryview 构造器）。 flags 参数是代表所请\n求缓冲区的类别的整数，例如这会影响返回的缓冲区是只读还是可写。 inspect.BufferFlags\n提供了解读旗标的便利方式。 此方法必须返回一个 memoryview 对象。\nobject.__release_buffer__(self, buffer)\n当一个缓冲区不再需要时将被调用。 buffer 参数是在此之前由 __buffer__() 返回的\nmemoryview 对象。 此方法必须释放任何关联到该缓冲区的资源。 此方法应当返回 None。 不\n需要执行任何清理的缓冲区对象不要求实现此方法。\nAdded in version 3.12. |  |  |  |\n|  |  | 参见:\nPEP 688 - 使缓冲区协议在 Python 中可访问\n引入 Python __buffer__ 和 __release_buffer__ 方法。\ncollections.abc.Buffer\n缓冲区类型的 ABC。 |  |  |  |\n|  |  | 3.3.12. 标注\n函数、类和模块可能包含 注解，这是一种将信息（通常是 类型注解）与符号关联起来的方法。\nobject.__annotations__ |  |  |  |\n\n此属性包含对象的注解。它是 惰性求值，因此访问该属性可能会执行任意代码并引发异常。如\n果求值成功，则将属性设置为从变量名到注解的字典映射。\n在 3.14 版本发生变更: 标注现在将被惰性求值。\nobject.__annotate__(format)\n一个 annotate function。 将返回一个将属性/形参名称映射到其标注值的新字典对象。\n接受一个格式形参，该参数指定应以何种格式提供注解值。 它必须是 annotationlib.Format\n枚举的成员，或者是一个值对应于枚举成员的整数。\n如果注解函数不支持请求的格式，它必须引发 NotImplementedError。 注解函数必须始终支\n持 VALUE 格式；当以这种格式调用时，它们不能引发 NotImplementedError()。\n当以 VALUE 格式调用时，注解函数可能引发 NameError；当调用请求任何其他格式时，它不得\n引发 NameError。\n如果一个对象没有任何注解，__annotate__ 最好设置为 None (不能删除)，而不是设置为返回\n空字典的函数。\nAdded in version 3.14.\n参见:\nPEP 649 --- 使用描述器进行延迟标注求值\n引入标注的惰性求值以及 __annotate__ 函数。\n3.3.13. 特殊方法查找\n对于自定义类来说，特殊方法的隐式唤起仅保证在其定义于对象类型中时能正确地发挥作用，而不\n能定义在对象实例字典中。 该行为就是以下代码会引发异常的原因。:\n>>> class C:\n... pass\n...\n>>> c = C()\n>>> c.__len__ = lambda: 5\n>>> len(c)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: object of type 'C' has no len()\n此行为背后的原理在于包括类型对象在内的所有对象都会实现的几个特殊方法如 __hash__() 和\n__repr__()。 如果这些方法的隐式查找使用了传统的查找过程，则当它们在针对类型对象自身被唤\n起时将会失败:\n>>> 1 .__hash__() == hash(1)\nTrue\n>>> int.__hash__() == hash(int)\nTraceback (most recent call last):\n\n|  | 此属性包含对象的注解。它是 惰性求值，因此访问该属性可能会执行任意代码并引发异常。如\n果求值成功，则将属性设置为从变量名到注解的字典映射。\n在 3.14 版本发生变更: 标注现在将被惰性求值。\nobject.__annotate__(format)\n一个 annotate function。 将返回一个将属性/形参名称映射到其标注值的新字典对象。\n接受一个格式形参，该参数指定应以何种格式提供注解值。 它必须是 annotationlib.Format\n枚举的成员，或者是一个值对应于枚举成员的整数。\n如果注解函数不支持请求的格式，它必须引发 NotImplementedError。 注解函数必须始终支\n持 VALUE 格式；当以这种格式调用时，它们不能引发 NotImplementedError()。\n当以 VALUE 格式调用时，注解函数可能引发 NameError；当调用请求任何其他格式时，它不得\n引发 NameError。\n如果一个对象没有任何注解，__annotate__ 最好设置为 None (不能删除)，而不是设置为返回\n空字典的函数。\nAdded in version 3.14. |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 649 --- 使用描述器进行延迟标注求值\n引入标注的惰性求值以及 __annotate__ 函数。 |  |\n|  | 3.3.13. 特殊方法查找\n对于自定义类来说，特殊方法的隐式唤起仅保证在其定义于对象类型中时能正确地发挥作用，而不\n能定义在对象实例字典中。 该行为就是以下代码会引发异常的原因。: |  |\n|  | >>> class C:\n... pass\n...\n>>> c = C()\n>>> c.__len__ = lambda: 5\n>>> len(c)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: object of type 'C' has no len() |  |\n|  | 此行为背后的原理在于包括类型对象在内的所有对象都会实现的几个特殊方法如 __hash__() 和\n__repr__()。 如果这些方法的隐式查找使用了传统的查找过程，则当它们在针对类型对象自身被唤\n起时将会失败: |  |\n|  | >>> 1 .__hash__() == hash(1)\nTrue\n>>> int.__hash__() == hash(int)\nTraceback (most recent call last): |  |\n\nFile \"<stdin>\", line 1, in <module>\nTypeError: descriptor '__hash__' of 'int' object needs an argument\n以这种方式不正确地尝试唤起一个类的未绑定方法有时被称为‘元类混淆’，可以通过在查找特殊方法\n时绕过实例的方式来避免:\n>>> type(1).__hash__(1) == hash(1)\nTrue\n>>> type(int).__hash__(int) == hash(int)\nTrue\n除了出于正确性考虑而会绕过任何实例属性，隐式特殊方法查找通常还会绕过\n__getattribute__() 方法，甚至包括对象的元类:\n>>> class Meta(type):\n... def __getattribute__(*args):\n... print(\"Metaclass getattribute invoked\")\n... return type.__getattribute__(*args)\n...\n>>> class C(object, metaclass=Meta):\n... def __len__(self):\n... return 10\n... def __getattribute__(*args):\n... print(\"Class getattribute invoked\")\n... return object.__getattribute__(*args)\n...\n>>> c = C()\n>>> c.__len__() # 通过实例的显式查找\nClass getattribute invoked\n10\n>>> type(c).__len__(c) # 通过类型的显式查找\nMetaclass getattribute invoked\n10\n>>> len(c) # 隐式查找\n10\n以这种方式绕过 __getattribute__() 机制为解释器内部的速度优化提供了显著的空间，其代价则\n是牺牲了一些处理特殊方法时的灵活性（特殊方法 must 必须设置在类对象自身上以便始终一致地由\n解释器唤起）。\n3.4. 协程\n3.4.1. 可等待对象\nawaitable 对象主要实现了 __await__() 方法。 从 async def 函数返回的 协程对象 即为可等待对\n象。\n备注: 从带有 types.coroutine() 装饰器的生成器返回的 generator iterator 对象也属于可等待\n对象，但它们并未实现 __await__()。\nobject.__await__(self)\n\n|  | File \"<stdin>\", line 1, in <module>\nTypeError: descriptor '__hash__' of 'int' object needs an argument |  |\n| --- | --- | --- |\n|  | 以这种方式不正确地尝试唤起一个类的未绑定方法有时被称为‘元类混淆’，可以通过在查找特殊方法\n时绕过实例的方式来避免: |  |\n|  | >>> type(1).__hash__(1) == hash(1)\nTrue\n>>> type(int).__hash__(int) == hash(int)\nTrue |  |\n|  | 除了出于正确性考虑而会绕过任何实例属性，隐式特殊方法查找通常还会绕过\n__getattribute__() 方法，甚至包括对象的元类: |  |\n|  | >>> class Meta(type):\n... def __getattribute__(*args):\n... print(\"Metaclass getattribute invoked\")\n... return type.__getattribute__(*args)\n...\n>>> class C(object, metaclass=Meta):\n... def __len__(self):\n... return 10\n... def __getattribute__(*args):\n... print(\"Class getattribute invoked\")\n... return object.__getattribute__(*args)\n...\n>>> c = C()\n>>> c.__len__() # 通过实例的显式查找\nClass getattribute invoked\n10\n>>> type(c).__len__(c) # 通过类型的显式查找\nMetaclass getattribute invoked\n10\n>>> len(c) # 隐式查找\n10 |  |\n|  | 以这种方式绕过 __getattribute__() 机制为解释器内部的速度优化提供了显著的空间，其代价则\n是牺牲了一些处理特殊方法时的灵活性（特殊方法 must 必须设置在类对象自身上以便始终一致地由\n解释器唤起）。\n3.4. 协程\n3.4.1. 可等待对象\nawaitable 对象主要实现了 __await__() 方法。 从 async def 函数返回的 协程对象 即为可等待对\n象。 |  |\n|  | 备注: 从带有 types.coroutine() 装饰器的生成器返回的 generator iterator 对象也属于可等待\n对象，但它们并未实现 __await__()。 |  |\n|  | object.__await__(self) |  |\n\n必须返回一个 iterator。 应当被用来实现 awaitable 对象。 例如，asyncio.Future 实现了此方\n法以与 await 表达式兼容。 object 类本身不是可等待对象因而不提供此方法。\n备注: 本语言不会对 __await__ 所返回的迭代器产生的对象的类型或值施加任何限制，因\n为这是负责管理 awaitable 对象的异步执行框架的具体实现 (如 asyncio) 专属特性。\nAdded in version 3.5.\n参见: PEP 492 了解有关可等待对象的详细信息。\n3.4.2. 协程对象\n协程对象 属于 awaitable 对象。 协程的执行可以通过调用 __await__() 并迭代其结果来控制。 当\n协程结束执行并返回时，迭代器会引发 StopIteration，而该异常的 value 属性将存放返回值。\n如果协程引发了异常，它会被迭代器传播出去。 协程不应当直接引发未被处理的 StopIteration\n异常。\n协程也具有下面列出的方法，它们类似于生成器的对应方法 (参见 生成器-迭代器的方法)。 但是，与\n生成器不同，协程并不直接支持迭代。\n在 3.5.2 版本发生变更: 等待一个协程超过一次将引发 RuntimeError。\ncoroutine.send(value)\n开始或恢复协程的执行。 如果 value 为 None，这将等价于前往 __await__() 所返回的迭代器\n的下一项。 如果 value 不为 None，此方法将委托给导致协挂起的迭代器的 send() 方法。 其\n结果（返回值, StopIteration 或是其他异常）将与上述对 __await__() 返回值进行迭代的结\n果相同。\ncoroutine.throw(value)\ncoroutine.throw(type[, value[, traceback]])\n在协程内引发指定的异常。 此方法将委托给导致该协程挂起的迭代器的 throw() 方法，如果存\n在此方法的话。 否则，该异常将在挂起点被引发。 其结果（返回值，StopIteration 或是其\n他异常）将与上述对 __await__() 返回值进行迭代的结果相同。 如果该异常未在协程内被捕\n获，则将回传给调用方。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\ncoroutine.close()\n此方法会使得协程清理自身并退出。 如果协程被挂起，此方法会先委托给导致协程挂起的迭代\n器的 close() 方法，如果存在该方法。 然后它会在挂起点引发 GeneratorExit，使得协程立\n即清理自身。 最后，协程会被标记为已结束执行，即使它根本未被启动。\n当协程对象将要被销毁时，会使用以上处理过程来自动关闭。\n3.4.3. 异步迭代器\n\n|  | 必须返回一个 iterator。 应当被用来实现 awaitable 对象。 例如，asyncio.Future 实现了此方\n法以与 await 表达式兼容。 object 类本身不是可等待对象因而不提供此方法。\n备注: 本语言不会对 __await__ 所返回的迭代器产生的对象的类型或值施加任何限制，因\n为这是负责管理 awaitable 对象的异步执行框架的具体实现 (如 asyncio) 专属特性。\nAdded in version 3.5. |  |\n| --- | --- | --- |\n|  | 参见: PEP 492 了解有关可等待对象的详细信息。 |  |\n|  | 3.4.2. 协程对象\n协程对象 属于 awaitable 对象。 协程的执行可以通过调用 __await__() 并迭代其结果来控制。 当\n协程结束执行并返回时，迭代器会引发 StopIteration，而该异常的 value 属性将存放返回值。\n如果协程引发了异常，它会被迭代器传播出去。 协程不应当直接引发未被处理的 StopIteration\n异常。\n协程也具有下面列出的方法，它们类似于生成器的对应方法 (参见 生成器-迭代器的方法)。 但是，与\n生成器不同，协程并不直接支持迭代。\n在 3.5.2 版本发生变更: 等待一个协程超过一次将引发 RuntimeError。\ncoroutine.send(value)\n开始或恢复协程的执行。 如果 value 为 None，这将等价于前往 __await__() 所返回的迭代器\n的下一项。 如果 value 不为 None，此方法将委托给导致协挂起的迭代器的 send() 方法。 其\n结果（返回值, StopIteration 或是其他异常）将与上述对 __await__() 返回值进行迭代的结\n果相同。\ncoroutine.throw(value)\ncoroutine.throw(type[, value[, traceback]])\n在协程内引发指定的异常。 此方法将委托给导致该协程挂起的迭代器的 throw() 方法，如果存\n在此方法的话。 否则，该异常将在挂起点被引发。 其结果（返回值，StopIteration 或是其\n他异常）将与上述对 __await__() 返回值进行迭代的结果相同。 如果该异常未在协程内被捕\n获，则将回传给调用方。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\ncoroutine.close()\n此方法会使得协程清理自身并退出。 如果协程被挂起，此方法会先委托给导致协程挂起的迭代\n器的 close() 方法，如果存在该方法。 然后它会在挂起点引发 GeneratorExit，使得协程立\n即清理自身。 最后，协程会被标记为已结束执行，即使它根本未被启动。\n当协程对象将要被销毁时，会使用以上处理过程来自动关闭。\n3.4.3. 异步迭代器 |  |\n\n异步迭代器 可以在其 __anext__ 方法中调用异步代码。\n异步迭代器可在 async for 语句中使用。\nobject 类本身不提供这些方法。\nobject.__aiter__(self)\n必须返回一个 异步迭代器 对象。\nobject.__anext__(self)\n必须返回一个 可等待对象 输出迭代器的下一结果值。 当迭代结束时应该引发\nStopAsyncIteration 错误。\n异步可迭代对象的一个示例:\nclass Reader:\nasync def readline(self):\n...\ndef __aiter__(self):\nreturn self\nasync def __anext__(self):\nval = await self.readline()\nif val == b'':\nraise StopAsyncIteration\nreturn val\nAdded in version 3.5.\n在 3.7 版本发生变更: 在 Python 3.7 之前，__aiter__() 可以返回一个 可等待对象 并将被解\n析为 异步迭代器。\n从 Python 3.7 开始，__aiter__() 必须返回一个异步迭代器对象。 返回任何其他对象都将导\n致 TypeError 错误。\n3.4.4. 异步上下文管理器\n异步上下文管理器 是 上下文管理器 的一种，它能够在其 __aenter__ 和 __aexit__ 方法中暂停执\n行。\n异步上下文管理器可在 async with 语句中使用。\nobject 类本身不提供这些方法。\nobject.__aenter__(self)\n在语义上类似于 __enter__()，仅有的区别在于它必须返回一个 可等待对象。\nobject.__aexit__(self, exc_type, exc_value, traceback)\n在语义上类似于 __exit__()，仅有的区别在于它必须返回一个 可等待对象。\n异步上下文管理器类的一个示例:\n\n|  | 异步迭代器 可以在其 __anext__ 方法中调用异步代码。\n异步迭代器可在 async for 语句中使用。\nobject 类本身不提供这些方法。\nobject.__aiter__(self)\n必须返回一个 异步迭代器 对象。\nobject.__anext__(self)\n必须返回一个 可等待对象 输出迭代器的下一结果值。 当迭代结束时应该引发\nStopAsyncIteration 错误。\n异步可迭代对象的一个示例: |  |\n| --- | --- | --- |\n|  | class Reader:\nasync def readline(self):\n...\ndef __aiter__(self):\nreturn self\nasync def __anext__(self):\nval = await self.readline()\nif val == b'':\nraise StopAsyncIteration\nreturn val |  |\n|  | Added in version 3.5.\n在 3.7 版本发生变更: 在 Python 3.7 之前，__aiter__() 可以返回一个 可等待对象 并将被解\n析为 异步迭代器。\n从 Python 3.7 开始，__aiter__() 必须返回一个异步迭代器对象。 返回任何其他对象都将导\n致 TypeError 错误。\n3.4.4. 异步上下文管理器\n异步上下文管理器 是 上下文管理器 的一种，它能够在其 __aenter__ 和 __aexit__ 方法中暂停执\n行。\n异步上下文管理器可在 async with 语句中使用。\nobject 类本身不提供这些方法。\nobject.__aenter__(self)\n在语义上类似于 __enter__()，仅有的区别在于它必须返回一个 可等待对象。\nobject.__aexit__(self, exc_type, exc_value, traceback)\n在语义上类似于 __exit__()，仅有的区别在于它必须返回一个 可等待对象。\n异步上下文管理器类的一个示例: |  |\n\nclass AsyncContextManager:\nasync def __aenter__(self):\nawait log('entering context')\nasync def __aexit__(self, exc_type, exc, tb):\nawait log('exiting context')\nAdded in version 3.5.\n备注\n[1] 在某些情况下 有可能 基于可控的条件改变一个对象的类型。 但这通常不是个好主意，因为如果\n处理不当会导致一些非常怪异的行为。\n[2] __hash__(), __iter__(), __reversed__(), __contains__(), __class_getitem__() 和\n__fspath__() 方法对此有特殊处理。 其他方法仍然会引发 TypeError，但可能会依赖 None\n是不可调用对象的行为来做到这一点。\n[3] 这里的“不支持”是指该类无此方法，或方法返回 NotImplemented 。 如果你想强制回退到右操\n作数的反射方法，请不要设置方法为 None — 那会造成显式地 阻塞 此种回退的相反效果。\n[4] 对于相同类型的操作数，如果非反射方法 (如 __add__()) 执行失败则相应的操作将被视为不受\n支持，这就是反射方法不会被调用的原因。\n[5] 如果右操作数的类型为左操作数的类型的子类，则具有优先地位的反射方法将允许子类重写其\n祖先类的操作。\n\n| class AsyncContextManager:\nasync def __aenter__(self):\nawait log('entering context')\nasync def __aexit__(self, exc_type, exc, tb):\nawait log('exiting context') |\n| --- |\n| Added in version 3.5.\n备注\n[1] 在某些情况下 有可能 基于可控的条件改变一个对象的类型。 但这通常不是个好主意，因为如果\n处理不当会导致一些非常怪异的行为。\n[2] __hash__(), __iter__(), __reversed__(), __contains__(), __class_getitem__() 和\n__fspath__() 方法对此有特殊处理。 其他方法仍然会引发 TypeError，但可能会依赖 None\n是不可调用对象的行为来做到这一点。\n[3] 这里的“不支持”是指该类无此方法，或方法返回 NotImplemented 。 如果你想强制回退到右操\n作数的反射方法，请不要设置方法为 None — 那会造成显式地 阻塞 此种回退的相反效果。\n[4] 对于相同类型的操作数，如果非反射方法 (如 __add__()) 执行失败则相应的操作将被视为不受\n支持，这就是反射方法不会被调用的原因。\n[5] 如果右操作数的类型为左操作数的类型的子类，则具有优先地位的反射方法将允许子类重写其\n祖先类的操作。 |", "metadata": {"title": "03_数据模型", "source": "md_docs\\python_reference_md\\03_数据模型.md", "doc_type": "语言参考", "language": "中文", "doc_id": "5b55d4e0"}}
{"doc_id": "4ea7d840", "content": "4. 执行模型\n4.1. 程序的结构\nPython 程序是由代码块构成的。 代码块 是被作为一个单元来执行的一段 Python 程序文本。 以下几\n个都属于代码块：模块、函数体和类定义。 交互式输入的每条命令都是代码块。 一个脚本文件（作\n为标准输入发送给解释器或是作为命令行参数发送给解释器的文件）也是代码块。 一条脚本命令\n（通过 -c 选项在解释器命令行中指定的命令）也是代码块。 通过在命令行中使用 -m 参数作为最高\n层级脚本（即 __main__ 模块）运行的模块也是代码块。 传递给内置函数 eval() 和 exec() 的字\n符串参数也是代码块。\n代码块在 执行帧 中被执行。 一个帧会包含某些管理信息（用于调试）并决定代码块执行完成后应前\n往何处以及如何继续执行。\n4.2. 命名与绑定\n4.2.1. 名称的绑定\n名称 用于指代对象。 名称是通过名称绑定操作来引入的。\n下面的结构将名字绑定:\n函数的正式参数，\n类定义，\n函数定义，\n赋值表达式,\n如果在一个赋值中出现，则为标识符的 目标 :\nfor 循环头,\n在 with 语句, except 子句, except* 子句，或格式化模式匹配的 as 模式的 as 之后，\n在结构模式匹配中的捕获模式\nimport 语句。\ntype 语句。\n类型形参列表。\n形式为 from ... import * 的 import 语句绑定所有在导入的模块中定义的名字，除了那些以下划\n线开头的名字。这种形式只能在模块级别上使用。\ndel 语句的目标也被视作一种绑定（虽然其实际语义为解除名称绑定）。\n每条赋值或导入语句均发生于类或函数内部定义的代码块中，或是发生于模块层级（即最高层级的\n代码块）。\n如果某个名称绑定在一个代码块中，则它就是该代码块的局部变量，除非声明为 nonlocal 或\nglobal。 如果某个名称绑定在模块层级，则它就是全局变量。 （模块代码块的变量既是局部变量\n\n又是全局变量。） 如果某个变量在一个代码块中被使用但不是在其中定义的，则它是 free\nvariable。\n每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 绑定。\n4.2.2. 名称的解析\n作用域 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该\n代码块。 如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有\n某个被包含代码块引入了对该名称的不同绑定。\n当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种\n作用域的集合称为该代码块的 环境。\n当一个名称完全找不到时，将会引发 NameError 异常。 如果当前作用域为函数作用域，且该名称指\n向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发\nUnboundLocalError 异常。 UnboundLocalError 为 NameError 的一个子类。\n如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用都会被视为对当\n前代码块的引用。 当一个名称在其被绑定前就在代码块内被使用时将会导致错误。 这个规则是很微\n妙的。 Python 缺少声明语法并且允许名称绑定操作发生于代码块内的任何位置。 一个代码块的局\n部变量可通过在整个代码块文本中扫描名称绑定操作来确定。 请参阅 UnboundLocalError 的 FAQ 条\n目 来获取示例。\n如果 global 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空\n间内对该名称绑定的引用。 名称在最高层级命名空间内的解析是通过搜索全局命名空间，也就是包\n含该代码块的模块的命名空间，以及内置命名空间即 builtins 模块的命名空间。 全局命名空间会\n先被搜索。 如果未在其中找到相应名称，将再搜索内置命名空间。 如果未在内置命名空间中找到相\n应名称，将在全局命名空间中创建新变量。 global 语句必须位于所有对其所列名称的使用之前。\nglobal 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中\n有一条 global 语句，则该自由变量也会被当作是全局变量。\nnonlocal 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 如果指定的名称\n不存在于任何包含函数作用域中则将在编译时引发 SyntaxError。 类型形参 不能使用 nonlocal 语\n句来重新绑定。\n模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 __main__。\n类定义代码块以及传给 exec() 和 eval() 的参数是名称解析的上下文中的特殊情况。 类定义是可\n能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部\n变量会在全局命名空间中查找。 类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名\n称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中。 这包括推导式和生成器表达\n式，但不包括 标注作用域，因为它可以访问所包含的类作用域。 这意味着以下代码将会失败:\nclass A:\na = 42\nb = list(a + i for i in range(10))\n\n|  | 又是全局变量。） 如果某个变量在一个代码块中被使用但不是在其中定义的，则它是 free\nvariable。\n每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 绑定。\n4.2.2. 名称的解析\n作用域 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该\n代码块。 如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有\n某个被包含代码块引入了对该名称的不同绑定。\n当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种\n作用域的集合称为该代码块的 环境。\n当一个名称完全找不到时，将会引发 NameError 异常。 如果当前作用域为函数作用域，且该名称指\n向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发\nUnboundLocalError 异常。 UnboundLocalError 为 NameError 的一个子类。\n如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用都会被视为对当\n前代码块的引用。 当一个名称在其被绑定前就在代码块内被使用时将会导致错误。 这个规则是很微\n妙的。 Python 缺少声明语法并且允许名称绑定操作发生于代码块内的任何位置。 一个代码块的局\n部变量可通过在整个代码块文本中扫描名称绑定操作来确定。 请参阅 UnboundLocalError 的 FAQ 条\n目 来获取示例。\n如果 global 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空\n间内对该名称绑定的引用。 名称在最高层级命名空间内的解析是通过搜索全局命名空间，也就是包\n含该代码块的模块的命名空间，以及内置命名空间即 builtins 模块的命名空间。 全局命名空间会\n先被搜索。 如果未在其中找到相应名称，将再搜索内置命名空间。 如果未在内置命名空间中找到相\n应名称，将在全局命名空间中创建新变量。 global 语句必须位于所有对其所列名称的使用之前。\nglobal 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中\n有一条 global 语句，则该自由变量也会被当作是全局变量。\nnonlocal 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 如果指定的名称\n不存在于任何包含函数作用域中则将在编译时引发 SyntaxError。 类型形参 不能使用 nonlocal 语\n句来重新绑定。\n模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 __main__。\n类定义代码块以及传给 exec() 和 eval() 的参数是名称解析的上下文中的特殊情况。 类定义是可\n能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部\n变量会在全局命名空间中查找。 类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名\n称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中。 这包括推导式和生成器表达\n式，但不包括 标注作用域，因为它可以访问所包含的类作用域。 这意味着以下代码将会失败: |  |\n| --- | --- | --- |\n|  | class A:\na = 42\nb = list(a + i for i in range(10)) |  |\n|  |  |  |\n\n但是，下面的代码将会成功:\nclass A:\ntype Alias = Nested\nclass Nested: pass\nprint(A.Alias.__value__) # <type 'A.Nested'>\n4.2.3. 标注作用域\n标注, 类型形参列表 和 type 语句引入了 标注作用域，其行为基本类似于函数作用域，但具有下文讨\n论的一些差异。\n标注作用域将在下列情况中使用:\n函数标注。\n变量标注。\n针对 泛型类型别名 的类型形参列表。\n针对 泛型函数 的类型形参列表。 泛型函数的标注会在标注作用域内执行，但其默认值和装饰器\n则不会。\n针对 泛型类 的类型形参列表。 泛型类的基类和关键字参数会在标注作用域内执行，但其装饰器\n则不会。\n针对类型形参的绑定、约束和默认值 (惰性求值)。\n类型别名的值 (惰性求值)。\n标注作用域在以下几个方面不同于函数作用域:\n标注作用域能够访问其所包含的类命名空间。 如果某个标注作用域紧接在一个类作用域之内，或\n是位于紧接一个类作用域的另一个标注作用域之内，则该标注作用域中的代码将能使用在该类作\n用域中定义的名称，就像它是在该类内部直接执行一样。 这不同于在类中定义的常规函数，后者\n无法访问在类作用域中定义的名称。\n标注作用域中的表达式不能包含 yield, yield from, await 或 := 表达式。 （这些表达式在包含\n于标注作用域之内的其他作用域中则是允许的。）\n在标注作用域中定义的名称不能在内部作用域中通过 nonlocal 语句来重新绑定。 这只包括类型\n形参，因为没有其他可以在标注作用域内部出现的语法元素能够引入新的名称。\n虽然标注作用域具有一个内部名称，但该名称不会反映在作用域内定义的对象的 qualified name\n中。 相反，这些对象的 __qualname__ 就像它们是定义在包含作用域中的对象一样。\nAdded in version 3.12: 标注作用域是在 Python 3.12 中作为 PEP 695 的一部分引入的。\n在 3.13 版本发生变更: 标注作用域也被用于类型形参默认值，这是由 PEP 696 引入的。\n在 3.14 版本发生变更: 标注作用域现在也被用于标注，如 PEP 649 和 PEP 749 所说明的。\n4.2.4. 惰性求值\n大多数标注作用域采用 惰性求值。 这包括标注、通过 type 语句创建的类型别名的值，以及通过 类\n型形参语法 创建的类型变量的绑定、约束和默认值。 这意味着它们在类型别名或类型变量被创建\n\n|  | 但是，下面的代码将会成功: |  |\n| --- | --- | --- |\n|  | class A:\ntype Alias = Nested\nclass Nested: pass\nprint(A.Alias.__value__) # <type 'A.Nested'> |  |\n|  | 4.2.3. 标注作用域\n标注, 类型形参列表 和 type 语句引入了 标注作用域，其行为基本类似于函数作用域，但具有下文讨\n论的一些差异。\n标注作用域将在下列情况中使用:\n函数标注。\n变量标注。\n针对 泛型类型别名 的类型形参列表。\n针对 泛型函数 的类型形参列表。 泛型函数的标注会在标注作用域内执行，但其默认值和装饰器\n则不会。\n针对 泛型类 的类型形参列表。 泛型类的基类和关键字参数会在标注作用域内执行，但其装饰器\n则不会。\n针对类型形参的绑定、约束和默认值 (惰性求值)。\n类型别名的值 (惰性求值)。\n标注作用域在以下几个方面不同于函数作用域:\n标注作用域能够访问其所包含的类命名空间。 如果某个标注作用域紧接在一个类作用域之内，或\n是位于紧接一个类作用域的另一个标注作用域之内，则该标注作用域中的代码将能使用在该类作\n用域中定义的名称，就像它是在该类内部直接执行一样。 这不同于在类中定义的常规函数，后者\n无法访问在类作用域中定义的名称。\n标注作用域中的表达式不能包含 yield, yield from, await 或 := 表达式。 （这些表达式在包含\n于标注作用域之内的其他作用域中则是允许的。）\n在标注作用域中定义的名称不能在内部作用域中通过 nonlocal 语句来重新绑定。 这只包括类型\n形参，因为没有其他可以在标注作用域内部出现的语法元素能够引入新的名称。\n虽然标注作用域具有一个内部名称，但该名称不会反映在作用域内定义的对象的 qualified name\n中。 相反，这些对象的 __qualname__ 就像它们是定义在包含作用域中的对象一样。\nAdded in version 3.12: 标注作用域是在 Python 3.12 中作为 PEP 695 的一部分引入的。\n在 3.13 版本发生变更: 标注作用域也被用于类型形参默认值，这是由 PEP 696 引入的。\n在 3.14 版本发生变更: 标注作用域现在也被用于标注，如 PEP 649 和 PEP 749 所说明的。\n4.2.4. 惰性求值\n大多数标注作用域采用 惰性求值。 这包括标注、通过 type 语句创建的类型别名的值，以及通过 类\n型形参语法 创建的类型变量的绑定、约束和默认值。 这意味着它们在类型别名或类型变量被创建 |  |\n\n时、或带有标注的对象被创建时不会被求值。 作为替代行为，它们只有在需要时才会被求值，例如\n在一个类型别名上的 __value__ 属性被访问的时候。\n示例:\n>>> type Alias = 1/0\n>>> Alias.__value__\nTraceback (most recent call last):\n...\nZeroDivisionError: division by zero\n>>> def func[T: 1/0](): pass\n>>> T = func.__type_params__[0]\n>>> T.__bound__\nTraceback (most recent call last):\n...\nZeroDivisionError: division by zero\n此处的异常只有在类型别名的 __value__ 属性或类型变量的 __bound__ 属性被访问时才会被引\n发。\n此行为主要适用于当创建类型别名或类型变量时对尚未被定义的类型进行引用。 例如，惰性求值将\n允许创建相互递归的类型别名:\nfrom typing import Literal\ntype SimpleExpr = int | Parenthesized\ntype Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\ntype Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]\n被惰性求值的值是在 标记作用域 内进行求值的，这意味着出现在被惰性求值的值内部的名称的查找\n范围就相当于它们是在紧邻的作用域中被使用。\nAdded in version 3.12.\n4.2.5. 内置命名空间和受限的执行\n用户不应该接触 __builtins__，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值\n则应该 import builtins 并相应地修改该模块中的属性。\n与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称\n__builtins__ 来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。\n默认情况下，当在 __main__ 模块中时，__builtins__ 就是内置模块 builtins；当在任何其他模\n块中时，__builtins__ 则是 builtins 模块自身的字典的一个别名。\n4.2.6. 与动态特性的交互\n自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42:\ni = 10\ndef f():\nprint(i)\ni = 42\nf()\n\n|  | 时、或带有标注的对象被创建时不会被求值。 作为替代行为，它们只有在需要时才会被求值，例如\n在一个类型别名上的 __value__ 属性被访问的时候。\n示例: |  |\n| --- | --- | --- |\n|  | >>> type Alias = 1/0\n>>> Alias.__value__\nTraceback (most recent call last):\n...\nZeroDivisionError: division by zero\n>>> def func[T: 1/0](): pass\n>>> T = func.__type_params__[0]\n>>> T.__bound__\nTraceback (most recent call last):\n...\nZeroDivisionError: division by zero |  |\n|  | 此处的异常只有在类型别名的 __value__ 属性或类型变量的 __bound__ 属性被访问时才会被引\n发。\n此行为主要适用于当创建类型别名或类型变量时对尚未被定义的类型进行引用。 例如，惰性求值将\n允许创建相互递归的类型别名: |  |\n|  | from typing import Literal\ntype SimpleExpr = int | Parenthesized\ntype Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\ntype Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr] |  |\n|  | 被惰性求值的值是在 标记作用域 内进行求值的，这意味着出现在被惰性求值的值内部的名称的查找\n范围就相当于它们是在紧邻的作用域中被使用。\nAdded in version 3.12.\n4.2.5. 内置命名空间和受限的执行\n用户不应该接触 __builtins__，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值\n则应该 import builtins 并相应地修改该模块中的属性。\n与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称\n__builtins__ 来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。\n默认情况下，当在 __main__ 模块中时，__builtins__ 就是内置模块 builtins；当在任何其他模\n块中时，__builtins__ 则是 builtins 模块自身的字典的一个别名。\n4.2.6. 与动态特性的交互\n自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42: |  |\n|  | i = 10\ndef f():\nprint(i)\ni = 42\nf() |  |\n\neval() 和 exec() 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命\n名空间中被解析。 自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 [1]\nexec() 和 eval() 函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它\n会同时作用于两者。\n4.3. 异常\n异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测\n到的位置 引发，它可以被当前包围代码块或是任何直接或间接唤起发生错误的代码块的其他代码块\n所 处理。\nPython 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以\n通过 raise 语句显式地引发异常。 异常处理是通过 try ... except 语句来指定的。 该语句的\nfinally 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被\n执行。\nPython 的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执\n行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。\n当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种\n情况，它都会打印栈回溯信息，除非是当异常为 SystemExit 的时候。\n异常是通过类实例来标识的。 except 子句会依据实例的类来选择：它必须引用实例的类或是其所\n属的 非虚基类 。 实例可通过处理器被接收，并可携带有关异常条件的附加信息。\n备注: 异常消息不是 Python API 的组成部分。 其内容可能在 Python 升级到新版本时不经警告地\n发生改变，不应该被需要在多版本解释器中运行的代码所依赖。\n另请参看 try 语句 小节中对 try 语句的描述以及 raise 语句 小节中对 raise 语句的描述。\n4.4. 运行时组件\n4.4.1. 通用计算模型\nPython 的执行模型并非是在真空中运作的。 它存在于一台主机并通过该主机的运行时环境运行，包\n括其中的操作系统 (OS)，如果有具体操作系统的话。 当一个程序运行时，决定它如何在主机上运行\n的各个概念层大致是这样的：\n主机\n进程 (全局资源)\n线程 (运行机器码)\n每个进程代表一个在主机上运行的程序。 可以将每个进程本身视作其程序的数据部分。 可以将进程\n的各个线程视为程序的执行部分。 这一区别对于理解 Python 运行时的概念是很重要的。\n进程作为数据部分，是程序运行所在的执行上下文。 它主要由主机分配给程序的资源集合组成，包\n括内存、信号、文件句柄、套接字以及环境变量等。\n\n|  | eval() 和 exec() 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命\n名空间中被解析。 自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 [1]\nexec() 和 eval() 函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它\n会同时作用于两者。\n4.3. 异常\n异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测\n到的位置 引发，它可以被当前包围代码块或是任何直接或间接唤起发生错误的代码块的其他代码块\n所 处理。\nPython 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以\n通过 raise 语句显式地引发异常。 异常处理是通过 try ... except 语句来指定的。 该语句的\nfinally 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被\n执行。\nPython 的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执\n行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。\n当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种\n情况，它都会打印栈回溯信息，除非是当异常为 SystemExit 的时候。\n异常是通过类实例来标识的。 except 子句会依据实例的类来选择：它必须引用实例的类或是其所\n属的 非虚基类 。 实例可通过处理器被接收，并可携带有关异常条件的附加信息。 |  |\n| --- | --- | --- |\n|  | 备注: 异常消息不是 Python API 的组成部分。 其内容可能在 Python 升级到新版本时不经警告地\n发生改变，不应该被需要在多版本解释器中运行的代码所依赖。 |  |\n|  | 另请参看 try 语句 小节中对 try 语句的描述以及 raise 语句 小节中对 raise 语句的描述。\n4.4. 运行时组件\n4.4.1. 通用计算模型\nPython 的执行模型并非是在真空中运作的。 它存在于一台主机并通过该主机的运行时环境运行，包\n括其中的操作系统 (OS)，如果有具体操作系统的话。 当一个程序运行时，决定它如何在主机上运行\n的各个概念层大致是这样的：\n主机\n进程 (全局资源)\n线程 (运行机器码)\n每个进程代表一个在主机上运行的程序。 可以将每个进程本身视作其程序的数据部分。 可以将进程\n的各个线程视为程序的执行部分。 这一区别对于理解 Python 运行时的概念是很重要的。\n进程作为数据部分，是程序运行所在的执行上下文。 它主要由主机分配给程序的资源集合组成，包\n括内存、信号、文件句柄、套接字以及环境变量等。 |  |\n\nProcesses are isolated and independent from one another. (The same is true for hosts.) The host\nmanages the process' access to its assigned resources, in addition to coordinating between\nprocesses.\nEach thread represents the actual execution of the program's machine code, running relative to the\nresources assigned to the program's process. It's strictly up to the host how and when that\nexecution takes place.\nFrom the point of view of Python, a program always starts with exactly one thread. However, the\nprogram may grow to run in multiple simultaneous threads. Not all hosts support multiple threads\nper process, but most do. Unlike processes, threads in a process are not isolated and independent\nfrom one another. Specifically, all threads in a process share all of the process' resources.\nThe fundamental point of threads is that each one does run independently, at the same time as the\nothers. That may be only conceptually at the same time (\"concurrently\") or physically (\"in parallel\").\nEither way, the threads effectively run at a non-synchronized rate.\n备注: That non-synchronized rate means none of the process' memory is guaranteed to stay\nconsistent for the code running in any given thread. Thus multi-threaded programs must take\ncare to coordinate access to intentionally shared resources. Likewise, they must take care to be\nabsolutely diligent about not accessing any other resources in multiple threads; otherwise two\nthreads running at the same time might accidentally interfere with each other's use of some\nshared data. All this is true for both Python programs and the Python runtime.\nThe cost of this broad, unstructured requirement is the tradeoff for the kind of raw concurrency\nthat threads provide. The alternative to the required discipline generally means dealing with\nnon-deterministic bugs and data corruption.\n4.4.2. Python Runtime Model\nThe same conceptual layers apply to each Python program, with some extra data layers specific to\nPython:\n主机\n进程 (全局资源)\nPython global runtime (state)\nPython interpreter (state)\nthread (runs Python bytecode and \"C-API\")\nPython thread state\nAt the conceptual level: when a Python program starts, it looks exactly like that diagram, with one\nof each. The runtime may grow to include multiple interpreters, and each interpreter may grow to\ninclude multiple thread states.\n备注: A Python implementation won't necessarily implement the runtime layers distinctly or\neven concretely. The only exception is places where distinct layers are directly specified or\n\n|  | Processes are isolated and independent from one another. (The same is true for hosts.) The host\nmanages the process' access to its assigned resources, in addition to coordinating between\nprocesses.\nEach thread represents the actual execution of the program's machine code, running relative to the\nresources assigned to the program's process. It's strictly up to the host how and when that\nexecution takes place.\nFrom the point of view of Python, a program always starts with exactly one thread. However, the\nprogram may grow to run in multiple simultaneous threads. Not all hosts support multiple threads\nper process, but most do. Unlike processes, threads in a process are not isolated and independent\nfrom one another. Specifically, all threads in a process share all of the process' resources.\nThe fundamental point of threads is that each one does run independently, at the same time as the\nothers. That may be only conceptually at the same time (\"concurrently\") or physically (\"in parallel\").\nEither way, the threads effectively run at a non-synchronized rate. |  |\n| --- | --- | --- |\n|  | 备注: That non-synchronized rate means none of the process' memory is guaranteed to stay\nconsistent for the code running in any given thread. Thus multi-threaded programs must take\ncare to coordinate access to intentionally shared resources. Likewise, they must take care to be\nabsolutely diligent about not accessing any other resources in multiple threads; otherwise two\nthreads running at the same time might accidentally interfere with each other's use of some\nshared data. All this is true for both Python programs and the Python runtime.\nThe cost of this broad, unstructured requirement is the tradeoff for the kind of raw concurrency\nthat threads provide. The alternative to the required discipline generally means dealing with\nnon-deterministic bugs and data corruption. |  |\n|  | 4.4.2. Python Runtime Model\nThe same conceptual layers apply to each Python program, with some extra data layers specific to\nPython:\n主机\n进程 (全局资源)\nPython global runtime (state)\nPython interpreter (state)\nthread (runs Python bytecode and \"C-API\")\nPython thread state\nAt the conceptual level: when a Python program starts, it looks exactly like that diagram, with one\nof each. The runtime may grow to include multiple interpreters, and each interpreter may grow to\ninclude multiple thread states. |  |\n|  | 备注: A Python implementation won't necessarily implement the runtime layers distinctly or\neven concretely. The only exception is places where distinct layers are directly specified or |  |\n\nexposed to users, like through the threading module.\n备注: The initial interpreter is typically called the \"main\" interpreter. Some Python\nimplementations, like CPython, assign special roles to the main interpreter.\nLikewise, the host thread where the runtime was initialized is known as the \"main\" thread. It may\nbe different from the process' initial thread, though they are often the same. In some cases\n\"main thread\" may be even more specific and refer to the initial thread state. A Python runtime\nmight assign specific responsibilities to the main thread, such as handling signals.\nAs a whole, the Python runtime consists of the global runtime state, interpreters, and thread states.\nThe runtime ensures all that state stays consistent over its lifetime, particularly when used with\nmultiple host threads.\nThe global runtime, at the conceptual level, is just a set of interpreters. While those interpreters are\notherwise isolated and independent from one another, they may share some data or other\nresources. The runtime is responsible for managing these global resources safely. The actual nature\nand management of these resources is implementation-specific. Ultimately, the external utility of\nthe global runtime is limited to managing interpreters.\nIn contrast, an \"interpreter\" is conceptually what we would normally think of as the (full-featured)\n\"Python runtime\". When machine code executing in a host thread interacts with the Python\nruntime, it calls into Python in the context of a specific interpreter.\n备注: The term \"interpreter\" here is not the same as the \"bytecode interpreter\", which is what\nregularly runs in threads, executing compiled Python code.\nIn an ideal world, \"Python runtime\" would refer to what we currently call \"interpreter\". However,\nit's been called \"interpreter\" at least since introduced in 1997 (CPython:a027efa5b).\nEach interpreter completely encapsulates all of the non-process-global, non-thread-specific state\nneeded for the Python runtime to work. Notably, the interpreter's state persists between uses. It\nincludes fundamental data like sys.modules. The runtime ensures multiple threads using the same\ninterpreter will safely share it between them.\nA Python implementation may support using multiple interpreters at the same time in the same\nprocess. They are independent and isolated from one another. For example, each interpreter has its\nown sys.modules.\nFor thread-specific runtime state, each interpreter has a set of thread states, which it manages, in\nthe same way the global runtime contains a set of interpreters. It can have thread states for as\nmany host threads as it needs. It may even have multiple thread states for the same host thread,\nthough that isn't as common.\nEach thread state, conceptually, has all the thread-specific runtime data an interpreter needs to\noperate in one host thread. The thread state includes the current raised exception and the thread's\n\n|  | exposed to users, like through the threading module. |  |\n| --- | --- | --- |\n|  |  |  |\n|  | 备注: The initial interpreter is typically called the \"main\" interpreter. Some Python\nimplementations, like CPython, assign special roles to the main interpreter.\nLikewise, the host thread where the runtime was initialized is known as the \"main\" thread. It may\nbe different from the process' initial thread, though they are often the same. In some cases\n\"main thread\" may be even more specific and refer to the initial thread state. A Python runtime\nmight assign specific responsibilities to the main thread, such as handling signals. |  |\n|  | As a whole, the Python runtime consists of the global runtime state, interpreters, and thread states.\nThe runtime ensures all that state stays consistent over its lifetime, particularly when used with\nmultiple host threads.\nThe global runtime, at the conceptual level, is just a set of interpreters. While those interpreters are\notherwise isolated and independent from one another, they may share some data or other\nresources. The runtime is responsible for managing these global resources safely. The actual nature\nand management of these resources is implementation-specific. Ultimately, the external utility of\nthe global runtime is limited to managing interpreters.\nIn contrast, an \"interpreter\" is conceptually what we would normally think of as the (full-featured)\n\"Python runtime\". When machine code executing in a host thread interacts with the Python\nruntime, it calls into Python in the context of a specific interpreter. |  |\n|  | 备注: The term \"interpreter\" here is not the same as the \"bytecode interpreter\", which is what\nregularly runs in threads, executing compiled Python code.\nIn an ideal world, \"Python runtime\" would refer to what we currently call \"interpreter\". However,\nit's been called \"interpreter\" at least since introduced in 1997 (CPython:a027efa5b). |  |\n|  | Each interpreter completely encapsulates all of the non-process-global, non-thread-specific state\nneeded for the Python runtime to work. Notably, the interpreter's state persists between uses. It\nincludes fundamental data like sys.modules. The runtime ensures multiple threads using the same\ninterpreter will safely share it between them.\nA Python implementation may support using multiple interpreters at the same time in the same\nprocess. They are independent and isolated from one another. For example, each interpreter has its\nown sys.modules.\nFor thread-specific runtime state, each interpreter has a set of thread states, which it manages, in\nthe same way the global runtime contains a set of interpreters. It can have thread states for as\nmany host threads as it needs. It may even have multiple thread states for the same host thread,\nthough that isn't as common.\nEach thread state, conceptually, has all the thread-specific runtime data an interpreter needs to\noperate in one host thread. The thread state includes the current raised exception and the thread's |  |\n\nPython call stack. It may include other thread-specific resources.\n备注: The term \"Python thread\" can sometimes refer to a thread state, but normally it means a\nthread created using the threading module.\nEach thread state, over its lifetime, is always tied to exactly one interpreter and exactly one host\nthread. It will only ever be used in that thread and with that interpreter.\nMultiple thread states may be tied to the same host thread, whether for different interpreters or\neven the same interpreter. However, for any given host thread, only one of the thread states tied to\nit can be used by the thread at a time.\nThread states are isolated and independent from one another and don't share any data, except for\npossibly sharing an interpreter and objects or other resources belonging to that interpreter.\nOnce a program is running, new Python threads can be created using the threading module (on\nplatforms and Python implementations that support threads). Additional processes can be created\nusing the os, subprocess, and multiprocessing modules. Interpreters can be created and used\nwith the interpreters module. Coroutines (async) can be run using asyncio in each interpreter,\ntypically only in a single thread (often the main thread).\n备注\n[1] 出现这样的限制是由于通过这些操作执行的代码在模块被编译的时候并不可用。\n\n| Python call stack. It may include other thread-specific resources. |\n| --- |\n| 备注: The term \"Python thread\" can sometimes refer to a thread state, but normally it means a\nthread created using the threading module. |\n| Each thread state, over its lifetime, is always tied to exactly one interpreter and exactly one host\nthread. It will only ever be used in that thread and with that interpreter.\nMultiple thread states may be tied to the same host thread, whether for different interpreters or\neven the same interpreter. However, for any given host thread, only one of the thread states tied to\nit can be used by the thread at a time.\nThread states are isolated and independent from one another and don't share any data, except for\npossibly sharing an interpreter and objects or other resources belonging to that interpreter.\nOnce a program is running, new Python threads can be created using the threading module (on\nplatforms and Python implementations that support threads). Additional processes can be created\nusing the os, subprocess, and multiprocessing modules. Interpreters can be created and used\nwith the interpreters module. Coroutines (async) can be run using asyncio in each interpreter,\ntypically only in a single thread (often the main thread).\n备注\n[1] 出现这样的限制是由于通过这些操作执行的代码在模块被编译的时候并不可用。 |", "metadata": {"title": "04_执行模型", "source": "md_docs\\python_reference_md\\04_执行模型.md", "doc_type": "语言参考", "language": "中文", "doc_id": "4ea7d840"}}
{"doc_id": "ad5d721c", "content": "5. 导入系统\n一个 module 内的 Python 代码通过 importing 操作就能够访问另一个模块内的代码。 import 语句\n是唤起导入机制的最常用方式，但不是唯一的方式。 importlib.import_module() 以及内置的\n__import__() 等函数也可以被用来唤起导入机制。\nimport 语句结合了两个操作；它先搜索指定名称的模块，然后将搜索结果绑定到当前作用域中的名\n称。 import 语句的搜索操作被定义为对 __import__() 函数的调用并带有适当的参数。\n__import__() 的返回值会被用于执行 import 语句的名称绑定操作。 请参阅 import 语句了解名称\n绑定操作的更多细节。\n对 __import__() 的直接调用将仅执行模块搜索以及在找到时的模块创建操作。 不过也可能产生某\n些副作用，例如导入父包和更新各种缓存 (包括 sys.modules)，只有 import 语句会执行名称绑定\n操作。\n当 import 语句被执行时，标准的内置 __import__() 函数会被调用。 其他唤起导入系统的机制 (例\n如 importlib.import_module()) 可能会选择绕过 __import__() 并使用它们自己的解决方案来实\n现导入机制。\n当一个模块首次被导入时，Python 会搜索该模块，如果找到就创建一个 module 对象 [1] 并初始化\n它。 如果指定名称的模块未找到，则会引发 ModuleNotFoundError。 当唤起导入机制时，Python\n会实现多种策略来搜索指定名称的模块。 这些策略可以通过使用使用下文所描述的多种钩子来加以\n修改和扩展。\n在 3.3 版本发生变更: 导入系统已被更新以完全实现 PEP 302 中的第二阶段要求。 不会再有任\n何隐式的导入机制 —— 整个导入系统都通过 sys.meta_path 暴露出来。 此外，对原生命名\n空间包的支持也已被实现 (参见 PEP 420)。\n5.1. importlib\nimportlib 模块提供了一个丰富的 API 用来与导入系统进行交互。 例如\nimportlib.import_module() 提供了相比内置的 __import__() 更推荐、更简单的 API 用来唤起导\n入机制。 更多细节请参看 importlib 库文档。\n5.2. 包\nPython 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实\n现。 为了帮助组织模块并提供名称层次结构，Python 还引入了 包 的概念。\n你可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类比做过于\n字面的理解，因为包和模块不是必须来自于文件系统。 为了方便理解本文档，我们将继续使用这种\n\n目录和文件的类比。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可\n以有子包。\n要注意的一个重点概念是所有包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特\n殊的模块。 特别地，任何具有 __path__ 属性的模块都会被当作是包。\n所有模块都有自己的名字。 子包名与其父包名会以点号分隔，与 Python 的标准属性访问语法一\n致。 因此你可能会有一个名为 email 的包，这个包中又有一个名为 email.mime 的子包以及该子包\n中的名为 email.mime.text 的子包。\n5.2.1. 常规包\nPython 定义了两种类型的包，常规包 和 命名空间包。 常规包是传统的包类型，它们在 Python 3.2\n及之前就已存在。 常规包通常以一个包含 __init__.py 文件的目录形式实现。 当一个常规包被导\n入时，这个 __init__.py 文件会隐式地被执行，它所定义的对象会被绑定到该包命名空间中的名\n称。__init__.py 文件可以包含与任何其他模块中所包含的 Python 代码相似的代码，Python 将在\n模块被导入时为其添加额外的属性。\n例如，以下文件系统布局定义了一个最高层级的 parent 包和三个子包:\nparent/\n__init__.py\none/\n__init__.py\ntwo/\n__init__.py\nthree/\n__init__.py\n导入 parent.one 将隐式地执行 parent/__init__.py 和 parent/one/__init__.py。 后续导入\nparent.two 或 parent.three 则将分别执行 parent/two/__init__.py 和\nparent/three/__init__.py。\n5.2.2. 命名空间包\n命名空间包是由多个 部分 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不\n同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命\n名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。\n命名空间包的 __path__ 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径\n(或者最高层级包的 sys.path) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对\n包部分的搜索。\n命名空间包没有 parent/__init__.py 文件。 实际上，在导入搜索期间可能找到多个 parent 目\n录，每个都由不同的部分所提供。 因此 parent/one 的物理位置不一定与 parent/two 相邻。 在这\n种情况下，Python 将为顶级的 parent 包创建一个命名空间包，无论是它本身还是它的某个子包被\n导入。\n\n|  | 目录和文件的类比。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可\n以有子包。\n要注意的一个重点概念是所有包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特\n殊的模块。 特别地，任何具有 __path__ 属性的模块都会被当作是包。\n所有模块都有自己的名字。 子包名与其父包名会以点号分隔，与 Python 的标准属性访问语法一\n致。 因此你可能会有一个名为 email 的包，这个包中又有一个名为 email.mime 的子包以及该子包\n中的名为 email.mime.text 的子包。\n5.2.1. 常规包\nPython 定义了两种类型的包，常规包 和 命名空间包。 常规包是传统的包类型，它们在 Python 3.2\n及之前就已存在。 常规包通常以一个包含 __init__.py 文件的目录形式实现。 当一个常规包被导\n入时，这个 __init__.py 文件会隐式地被执行，它所定义的对象会被绑定到该包命名空间中的名\n称。__init__.py 文件可以包含与任何其他模块中所包含的 Python 代码相似的代码，Python 将在\n模块被导入时为其添加额外的属性。\n例如，以下文件系统布局定义了一个最高层级的 parent 包和三个子包: |  |\n| --- | --- | --- |\n|  | parent/\n__init__.py\none/\n__init__.py\ntwo/\n__init__.py\nthree/\n__init__.py |  |\n|  | 导入 parent.one 将隐式地执行 parent/__init__.py 和 parent/one/__init__.py。 后续导入\nparent.two 或 parent.three 则将分别执行 parent/two/__init__.py 和\nparent/three/__init__.py。\n5.2.2. 命名空间包\n命名空间包是由多个 部分 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不\n同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命\n名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。\n命名空间包的 __path__ 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径\n(或者最高层级包的 sys.path) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对\n包部分的搜索。\n命名空间包没有 parent/__init__.py 文件。 实际上，在导入搜索期间可能找到多个 parent 目\n录，每个都由不同的部分所提供。 因此 parent/one 的物理位置不一定与 parent/two 相邻。 在这\n种情况下，Python 将为顶级的 parent 包创建一个命名空间包，无论是它本身还是它的某个子包被\n导入。 |  |\n\n另请参阅 PEP 420 了解对命名空间包的规格描述。\n5.3. 搜索\n为了开始搜索，Python 需要被导入模块（或者包，对于当前讨论来说两者没有差别）的完整 限定名\n称。 此名称可以来自 import 语句所带的各种参数，或者来自传给 importlib.import_module()\n或 __import__() 函数的形参。\n此名称会在导入搜索的各个阶段被使用，它也可以是指向一个子模块的带点号路径，例如\nfoo.bar.baz。 在这种情况下，Python 会先尝试导入 foo，然后是 foo.bar，最后是\nfoo.bar.baz。 如果这些导入中的任何一个失败，都会引发 ModuleNotFoundError。\n5.3.1. 模块缓存\n在导入搜索期间首先会被检查的地方是 sys.modules。 这个映射起到缓存之前导入的所有模块的作\n用（包括其中间路径）。 因此如果之前导入过 foo.bar.baz，则 sys.modules 将包含 foo,\nfoo.bar 和 foo.bar.baz 条目。 每个键的值就是相应的模块对象。\n在导入期间，会在 sys.modules 查找模块名称，如存在则其关联的值就是需要导入的模块，导入过\n程完成。 然而，如果值为 None，则会引发 ModuleNotFoundError。 如果找不到指定模块名称，\nPython 将继续搜索该模块。\nsys.modules 是可写的。删除键可能不会破坏关联的模块（因为其他模块可能会保留对它的引\n用），但它会使命名模块的缓存条目无效，导致 Python 在下次导入时重新搜索命名模块。键也可以\n赋值为 None ，强制下一次导入模块导致 ModuleNotFoundError 。\n但是要小心，因为如果你还保有对某个模块对象的引用，同时停用其在 sys.modules 中的缓存条\n目，然后又再次导入该名称的模块，则前后两个模块对象将 不是 同一个。 相反地，\nimportlib.reload() 将重用 同一个 模块对象，并简单地通过重新运行模块的代码来重新初始化模\n块内容。\n5.3.2. 查找器和加载器\n如果指定名称的模块在 sys.modules 找不到，则将唤起 Python 的导入协议以查找和加载该模块。\n此协议由两个概念性模块构成，即 查找器 和 加载器。 查找器的任务是确定是否能使用其所知的策\n略找到该名称的模块。 同时实现这两种接口的对象称为 导入器 —— 它们在确定能加载所需的模块\n时会返回其自身。\nPython 包含了多个默认查找器和导入器。 第一个知道如何定位内置模块，第二个知道如何定位冻结\n模块。 第三个默认查找器会在 import path 中搜索模块。 import path 是一个由文件系统路径或 zip\n文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。\n导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域。\n查找器并不真正加载模块。 如果它们能找到指定名称的模块，会返回一个 模块规格说明，这是对模\n块导入相关信息的封装，供后续导入机制用于在加载模块时使用。\n\n|  | 另请参阅 PEP 420 了解对命名空间包的规格描述。\n5.3. 搜索\n为了开始搜索，Python 需要被导入模块（或者包，对于当前讨论来说两者没有差别）的完整 限定名\n称。 此名称可以来自 import 语句所带的各种参数，或者来自传给 importlib.import_module()\n或 __import__() 函数的形参。\n此名称会在导入搜索的各个阶段被使用，它也可以是指向一个子模块的带点号路径，例如\nfoo.bar.baz。 在这种情况下，Python 会先尝试导入 foo，然后是 foo.bar，最后是\nfoo.bar.baz。 如果这些导入中的任何一个失败，都会引发 ModuleNotFoundError。\n5.3.1. 模块缓存\n在导入搜索期间首先会被检查的地方是 sys.modules。 这个映射起到缓存之前导入的所有模块的作\n用（包括其中间路径）。 因此如果之前导入过 foo.bar.baz，则 sys.modules 将包含 foo,\nfoo.bar 和 foo.bar.baz 条目。 每个键的值就是相应的模块对象。\n在导入期间，会在 sys.modules 查找模块名称，如存在则其关联的值就是需要导入的模块，导入过\n程完成。 然而，如果值为 None，则会引发 ModuleNotFoundError。 如果找不到指定模块名称，\nPython 将继续搜索该模块。\nsys.modules 是可写的。删除键可能不会破坏关联的模块（因为其他模块可能会保留对它的引\n用），但它会使命名模块的缓存条目无效，导致 Python 在下次导入时重新搜索命名模块。键也可以\n赋值为 None ，强制下一次导入模块导致 ModuleNotFoundError 。\n但是要小心，因为如果你还保有对某个模块对象的引用，同时停用其在 sys.modules 中的缓存条\n目，然后又再次导入该名称的模块，则前后两个模块对象将 不是 同一个。 相反地，\nimportlib.reload() 将重用 同一个 模块对象，并简单地通过重新运行模块的代码来重新初始化模\n块内容。\n5.3.2. 查找器和加载器\n如果指定名称的模块在 sys.modules 找不到，则将唤起 Python 的导入协议以查找和加载该模块。\n此协议由两个概念性模块构成，即 查找器 和 加载器。 查找器的任务是确定是否能使用其所知的策\n略找到该名称的模块。 同时实现这两种接口的对象称为 导入器 —— 它们在确定能加载所需的模块\n时会返回其自身。\nPython 包含了多个默认查找器和导入器。 第一个知道如何定位内置模块，第二个知道如何定位冻结\n模块。 第三个默认查找器会在 import path 中搜索模块。 import path 是一个由文件系统路径或 zip\n文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。\n导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域。\n查找器并不真正加载模块。 如果它们能找到指定名称的模块，会返回一个 模块规格说明，这是对模\n块导入相关信息的封装，供后续导入机制用于在加载模块时使用。 |  |\n| --- | --- | --- |\n\n以下各节描述了有关查找器和加载器协议的更多细节，包括你应该如何创建并注册新的此类对象来\n扩展导入机制。\n在 3.4 版本发生变更: 在之前的 Python 版本中，查找器会直接返回 加载器，现在它们则返回模\n块规格说明，其中 包含 加载器。 加载器仍然在导入期间被使用，但负担的任务有所减少。\n5.3.3. 导入钩子\n导入机制被设计为可扩展；其中的基本机制是 导入钩子。 导入钩子有两种类型: 元钩子 和 导入路径\n钩子。\n元钩子在导入过程开始时被调用，此时任何其他导入过程尚未发生，但 sys.modules 缓存查找除\n外。 这允许元钩子重载 sys.path 过程、冻结模块甚至内置模块。 元钩子的注册是通过向\nsys.meta_path 添加新的查找器对象，具体如下所述。\n导入路径钩子是作为 sys.path (或 package.__path__) 过程的一部分，在遇到它们所关联的路径项\n的时候被调用。 导入路径钩子的注册是通过向 sys.path_hooks 添加新的可调用对象，具体如下所\n述。\n5.3.4. 元路径\n当指定名称的模块在 sys.modules 中找不到时，Python 会接着搜索 sys.meta_path，其中包含元\n路径查找器对象列表。 这些查找器将按顺序被查询以确定它们是否知道如何处理该名称的模块。 元\n路径查找器必须实现名为 find_spec() 的方法，它接受三个参数：名称、导入路径和（可选的）目\n标模块。 元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。\n如果元路径查找器知道如何处理指定名称的模块，它将返回一个说明对象。 如果它不能处理该名称\n的模块，则会返回 None。 如果 sys.meta_path 处理过程到达列表末尾仍未返回说明对象，则将引\n发 ModuleNotFoundError。 任何其他被引发异常将直接向上传播，并放弃导入过程。\n元路径查找器的 find_spec() 方法调用将附带两个或三个参数。 第一个是被导入模块的完整限定名\n称，例如 foo.bar.baz。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参\n数为 None，但对于子模块或子包，第二个参数为父包的 __path__ 属性的值。 如果相应折\n__path__ 属性无法访问，则会引发 ModuleNotFoundError。 第三个参数是将被作为稍后加载目标\n的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。\n对于单个导入请求可以多次遍历元路径。 例如，假设所涉及的模块都尚未被缓存，则导入\nfoo.bar.baz 将首先执行顶级的导入，在每个元路径查找器 (mpf) 上调用 mpf.find_spec(\"foo\",\nNone, None)。 在导入 foo 之后，foo.bar 将通过第二次遍历元路径来导入，调用\nmpf.find_spec(\"foo.bar\", foo.__path__, None)。 一旦 foo.bar 完成导入，最后一次遍历将\n调用 mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)。\n有些元路径查找器只支持顶级导入。 当把 None 以外的对象作为第三个参数传入时，这些导入器将\n总是返回 None。\nPython 的默认 sys.meta_path 具有三种元路径查找器，一种知道如何导入内置模块，一种知道如\n何导入冻结模块，还有一种知道如何导入来自 import path 的模块 (即 path based finder)。\n\n|  |  | 以下各节描述了有关查找器和加载器协议的更多细节，包括你应该如何创建并注册新的此类对象来\n扩展导入机制。\n在 3.4 版本发生变更: 在之前的 Python 版本中，查找器会直接返回 加载器，现在它们则返回模\n块规格说明，其中 包含 加载器。 加载器仍然在导入期间被使用，但负担的任务有所减少。\n5.3.3. 导入钩子\n导入机制被设计为可扩展；其中的基本机制是 导入钩子。 导入钩子有两种类型: 元钩子 和 导入路径\n钩子。\n元钩子在导入过程开始时被调用，此时任何其他导入过程尚未发生，但 sys.modules 缓存查找除\n外。 这允许元钩子重载 sys.path 过程、冻结模块甚至内置模块。 元钩子的注册是通过向\nsys.meta_path 添加新的查找器对象，具体如下所述。\n导入路径钩子是作为 sys.path (或 package.__path__) 过程的一部分，在遇到它们所关联的路径项\n的时候被调用。 导入路径钩子的注册是通过向 sys.path_hooks 添加新的可调用对象，具体如下所\n述。\n5.3.4. 元路径\n当指定名称的模块在 sys.modules 中找不到时，Python 会接着搜索 sys.meta_path，其中包含元\n路径查找器对象列表。 这些查找器将按顺序被查询以确定它们是否知道如何处理该名称的模块。 元\n路径查找器必须实现名为 find_spec() 的方法，它接受三个参数：名称、导入路径和（可选的）目\n标模块。 元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。\n如果元路径查找器知道如何处理指定名称的模块，它将返回一个说明对象。 如果它不能处理该名称\n的模块，则会返回 None。 如果 sys.meta_path 处理过程到达列表末尾仍未返回说明对象，则将引\n发 ModuleNotFoundError。 任何其他被引发异常将直接向上传播，并放弃导入过程。\n元路径查找器的 find_spec() 方法调用将附带两个或三个参数。 第一个是被导入模块的完整限定名\n称，例如 foo.bar.baz。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参\n数为 None，但对于子模块或子包，第二个参数为父包的 __path__ 属性的值。 如果相应折\n__path__ 属性无法访问，则会引发 ModuleNotFoundError。 第三个参数是将被作为稍后加载目标\n的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。\n对于单个导入请求可以多次遍历元路径。 例如，假设所涉及的模块都尚未被缓存，则导入\nfoo.bar.baz 将首先执行顶级的导入，在每个元路径查找器 (mpf) 上调用 mpf.find_spec(\"foo\",\nNone, None)。 在导入 foo 之后，foo.bar 将通过第二次遍历元路径来导入，调用\nmpf.find_spec(\"foo.bar\", foo.__path__, None)。 一旦 foo.bar 完成导入，最后一次遍历将\n调用 mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)。\n有些元路径查找器只支持顶级导入。 当把 None 以外的对象作为第三个参数传入时，这些导入器将\n总是返回 None。\nPython 的默认 sys.meta_path 具有三种元路径查找器，一种知道如何导入内置模块，一种知道如\n何导入冻结模块，还有一种知道如何导入来自 import path 的模块 (即 path based finder)。 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | mpf.find_spec(\"foo\", |  |  |\n|  |  |  |  |  |  |\n|  |  | None, None) |  |  |  |\n|  |  |  |  |  |  |\n\n在 3.4 版本发生变更: 元路径查找器的 find_spec() 方法替代了 find_module()，后者现已被\n弃用。 虽然它仍将可以不加修改地继续使用，但导入机制仅会在查找器未实现 find_spec()\n时尝试使用它。\n在 3.10 版本发生变更: 导入系统使用 find_module() 现在将引发 ImportWarning。\n在 3.12 版本发生变更: find_module() 已被移除。 请改用 find_spec()。\n5.4. 加载\n当一个模块说明被找到时，导入机制将在加载该模块时使用它（及其所包含的加载器）。 下面是导\n入的加载部分所发生过程的简要说明:\nmodule = None\nif spec.loader is not None and hasattr(spec.loader, 'create_module'):\n# 假定 'exec_module' 也将在该加载器上定义。\nmodule = spec.loader.create_module(spec)\nif module is None:\nmodule = ModuleType(spec.name)\n# 导入相关的模块属性在此设置：\n_init_module_attrs(spec, module)\nif spec.loader is None:\n# 不受支持\nraise ImportError\nif spec.origin is None and spec.submodule_search_locations is not None:\n# 命名空间包\nsys.modules[spec.name] = module\nelif not hasattr(spec.loader, 'exec_module'):\nmodule = spec.loader.load_module(spec.name)\nelse:\nsys.modules[spec.name] = module\ntry:\nspec.loader.exec_module(module)\nexcept BaseException:\ntry:\ndel sys.modules[spec.name]\nexcept KeyError:\npass\nraise\nreturn sys.modules[spec.name]\n请注意以下细节:\n如果在 sys.modules 中存在指定名称的模块对象，导入操作会已经将其返回。\n在加载器执行模块代码之前，该模块将存在于 sys.modules 中。 这一点很关键，因为该模块代\n码可能（直接或间接地）导入其自身；预先将其添加到 sys.modules 可防止在最坏情况下的无限\n递归和最好情况下的多次加载。\n如果加载失败，则该模块 -- 只限加载失败的模块 -- 将从 sys.modules 中移除。 任何已存在于\nsys.modules 缓存的模块，以及任何作为附带影响被成功加载的模块仍会保留在缓存中。 这与重\n新加载不同，后者会把即使加载失败的模块也保留在 sys.modules 中。\n在模块创建完成但还未执行之前，导入机制会设置导入相关模块属性（在上面的示例伪代码中为\n“_init_module_attrs”），详情参见 后续部分。\n\n|  | 在 3.4 版本发生变更: 元路径查找器的 find_spec() 方法替代了 find_module()，后者现已被\n弃用。 虽然它仍将可以不加修改地继续使用，但导入机制仅会在查找器未实现 find_spec()\n时尝试使用它。\n在 3.10 版本发生变更: 导入系统使用 find_module() 现在将引发 ImportWarning。\n在 3.12 版本发生变更: find_module() 已被移除。 请改用 find_spec()。\n5.4. 加载\n当一个模块说明被找到时，导入机制将在加载该模块时使用它（及其所包含的加载器）。 下面是导\n入的加载部分所发生过程的简要说明: |  |\n| --- | --- | --- |\n|  | module = None\nif spec.loader is not None and hasattr(spec.loader, 'create_module'):\n# 假定 'exec_module' 也将在该加载器上定义。\nmodule = spec.loader.create_module(spec)\nif module is None:\nmodule = ModuleType(spec.name)\n# 导入相关的模块属性在此设置：\n_init_module_attrs(spec, module)\nif spec.loader is None:\n# 不受支持\nraise ImportError\nif spec.origin is None and spec.submodule_search_locations is not None:\n# 命名空间包\nsys.modules[spec.name] = module\nelif not hasattr(spec.loader, 'exec_module'):\nmodule = spec.loader.load_module(spec.name)\nelse:\nsys.modules[spec.name] = module\ntry:\nspec.loader.exec_module(module)\nexcept BaseException:\ntry:\ndel sys.modules[spec.name]\nexcept KeyError:\npass\nraise\nreturn sys.modules[spec.name] |  |\n|  | 请注意以下细节:\n如果在 sys.modules 中存在指定名称的模块对象，导入操作会已经将其返回。\n在加载器执行模块代码之前，该模块将存在于 sys.modules 中。 这一点很关键，因为该模块代\n码可能（直接或间接地）导入其自身；预先将其添加到 sys.modules 可防止在最坏情况下的无限\n递归和最好情况下的多次加载。\n如果加载失败，则该模块 -- 只限加载失败的模块 -- 将从 sys.modules 中移除。 任何已存在于\nsys.modules 缓存的模块，以及任何作为附带影响被成功加载的模块仍会保留在缓存中。 这与重\n新加载不同，后者会把即使加载失败的模块也保留在 sys.modules 中。\n在模块创建完成但还未执行之前，导入机制会设置导入相关模块属性（在上面的示例伪代码中为\n“_init_module_attrs”），详情参见 后续部分。 |  |\n\n模块执行是加载的关键时刻，在此期间将填充模块的命名空间。 执行会完全委托给加载器，由加\n载器决定要填充的内容和方式。\n在加载过程中创建并传递给 exec_module() 的模块并不一定就是在导入结束时返回的模块 [2]。\n在 3.4 版本发生变更: 导入系统已经接管了加载器建立样板的责任。 这些在以前是由\nimportlib.abc.Loader.load_module() 方法来执行的。\n5.4.1. 加载器\n模块加载器提供关键的加载功能：模块执行。 导入机制调用\nimportlib.abc.Loader.exec_module() 方法并传入一个参数来执行模块对象。 从\nexec_module() 返回的任何值都将被忽略。\n加载器必须满足下列要求:\n如果模块是一个 Python 模块（而非内置模块或动态加载的扩展），加载器应该在模块的全局命名\n空间 (module.__dict__) 中执行模块的代码。\n如果加载器无法执行指定模块，它应该引发 ImportError，不过在 exec_module() 期间引发的\n任何其他异常也会被传播。\n在许多情况下，查找器和加载器可以是同一对象；在此情况下 find_spec() 方法将返回一个规格说\n明，其中加载器会被设为 self。\n模块加载器可以选择通过实现 create_module() 方法在加载期间创建模块对象。 它接受一个参\n数，即模块规格说明，并返回新的模块对象供加载期间使用。 create_module() 不需要在模块对象\n上设置任何属性。 如果模块返回 None，导入机制将自行创建新模块。\nAdded in version 3.4: 加载器的 create_module() 方法。\n在 3.4 版本发生变更: load_module() 方法被 exec_module() 所替代，导入机制会对加载的所\n有样板责任作出假定。\n为了与现有的加载器兼容，导入机制会使用导入器的 load_module() 方法，如果它存在且导\n入器也未实现 exec_module()。 但是，load_module() 现已弃用，加载器应该转而实现\nexec_module()。\n除了执行模块之外，load_module() 方法必须实现上文描述的所有样板加载功能。 所有相同\n的限制仍然适用，并带有一些附加规定:\n如果 sys.modules 中存在指定名称的模块对象，加载器必须使用已存在的模块。 （否则\nimportlib.reload() 将无法正确工作。） 如果该名称模块不存在于 sys.modules 中，加\n载器必须创建一个新的模块对象并将其加入 sys.modules。\n在加载器执行模块代码之前，模块 必须 存在于 sys.modules 之中，以防止无限递归或多次\n加载。\n如果加载失败，加载器必须移除任何它已加入到 sys.modules 中的模块，但它必须 仅限 移\n除加载失败的模块，且所移除的模块应为加载器自身显式加载的。\n\n|  | 模块执行是加载的关键时刻，在此期间将填充模块的命名空间。 执行会完全委托给加载器，由加\n载器决定要填充的内容和方式。\n在加载过程中创建并传递给 exec_module() 的模块并不一定就是在导入结束时返回的模块 [2]。\n在 3.4 版本发生变更: 导入系统已经接管了加载器建立样板的责任。 这些在以前是由\nimportlib.abc.Loader.load_module() 方法来执行的。\n5.4.1. 加载器\n模块加载器提供关键的加载功能：模块执行。 导入机制调用\nimportlib.abc.Loader.exec_module() 方法并传入一个参数来执行模块对象。 从\nexec_module() 返回的任何值都将被忽略。\n加载器必须满足下列要求:\n如果模块是一个 Python 模块（而非内置模块或动态加载的扩展），加载器应该在模块的全局命名\n空间 (module.__dict__) 中执行模块的代码。\n如果加载器无法执行指定模块，它应该引发 ImportError，不过在 exec_module() 期间引发的\n任何其他异常也会被传播。\n在许多情况下，查找器和加载器可以是同一对象；在此情况下 find_spec() 方法将返回一个规格说\n明，其中加载器会被设为 self。\n模块加载器可以选择通过实现 create_module() 方法在加载期间创建模块对象。 它接受一个参\n数，即模块规格说明，并返回新的模块对象供加载期间使用。 create_module() 不需要在模块对象\n上设置任何属性。 如果模块返回 None，导入机制将自行创建新模块。\nAdded in version 3.4: 加载器的 create_module() 方法。\n在 3.4 版本发生变更: load_module() 方法被 exec_module() 所替代，导入机制会对加载的所\n有样板责任作出假定。\n为了与现有的加载器兼容，导入机制会使用导入器的 load_module() 方法，如果它存在且导\n入器也未实现 exec_module()。 但是，load_module() 现已弃用，加载器应该转而实现\nexec_module()。\n除了执行模块之外，load_module() 方法必须实现上文描述的所有样板加载功能。 所有相同\n的限制仍然适用，并带有一些附加规定:\n如果 sys.modules 中存在指定名称的模块对象，加载器必须使用已存在的模块。 （否则\nimportlib.reload() 将无法正确工作。） 如果该名称模块不存在于 sys.modules 中，加\n载器必须创建一个新的模块对象并将其加入 sys.modules。\n在加载器执行模块代码之前，模块 必须 存在于 sys.modules 之中，以防止无限递归或多次\n加载。\n如果加载失败，加载器必须移除任何它已加入到 sys.modules 中的模块，但它必须 仅限 移\n除加载失败的模块，且所移除的模块应为加载器自身显式加载的。 |  |\n| --- | --- | --- |\n\n在 3.5 版本发生变更: 当 exec_module() 已定义但 create_module() 未定义时将引发\nDeprecationWarning。\n在 3.6 版本发生变更: 当 exec_module() 已定义但 create_module() 未定义时将引发\nImportError。\n在 3.10 版本发生变更: 使用 load_module() 将引发 ImportWarning。\n5.4.2. 子模块\n当使用任意机制 (例如 importlib API, import 及 import-from 语句或者内置的 __import__()) 加\n载一个子模块时，父模块的命名空间中会添加一个对子模块对象的绑定。 例如，如果包 spam 有一\n个子模块 foo，则在导入 spam.foo 之后，spam 将具有一个 绑定到相应子模块的 foo 属性。 假如\n现在有如下的目录结构:\nspam/\n__init__.py\nfoo.py\n并且 spam/__init__.py 中有如下几行内容:\nfrom .foo import Foo\n那么执行如下代码将把 foo 和 Foo 的名称绑定添加到 spam 模块中:\n>>> import spam\n>>> spam.foo\n<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n>>> spam.Foo\n<class 'spam.foo.Foo'>\n按照通常的 Python 名称绑定规则，这看起来可能会令人惊讶，但它实际上是导入系统的一个基本特\n性。 保持不变的一点是如果你有 sys.modules['spam'] 和 sys.modules['spam.foo'] (例如在上\n述导入之后就是如此)，则后者必须显示为前者的 foo 属性。\n5.4.3. 模块规格说明\n导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块\n通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。\n在导入期间使用规格说明可允许状态在导入系统各组件之间传递，例如在创建模块规格说明的查找\n器和执行模块的加载器之间。 最重要的一点是，它允许导入机制执行加载的样板操作，在没有模块\n规格说明的情况下这是加载器的责任。\n模块的规格说明将作为 module.__spec__ 公开。 正确设置 __spec__ 将同时应用于 解释器启动期\n间初始化的模块。 唯一的例外是 __main__，其中的 __spec__ 会 在某些情况下设为 None。\n请参阅 ModuleSpec 了解有关模块规格的详细内容。\nAdded in version 3.4.\n\n|  | 在 3.5 版本发生变更: 当 exec_module() 已定义但 create_module() 未定义时将引发\nDeprecationWarning。\n在 3.6 版本发生变更: 当 exec_module() 已定义但 create_module() 未定义时将引发\nImportError。\n在 3.10 版本发生变更: 使用 load_module() 将引发 ImportWarning。\n5.4.2. 子模块\n当使用任意机制 (例如 importlib API, import 及 import-from 语句或者内置的 __import__()) 加\n载一个子模块时，父模块的命名空间中会添加一个对子模块对象的绑定。 例如，如果包 spam 有一\n个子模块 foo，则在导入 spam.foo 之后，spam 将具有一个 绑定到相应子模块的 foo 属性。 假如\n现在有如下的目录结构: |  |\n| --- | --- | --- |\n|  | spam/\n__init__.py\nfoo.py |  |\n|  | 并且 spam/__init__.py 中有如下几行内容: |  |\n|  | from .foo import Foo |  |\n|  | 那么执行如下代码将把 foo 和 Foo 的名称绑定添加到 spam 模块中: |  |\n|  | >>> import spam\n>>> spam.foo\n<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n>>> spam.Foo\n<class 'spam.foo.Foo'> |  |\n|  | 按照通常的 Python 名称绑定规则，这看起来可能会令人惊讶，但它实际上是导入系统的一个基本特\n性。 保持不变的一点是如果你有 sys.modules['spam'] 和 sys.modules['spam.foo'] (例如在上\n述导入之后就是如此)，则后者必须显示为前者的 foo 属性。\n5.4.3. 模块规格说明\n导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块\n通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。\n在导入期间使用规格说明可允许状态在导入系统各组件之间传递，例如在创建模块规格说明的查找\n器和执行模块的加载器之间。 最重要的一点是，它允许导入机制执行加载的样板操作，在没有模块\n规格说明的情况下这是加载器的责任。\n模块的规格说明将作为 module.__spec__ 公开。 正确设置 __spec__ 将同时应用于 解释器启动期\n间初始化的模块。 唯一的例外是 __main__，其中的 __spec__ 会 在某些情况下设为 None。\n请参阅 ModuleSpec 了解有关模块规格的详细内容。\nAdded in version 3.4. |  |\n\n5.4.4. 模块的 __path__ 属性\n__path__ 属性应当是一个（可能为空的）枚举将用于查找包的子模块的位置的字符串 sequence。\n根据定义，如果一个模块具有 __path__ 属性，它就是一个 package。\n包的 __path__ 属性会在导入其子包期间被使用。 在导入机制内部，它的功能与 sys.path 基本相\n同，即在导入期间提供一个模拟搜索位置列表。 但是，__path__ 相比 sys.path 通常要受到更多\n约束。\n作用于 sys.path 的规则同样适用于包的 __path__。 sys.path_hooks (见下文) 会在遍历包的\n__path__ 时被查询。\n包的 __init__.py 文件可以设置或更改包的 __path__ 属性，而且这是在 PEP 420 之前实现命名空\n间包的典型方式。 随着 PEP 420 的引入，命名空间包不再需要提供仅包含 __path__ 操控代码的\n__init__.py 文件；导入机制会自动为命名空间包正确地设置 __path__。\n5.4.5. 模块的 repr\n默认情况下，全部模块都具有一个可用的 repr，但是你可以依据上述的属性设置，在模块的规格说\n明中更为显式地控制模块对象的 repr。\n如果模块具有 spec (__spec__)，导入机制将尝试用它来生成一个 repr。 如果生成失败或找不到\nspec，导入系统将使用模块中的各种可用信息来制作一个默认 repr。 它将尝试使用\nmodule.__name__, module.__file__ 以及 module.__loader__ 作为 repr 的输入，并将任何丢失\n的信息赋为默认值。\n以下是所使用的确切规则:\n如果模块具有 __spec__ 属性，其中的规格信息会被用来生成 repr。 被查询的属性有 \"name\",\n\"loader\", \"origin\" 和 \"has_location\" 等等。\n如果模块具有 __file__ 属性，这会被用作模块 repr 的一部分。\n如果模块没有 __file__ 但是有 __loader__ 且取值不为 None，则加载器的 repr 会被用作模块\nrepr 的一部分。\n对于其他情况，仅在 repr 中使用模块的 __name__。\n在 3.12 版本发生变更: module_repr() 自 Python 3.4 起已被弃用，在 Python 3.12 中已被移除\n且不会在模块的 repr 计算期间被调用。\n5.4.6. 已缓存字节码的失效\n在 Python 从 .pyc 文件加载已缓存字节码之前，它会检查缓存是否由最新的 .py 源文件所生成。\n默认情况下，Python 通过在所写入缓存文件中保存源文件的最新修改时间戳和大小来实现这一点。\n在运行时，导入系统会通过比对缓存文件中保存的元数据和源文件的元数据确定该缓存的有效性。\nPython 也支持“基于哈希的”缓存文件，即保存源文件内容的哈希值而不是其元数据。 存在两种基于\n哈希的 .pyc 文件：检查型和非检查型。 对于检查型基于哈希的 .pyc 文件，Python 会通过求哈希\n源文件并将结果哈希值与缓存文件中的哈希值比对来确定缓存有效性。 如果检查型基于哈希的缓存\n\n|  | 5.4.4. 模块的 __path__ 属性\n__path__ 属性应当是一个（可能为空的）枚举将用于查找包的子模块的位置的字符串 sequence。\n根据定义，如果一个模块具有 __path__ 属性，它就是一个 package。\n包的 __path__ 属性会在导入其子包期间被使用。 在导入机制内部，它的功能与 sys.path 基本相\n同，即在导入期间提供一个模拟搜索位置列表。 但是，__path__ 相比 sys.path 通常要受到更多\n约束。\n作用于 sys.path 的规则同样适用于包的 __path__。 sys.path_hooks (见下文) 会在遍历包的\n__path__ 时被查询。\n包的 __init__.py 文件可以设置或更改包的 __path__ 属性，而且这是在 PEP 420 之前实现命名空\n间包的典型方式。 随着 PEP 420 的引入，命名空间包不再需要提供仅包含 __path__ 操控代码的\n__init__.py 文件；导入机制会自动为命名空间包正确地设置 __path__。\n5.4.5. 模块的 repr\n默认情况下，全部模块都具有一个可用的 repr，但是你可以依据上述的属性设置，在模块的规格说\n明中更为显式地控制模块对象的 repr。\n如果模块具有 spec (__spec__)，导入机制将尝试用它来生成一个 repr。 如果生成失败或找不到\nspec，导入系统将使用模块中的各种可用信息来制作一个默认 repr。 它将尝试使用\nmodule.__name__, module.__file__ 以及 module.__loader__ 作为 repr 的输入，并将任何丢失\n的信息赋为默认值。\n以下是所使用的确切规则:\n如果模块具有 __spec__ 属性，其中的规格信息会被用来生成 repr。 被查询的属性有 \"name\",\n\"loader\", \"origin\" 和 \"has_location\" 等等。\n如果模块具有 __file__ 属性，这会被用作模块 repr 的一部分。\n如果模块没有 __file__ 但是有 __loader__ 且取值不为 None，则加载器的 repr 会被用作模块\nrepr 的一部分。\n对于其他情况，仅在 repr 中使用模块的 __name__。\n在 3.12 版本发生变更: module_repr() 自 Python 3.4 起已被弃用，在 Python 3.12 中已被移除\n且不会在模块的 repr 计算期间被调用。\n5.4.6. 已缓存字节码的失效\n在 Python 从 .pyc 文件加载已缓存字节码之前，它会检查缓存是否由最新的 .py 源文件所生成。\n默认情况下，Python 通过在所写入缓存文件中保存源文件的最新修改时间戳和大小来实现这一点。\n在运行时，导入系统会通过比对缓存文件中保存的元数据和源文件的元数据确定该缓存的有效性。\nPython 也支持“基于哈希的”缓存文件，即保存源文件内容的哈希值而不是其元数据。 存在两种基于\n哈希的 .pyc 文件：检查型和非检查型。 对于检查型基于哈希的 .pyc 文件，Python 会通过求哈希\n源文件并将结果哈希值与缓存文件中的哈希值比对来确定缓存有效性。 如果检查型基于哈希的缓存 |  |\n| --- | --- | --- |\n\n文件被确定为失效，Python 会重新生成并写入一个新的检查型基于哈希的缓存文件。 对于非检查型\n.pyc 文件，只要其存在 Python 就会直接认定缓存文件有效。 确定基于哈希的 .pyc 文件有效性的\n行为可通过 --check-hash-based-pycs 旗标来重载。\n在 3.7 版本发生变更: 增加了基于哈希的 .pyc 文件。在此之前，Python 只支持基于时间戳来\n确定字节码缓存的有效性。\n5.5. 基于路径的查找器\n在之前已经提及，Python 带有几种默认的元路径查找器。 其中之一是 path based finder\n(PathFinder)，它会搜索包含一个 路径条目 列表的 import path。 每个路径条目指定一个用于搜索\n模块的位置。\n基于路径的查找器自身并不知道如何进行导入。 它只是遍历单独的路径条目，将它们各自关联到某\n个知道如何处理特定类型路径的路径条目查找器。\n默认的路径条目查找器集合实现了在文件系统中查找模块的所有语义，可处理多种特殊文件类型例\n如 Python 源码 (.py 文件)，Python 字节码 (.pyc 文件) 以及共享库 (例如 .so 文件)。 在标准库中\nzipimport 模块的支持下，默认路径条目查找器还能处理所有来自 zip 文件的上述文件类型。\n路径条目不必仅限于文件系统位置。 它们可以指向 URL、数据库查询或可以用字符串指定的任何其\n他位置。\n基于路径的查找器还提供了额外的钩子和协议以便能扩展和定制可搜索路径条目的类型。 例如，如\n果你想要支持网络 URL 形式的路径条目，你可以编写一个实现 HTTP 语义在网络上查找模块的钩\n子。 这个钩子（可调用对象）应当返回一个支持下述协议的 path entry finder，以被用来获取一个\n专门针对来自网络的模块的加载器。\n预先的警告：本节和上节都使用了 查找器 这一术语，并通过 meta path finder 和 path entry finder\n两个术语来明确区分它们。 这两种类型的查找器非常相似，支持相似的协议，且在导入过程中以相\n似的方式运作，但关键的一点是要记住它们是有微妙差异的。 特别地，元路径查找器作用于导入过\n程的开始，主要是启动 sys.meta_path 遍历。\n相比之下，路径条目查找器在某种意义上说是基于路径的查找器的实现细节，实际上，如果需要从\nsys.meta_path 移除基于路径的查找器，并不会有任何路径条目查找器被唤起。\n5.5.1. 路径条目查找器\npath based finder 会负责查找和加载通过 path entry 字符串来指定位置的 Python 模块和包。 多数\n路径条目所指定的是文件系统中的位置，但它们并不必受限于此。\n作为一种元路径查找器，path based finder 实现了上文描述的 find_spec() 协议，但是它还对外公\n开了一些附加钩子，可被用来定制模块如何从 import path 查找和加载。\n有三个变量由 path based finder, sys.path, sys.path_hooks 和 sys.path_importer_cache 所使\n用。 包对象的 __path__ 属性也会被使用。 它们提供了可用于定制导入机制的额外方式。\n\n|  | 文件被确定为失效，Python 会重新生成并写入一个新的检查型基于哈希的缓存文件。 对于非检查型\n.pyc 文件，只要其存在 Python 就会直接认定缓存文件有效。 确定基于哈希的 .pyc 文件有效性的\n行为可通过 --check-hash-based-pycs 旗标来重载。\n在 3.7 版本发生变更: 增加了基于哈希的 .pyc 文件。在此之前，Python 只支持基于时间戳来\n确定字节码缓存的有效性。\n5.5. 基于路径的查找器\n在之前已经提及，Python 带有几种默认的元路径查找器。 其中之一是 path based finder\n(PathFinder)，它会搜索包含一个 路径条目 列表的 import path。 每个路径条目指定一个用于搜索\n模块的位置。\n基于路径的查找器自身并不知道如何进行导入。 它只是遍历单独的路径条目，将它们各自关联到某\n个知道如何处理特定类型路径的路径条目查找器。\n默认的路径条目查找器集合实现了在文件系统中查找模块的所有语义，可处理多种特殊文件类型例\n如 Python 源码 (.py 文件)，Python 字节码 (.pyc 文件) 以及共享库 (例如 .so 文件)。 在标准库中\nzipimport 模块的支持下，默认路径条目查找器还能处理所有来自 zip 文件的上述文件类型。\n路径条目不必仅限于文件系统位置。 它们可以指向 URL、数据库查询或可以用字符串指定的任何其\n他位置。\n基于路径的查找器还提供了额外的钩子和协议以便能扩展和定制可搜索路径条目的类型。 例如，如\n果你想要支持网络 URL 形式的路径条目，你可以编写一个实现 HTTP 语义在网络上查找模块的钩\n子。 这个钩子（可调用对象）应当返回一个支持下述协议的 path entry finder，以被用来获取一个\n专门针对来自网络的模块的加载器。\n预先的警告：本节和上节都使用了 查找器 这一术语，并通过 meta path finder 和 path entry finder\n两个术语来明确区分它们。 这两种类型的查找器非常相似，支持相似的协议，且在导入过程中以相\n似的方式运作，但关键的一点是要记住它们是有微妙差异的。 特别地，元路径查找器作用于导入过\n程的开始，主要是启动 sys.meta_path 遍历。\n相比之下，路径条目查找器在某种意义上说是基于路径的查找器的实现细节，实际上，如果需要从\nsys.meta_path 移除基于路径的查找器，并不会有任何路径条目查找器被唤起。\n5.5.1. 路径条目查找器\npath based finder 会负责查找和加载通过 path entry 字符串来指定位置的 Python 模块和包。 多数\n路径条目所指定的是文件系统中的位置，但它们并不必受限于此。\n作为一种元路径查找器，path based finder 实现了上文描述的 find_spec() 协议，但是它还对外公\n开了一些附加钩子，可被用来定制模块如何从 import path 查找和加载。\n有三个变量由 path based finder, sys.path, sys.path_hooks 和 sys.path_importer_cache 所使\n用。 包对象的 __path__ 属性也会被使用。 它们提供了可用于定制导入机制的额外方式。 |  |\n| --- | --- | --- |\n\nsys.path 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 PYTHONPATH 环境变量以及\n多种其他特定安装和实现专属的默认位置。 sys.path 中的条目可指定文件系统中的目录、zip 文件\n及其他可用于搜索模块的潜在“位置“（参见 site 模块），例如 URL 或数据库查询等。 在 sys.path\n中应当只有字符串；所有其他数据类型都会被忽略。\npath based finder 是一种 meta path finder，因此导入机制会通过调用上文描述的基于路径的查找器\n的 find_spec() 方法来启动 import path 搜索。 当要向 find_spec() 传入 path 参数时，它将是\n一个可遍历的字符串列表 —— 通常为用来在其内部进行导入的包的 __path__ 属性。 如果 path 参\n数为 None，这表示最高层级的导入，将会使用 sys.path。\n基于路径的查找器会迭代搜索路径中的每个条目，并且每次都查找与路径条目对应的 path entry\nfinder (PathEntryFinder)。 因为这种操作可能很耗费资源 (例如搜索会有 stat() 调用的开销)，基\n于路径的查找器会维持一个将路径条目映射到路径条目查找器的缓存。 这个缓存是在\nsys.path_importer_cache 中维护的 (尽管如此命名，但这个缓存实际存放的是查找器对象而非仅\n限于 importer 对象)。 通过这种方式，对特定 path entry 位置的 path entry finder 的高耗费搜索只\n需进行一次。 用户代码可以自由地从 sys.path_importer_cache 移除缓存条目以强制基于路径的\n查找器再次执行路径条目搜索。\n如果路径条目不存在于缓存中，基于路径的查找器会迭代 sys.path_hooks 中的每个可调用对象。\n对此列表中的每个 路径条目钩子 的调用会带有一个参数，即要搜索的路径条目。 每个可调用对象或\n是返回可处理路径条目的 path entry finder，或是引发 ImportError。 基于路径的查找器使用\nImportError 来表示钩子无法找到与 path entry 相对应的 path entry finder。 该异常会被忽略并继\n续进行 import path 的迭代。 每个钩子应该期待接收一个字符串或字节串对象；字节串对象的编码\n由钩子决定（例如可以是文件系统使用的编码 UTF-8 或其它编码），如果钩子无法解码参数，它应\n该引发 ImportError。\n如果 sys.path_hooks 迭代结束时没有返回 path entry finder，则基于路径的查找器 find_spec()\n方法将在 sys.path_importer_cache 中存入 None (表示此路径条目没有对应的查找器) 并返回\nNone，表示此 meta path finder 无法找到该模块。\n如果 sys.path_hooks 中的某个 path entry hook 可调用对象的返回值 是 一个 path entry finder，\n则以下协议会被用来向查找器请求一个模块的规格说明，并在加载该模块时被使用。\n当前工作目录 -- 由一个空字符串表示 -- 的处理方式与 sys.path 中的其他条目略有不同。 首先，\n如果当前工作目录无法被确定或找到，则 sys.path_importer_cache 中不会存放任何值。 其次，\n每次模块查找都会对当前工作目录的值进行全新查找。 第三，由 sys.path_importer_cache 使用\n并由 importlib.machinery.PathFinder.find_spec() 返回的路径将是实际的当前工作目录而非\n空字符串。\n5.5.2. 路径条目查找器协议\n为了支持模块和已初始化包的导入，也为了给命名空间包提供组成部分，路径条目查找器必须实现\nfind_spec() 方法。\nfind_spec() 接受两个参数，即要导入模块的完整限定名称，以及（可选的）目标模块。\nfind_spec() 返回模块的完全填充好的规格说明。 这个规格说明总是包含“加载器”集合（但有一个\n\n|  | sys.path 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 PYTHONPATH 环境变量以及\n多种其他特定安装和实现专属的默认位置。 sys.path 中的条目可指定文件系统中的目录、zip 文件\n及其他可用于搜索模块的潜在“位置“（参见 site 模块），例如 URL 或数据库查询等。 在 sys.path\n中应当只有字符串；所有其他数据类型都会被忽略。\npath based finder 是一种 meta path finder，因此导入机制会通过调用上文描述的基于路径的查找器\n的 find_spec() 方法来启动 import path 搜索。 当要向 find_spec() 传入 path 参数时，它将是\n一个可遍历的字符串列表 —— 通常为用来在其内部进行导入的包的 __path__ 属性。 如果 path 参\n数为 None，这表示最高层级的导入，将会使用 sys.path。\n基于路径的查找器会迭代搜索路径中的每个条目，并且每次都查找与路径条目对应的 path entry\nfinder (PathEntryFinder)。 因为这种操作可能很耗费资源 (例如搜索会有 stat() 调用的开销)，基\n于路径的查找器会维持一个将路径条目映射到路径条目查找器的缓存。 这个缓存是在\nsys.path_importer_cache 中维护的 (尽管如此命名，但这个缓存实际存放的是查找器对象而非仅\n限于 importer 对象)。 通过这种方式，对特定 path entry 位置的 path entry finder 的高耗费搜索只\n需进行一次。 用户代码可以自由地从 sys.path_importer_cache 移除缓存条目以强制基于路径的\n查找器再次执行路径条目搜索。\n如果路径条目不存在于缓存中，基于路径的查找器会迭代 sys.path_hooks 中的每个可调用对象。\n对此列表中的每个 路径条目钩子 的调用会带有一个参数，即要搜索的路径条目。 每个可调用对象或\n是返回可处理路径条目的 path entry finder，或是引发 ImportError。 基于路径的查找器使用\nImportError 来表示钩子无法找到与 path entry 相对应的 path entry finder。 该异常会被忽略并继\n续进行 import path 的迭代。 每个钩子应该期待接收一个字符串或字节串对象；字节串对象的编码\n由钩子决定（例如可以是文件系统使用的编码 UTF-8 或其它编码），如果钩子无法解码参数，它应\n该引发 ImportError。\n如果 sys.path_hooks 迭代结束时没有返回 path entry finder，则基于路径的查找器 find_spec()\n方法将在 sys.path_importer_cache 中存入 None (表示此路径条目没有对应的查找器) 并返回\nNone，表示此 meta path finder 无法找到该模块。\n如果 sys.path_hooks 中的某个 path entry hook 可调用对象的返回值 是 一个 path entry finder，\n则以下协议会被用来向查找器请求一个模块的规格说明，并在加载该模块时被使用。\n当前工作目录 -- 由一个空字符串表示 -- 的处理方式与 sys.path 中的其他条目略有不同。 首先，\n如果当前工作目录无法被确定或找到，则 sys.path_importer_cache 中不会存放任何值。 其次，\n每次模块查找都会对当前工作目录的值进行全新查找。 第三，由 sys.path_importer_cache 使用\n并由 importlib.machinery.PathFinder.find_spec() 返回的路径将是实际的当前工作目录而非\n空字符串。\n5.5.2. 路径条目查找器协议\n为了支持模块和已初始化包的导入，也为了给命名空间包提供组成部分，路径条目查找器必须实现\nfind_spec() 方法。\nfind_spec() 接受两个参数，即要导入模块的完整限定名称，以及（可选的）目标模块。\nfind_spec() 返回模块的完全填充好的规格说明。 这个规格说明总是包含“加载器”集合（但有一个 |  |\n| --- | --- | --- |\n\n例外）。\n为了向导入机制提示该规格说明代表一个命名空间 portion，路径条目查找器会将\nsubmodule_search_locations 设为一个包含该部分的列表。\n在 3.4 版本发生变更: find_spec() 替代了 find_loader() 和 find_module()，这两者现在\n都已被弃用，但会在 find_spec() 未定义时被使用。\n较旧的路径条目查找器可能会实现这两个已弃用的方法中的一个而没有实现 find_spec()。\n为保持向后兼容，这两个方法仍会被接受。 但是，如果在路径条目查找器上实现了\nfind_spec()，这两个遗留方法就会被忽略。\nfind_loader() 接受一个参数，即要导入模块的完整限定名称。 find_loader() 返回一个 2\n元组，其中第一项是加载器而第二项是命名空间 portion。\n为了向后兼容其他导入协议的实现，许多路径条目查找器也同样支持元路径查找器所支持的传\n统 find_module() 方法。 但是路径条目查找器 find_module() 方法的调用绝不会带有 path\n参数（它们被期望记录来自对路径钩子初始调用的恰当路径信息）。\n路径条目查找器的 find_module() 方法已弃用，因为它不允许路径条目查找器为命名空间包\n提供部分。 如果 find_loader() 和 find_module() 同时存在于一个路径条目查找器中，导\n入系统将总是调用 find_loader() 而不选择 find_module()。\n在 3.10 版本发生变更: 导入系统对 find_module() 和 find_loader() 的调用将引发\nImportWarning。\n在 3.12 版本发生变更: find_module() 和 find_loader() 已被移除。\n5.6. 替换标准导入系统\n替换整个导入系统的最可靠机制是移除 sys.meta_path 的默认内容，,将其完全替换为自定义的元路\n径钩子。\n一个可行的方式是仅改变导入语句的行为而不影响访问导入系统的其他 API，那么替换内置的\n__import__() 函数可能就够了。 这种技巧也可以在模块层级上运用，即只在某个模块内部改变导\n入语句的行为。\n想要选择性地预先防止在元路径上从一个钩子导入某些模块（而不是完全禁用标准导入系统），只\n需直接从 find_spec() 引发 ModuleNotFoundError 而非返回 None 就足够了。 返回后者表示元路\n径搜索应当继续，而引发异常则会立即终止搜索。\n5.7. 包相对导入\n相对导入使用前缀点号。 一个前缀点号表示相对导入从当前包开始。 两个或更多前缀点号表示对当\n前包的上级包的相对导入，第一个点号之后的每个点号代表一级。 例如，给定以下的包布局结构:\npackage/\n__init__.py\n\n|  | 例外）。\n为了向导入机制提示该规格说明代表一个命名空间 portion，路径条目查找器会将\nsubmodule_search_locations 设为一个包含该部分的列表。\n在 3.4 版本发生变更: find_spec() 替代了 find_loader() 和 find_module()，这两者现在\n都已被弃用，但会在 find_spec() 未定义时被使用。\n较旧的路径条目查找器可能会实现这两个已弃用的方法中的一个而没有实现 find_spec()。\n为保持向后兼容，这两个方法仍会被接受。 但是，如果在路径条目查找器上实现了\nfind_spec()，这两个遗留方法就会被忽略。\nfind_loader() 接受一个参数，即要导入模块的完整限定名称。 find_loader() 返回一个 2\n元组，其中第一项是加载器而第二项是命名空间 portion。\n为了向后兼容其他导入协议的实现，许多路径条目查找器也同样支持元路径查找器所支持的传\n统 find_module() 方法。 但是路径条目查找器 find_module() 方法的调用绝不会带有 path\n参数（它们被期望记录来自对路径钩子初始调用的恰当路径信息）。\n路径条目查找器的 find_module() 方法已弃用，因为它不允许路径条目查找器为命名空间包\n提供部分。 如果 find_loader() 和 find_module() 同时存在于一个路径条目查找器中，导\n入系统将总是调用 find_loader() 而不选择 find_module()。\n在 3.10 版本发生变更: 导入系统对 find_module() 和 find_loader() 的调用将引发\nImportWarning。\n在 3.12 版本发生变更: find_module() 和 find_loader() 已被移除。\n5.6. 替换标准导入系统\n替换整个导入系统的最可靠机制是移除 sys.meta_path 的默认内容，,将其完全替换为自定义的元路\n径钩子。\n一个可行的方式是仅改变导入语句的行为而不影响访问导入系统的其他 API，那么替换内置的\n__import__() 函数可能就够了。 这种技巧也可以在模块层级上运用，即只在某个模块内部改变导\n入语句的行为。\n想要选择性地预先防止在元路径上从一个钩子导入某些模块（而不是完全禁用标准导入系统），只\n需直接从 find_spec() 引发 ModuleNotFoundError 而非返回 None 就足够了。 返回后者表示元路\n径搜索应当继续，而引发异常则会立即终止搜索。\n5.7. 包相对导入\n相对导入使用前缀点号。 一个前缀点号表示相对导入从当前包开始。 两个或更多前缀点号表示对当\n前包的上级包的相对导入，第一个点号之后的每个点号代表一级。 例如，给定以下的包布局结构: |  |\n| --- | --- | --- |\n|  | package/\n__init__.py |  |\n\nsubpackage1/\n__init__.py\nmoduleX.py\nmoduleY.py\nsubpackage2/\n__init__.py\nmoduleZ.py\nmoduleA.py\n不论是在 subpackage1/moduleX.py 还是 subpackage1/__init__.py 中，以下导入都是有效的:\nfrom .moduleY import spam\nfrom .moduleY import spam as ham\nfrom . import moduleY\nfrom ..subpackage1 import moduleY\nfrom ..subpackage2.moduleZ import eggs\nfrom ..moduleA import foo\n绝对导入可以使用 import <> 或 from <> import <> 语法，但相对导入只能使用第二种形式；其\n中的原因在于:\nimport XXX.YYY.ZZZ\n应当提供 XXX.YYY.ZZZ 作为可用表达式，但 .moduleY 不是一个有效的表达式。\n5.8. 有关 __main__ 的特殊事项\n对于 Python 的导入系统来说 __main__ 模块是一个特殊情况。 正如在 另一节 中所述，__main__\n模块是在解释器启动时直接初始化的，与 sys 和 builtins 很类似。 但是，与那两者不同，它并不\n被严格归类为内置模块。 这是因为 __main__ 被初始化的方式依赖于唤起解释器所附带的旗标和其\n他选项。\n5.8.1. __main__.__spec__\n根据 __main__ 被初始化的方式，__main__.__spec__ 会被设置相应值或是 None。\n当 Python 附加 -m 选项启动时，__spec__ 会被设为相应模块或包的模块规格说明。 __spec__ 也\n会在 __main__ 模块作为执行某个目录，zip 文件或其它 sys.path 条目的一部分加载时被填充。\n在 其余的情况 下 __main__.__spec__ 会被设为 None，因为用于填充 __main__ 的代码不直接与可\n导入的模块相对应:\n交互型提示\n-c 选项\n从 stdin 运行\n直接从源码或字节码文件运行\n请注意在最后一种情况中 __main__.__spec__ 总是为 None，即使 文件从技术上说可以作为一个模\n块被导入。 如果想要让 __main__ 中的元数据生效，请使用 -m 开关。\n\n|  | subpackage1/\n__init__.py\nmoduleX.py\nmoduleY.py\nsubpackage2/\n__init__.py\nmoduleZ.py\nmoduleA.py |  |\n| --- | --- | --- |\n|  | 不论是在 subpackage1/moduleX.py 还是 subpackage1/__init__.py 中，以下导入都是有效的: |  |\n|  | from .moduleY import spam\nfrom .moduleY import spam as ham\nfrom . import moduleY\nfrom ..subpackage1 import moduleY\nfrom ..subpackage2.moduleZ import eggs\nfrom ..moduleA import foo |  |\n|  | 绝对导入可以使用 import <> 或 from <> import <> 语法，但相对导入只能使用第二种形式；其\n中的原因在于: |  |\n|  | import XXX.YYY.ZZZ |  |\n|  | 应当提供 XXX.YYY.ZZZ 作为可用表达式，但 .moduleY 不是一个有效的表达式。\n5.8. 有关 __main__ 的特殊事项\n对于 Python 的导入系统来说 __main__ 模块是一个特殊情况。 正如在 另一节 中所述，__main__\n模块是在解释器启动时直接初始化的，与 sys 和 builtins 很类似。 但是，与那两者不同，它并不\n被严格归类为内置模块。 这是因为 __main__ 被初始化的方式依赖于唤起解释器所附带的旗标和其\n他选项。\n5.8.1. __main__.__spec__\n根据 __main__ 被初始化的方式，__main__.__spec__ 会被设置相应值或是 None。\n当 Python 附加 -m 选项启动时，__spec__ 会被设为相应模块或包的模块规格说明。 __spec__ 也\n会在 __main__ 模块作为执行某个目录，zip 文件或其它 sys.path 条目的一部分加载时被填充。\n在 其余的情况 下 __main__.__spec__ 会被设为 None，因为用于填充 __main__ 的代码不直接与可\n导入的模块相对应:\n交互型提示\n-c 选项\n从 stdin 运行\n直接从源码或字节码文件运行\n请注意在最后一种情况中 __main__.__spec__ 总是为 None，即使 文件从技术上说可以作为一个模\n块被导入。 如果想要让 __main__ 中的元数据生效，请使用 -m 开关。 |  |\n\n还要注意即使是在 __main__ 对应于一个可导入模块且 __main__.__spec__ 被相应地设定时，它们\n仍会被视为 不同的 模块。 这是由于以下事实：使用 if __name__ == \"__main__\": 检测来保护的\n代码块仅会在模块被用来填充 __main__ 命名空间时而非普通的导入时被执行。\n5.9. 参考文献\n导入机制自 Python 诞生之初至今已发生了很大的变化。 原始的 包规格说明 仍然可以查阅，但在撰\n写该文档之后许多相关细节已被修改。\n原始的 sys.meta_path 规格说明见 PEP 302，后续的扩展说明见 PEP 420。\nPEP 420 为 Python 3.3 引入了 命名空间包。 PEP 420 还引入了 find_loader() 协议作为\nfind_module() 的替代。\nPEP 366 描述了新增的 __package__ 属性，用于在模块中的显式相对导入。\nPEP 328 引入了绝对和显式相对导入，并初次提出了 __name__ 语义，最终由 PEP 366 为\n__package__ 加入规范描述。\nPEP 338 定义了将模块作为脚本执行。\nPEP 451 在 spec 对象中增加了对每个模块导入状态的封装。 它还将加载器的大部分样板责任移交回\n导入机制中。 这些改变允许弃用导入系统中的一些 API 并为查找器和加载器增加一些新的方法。\n备注\n[1] 参见 types.ModuleType。\n[2] importlib 实现避免直接使用返回值。 而是通过在 sys.modules 中查找模块名称来获取模块对\n象。 这种方式的间接影响是被导入的模块可能在 sys.modules 中替换其自身。 这属于具体实\n现的特定行为，不保证能在其他 Python 实现中起作用。", "metadata": {"title": "05_导入系统", "source": "md_docs\\python_reference_md\\05_导入系统.md", "doc_type": "语言参考", "language": "中文", "doc_id": "ad5d721c"}}
{"doc_id": "9597aea9", "content": "6. 表达式\n本章将解释 Python 中组成表达式的各种元素的的含义。\n语法注释: 在本章和后续章节中，会使用扩展 BNF 标注来描述语法而不是词法分析。 当（某种替代\n的）语法规则具有如下形式\nname: othername\n并且没有给出语义，则这种形式的 name 在语法上与 othername 相同。\n6.1. 算术转换\n如果在下面某个算术运算符的描述中使用了“数字参数被转换为普通实数类型”这样的说法，则意味着\n针对内置类型的运算符实现的作用方式如下：\n如果两个参数均为复数，则不会执行任何转换；\n如果任一参数为复数或浮点数，另一参数将被转换为浮点数；\n否则，两者应该都为整数，不需要进行转换。\n某些附加规则会作用于特定运算符（例如，字符串作为 '%' 运算符的左运算参数）。 扩展必须定义\n它们自己的转换行为。\n6.2. 原子\n“原子”指表达式的最基本构成元素。 最简单的原子是标识符和字面值。 以圆括号、方括号或花括号\n包括的形式在语法上也被归类为原子。 原子的句法为:\natom: identifier | literal | enclosure\nenclosure: parenth_form | list_display | dict_display | set_display\n| generator_expression | yield_atom\n6.2.1. 标识符（名称）\n作为原子出现的标识符叫做名称。 请参看 名称（标识符和关键字） 一节了解其词法定义，以及 命\n名与绑定 获取有关命名与绑定的文档。\n当名称被绑定到一个对象时，对该原子求值将返回相应对象。 当名称未被绑定时，尝试对其求值将\n引发 NameError 异常。\n6.2.1.1. 私有名称的 mangling\n当类定义中出现的标识符，以两个或更多下划线开头，并且不以两个或更多下划线结尾，就称它为\n类的 private name 。\n\n| 6. 表达式\n本章将解释 Python 中组成表达式的各种元素的的含义。\n语法注释: 在本章和后续章节中，会使用扩展 BNF 标注来描述语法而不是词法分析。 当（某种替代\n的）语法规则具有如下形式 |\n| --- |\n| name: othername |\n| 并且没有给出语义，则这种形式的 name 在语法上与 othername 相同。\n6.1. 算术转换\n如果在下面某个算术运算符的描述中使用了“数字参数被转换为普通实数类型”这样的说法，则意味着\n针对内置类型的运算符实现的作用方式如下：\n如果两个参数均为复数，则不会执行任何转换；\n如果任一参数为复数或浮点数，另一参数将被转换为浮点数；\n否则，两者应该都为整数，不需要进行转换。\n某些附加规则会作用于特定运算符（例如，字符串作为 '%' 运算符的左运算参数）。 扩展必须定义\n它们自己的转换行为。\n6.2. 原子\n“原子”指表达式的最基本构成元素。 最简单的原子是标识符和字面值。 以圆括号、方括号或花括号\n包括的形式在语法上也被归类为原子。 原子的句法为: |\n| atom: identifier | literal | enclosure\nenclosure: parenth_form | list_display | dict_display | set_display\n| generator_expression | yield_atom |\n| 6.2.1. 标识符（名称）\n作为原子出现的标识符叫做名称。 请参看 名称（标识符和关键字） 一节了解其词法定义，以及 命\n名与绑定 获取有关命名与绑定的文档。\n当名称被绑定到一个对象时，对该原子求值将返回相应对象。 当名称未被绑定时，尝试对其求值将\n引发 NameError 异常。\n6.2.1.1. 私有名称的 mangling\n当类定义中出现的标识符，以两个或更多下划线开头，并且不以两个或更多下划线结尾，就称它为\n类的 private name 。 |\n\n参见: 类规范说明。\n更具体地，私有名称在其字节码生成之前即被转为更长的名字。如果转换后的名字长于255字符，实\n现可以决定缩短。\n这一转换过程和标识符使用的语法上下文无关，仅有以下几种私有标识符会被mangle：\n用作被分配或读取的变量的名字的，或者用作被访问的属性的名字的。\n但是嵌套的函数、类和类型别名的 __name__ 属性不会被 mangle。\n导入的模块的名称，例如 import __spam 中的 __spam。 若模块属于一个包（即它的名称中有点\n号），这个名称 不会 被 mangle，比如 import __foo.bar 中的 __foo 不会被 mangle。\n导入的成员的名称，比如 from spam import __f 中的 __f。\n转换规则的定义如下：\n类名称，先移除全部的开头下划线并插入一个开头下划线，再插入到标识符的前面，例如出现在\n名为 Foo, _Foo 或 __Foo 类中的标识符 __spam 将被转换为 _Foo__spam。\n如果类名称仅由下划线组成，则转换为标识符本身，例如出现在名为 _ 或 __ 类中的标识符\n__spam 将保持原样。\n6.2.2. 字面值\nPython 支持字符串和字节串字面值，以及几种数字字面值:\nliteral: strings | NUMBER\n对字面值求值将返回一个该值所对应类型的对象（字符串、字节串、整数、浮点数、复数）。 对于\n浮点数和虚数（复数）的情况，该值可能为近似值。 详情参见 字面量 小节。有关 string 的详细信\n息，请参阅 字符串字面值合并 小节。\n所有字面值都对应于不可变数据类型，因此对象标识的重要性不如其实际值。 多次对具有相同值的\n字面值求值（不论是发生在程序文本的相同位置还是不同位置）可能得到相同对象或是具有相同值\n的不同对象。\n6.2.2.1. 字符串字面值合并\n允许多个相邻的字符串或字节字面量（以空白符分隔）可以使用不同的引号约定，其含义与将这些\n字面量拼接后的结果相同:\n>>> \"hello\" 'world'\n\"helloworld\"\n形式上：\nstrings: ( STRING | fstring)+ | tstring+\n\n|  | 参见: 类规范说明。 |  |\n| --- | --- | --- |\n|  | 更具体地，私有名称在其字节码生成之前即被转为更长的名字。如果转换后的名字长于255字符，实\n现可以决定缩短。\n这一转换过程和标识符使用的语法上下文无关，仅有以下几种私有标识符会被mangle：\n用作被分配或读取的变量的名字的，或者用作被访问的属性的名字的。\n但是嵌套的函数、类和类型别名的 __name__ 属性不会被 mangle。\n导入的模块的名称，例如 import __spam 中的 __spam。 若模块属于一个包（即它的名称中有点\n号），这个名称 不会 被 mangle，比如 import __foo.bar 中的 __foo 不会被 mangle。\n导入的成员的名称，比如 from spam import __f 中的 __f。\n转换规则的定义如下：\n类名称，先移除全部的开头下划线并插入一个开头下划线，再插入到标识符的前面，例如出现在\n名为 Foo, _Foo 或 __Foo 类中的标识符 __spam 将被转换为 _Foo__spam。\n如果类名称仅由下划线组成，则转换为标识符本身，例如出现在名为 _ 或 __ 类中的标识符\n__spam 将保持原样。\n6.2.2. 字面值\nPython 支持字符串和字节串字面值，以及几种数字字面值: |  |\n|  | literal: strings | NUMBER |  |\n|  | 对字面值求值将返回一个该值所对应类型的对象（字符串、字节串、整数、浮点数、复数）。 对于\n浮点数和虚数（复数）的情况，该值可能为近似值。 详情参见 字面量 小节。有关 string 的详细信\n息，请参阅 字符串字面值合并 小节。\n所有字面值都对应于不可变数据类型，因此对象标识的重要性不如其实际值。 多次对具有相同值的\n字面值求值（不论是发生在程序文本的相同位置还是不同位置）可能得到相同对象或是具有相同值\n的不同对象。\n6.2.2.1. 字符串字面值合并\n允许多个相邻的字符串或字节字面量（以空白符分隔）可以使用不同的引号约定，其含义与将这些\n字面量拼接后的结果相同: |  |\n|  | >>> \"hello\" 'world'\n\"helloworld\" |  |\n|  | 形式上： |  |\n|  | strings: ( STRING | fstring)+ | tstring+ |  |\n|  |  |  |\n\n此特性是在语法层面定义的，因此仅适用于字面量。若要在运行时拼接字符串表达式，可以使用 '+'\n运算符:\n>>> greeting = \"Hello\"\n>>> space = \" \"\n>>> name = \"Blaise\"\n>>> print(greeting + space + name) # 不是: print(greeting space name)\nHello Blaise\n字面量拼接可以自由混合原始字符串、三引号字符串和格式化字符串字面量。例如:\n>>> \"Hello\" r', ' f\"{name}!\"\n\"Hello, Blaise!\"\n此特性可用于减少所需的反斜杠数量，方便地将长字符串分割到多行，甚至还能为字符串的特定部\n分添加注释。例如:\nre.compile(\"[A-Za-z_]\" # 字母或下划线\n\"[A-Za-z0-9_]*\" # 字母、数字或下划线\n)\n不过，字节字面量只能与其他字节字面量组合，不能与任何类型的字符串字面量组合。此外，模板\n字符串字面量也只能与其他模板字符串字面量组合。\n>>> t\"Hello\" t\"{name}!\"\nTemplate(strings=('Hello', '!'), interpolations=(...))\n6.2.3. 带圆括号的形式\n带圆括号的形式是包含在圆括号中的可选表达式列表。\nparenth_form: \"(\" [starred_expression] \")\"\n带圆括号的表达式列表将返回该表达式列表所产生的任何东西：如果该列表包含至少一个逗号，它\n会产生一个元组；否则，它会产生该表达式列表所对应的单一表达式。\n一对内容为空的圆括号将产生一个空的元组对象。 由于元组是不可变对象，因此适用与字面值相同\n的规则（即两次出现的空元组产生的对象可能相同也可能不同）。\n请注意元组并不是由圆括号构建的，实际起作用的是逗号。 例外情况是空元组，这时圆括号 才是 必\n须的 --- 允许在表达式中使用不带圆括号的“空”会导致歧义并会造成常见输入错误无法被捕获。\n6.2.4. 列表、集合与字典的显示\n为了构建列表、集合或字典，Python 提供了名为“显示”的特殊句法，每个类型各有两种形式:\n第一种是显式地列出容器内容\n第二种是通过一组循环和筛选指令计算出来，称为 推导式。\n推导式的常用句法元素为:\n\n|  | 此特性是在语法层面定义的，因此仅适用于字面量。若要在运行时拼接字符串表达式，可以使用 '+'\n运算符: |  |\n| --- | --- | --- |\n|  | >>> greeting = \"Hello\"\n>>> space = \" \"\n>>> name = \"Blaise\"\n>>> print(greeting + space + name) # 不是: print(greeting space name)\nHello Blaise |  |\n|  | 字面量拼接可以自由混合原始字符串、三引号字符串和格式化字符串字面量。例如: |  |\n|  | >>> \"Hello\" r', ' f\"{name}!\"\n\"Hello, Blaise!\" |  |\n|  | 此特性可用于减少所需的反斜杠数量，方便地将长字符串分割到多行，甚至还能为字符串的特定部\n分添加注释。例如: |  |\n|  | re.compile(\"[A-Za-z_]\" # 字母或下划线\n\"[A-Za-z0-9_]*\" # 字母、数字或下划线\n) |  |\n|  | 不过，字节字面量只能与其他字节字面量组合，不能与任何类型的字符串字面量组合。此外，模板\n字符串字面量也只能与其他模板字符串字面量组合。 |  |\n|  | >>> t\"Hello\" t\"{name}!\"\nTemplate(strings=('Hello', '!'), interpolations=(...)) |  |\n|  | 6.2.3. 带圆括号的形式\n带圆括号的形式是包含在圆括号中的可选表达式列表。 |  |\n|  | parenth_form: \"(\" [starred_expression] \")\" |  |\n|  | 带圆括号的表达式列表将返回该表达式列表所产生的任何东西：如果该列表包含至少一个逗号，它\n会产生一个元组；否则，它会产生该表达式列表所对应的单一表达式。\n一对内容为空的圆括号将产生一个空的元组对象。 由于元组是不可变对象，因此适用与字面值相同\n的规则（即两次出现的空元组产生的对象可能相同也可能不同）。\n请注意元组并不是由圆括号构建的，实际起作用的是逗号。 例外情况是空元组，这时圆括号 才是 必\n须的 --- 允许在表达式中使用不带圆括号的“空”会导致歧义并会造成常见输入错误无法被捕获。\n6.2.4. 列表、集合与字典的显示\n为了构建列表、集合或字典，Python 提供了名为“显示”的特殊句法，每个类型各有两种形式:\n第一种是显式地列出容器内容\n第二种是通过一组循环和筛选指令计算出来，称为 推导式。\n推导式的常用句法元素为: |  |\n\ncomprehension: assignment_expression comp_for\ncomp_for: [\"async\"] \"for\" target_list \"in\" or_test [comp_iter]\ncomp_iter: comp_for | comp_if\ncomp_if: \"if\" or_test [comp_iter]\n推导式的结构是一个单独表达式后面加至少一个 for 子句以及零个或更多个 for 或 if 子句。 在这\n种情况下，新容器的元素产生方式是将每个 for 或 if 子句视为一个代码块，按从左至右的顺序嵌\n套，然后每次到达最内层代码块时就对表达式进行求值以产生一个元素。\n不过，除了最左边 for 子句中的可迭代表达式，推导式是在另一个隐式嵌套的作用域内执行的。 这\n能确保赋给目标列表的名称不会“泄露”到外层的作用域。\n最左边的 for 子句中的可迭代对象表达式会直接在外层作用域中被求值，然后作为一个参数被传给\n隐式嵌套的作用域。 后续的 for 子句以及最左侧 for 子句中的任何筛选条件不能在外层作用域中被\n求值，因为它们可能依赖于从最左侧可迭代对象中获得的值。 例如: [x*y for x in range(10)\nfor y in range(x, x+10)]。\n为了确保推导式得出的结果总是一个类型正确的容器，在隐式嵌套作用域内禁止使用 yield 和\nyield from 表达式。\n从 Python 3.6 开始，在 async def 函数中，可以使用 async for 子句来迭代 asynchronous\niterator。 在 async def 函数中的推导式可以由打头的表达式后跟一个 for 或 async for 子句组\n成，并可能包含附加的 for 或 async for 子句，还可能使用 await 表达式。\n如果一个推导式包含 async for 子句，或者如果它在最左侧的 for 子句中可迭代对象表达式以外的\n任何地方包含 await 表达式或其他异步推导式，那它就被称为 asynchronous comprehension。 异步\n推导式可以挂起它所在的协程函数的执行。 另请参阅 PEP 530。\nAdded in version 3.6: 引入了异步推导式。\n在 3.8 版本发生变更: yield 和 yield from 在隐式嵌套的作用域中已被禁用。\n在 3.11 版本发生变更: 现在允许在异步函数的推导式中使用异步推导式。 外部推导式将隐式地\n转为异步的。\n6.2.5. 列表显示\n列表显示是一个用方括号括起来的可能为空的表达式系列:\nlist_display: \"[\" [flexible_expression_list | comprehension] \"]\"\n列表显示会产生一个新的列表对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号\n分隔的一系列表达式时，其元素会从左至右被求值并按此顺序放入列表对象。 当提供一个推导式\n时，列表会根据推导式所产生的结果元素进行构建。\n6.2.6. 集合显示\n集合显示是用花括号标明的，与字典显示的区别在于没有冒号分隔的键和值:\n\n|  |  | comprehension: assignment_expression comp_for\ncomp_for: [\"async\"] \"for\" target_list \"in\" or_test [comp_iter]\ncomp_iter: comp_for | comp_if\ncomp_if: \"if\" or_test [comp_iter] |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | 推导式的结构是一个单独表达式后面加至少一个 for 子句以及零个或更多个 for 或 if 子句。 在这\n种情况下，新容器的元素产生方式是将每个 for 或 if 子句视为一个代码块，按从左至右的顺序嵌\n套，然后每次到达最内层代码块时就对表达式进行求值以产生一个元素。\n不过，除了最左边 for 子句中的可迭代表达式，推导式是在另一个隐式嵌套的作用域内执行的。 这\n能确保赋给目标列表的名称不会“泄露”到外层的作用域。\n最左边的 for 子句中的可迭代对象表达式会直接在外层作用域中被求值，然后作为一个参数被传给\n隐式嵌套的作用域。 后续的 for 子句以及最左侧 for 子句中的任何筛选条件不能在外层作用域中被\n求值，因为它们可能依赖于从最左侧可迭代对象中获得的值。 例如: [x*y for x in range(10)\nfor y in range(x, x+10)]。\n为了确保推导式得出的结果总是一个类型正确的容器，在隐式嵌套作用域内禁止使用 yield 和\nyield from 表达式。\n从 Python 3.6 开始，在 async def 函数中，可以使用 async for 子句来迭代 asynchronous\niterator。 在 async def 函数中的推导式可以由打头的表达式后跟一个 for 或 async for 子句组\n成，并可能包含附加的 for 或 async for 子句，还可能使用 await 表达式。\n如果一个推导式包含 async for 子句，或者如果它在最左侧的 for 子句中可迭代对象表达式以外的\n任何地方包含 await 表达式或其他异步推导式，那它就被称为 asynchronous comprehension。 异步\n推导式可以挂起它所在的协程函数的执行。 另请参阅 PEP 530。\nAdded in version 3.6: 引入了异步推导式。\n在 3.8 版本发生变更: yield 和 yield from 在隐式嵌套的作用域中已被禁用。\n在 3.11 版本发生变更: 现在允许在异步函数的推导式中使用异步推导式。 外部推导式将隐式地\n转为异步的。\n6.2.5. 列表显示\n列表显示是一个用方括号括起来的可能为空的表达式系列: |  |  |  |\n|  |  |  | [x*y for x in range(10) |  |  |\n|  |  |  |  |  |  |\n|  |  | for y in range(x, x+10)] |  |  |  |\n|  |  |  |  |  |  |\n|  |  | list_display: \"[\" [flexible_expression_list | comprehension] \"]\" |  |  |  |\n|  |  | 列表显示会产生一个新的列表对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号\n分隔的一系列表达式时，其元素会从左至右被求值并按此顺序放入列表对象。 当提供一个推导式\n时，列表会根据推导式所产生的结果元素进行构建。\n6.2.6. 集合显示\n集合显示是用花括号标明的，与字典显示的区别在于没有冒号分隔的键和值: |  |  |  |\n\nset_display: \"{\" (flexible_expression_list | comprehension) \"}\"\n集合显示会产生一个新的可变集合对象，其内容通过一系列表达式或一个推导式来指定。 当提供由\n逗号分隔的一系列表达式时，其元素会从左至右被求值并加入到集合对象。 当提供一个推导式时，\n集合会根据推导式所产生的结果元素进行构建。\n空集合不能用 {} 来构建；该字面值所构建的是一个空字典。\n6.2.7. 字典显示\n字典显示是一个用花括号括起来的可能为空的字典条目（键/值对）系列:\ndict_display: \"{\" [dict_item_list | dict_comprehension] \"}\"\ndict_item_list: dict_item (\",\" dict_item)* [\",\"]\ndict_item: expression \":\" expression | \"**\" or_expr\ndict_comprehension: expression \":\" expression comp_for\n字典显示会产生一个新的字典对象。\n如果给出一个由逗号分隔的字典条目序列，它们会从左至右被求值以定义字典的条目：每个键对象\n会被用作字典中存放相应值的键。 这意味着你可以在字典条目列表中多次指定相同的键，而最终字\n典的值将由最后一次给出的键决定。\n双星号 ** 表示 字典拆包。 它的操作数必须是一个 mapping。 每个映射项会被加入到新的字典。\n后续的值会替换先前的字典项和先前的字典拆包所设置的值。\nAdded in version 3.5: 拆包到字典显示，最初由 PEP 448 提出。\n字典推导式与列表和集合推导式有所不同，它需要以冒号分隔的两个表达式，后面带上标准的 \"for\"\n和 \"if\" 子句。 当推导式被执行时，作为结果的键和值元素会按它们的产生顺序被加入新的字典。\n对键的取值类型的限制已列在之前的 标准类型层级结构 一节中。 （总的说来，键的类型应为\nhashable，这就排除了所有可变对象。） 重复键之间的冲突不会被检测；指定键所保存的最后一个\n值（即在显示中排最右边的文本）将为最终的值。\n在 3.8 版本发生变更: 在 Python 3.8 之前的字典推导式中，并没有定义好键和值的求值顺序。\n在 CPython 中，值会先于键被求值。 根据 PEP 572 的提议，从 3.8 开始，键会先于值被求\n值。\n6.2.8. 生成器表达式\n生成器表达式是用圆括号括起来的紧凑形式生成器标注。\ngenerator_expression: \"(\" expression comp_for \")\"\n生成器表达式会产生一个新的生成器对象。 其句法与推导式相同，区别在于它是用圆括号而不是用\n方括号或花括号括起来的。\n\n|  | set_display: \"{\" (flexible_expression_list | comprehension) \"}\" |  |\n| --- | --- | --- |\n|  | 集合显示会产生一个新的可变集合对象，其内容通过一系列表达式或一个推导式来指定。 当提供由\n逗号分隔的一系列表达式时，其元素会从左至右被求值并加入到集合对象。 当提供一个推导式时，\n集合会根据推导式所产生的结果元素进行构建。\n空集合不能用 {} 来构建；该字面值所构建的是一个空字典。\n6.2.7. 字典显示\n字典显示是一个用花括号括起来的可能为空的字典条目（键/值对）系列: |  |\n|  | dict_display: \"{\" [dict_item_list | dict_comprehension] \"}\"\ndict_item_list: dict_item (\",\" dict_item)* [\",\"]\ndict_item: expression \":\" expression | \"**\" or_expr\ndict_comprehension: expression \":\" expression comp_for |  |\n|  | 字典显示会产生一个新的字典对象。\n如果给出一个由逗号分隔的字典条目序列，它们会从左至右被求值以定义字典的条目：每个键对象\n会被用作字典中存放相应值的键。 这意味着你可以在字典条目列表中多次指定相同的键，而最终字\n典的值将由最后一次给出的键决定。\n双星号 ** 表示 字典拆包。 它的操作数必须是一个 mapping。 每个映射项会被加入到新的字典。\n后续的值会替换先前的字典项和先前的字典拆包所设置的值。\nAdded in version 3.5: 拆包到字典显示，最初由 PEP 448 提出。\n字典推导式与列表和集合推导式有所不同，它需要以冒号分隔的两个表达式，后面带上标准的 \"for\"\n和 \"if\" 子句。 当推导式被执行时，作为结果的键和值元素会按它们的产生顺序被加入新的字典。\n对键的取值类型的限制已列在之前的 标准类型层级结构 一节中。 （总的说来，键的类型应为\nhashable，这就排除了所有可变对象。） 重复键之间的冲突不会被检测；指定键所保存的最后一个\n值（即在显示中排最右边的文本）将为最终的值。\n在 3.8 版本发生变更: 在 Python 3.8 之前的字典推导式中，并没有定义好键和值的求值顺序。\n在 CPython 中，值会先于键被求值。 根据 PEP 572 的提议，从 3.8 开始，键会先于值被求\n值。\n6.2.8. 生成器表达式\n生成器表达式是用圆括号括起来的紧凑形式生成器标注。 |  |\n|  | generator_expression: \"(\" expression comp_for \")\" |  |\n|  | 生成器表达式会产生一个新的生成器对象。 其句法与推导式相同，区别在于它是用圆括号而不是用\n方括号或花括号括起来的。 |  |\n\n在生成器表达式中使用的变量会在为生成器对象调用 __next__() 方法的时候以惰性方式被求值\n（即与普通生成器相同的方式）。 但是，最左侧 for 子句内的可迭代对象是会被立即求值的，且会\n立即为这个可迭代对象创建 iterator，因此在创建迭代器时产生的错误会在生成器表达式被定义时被\n检测到，而不是在获取第一个值时才出错。 后续的 for 子句以及最左侧 for 子句内的任何筛选条件\n无法在外层作用域内被求值，因为它们可能会依赖于从最左侧可迭代对象获取的值。 例如: (x*y\nfor x in range(10) for y in range(x, x+10))。\n圆括号在只附带一个参数的调用中可以被省略。 详情参见 调用 一节。\n为了避免干扰到生成器表达式本身的预期操作，禁止在隐式定义的生成器中使用 yield 和 yield\nfrom 表达式。\n如果生成器表达式包含 async for 子句或 await 表达式，则称为 异步生成器表达式。 异步生成器\n表达式会返回一个新的异步生成器对象，此对象属于异步迭代器 (参见 异步迭代器)。\nAdded in version 3.6: 引入了异步生成器表达式。\n在 3.7 版本发生变更: 在 Python 3.7 之前，异步生成器表达式只能在 async def 协和中出现。\n从 3.7 开始，任何函数都可以使用异步生成器表达式。\n在 3.8 版本发生变更: yield 和 yield from 在隐式嵌套的作用域中已被禁用。\n6.2.9. yield 表达式\nyield_atom: \"(\" yield_expression \")\"\nyield_from: \"yield\" \"from\" expression\nyield_expression: \"yield\" yield_list | yield_from\nyield 表达式在定义 generator 函数或 asynchronous generator 函数时才会用到因此只能在函数定义\n的内部使用。 在一个函数体内使用 yield 表达式会使这个函数变成一个生成器函数，而在一个\nasync def 函数的内部使用它则会让这个协程函数变成一个异步生成器函数。 例如:\ndef gen(): # 定义一个生成器函数\nyield 123\nasync def agen(): # 定义一个异步生成器函数\nyield 123\n由于它们会对外层作用域造成附带影响，yield 表达式不被允许作为用于实现推导式和生成器表达\n式的隐式定义作用域的一部分。\n在 3.8 版本发生变更: 禁止在实现推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达\n式。\n下面是对生成器函数的描述，异步生成器函数会在 异步生成器函数 一节中单独介绍。\n当一个生成器函数被调用时，它将返回一个名为生成器的迭代器。 然后这个生成器将控制生成器函\n数的执行。 执行过程会在这个生成器的某个方法被调用时开始。 这时，函数会执行到第一个 yield\n表达式，在那里它将再次被挂起，向生成器的调用方返回 yield_list 的值，或者如果 yield_list\n被省略则返回 None。 所谓的挂起，就是说所有局部状态都会被保留，包括局部变量的当前绑定、指\n\n|  |  |  | 在生成器表达式中使用的变量会在为生成器对象调用 __next__() 方法的时候以惰性方式被求值\n（即与普通生成器相同的方式）。 但是，最左侧 for 子句内的可迭代对象是会被立即求值的，且会\n立即为这个可迭代对象创建 iterator，因此在创建迭代器时产生的错误会在生成器表达式被定义时被\n检测到，而不是在获取第一个值时才出错。 后续的 for 子句以及最左侧 for 子句内的任何筛选条件\n无法在外层作用域内被求值，因为它们可能会依赖于从最左侧可迭代对象获取的值。 例如: (x*y\nfor x in range(10) for y in range(x, x+10))。\n圆括号在只附带一个参数的调用中可以被省略。 详情参见 调用 一节。\n为了避免干扰到生成器表达式本身的预期操作，禁止在隐式定义的生成器中使用 yield 和 yield\nfrom 表达式。\n如果生成器表达式包含 async for 子句或 await 表达式，则称为 异步生成器表达式。 异步生成器\n表达式会返回一个新的异步生成器对象，此对象属于异步迭代器 (参见 异步迭代器)。\nAdded in version 3.6: 引入了异步生成器表达式。\n在 3.7 版本发生变更: 在 Python 3.7 之前，异步生成器表达式只能在 async def 协和中出现。\n从 3.7 开始，任何函数都可以使用异步生成器表达式。\n在 3.8 版本发生变更: yield 和 yield from 在隐式嵌套的作用域中已被禁用。\n6.2.9. yield 表达式 |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  | (x*y |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | for x in range(10) for y in range(x, x+10)) |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | from |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  | yield_atom: \"(\" yield_expression \")\"\nyield_from: \"yield\" \"from\" expression\nyield_expression: \"yield\" yield_list | yield_from |  |  |  |\n|  |  |  | yield 表达式在定义 generator 函数或 asynchronous generator 函数时才会用到因此只能在函数定义\n的内部使用。 在一个函数体内使用 yield 表达式会使这个函数变成一个生成器函数，而在一个\nasync def 函数的内部使用它则会让这个协程函数变成一个异步生成器函数。 例如: |  |  |  |\n|  |  |  | def gen(): # 定义一个生成器函数\nyield 123\nasync def agen(): # 定义一个异步生成器函数\nyield 123 |  |  |  |\n|  |  |  | 由于它们会对外层作用域造成附带影响，yield 表达式不被允许作为用于实现推导式和生成器表达\n式的隐式定义作用域的一部分。\n在 3.8 版本发生变更: 禁止在实现推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达\n式。\n下面是对生成器函数的描述，异步生成器函数会在 异步生成器函数 一节中单独介绍。\n当一个生成器函数被调用时，它将返回一个名为生成器的迭代器。 然后这个生成器将控制生成器函\n数的执行。 执行过程会在这个生成器的某个方法被调用时开始。 这时，函数会执行到第一个 yield\n表达式，在那里它将再次被挂起，向生成器的调用方返回 yield_list 的值，或者如果 yield_list\n被省略则返回 None。 所谓的挂起，就是说所有局部状态都会被保留，包括局部变量的当前绑定、指 |  |  |  |\n\n| yield |  |\n| --- | --- |\n\n令指针、内部求值栈及任何异常处理等等。 当通过调用生成器的某个方法恢复执行时，这个函数的\n运行就与 yield 表达式只是一个外部调用的情况完全一样。 在恢复执行后 yield 表达式的值取决于恢\n复执行所调用的方法。 如果是用 __next__() (一般是通过 for 或者 next() 内置函数) 则结果为\nNone。 在其他情况下，如果是用 send()，则结果将为传给该方法的值。\n所有这些使生成器函数与协程非常相似；它们 yield 多次，它们具有多个入口点，并且它们的执行可\n以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行；控制权总是转移到\n生成器的调用者。\n在 try 结构中的任何位置都允许yield表达式。如果生成器在(因为引用计数到零或是因为被垃圾回\n收)销毁之前没有恢复执行，将调用生成器-迭代器的 close() 方法. close 方法允许任何挂起的\nfinally 子句执行。\n当使用 yield from <expr> 时，所提供的表达式必须是一个可迭代对象。 迭代该可迭代对象所产\n生的值会被直接传递给当前生成器方法的调用者。 任何通过 send() 传入的值以及任何通过\nthrow() 传入的异常如果有适当的方法则会被传给下层迭代器。 如果不是这种情况，那么 send()\n将引发 AttributeError 或 TypeError，而 throw() 将立即引发所转入的异常。\n当下层迭代器完成时，被引发的 StopIteration 实例的 value 属性会成为 yield 表达式的值。 它可\n以在引发 StopIteration 时被显式地设置，也可以在子迭代器是一个生成器时自动地设置（通过从\n子生成器返回一个值）。\n在 3.3 版本发生变更: 添加 yield from <expr> 以委托控制流给一个子迭代器。\n当yield表达式是赋值语句右侧的唯一表达式时，括号可以省略。\n参见:\nPEP 255 - 简单生成器\n在 Python 中加入生成器和 yield 语句的提议。\nPEP 342 - 通过增强型生成器实现协程\n增强生成器 API 和语法的提议，使其可以被用作简单的协程。\nPEP 380 - 委托给子生成器的语法\n引入 yield_from 语法的提议，以方便地委托给子生成器。\nPEP 525 - 异步生成器\n通过给协程函数加入生成器功能对 PEP 492 进行扩展的提议。\n6.2.9.1. 生成器-迭代器的方法\n这个子小节描述了生成器迭代器的方法。 它们可被用于控制生成器函数的执行。\n请注意在生成器已经在执行时调用以下任何方法都会引发 ValueError 异常。\ngenerator.__next__()\n\n|  | 令指针、内部求值栈及任何异常处理等等。 当通过调用生成器的某个方法恢复执行时，这个函数的\n运行就与 yield 表达式只是一个外部调用的情况完全一样。 在恢复执行后 yield 表达式的值取决于恢\n复执行所调用的方法。 如果是用 __next__() (一般是通过 for 或者 next() 内置函数) 则结果为\nNone。 在其他情况下，如果是用 send()，则结果将为传给该方法的值。\n所有这些使生成器函数与协程非常相似；它们 yield 多次，它们具有多个入口点，并且它们的执行可\n以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行；控制权总是转移到\n生成器的调用者。\n在 try 结构中的任何位置都允许yield表达式。如果生成器在(因为引用计数到零或是因为被垃圾回\n收)销毁之前没有恢复执行，将调用生成器-迭代器的 close() 方法. close 方法允许任何挂起的\nfinally 子句执行。\n当使用 yield from <expr> 时，所提供的表达式必须是一个可迭代对象。 迭代该可迭代对象所产\n生的值会被直接传递给当前生成器方法的调用者。 任何通过 send() 传入的值以及任何通过\nthrow() 传入的异常如果有适当的方法则会被传给下层迭代器。 如果不是这种情况，那么 send()\n将引发 AttributeError 或 TypeError，而 throw() 将立即引发所转入的异常。\n当下层迭代器完成时，被引发的 StopIteration 实例的 value 属性会成为 yield 表达式的值。 它可\n以在引发 StopIteration 时被显式地设置，也可以在子迭代器是一个生成器时自动地设置（通过从\n子生成器返回一个值）。\n在 3.3 版本发生变更: 添加 yield from <expr> 以委托控制流给一个子迭代器。\n当yield表达式是赋值语句右侧的唯一表达式时，括号可以省略。 |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 255 - 简单生成器\n在 Python 中加入生成器和 yield 语句的提议。\nPEP 342 - 通过增强型生成器实现协程\n增强生成器 API 和语法的提议，使其可以被用作简单的协程。\nPEP 380 - 委托给子生成器的语法\n引入 yield_from 语法的提议，以方便地委托给子生成器。\nPEP 525 - 异步生成器\n通过给协程函数加入生成器功能对 PEP 492 进行扩展的提议。 |  |\n|  | 6.2.9.1. 生成器-迭代器的方法\n这个子小节描述了生成器迭代器的方法。 它们可被用于控制生成器函数的执行。\n请注意在生成器已经在执行时调用以下任何方法都会引发 ValueError 异常。\ngenerator.__next__() |  |\n\n开始一个生成器函数的执行或是从上次执行 yield 表达式的位置恢复执行。 当一个生成器函数\n通过 __next__() 方法恢复执行时，当前的 yield 表达式总是取值为 None。 随后会继续执行到\n下一个 yield 表达式，这时生成器将再次挂起，而 yield_list 的值会被返回给 __next__() 的\n调用方。 如果生成器没有产生下一个值就退出，则将引发 StopIteration 异常。\n此方法通常是隐式地调用，例如通过 for 循环或是内置的 next() 函数。\ngenerator.send(value)\n恢复执行并向生成器函数“发送”一个值。 value 参数将成为当前 yield 表达式的结果。 send()\n方法会返回生成器所产生的下一个值，或者如果生成器没有产生下一个值就退出则会引发\nStopIteration。 当调用 send() 来启动生成器时，它必须以 None 作为调用参数，因为这时\n没有可以接收值的 yield 表达式。\ngenerator.throw(value)\ngenerator.throw(type[, value[, traceback]])\n在生成器暂停的位置引发一个异常，并返回该生成器函数所产生的下一个值。 如果生成器没有\n产生下一个值就退出，则将引发 StopIteration 异常。 如果生成器函数没有捕获传入的异\n常，或是引发了另一个异常，则该异常会被传播给调用方。\n在典型的使用场景下，其调用将附带单个异常实例，类似于使用 raise 关键字的方式。\n但是为了向下兼容，也支持第二种签名方式，遵循来自旧版本 Python 的惯例。 type 参数应为\n一个异常类，而 value 应为一个异常实例。 如果未提供 value，则将调用 type 构造器来获取一\n个实例。 如果提供了 traceback，它将被设置到异常上，否则任何存储在 value 中的现有\n__traceback__ 属性都会被清空。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\ngenerator.close()\n在生成器函数暂停的位置引发 GeneratorExit (相当于调用 throw(GeneratorExit))。 如果生\n成器函数捕获该异常并返回一个值，这个值将从 close() 返回。 如果生成器函数已经关闭，或\n者引发了 GeneratorExit (由于未捕获异常)，close() 将返回 None。 如果生成器产生了一个\n值，则将引发 RuntimeError。 如果生成器引发了任何其他异常，它将被传播给调用方。 如果\n生成器已经由于异常或以正常退出方式结束执行，close() 将返回 None 并且不会造成其他影\n响。\n在 3.13 版本发生变更: 如果生成器在被关闭时返回了一个值，这个值将从 close() 返\n回。\n6.2.9.2. 例子\n这里是一个简单的例子，演示了生成器和生成器函数的行为:\n>>> def echo(value=None):\n... print(\"Execution starts when 'next()' is called for the first time.\")\n... try:\n... while True:\n\n|  | 开始一个生成器函数的执行或是从上次执行 yield 表达式的位置恢复执行。 当一个生成器函数\n通过 __next__() 方法恢复执行时，当前的 yield 表达式总是取值为 None。 随后会继续执行到\n下一个 yield 表达式，这时生成器将再次挂起，而 yield_list 的值会被返回给 __next__() 的\n调用方。 如果生成器没有产生下一个值就退出，则将引发 StopIteration 异常。\n此方法通常是隐式地调用，例如通过 for 循环或是内置的 next() 函数。\ngenerator.send(value)\n恢复执行并向生成器函数“发送”一个值。 value 参数将成为当前 yield 表达式的结果。 send()\n方法会返回生成器所产生的下一个值，或者如果生成器没有产生下一个值就退出则会引发\nStopIteration。 当调用 send() 来启动生成器时，它必须以 None 作为调用参数，因为这时\n没有可以接收值的 yield 表达式。\ngenerator.throw(value)\ngenerator.throw(type[, value[, traceback]])\n在生成器暂停的位置引发一个异常，并返回该生成器函数所产生的下一个值。 如果生成器没有\n产生下一个值就退出，则将引发 StopIteration 异常。 如果生成器函数没有捕获传入的异\n常，或是引发了另一个异常，则该异常会被传播给调用方。\n在典型的使用场景下，其调用将附带单个异常实例，类似于使用 raise 关键字的方式。\n但是为了向下兼容，也支持第二种签名方式，遵循来自旧版本 Python 的惯例。 type 参数应为\n一个异常类，而 value 应为一个异常实例。 如果未提供 value，则将调用 type 构造器来获取一\n个实例。 如果提供了 traceback，它将被设置到异常上，否则任何存储在 value 中的现有\n__traceback__ 属性都会被清空。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\ngenerator.close()\n在生成器函数暂停的位置引发 GeneratorExit (相当于调用 throw(GeneratorExit))。 如果生\n成器函数捕获该异常并返回一个值，这个值将从 close() 返回。 如果生成器函数已经关闭，或\n者引发了 GeneratorExit (由于未捕获异常)，close() 将返回 None。 如果生成器产生了一个\n值，则将引发 RuntimeError。 如果生成器引发了任何其他异常，它将被传播给调用方。 如果\n生成器已经由于异常或以正常退出方式结束执行，close() 将返回 None 并且不会造成其他影\n响。\n在 3.13 版本发生变更: 如果生成器在被关闭时返回了一个值，这个值将从 close() 返\n回。\n6.2.9.2. 例子\n这里是一个简单的例子，演示了生成器和生成器函数的行为: |  |\n| --- | --- | --- |\n|  | >>> def echo(value=None):\n... print(\"Execution starts when 'next()' is called for the first time.\")\n... try:\n... while True: |  |\n\n... try:\n... value = (yield value)\n... except Exception as e:\n... value = e\n... finally:\n... print(\"Don't forget to clean up when 'close()' is called.\")\n...\n>>> generator = echo(1)\n>>> print(next(generator))\nExecution starts when 'next()' is called for the first time.\n1\n>>> print(next(generator))\nNone\n>>> print(generator.send(2))\n2\n>>> generator.throw(TypeError, \"spam\")\nTypeError('spam',)\n>>> generator.close()\nDon't forget to clean up when 'close()' is called.\n对于 yield from 的例子, 参见“Python 有什么新变化”中的 PEP 380: 委托给子生成器的语法。\n6.2.9.3. 异步生成器函数\n在一个使用 async def 定义的函数或方法中出现的 yield 表达式会进一步将该函数定义为一个\nasynchronous generator 函数。\n当一个异步生成器函数被调用时，它会返回一个名为异步生成器对象的异步迭代器。 此对象将在之\n后控制该生成器函数的执行。 异步生成器对象通常被用在协程函数的 async for 语句中，类似于在\nfor 语句中使用生成器对象。\n调用某个异步生成器的方法将返回一个 awaitable 对象，执行会在此对象被等待时启动。 到那时，\n将执行至第一个 yield 表达式，在那里它会再次挂起，将 yield_list 的值返回给等待中的协程。\n与生成器一样，挂起意味着所有局部状态会被保留，包括局部变量的当前绑定、指令指针、内部求\n值栈以及任何异常处理的状态。 当执行在等待异步生成器的方法返回下一个对象后恢复时，该函数\n可以从原状态继续执行，就仿佛 yield 表达式只是另一个外部调用那样。 恢复执行后 yield 表达式的\n值取决于恢复执行所用的方法。 如果是使用 __anext__() 则结果为 None。 否则的话，如果是使用\nasend()，则结果将是传递给该方法的值。\n如果一个异步生成器恰好因 break、调用方任务被取消，或是其他异常而提前退出，生成器的异步\n清理代码将会运行并可能引发异常或访问意外上下文中的上下文变量 -- 也许是在它所依赖的任务的\n生命周期之后，或是在异步生成器垃圾回收钩子被调用时的事件循环关闭期间。 为了防止这种情\n况，调用方必须通过调用 aclose() 方法来显式地关闭异步生成器以终结生成器并最终从事件循环\n中将其分离。\n在异步生成器函数中，yield 表达式允许出现在 try 结构的任何位置。但是，如果一个异步生成器在\n其被终结（由于引用计数达到零或被作为垃圾回收）之前未被恢复，则 try 结构中的 yield 表达式\n可能导致挂起的 finally 子句执行失败。在此情况下，应由运行该异步生成器的事件循环或任务调\n度器来负责调用异步生成器-迭代器的 aclose() 方法并运行所返回的协程对象，从而允许任何挂起\n的 finally 子句得以执行。\n\n|  | ... try:\n... value = (yield value)\n... except Exception as e:\n... value = e\n... finally:\n... print(\"Don't forget to clean up when 'close()' is called.\")\n...\n>>> generator = echo(1)\n>>> print(next(generator))\nExecution starts when 'next()' is called for the first time.\n1\n>>> print(next(generator))\nNone\n>>> print(generator.send(2))\n2\n>>> generator.throw(TypeError, \"spam\")\nTypeError('spam',)\n>>> generator.close()\nDon't forget to clean up when 'close()' is called. |  |\n| --- | --- | --- |\n|  | 对于 yield from 的例子, 参见“Python 有什么新变化”中的 PEP 380: 委托给子生成器的语法。\n6.2.9.3. 异步生成器函数\n在一个使用 async def 定义的函数或方法中出现的 yield 表达式会进一步将该函数定义为一个\nasynchronous generator 函数。\n当一个异步生成器函数被调用时，它会返回一个名为异步生成器对象的异步迭代器。 此对象将在之\n后控制该生成器函数的执行。 异步生成器对象通常被用在协程函数的 async for 语句中，类似于在\nfor 语句中使用生成器对象。\n调用某个异步生成器的方法将返回一个 awaitable 对象，执行会在此对象被等待时启动。 到那时，\n将执行至第一个 yield 表达式，在那里它会再次挂起，将 yield_list 的值返回给等待中的协程。\n与生成器一样，挂起意味着所有局部状态会被保留，包括局部变量的当前绑定、指令指针、内部求\n值栈以及任何异常处理的状态。 当执行在等待异步生成器的方法返回下一个对象后恢复时，该函数\n可以从原状态继续执行，就仿佛 yield 表达式只是另一个外部调用那样。 恢复执行后 yield 表达式的\n值取决于恢复执行所用的方法。 如果是使用 __anext__() 则结果为 None。 否则的话，如果是使用\nasend()，则结果将是传递给该方法的值。\n如果一个异步生成器恰好因 break、调用方任务被取消，或是其他异常而提前退出，生成器的异步\n清理代码将会运行并可能引发异常或访问意外上下文中的上下文变量 -- 也许是在它所依赖的任务的\n生命周期之后，或是在异步生成器垃圾回收钩子被调用时的事件循环关闭期间。 为了防止这种情\n况，调用方必须通过调用 aclose() 方法来显式地关闭异步生成器以终结生成器并最终从事件循环\n中将其分离。\n在异步生成器函数中，yield 表达式允许出现在 try 结构的任何位置。但是，如果一个异步生成器在\n其被终结（由于引用计数达到零或被作为垃圾回收）之前未被恢复，则 try 结构中的 yield 表达式\n可能导致挂起的 finally 子句执行失败。在此情况下，应由运行该异步生成器的事件循环或任务调\n度器来负责调用异步生成器-迭代器的 aclose() 方法并运行所返回的协程对象，从而允许任何挂起\n的 finally 子句得以执行。 |  |\n\n为了能在事件循环终结时执行最终化处理，事件循环应当定义一个 终结器 函数，它接受一个异步生\n成器迭代器并将调用 aclose() 且执行该协程。 这个 终结器 可以通过调用\nsys.set_asyncgen_hooks() 来注册。 当首次迭代时，异步生成器迭代器将保存已注册的 终结器\n以便在最终化时调用。 有关 终结器 方法的参考示例请查看在 Lib/asyncio/base_events.py 的中的\nasyncio.Loop.shutdown_asyncgens 实现。\nyield from <expr> 表达式如果在异步生成器函数中使用会引发语法错误。\n6.2.9.4. 异步生成器-迭代器方法\n这个子小节描述了异步生成器迭代器的方法，它们可被用于控制生成器函数的执行。\nasync agen.__anext__()\n返回一个可等待对象，它在运行时会开始执行该异步生成器或是从上次执行的 yield 表达式位置\n恢复执行。 当一个异步生成器通过 __anext__() 方法恢复执行时，当前的 yield 表达或所返回\n的可等待对象总是取值为 None，它在运行时将继续执行到下一个 yield 表达式。 该 yield 表达\n式的 yield_list 的值会是完成的协程所引发的 StopIteration 异步的值。 如果异步生成器\n没有产生下一个值就退出，则该可等待对象将引发 StopAsyncIteration 异常，提示该异步迭\n代操作已完成。\n此方法通常是通过 async for 循环隐式地调用。\nasync agen.asend(value)\n返回一个可等待对象，它在运行时会恢复该异步生成器的执行。 与生成器的 send() 方法一\n样，此方法会“发送”一个值给异步生成器函数，其 value 参数会成为当前 yield 表达式的结果\n值。 asend() 方法所返回的可等待对象会将所引发的 StopIteration 作为生成器产生的下一\n个值返回，或者如果异步生成器没有产生下一个值就退出则引发 StopAsyncIteration。 当调\n用 asend() 来启动异步生成器时，它必须以 None 作为参数被调用，因为这时没有可以接收值\n的 yield 表达式。\nasync agen.athrow(value)\nasync agen.athrow(type[, value[, traceback]])\n返回一个可等待对象，它会在异步生成器暂停的位置引发 type 类型的异常，并返回该生成器\n函数所产生的下一个值，其值为所引发的 StopIteration 异常。 如果异步生成器没有产生下\n一个值就退出，则将由该可等待对象引发 StopAsyncIteration 异步。 如果生成器函数没有捕\n获传入的异常，或引发了另一个异常，则当可等待对象运行时该异常会被传播给可等待对象的\n调用者。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\nasync agen.aclose()\n返回一个可等待对象，它会在运行时向异步生成器函数暂停的位置抛入一个 GeneratorExit。\n如果该异步生成器函数正常退出、关闭或引发 GeneratorExit (由于未捕获该异常) 则返回的可\n等待对象将引发 StopIteration 异常。 后续调用异步生成器所返回的任何其他可等待对象将\n引发 StopAsyncIteration 异常。 如果异步生成器产生了一个值，该可等待对象会引发\n\n|  | 为了能在事件循环终结时执行最终化处理，事件循环应当定义一个 终结器 函数，它接受一个异步生\n成器迭代器并将调用 aclose() 且执行该协程。 这个 终结器 可以通过调用\nsys.set_asyncgen_hooks() 来注册。 当首次迭代时，异步生成器迭代器将保存已注册的 终结器\n以便在最终化时调用。 有关 终结器 方法的参考示例请查看在 Lib/asyncio/base_events.py 的中的\nasyncio.Loop.shutdown_asyncgens 实现。\nyield from <expr> 表达式如果在异步生成器函数中使用会引发语法错误。\n6.2.9.4. 异步生成器-迭代器方法\n这个子小节描述了异步生成器迭代器的方法，它们可被用于控制生成器函数的执行。\nasync agen.__anext__()\n返回一个可等待对象，它在运行时会开始执行该异步生成器或是从上次执行的 yield 表达式位置\n恢复执行。 当一个异步生成器通过 __anext__() 方法恢复执行时，当前的 yield 表达或所返回\n的可等待对象总是取值为 None，它在运行时将继续执行到下一个 yield 表达式。 该 yield 表达\n式的 yield_list 的值会是完成的协程所引发的 StopIteration 异步的值。 如果异步生成器\n没有产生下一个值就退出，则该可等待对象将引发 StopAsyncIteration 异常，提示该异步迭\n代操作已完成。\n此方法通常是通过 async for 循环隐式地调用。\nasync agen.asend(value)\n返回一个可等待对象，它在运行时会恢复该异步生成器的执行。 与生成器的 send() 方法一\n样，此方法会“发送”一个值给异步生成器函数，其 value 参数会成为当前 yield 表达式的结果\n值。 asend() 方法所返回的可等待对象会将所引发的 StopIteration 作为生成器产生的下一\n个值返回，或者如果异步生成器没有产生下一个值就退出则引发 StopAsyncIteration。 当调\n用 asend() 来启动异步生成器时，它必须以 None 作为参数被调用，因为这时没有可以接收值\n的 yield 表达式。\nasync agen.athrow(value)\nasync agen.athrow(type[, value[, traceback]])\n返回一个可等待对象，它会在异步生成器暂停的位置引发 type 类型的异常，并返回该生成器\n函数所产生的下一个值，其值为所引发的 StopIteration 异常。 如果异步生成器没有产生下\n一个值就退出，则将由该可等待对象引发 StopAsyncIteration 异步。 如果生成器函数没有捕\n获传入的异常，或引发了另一个异常，则当可等待对象运行时该异常会被传播给可等待对象的\n调用者。\n在 3.12 版本发生变更: 第二个签名 (type[, value[, traceback]]) 已被弃用并可能在未来的\nPython 版本中移除。\nasync agen.aclose()\n返回一个可等待对象，它会在运行时向异步生成器函数暂停的位置抛入一个 GeneratorExit。\n如果该异步生成器函数正常退出、关闭或引发 GeneratorExit (由于未捕获该异常) 则返回的可\n等待对象将引发 StopIteration 异常。 后续调用异步生成器所返回的任何其他可等待对象将\n引发 StopAsyncIteration 异常。 如果异步生成器产生了一个值，该可等待对象会引发 |  |\n| --- | --- | --- |\n\nRuntimeError。 如果异步生成器引发任何其他异常，它会被传播给可等待对象的调用者。 如\n果异步生成器已经由于异常或正常退出则后续调用 aclose() 将返回一个不会做任何事的可等\n待对象。\n6.3. 原型\n原型代表编程语言中最紧密绑定的操作。 它们的句法如下:\nprimary: atom | attributeref | subscription | slicing | call\n6.3.1. 属性引用\n属性引用是后面带有一个句点加一个名称的原型:\nattributeref: primary \".\" identifier\n此原型必须求值为一个支持属性引用的类型的对象，多数对象都支持此特性。 随后该对象会被要求\n产生以指定标识符为名称的属性。 所产生对象的类型和值会根据该对象来确定。 对同一属性引用的\n多次求值可能产生不同的对象。\n产生过程可通过重载 __getattribute__() 方法或 __getattr__() 方法来自定义。 将会先调用\n__getattribute__() 方法并返回一个值或者如果属性不可用则会引发 AttributeError。\n如果引发了 AttributeError 并且对象具有 __getattr__() 方法，则将调用该方法作为回退项。\n6.3.2. 抽取\n对一个 容器类 的实例执行抽取操作通常将会从该容器中选取一个元素。 而对一个 泛型类 执行抽取\n操作通常将会返回一个 GenericAlias 对象。\nsubscription: primary \"[\" flexible_expression_list \"]\"\n当一个对象被抽取时，解释器将对原型和表达式列表进行求值。\n原型必须可被求值为一个支持抽取操作的对象。 一个对象可通过同时定义 __getitem__() 和\n__class_getitem__() 或其中之一来支持抽取操作。 当原型被抽取时，表达式列表的求值结果将被\n传给以上方法中的一个。 对于在何时会调用 __class_getitem__ 而不是 __getitem__ 的更多细\n节，请参阅 __class_getitem__ 与 __getitem__。\n如果表达式列表包含至少一个逗号，或者如果某个表达式带有星号，该表达式列表将求值为包含该\n表达式列表中所有条目的 tuple。 在其他情况下，表达式列表将被求值为列表中唯一成员的值。\n在 3.11 版本发生变更: 一个表达式列表中的表达式可以带星号。 参见 PEP 646。\n对于内置对象，有两种类型的对象支持通过 __getitem__() 执行抽取操作:\n1. 映射。 如果原型是一个 mapping，则表达式列表必须求值为一个以该映射的某个键为值的对\n象，而抽取操作会在映射中选取该键所对应的值。 内置映射类的一个例子是 dict 类。\n\n|  | RuntimeError。 如果异步生成器引发任何其他异常，它会被传播给可等待对象的调用者。 如\n果异步生成器已经由于异常或正常退出则后续调用 aclose() 将返回一个不会做任何事的可等\n待对象。\n6.3. 原型\n原型代表编程语言中最紧密绑定的操作。 它们的句法如下: |  |\n| --- | --- | --- |\n|  | primary: atom | attributeref | subscription | slicing | call |  |\n|  | 6.3.1. 属性引用\n属性引用是后面带有一个句点加一个名称的原型: |  |\n|  | attributeref: primary \".\" identifier |  |\n|  | 此原型必须求值为一个支持属性引用的类型的对象，多数对象都支持此特性。 随后该对象会被要求\n产生以指定标识符为名称的属性。 所产生对象的类型和值会根据该对象来确定。 对同一属性引用的\n多次求值可能产生不同的对象。\n产生过程可通过重载 __getattribute__() 方法或 __getattr__() 方法来自定义。 将会先调用\n__getattribute__() 方法并返回一个值或者如果属性不可用则会引发 AttributeError。\n如果引发了 AttributeError 并且对象具有 __getattr__() 方法，则将调用该方法作为回退项。\n6.3.2. 抽取\n对一个 容器类 的实例执行抽取操作通常将会从该容器中选取一个元素。 而对一个 泛型类 执行抽取\n操作通常将会返回一个 GenericAlias 对象。 |  |\n|  | subscription: primary \"[\" flexible_expression_list \"]\" |  |\n|  | 当一个对象被抽取时，解释器将对原型和表达式列表进行求值。\n原型必须可被求值为一个支持抽取操作的对象。 一个对象可通过同时定义 __getitem__() 和\n__class_getitem__() 或其中之一来支持抽取操作。 当原型被抽取时，表达式列表的求值结果将被\n传给以上方法中的一个。 对于在何时会调用 __class_getitem__ 而不是 __getitem__ 的更多细\n节，请参阅 __class_getitem__ 与 __getitem__。\n如果表达式列表包含至少一个逗号，或者如果某个表达式带有星号，该表达式列表将求值为包含该\n表达式列表中所有条目的 tuple。 在其他情况下，表达式列表将被求值为列表中唯一成员的值。\n在 3.11 版本发生变更: 一个表达式列表中的表达式可以带星号。 参见 PEP 646。\n对于内置对象，有两种类型的对象支持通过 __getitem__() 执行抽取操作:\n1. 映射。 如果原型是一个 mapping，则表达式列表必须求值为一个以该映射的某个键为值的对\n象，而抽取操作会在映射中选取该键所对应的值。 内置映射类的一个例子是 dict 类。 |  |\n\n2. 序列。 如果原型是一个 sequence，则表达式列表必须求值为一个 int 或一个 slice (如下面\n的小节所讨论的)。 内置序列类的例子包括 str, list 和 tuple 等类。\n正式语法规则并未设置针对 序列 中负索引号的特殊保留条款。 不过，内置序列都提供了通过给索引\n号加上序列长度来解读负索引号的 __getitem__() 方法，因此举例来说，x[-1] 将选取 x 的最后\n一项。 结果值必须为一个小于序列中条目数的非负整数，抽取操作会选取索引号为该值的条目（从\n零开始计数）。 由于对负索引号和切片的支持是在 __getitem__() 方法中实现的，因而重写此方\n法的子类将需要显式地添加这种支持。\n字符串 是一种特殊的序列，其中的项是 字符。 字符并不是一种单独的数据类型而是长度恰好为一\n个字符的字符串。\n6.3.3. 切片\n切片就是在序列对象（字符串、元组或列表）中选择某个范围内的项。 切片可被用作表达式以及赋\n值或 del 语句的目标。 切片的句法如下:\nslicing: primary \"[\" slice_list \"]\"\nslice_list: slice_item (\",\" slice_item)* [\",\"]\nslice_item: expression | proper_slice\nproper_slice: [lower_bound] \":\" [upper_bound] [ \":\" [stride] ]\nlower_bound: expression\nupper_bound: expression\nstride: expression\n此处的正式句法中存在一点歧义：任何形似表达式列表的东西同样也会形似切片列表，因此任何抽\n取操作也可以被解析为切片。 为了不使句法更加复杂，于是通过定义将此情况解析为抽取优先于解\n析为切片来消除这种歧义（切片列表未包含正确的切片就属于此情况）。\n切片的语义如下所述。 原型通过一个根据所下所示的切片列表来构造的键进行索引（与普通的抽取\n一样使用 __getitem__() 方法）。 如果切片列表包含至少一个逗号，则键将是一个包含切片项转\n换形式的元组；否则的话，键将是单个切片项的转换形式。 切片项如为一个表达式，则其转换形式\n就是该表达式。 一个正确的切片的转换形式就是一个切片对象（参见 标准类型层级结构 一节），该\n对象的 start, stop 和 step 属性将分别为表达式所给出的下界、上界和步长值，省略的表达式将\n用 None 来替换。\n6.3.4. 调用\n所谓调用就是附带可能为空的一系列 参数 来执行一个可调用对象 (例如 function):\ncall: primary \"(\" [argument_list [\",\"] | comprehension] \")\"\nargument_list: positional_arguments [\",\" starred_and_keywords]\n[\",\" keywords_arguments]\n| starred_and_keywords [\",\" keywords_arguments]\n| keywords_arguments\npositional_arguments: positional_item (\",\" positional_item)*\npositional_item: assignment_expression | \"*\" expression\nstarred_and_keywords: (\"*\" expression | keyword_item)\n(\",\" \"*\" expression | \",\" keyword_item)*\nkeywords_arguments: (keyword_item | \"**\" expression)\n\n|  | 2. 序列。 如果原型是一个 sequence，则表达式列表必须求值为一个 int 或一个 slice (如下面\n的小节所讨论的)。 内置序列类的例子包括 str, list 和 tuple 等类。\n正式语法规则并未设置针对 序列 中负索引号的特殊保留条款。 不过，内置序列都提供了通过给索引\n号加上序列长度来解读负索引号的 __getitem__() 方法，因此举例来说，x[-1] 将选取 x 的最后\n一项。 结果值必须为一个小于序列中条目数的非负整数，抽取操作会选取索引号为该值的条目（从\n零开始计数）。 由于对负索引号和切片的支持是在 __getitem__() 方法中实现的，因而重写此方\n法的子类将需要显式地添加这种支持。\n字符串 是一种特殊的序列，其中的项是 字符。 字符并不是一种单独的数据类型而是长度恰好为一\n个字符的字符串。\n6.3.3. 切片\n切片就是在序列对象（字符串、元组或列表）中选择某个范围内的项。 切片可被用作表达式以及赋\n值或 del 语句的目标。 切片的句法如下: |  |\n| --- | --- | --- |\n|  | slicing: primary \"[\" slice_list \"]\"\nslice_list: slice_item (\",\" slice_item)* [\",\"]\nslice_item: expression | proper_slice\nproper_slice: [lower_bound] \":\" [upper_bound] [ \":\" [stride] ]\nlower_bound: expression\nupper_bound: expression\nstride: expression |  |\n|  | 此处的正式句法中存在一点歧义：任何形似表达式列表的东西同样也会形似切片列表，因此任何抽\n取操作也可以被解析为切片。 为了不使句法更加复杂，于是通过定义将此情况解析为抽取优先于解\n析为切片来消除这种歧义（切片列表未包含正确的切片就属于此情况）。\n切片的语义如下所述。 原型通过一个根据所下所示的切片列表来构造的键进行索引（与普通的抽取\n一样使用 __getitem__() 方法）。 如果切片列表包含至少一个逗号，则键将是一个包含切片项转\n换形式的元组；否则的话，键将是单个切片项的转换形式。 切片项如为一个表达式，则其转换形式\n就是该表达式。 一个正确的切片的转换形式就是一个切片对象（参见 标准类型层级结构 一节），该\n对象的 start, stop 和 step 属性将分别为表达式所给出的下界、上界和步长值，省略的表达式将\n用 None 来替换。\n6.3.4. 调用\n所谓调用就是附带可能为空的一系列 参数 来执行一个可调用对象 (例如 function): |  |\n|  | call: primary \"(\" [argument_list [\",\"] | comprehension] \")\"\nargument_list: positional_arguments [\",\" starred_and_keywords]\n[\",\" keywords_arguments]\n| starred_and_keywords [\",\" keywords_arguments]\n| keywords_arguments\npositional_arguments: positional_item (\",\" positional_item)*\npositional_item: assignment_expression | \"*\" expression\nstarred_and_keywords: (\"*\" expression | keyword_item)\n(\",\" \"*\" expression | \",\" keyword_item)*\nkeywords_arguments: (keyword_item | \"**\" expression) |  |\n\n(\",\" keyword_item | \",\" \"**\" expression)*\nkeyword_item: identifier \"=\" expression\n一个可选项为在位置和关键字参数后加上逗号而不影响语义。\n此原型必须被求值为一个可调用对象（用户自定义函数、内置函数、内置对象的方法、类对象、类\n实例的方法以及任何具有 __call__() 方法的对象都是可调用对象）。 所有参数表达式将在尝试调\n用前被求值）。 请参阅 函数定义 一节了解正式的 parameter 列表的语法。\n如果存在关键字参数，它们会先通过以下操作被转换为位置参数。 首先，为正式参数创建一个未填\n充空位的例表。 如果有 N 个位置参数，则它们会被放入前 N 个空位。 然后，对于每个关键字参\n数，使用标识符来确定其对应的空位（如果标识符与第一个正式参数名相同则使用第一个空位，依\n此类推）。 如果空位已被填充，则会引发 TypeError 异常。 否则，将参数值放入空位，进行填充\n（即使表达式为 None，它也会填充空位）。 当所有参数处理完毕时，尚未填充的空位将用来自函数\n定义的相应默认值来填充。 （函数一旦被定义，其默认值就会被计算；因此，当列表或字典这类可\n变对象被用作默认值时将会被所有未指定相应空位参数值的调用所共享；这种情况通常应当被避\n免。） 如果任何一个未填充空位没有指定默认值，则会引发 TypeError 异常。 在其他情况下，已\n填充空位的列表会被作为调用的参数列表。\n某些实现可能提供位置参数没有名称的内置函数，即使它们在文档说明的场合下有“命名”，因此不能\n以关键字形式提供参数。 在 CPython 中，以 C 编写并使用 PyArg_ParseTuple() 来解析其参数的\n函数实现就属于这种情况。\n如果存在比正式参数空位多的位置参数，将会引发 TypeError 异常，除非有一个正式参数使用了\n*identifier 句法；在此情况下，该正式参数将接受一个包含了多余位置参数的元组（如果没有多\n余位置参数则为一个空元组）。\n如果任何关键字参数没有与之对应的正式参数名称，将会引发 TypeError 异常，除非有一个正式参\n数使用了 **identifier 句法，该正式参数将接受一个包含了多余关键字参数的字典（使用关键字\n作为键而参数值作为与键对应的值），如果没有多余关键字参数则为一个（新的）空字典。\n如果函数调用中出现了 *expression 句法，expression 必须求值为一个 iterable。 来自该可迭代\n对象的元素会被当作是额外的位置参数。 对于 f(x1, x2, *y, x3, x4) 调用，如果 y 求值为一个\n序列 y1, ..., yM，则它就等价于一个带有 M+4 个位置参数 x1, x2, y1, ..., yM, x3, x4 的调用。\n这样做的一个后果是虽然 *expression 句法可能出现于显式的关键字参数 之后，但它会在关键字参\n数（以及任何 **expression 参数 -- 见下文） 之前 被处理。 因此:\n>>> def f(a, b):\n... print(a, b)\n...\n>>> f(b=1, *(2,))\n2 1\n>>> f(a=1, *(2,))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: f() got multiple values for keyword argument 'a'\n>>> f(1, *(2,))\n1 2\n\n|  | (\",\" keyword_item | \",\" \"**\" expression)*\nkeyword_item: identifier \"=\" expression |  |\n| --- | --- | --- |\n|  | 一个可选项为在位置和关键字参数后加上逗号而不影响语义。\n此原型必须被求值为一个可调用对象（用户自定义函数、内置函数、内置对象的方法、类对象、类\n实例的方法以及任何具有 __call__() 方法的对象都是可调用对象）。 所有参数表达式将在尝试调\n用前被求值）。 请参阅 函数定义 一节了解正式的 parameter 列表的语法。\n如果存在关键字参数，它们会先通过以下操作被转换为位置参数。 首先，为正式参数创建一个未填\n充空位的例表。 如果有 N 个位置参数，则它们会被放入前 N 个空位。 然后，对于每个关键字参\n数，使用标识符来确定其对应的空位（如果标识符与第一个正式参数名相同则使用第一个空位，依\n此类推）。 如果空位已被填充，则会引发 TypeError 异常。 否则，将参数值放入空位，进行填充\n（即使表达式为 None，它也会填充空位）。 当所有参数处理完毕时，尚未填充的空位将用来自函数\n定义的相应默认值来填充。 （函数一旦被定义，其默认值就会被计算；因此，当列表或字典这类可\n变对象被用作默认值时将会被所有未指定相应空位参数值的调用所共享；这种情况通常应当被避\n免。） 如果任何一个未填充空位没有指定默认值，则会引发 TypeError 异常。 在其他情况下，已\n填充空位的列表会被作为调用的参数列表。\n某些实现可能提供位置参数没有名称的内置函数，即使它们在文档说明的场合下有“命名”，因此不能\n以关键字形式提供参数。 在 CPython 中，以 C 编写并使用 PyArg_ParseTuple() 来解析其参数的\n函数实现就属于这种情况。\n如果存在比正式参数空位多的位置参数，将会引发 TypeError 异常，除非有一个正式参数使用了\n*identifier 句法；在此情况下，该正式参数将接受一个包含了多余位置参数的元组（如果没有多\n余位置参数则为一个空元组）。\n如果任何关键字参数没有与之对应的正式参数名称，将会引发 TypeError 异常，除非有一个正式参\n数使用了 **identifier 句法，该正式参数将接受一个包含了多余关键字参数的字典（使用关键字\n作为键而参数值作为与键对应的值），如果没有多余关键字参数则为一个（新的）空字典。\n如果函数调用中出现了 *expression 句法，expression 必须求值为一个 iterable。 来自该可迭代\n对象的元素会被当作是额外的位置参数。 对于 f(x1, x2, *y, x3, x4) 调用，如果 y 求值为一个\n序列 y1, ..., yM，则它就等价于一个带有 M+4 个位置参数 x1, x2, y1, ..., yM, x3, x4 的调用。\n这样做的一个后果是虽然 *expression 句法可能出现于显式的关键字参数 之后，但它会在关键字参\n数（以及任何 **expression 参数 -- 见下文） 之前 被处理。 因此: |  |\n|  | >>> def f(a, b):\n... print(a, b)\n...\n>>> f(b=1, *(2,))\n2 1\n>>> f(a=1, *(2,))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: f() got multiple values for keyword argument 'a'\n>>> f(1, *(2,))\n1 2 |  |\n|  |  |  |\n\n在同一个调用中同时使用关键字参数和 *expression 语句并不常见，因此实际上这样的混淆不会发\n生。\n如果函数调用中出现了 **expression，则 expression 必须求值为一个 mapping，其内容会被当\n作是额外的关键字参数。 如果一个形参与一个已给定值关键字相匹配（通过显式的关键字参数，或\n通过另一个解包），则会引发 TypeError 异常。\n当使用 **expression 时，该映射中的每个键都必须为字符串。 该映射中的每个值将被赋值给名称\n与键相同的适用于关键字赋值的第一个正式形参。 键名不需要是 Python 标识符（例如 \"max-temp\n°F\" 也是可接受的，但它将不能与可被声明的任何正式形参相匹配）。 如果键值对未与某个正式形\n参相匹配则将被 ** 形参所收集，或者如果没有此形参，则会引发 TypeError 异常。\n使用 *identifier 或 **identifier 句法的正式参数不能被用作位置参数空位或关键字参数名称。\n在 3.5 版本发生变更: 函数调用接受任意数量的 * 和 ** 拆包，位置参数可能跟在可迭代对象拆\n包 (*) 之后，而关键字参数可能跟在字典拆包 (**) 之后。 由 PEP 448 发起最初提议。\n除非引发了异常，调用总是会有返回值，返回值也可能为 None。 返回值的计算方式取决于可调用对\n象的类型。\n如果类型为---\n用户自定义函数:\n函数的代码块会被执行，并向其传入参数列表。 代码块所做的第一件事是将正式形参绑定到对\n应的参数；相关说明参见 函数定义 一节。 当代码块执行 return 语句时，这将指定函数调用的\n返回值。 如果执行到达代码块的末尾时并未执行过 return 语句，则返回值将为 None。\n内置函数或方法:\n具体结果依赖于解释器；有关内置函数和方法的描述参见 内置函数。\n类对象:\n返回该类的一个新实例。\n类实例方法:\n调用相应的用户自定义函数，向其传入的参数列表会比调用的参数列表多一项：该实例将成为\n第一个参数。\n类实例:\n该类定义定义 __call__() 方法；其效果将等价于调用该方法。\n6.4. await 表达式\n挂起 coroutine 的执行以等待一个 awaitable 对象。 只能在 coroutine function 内部使用。\nawait_expr: \"await\" primary\nAdded in version 3.5.\n\n|  |  | 在同一个调用中同时使用关键字参数和 *expression 语句并不常见，因此实际上这样的混淆不会发\n生。\n如果函数调用中出现了 **expression，则 expression 必须求值为一个 mapping，其内容会被当\n作是额外的关键字参数。 如果一个形参与一个已给定值关键字相匹配（通过显式的关键字参数，或\n通过另一个解包），则会引发 TypeError 异常。\n当使用 **expression 时，该映射中的每个键都必须为字符串。 该映射中的每个值将被赋值给名称\n与键相同的适用于关键字赋值的第一个正式形参。 键名不需要是 Python 标识符（例如 \"max-temp\n°F\" 也是可接受的，但它将不能与可被声明的任何正式形参相匹配）。 如果键值对未与某个正式形\n参相匹配则将被 ** 形参所收集，或者如果没有此形参，则会引发 TypeError 异常。\n使用 *identifier 或 **identifier 句法的正式参数不能被用作位置参数空位或关键字参数名称。\n在 3.5 版本发生变更: 函数调用接受任意数量的 * 和 ** 拆包，位置参数可能跟在可迭代对象拆\n包 (*) 之后，而关键字参数可能跟在字典拆包 (**) 之后。 由 PEP 448 发起最初提议。\n除非引发了异常，调用总是会有返回值，返回值也可能为 None。 返回值的计算方式取决于可调用对\n象的类型。\n如果类型为---\n用户自定义函数:\n函数的代码块会被执行，并向其传入参数列表。 代码块所做的第一件事是将正式形参绑定到对\n应的参数；相关说明参见 函数定义 一节。 当代码块执行 return 语句时，这将指定函数调用的\n返回值。 如果执行到达代码块的末尾时并未执行过 return 语句，则返回值将为 None。\n内置函数或方法:\n具体结果依赖于解释器；有关内置函数和方法的描述参见 内置函数。\n类对象:\n返回该类的一个新实例。\n类实例方法:\n调用相应的用户自定义函数，向其传入的参数列表会比调用的参数列表多一项：该实例将成为\n第一个参数。\n类实例:\n该类定义定义 __call__() 方法；其效果将等价于调用该方法。\n6.4. await 表达式\n挂起 coroutine 的执行以等待一个 awaitable 对象。 只能在 coroutine function 内部使用。 |  |  |\n| --- | --- | --- | --- | --- |\n|  |  |  | \"max-temp |  |\n|  |  |  |  |  |\n|  |  | °F\" |  |  |\n|  |  |  |  |  |\n|  |  | await_expr: \"await\" primary |  |  |\n|  |  | Added in version 3.5. |  |  |\n\n6.5. 幂运算符\n幂运算符的绑定比在其左侧的一元运算符更紧密；但绑定紧密程度不及在其右侧的一元运算符。 句\n法如下:\npower: (await_expr | primary) [\"**\" u_expr]\n因此，在一个未加圆括号的幂运算符和单目运算符序列中，运算符将从右向左求值（这不会限制操\n作数的求值顺序）: -1**2 结果将为 -1。\n幂运算符与附带两个参数调用内置 pow() 函数具有相同的语义：结果为对其左参数进行其右参数所\n指定幂次的乘方运算。 数值参数会先转换为相同类型，结果也为转换后的类型。\n对于 int 类型的操作数，结果将具有与操作数相同的类型，除非第二个参数为负数；在那种情况下，\n所有参数会被转换为 float 类型并输出 float 类型的结果。 例如，10**2 返回 100，而 10**-2 返回\n0.01。\n对 0.0 进行负数幂次运算将导致 ZeroDivisionError。 对负数进行分数幂次运算将返回 complex\n数值。 （在早期版本中这将引发 ValueError。）\n此运算可使用特殊的 __pow__() 和 __rpow__() 方法来自定义。\n6.6. 一元算术和位运算\n所有算术和位运算具有相同的优先级:\nu_expr: power | \"-\" u_expr | \"+\" u_expr | \"~\" u_expr\n单目运算符 - (负值) 将输出对数字参数的负值；该运算可通过 __neg__() 特殊方法来重写。\n单目运算符 + (正值) 将不加修改地输出其数字参数；该运算可通过 __pos__() 特殊方法来重写。\n单目运算符 ~ (取反) 将输出对其整数参数按位取反的结果。 对 x 按位取反被定义为 -(x+1)。 它只\n作用于整数或是重写了 __invert__() 特殊方法的自定义对象。\n在所有三种情况下，如果参数的类型不正确，将引发 TypeError 异常。\n6.7. 二元算术运算符\n二元算术运算符遵循传统的优先级。 请注意某些此类运算符也作用于特定的非数字类型。 除幂运算\n符以外只有两个优先级别，一个作用于乘法型运算符，另一个作用于加法型运算符:\nm_expr: u_expr | m_expr \"*\" u_expr | m_expr \"@\" m_expr |\nm_expr \"//\" u_expr | m_expr \"/\" u_expr |\nm_expr \"%\" u_expr\na_expr: m_expr | a_expr \"+\" m_expr | a_expr \"-\" m_expr\n\n|  | 6.5. 幂运算符\n幂运算符的绑定比在其左侧的一元运算符更紧密；但绑定紧密程度不及在其右侧的一元运算符。 句\n法如下: |  |\n| --- | --- | --- |\n|  | power: (await_expr | primary) [\"**\" u_expr] |  |\n|  | 因此，在一个未加圆括号的幂运算符和单目运算符序列中，运算符将从右向左求值（这不会限制操\n作数的求值顺序）: -1**2 结果将为 -1。\n幂运算符与附带两个参数调用内置 pow() 函数具有相同的语义：结果为对其左参数进行其右参数所\n指定幂次的乘方运算。 数值参数会先转换为相同类型，结果也为转换后的类型。\n对于 int 类型的操作数，结果将具有与操作数相同的类型，除非第二个参数为负数；在那种情况下，\n所有参数会被转换为 float 类型并输出 float 类型的结果。 例如，10**2 返回 100，而 10**-2 返回\n0.01。\n对 0.0 进行负数幂次运算将导致 ZeroDivisionError。 对负数进行分数幂次运算将返回 complex\n数值。 （在早期版本中这将引发 ValueError。）\n此运算可使用特殊的 __pow__() 和 __rpow__() 方法来自定义。\n6.6. 一元算术和位运算\n所有算术和位运算具有相同的优先级: |  |\n|  | u_expr: power | \"-\" u_expr | \"+\" u_expr | \"~\" u_expr |  |\n|  | 单目运算符 - (负值) 将输出对数字参数的负值；该运算可通过 __neg__() 特殊方法来重写。\n单目运算符 + (正值) 将不加修改地输出其数字参数；该运算可通过 __pos__() 特殊方法来重写。\n单目运算符 ~ (取反) 将输出对其整数参数按位取反的结果。 对 x 按位取反被定义为 -(x+1)。 它只\n作用于整数或是重写了 __invert__() 特殊方法的自定义对象。\n在所有三种情况下，如果参数的类型不正确，将引发 TypeError 异常。\n6.7. 二元算术运算符\n二元算术运算符遵循传统的优先级。 请注意某些此类运算符也作用于特定的非数字类型。 除幂运算\n符以外只有两个优先级别，一个作用于乘法型运算符，另一个作用于加法型运算符: |  |\n|  | m_expr: u_expr | m_expr \"*\" u_expr | m_expr \"@\" m_expr |\nm_expr \"//\" u_expr | m_expr \"/\" u_expr |\nm_expr \"%\" u_expr\na_expr: m_expr | a_expr \"+\" m_expr | a_expr \"-\" m_expr |  |\n|  |  |  |\n\n运算符 * (乘) 将产生其参数的乘积。 两个参数必须或者都为数字，或者一个参数必须为整数而另一\n个必须为序列。 在前一种情况下，两个数字将被转换为相同类型然后相乘。 在后一种情况下，将执\n行序列的重复；重复因子为负则产生一个空序列。\n此运算可使用特殊的 __mul__() 和 __rmul__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。\n运算符 @ (at) 的目标是用于矩阵乘法。 没有内置 Python 类型实现此运算符。\n此运算可使用特殊的 __matmul__() 和 __rmatmul__() 方法来自定义。\nAdded in version 3.5.\n运算符 / (除) 和 // (整除) 将输出其参数的商。 两个数字参数将先被转换为相同类型。 整数相除会\n输出一个 float 值，整数相整除的结果仍是整数；整除的结果就是使用 'floor' 函数进行算术除法的结\n果。 除以零的运算将引发 ZeroDivisionError 异常。\n除法运算可使用特殊的 __truediv__() 和 __rtruediv__() 方法来自定义。 向下整除运算可使用\n特殊的 __floordiv__() 和 __rfloordiv__() 方法来自定义。\n运算符 % (模) 将输出第一个参数除以第二个参数的余数。 两个数字参数将先被转换为相同类型。 右\n参数为零将引发 ZeroDivisionError 异常。 参数可以为浮点数，例如 3.14%0.7 等于 0.34 (因为\n3.14 等于 4*0.7 + 0.34)。 模运算符的结果的正负总是与第二个操作数一致（或是为零）；结果\n的绝对值一定小于第二个操作数的绝对值 [1]。\n整除与模运算符的联系可通过以下等式说明: x == (x//y)*y + (x%y)。 此外整除与模也可通过内\n置函数 divmod() 来同时进行: divmod(x, y) == (x//y, x%y)。 [2]。\n除了对数字执行模运算，运算符 % 还被字符串对象重载用于执行旧式的字符串格式化（又称插\n值）。 字符串格式化句法的描述参见 Python 库参考的 printf 风格的字符串格式化 一节。\nmodulo 运算可使用特殊的 __mod__() 和 __rmod__() 方法来自定义。\n整除运算符，模运算符和 divmod() 函数未被定义用于复数。 如果有必要可以使用 abs() 函数将其\n转换为浮点数。\n运算符 + (加) 将产生其参数的和。 两个参数必须或者都为数字，或者都为相同类型的序列。 在前一\n种情况下，两个数字将被转换为相同类型然后相加。 在后一种情况下，将执行序列的拼接。\n此运算可使用特殊的 __add__() 和 __radd__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。\n运算符 - (减) 将产生其参数的差。 两个数字参数将先被转换为相同的实数类型。\n此运算可使用特殊的 __sub__() 和 __rsub__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。\n\n|  | 运算符 * (乘) 将产生其参数的乘积。 两个参数必须或者都为数字，或者一个参数必须为整数而另一\n个必须为序列。 在前一种情况下，两个数字将被转换为相同类型然后相乘。 在后一种情况下，将执\n行序列的重复；重复因子为负则产生一个空序列。\n此运算可使用特殊的 __mul__() 和 __rmul__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。\n运算符 @ (at) 的目标是用于矩阵乘法。 没有内置 Python 类型实现此运算符。\n此运算可使用特殊的 __matmul__() 和 __rmatmul__() 方法来自定义。\nAdded in version 3.5.\n运算符 / (除) 和 // (整除) 将输出其参数的商。 两个数字参数将先被转换为相同类型。 整数相除会\n输出一个 float 值，整数相整除的结果仍是整数；整除的结果就是使用 'floor' 函数进行算术除法的结\n果。 除以零的运算将引发 ZeroDivisionError 异常。\n除法运算可使用特殊的 __truediv__() 和 __rtruediv__() 方法来自定义。 向下整除运算可使用\n特殊的 __floordiv__() 和 __rfloordiv__() 方法来自定义。\n运算符 % (模) 将输出第一个参数除以第二个参数的余数。 两个数字参数将先被转换为相同类型。 右\n参数为零将引发 ZeroDivisionError 异常。 参数可以为浮点数，例如 3.14%0.7 等于 0.34 (因为\n3.14 等于 4*0.7 + 0.34)。 模运算符的结果的正负总是与第二个操作数一致（或是为零）；结果\n的绝对值一定小于第二个操作数的绝对值 [1]。\n整除与模运算符的联系可通过以下等式说明: x == (x//y)*y + (x%y)。 此外整除与模也可通过内\n置函数 divmod() 来同时进行: divmod(x, y) == (x//y, x%y)。 [2]。\n除了对数字执行模运算，运算符 % 还被字符串对象重载用于执行旧式的字符串格式化（又称插\n值）。 字符串格式化句法的描述参见 Python 库参考的 printf 风格的字符串格式化 一节。\nmodulo 运算可使用特殊的 __mod__() 和 __rmod__() 方法来自定义。\n整除运算符，模运算符和 divmod() 函数未被定义用于复数。 如果有必要可以使用 abs() 函数将其\n转换为浮点数。\n运算符 + (加) 将产生其参数的和。 两个参数必须或者都为数字，或者都为相同类型的序列。 在前一\n种情况下，两个数字将被转换为相同类型然后相加。 在后一种情况下，将执行序列的拼接。\n此运算可使用特殊的 __add__() 和 __radd__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。\n运算符 - (减) 将产生其参数的差。 两个数字参数将先被转换为相同的实数类型。\n此运算可使用特殊的 __sub__() 和 __rsub__() 方法来自定义。\n在 3.14 版本发生变更: 如果只有一个操作数为复数，另一参数将被转换为浮点数。 |  |\n| --- | --- | --- |\n\n6.8. 移位运算\n移位运算的优先级低于算术运算:\nshift_expr: a_expr | shift_expr (\"<<\" | \">>\") a_expr\n这些运算符接受整数参数。 它们会将第一个参数左移或右移第二个参数所指定的比特位数。\n左移位运算可使用特殊的 __lshift__() 和 __rlshift__() 方法来自定义。 右移位运算可使用特\n殊的 __rshift__() 和 __rrshift__() 方法来自定义。\n右移 n 位被定义为被 pow(2,n) 整除。 左移 n 位被定义为乘以 pow(2,n)。\n6.9. 二元位运算\n三种位运算具有各不相同的优先级:\nand_expr: shift_expr | and_expr \"&\" shift_expr\nxor_expr: and_expr | xor_expr \"^\" and_expr\nor_expr: xor_expr | or_expr \"|\" xor_expr\n& 运算符将输出对其参数按位 AND 的结果，参数必须都为整数或者其中之一必须为重写了\n__and__() 或 __rand__() 特殊方法的自定义对象。\n^ 运算符将输出对其参数按位 XOR (异或) 的结果，参数必须都为整数或者其中之一必须为重写了\n__xor__() 或 __rxor__() 特殊方法的自定义对象。\n| 运算符将输出对其参数按位OR (非异或) 的结果，参数必须都为整数或者其中之一为重写了\n__or__() 或 __ror__() 特殊方法的自定义对象。\n6.10. 比较运算\n与 C 不同，Python 中所有比较运算的优先级相同，低于任何算术、移位或位运算。 另一个与 C 不\n同之处在于 a < b < c 这样的表达式会按传统算术法则来解读:\ncomparison: or_expr (comp_operator or_expr)*\ncomp_operator: \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\"\n| \"is\" [\"not\"] | [\"not\"] \"in\"\n比较运算会产生布尔值: True 或 False。 自定义的 富比较方法 可能返回非布尔值。 在此情况下\nPython 将在布尔运算上下文中对该值调用 bool()。\n比较运算可以任意串连，例如 x < y <= z 等价于 x < y and y <= z，除了 y 只被求值一次（但\n在两种写法下当 x < y 值为假时 z 都不会被求值）。\n正式的说法是这样：如果 a, b, c, ..., y, z 为表达式而 op1, op2, ..., opN 为比较运算符，则 a op1 b\nop2 c ... y opN z 就等价于 a op1 b and b op2 c and ... y opN z，不同点在于每个表达式\n最多只被求值一次。\n\n|  |  | 6.8. 移位运算\n移位运算的优先级低于算术运算: |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | shift_expr: a_expr | shift_expr (\"<<\" | \">>\") a_expr |  |  |  |\n|  |  | 这些运算符接受整数参数。 它们会将第一个参数左移或右移第二个参数所指定的比特位数。\n左移位运算可使用特殊的 __lshift__() 和 __rlshift__() 方法来自定义。 右移位运算可使用特\n殊的 __rshift__() 和 __rrshift__() 方法来自定义。\n右移 n 位被定义为被 pow(2,n) 整除。 左移 n 位被定义为乘以 pow(2,n)。\n6.9. 二元位运算\n三种位运算具有各不相同的优先级: |  |  |  |\n|  |  | and_expr: shift_expr | and_expr \"&\" shift_expr\nxor_expr: and_expr | xor_expr \"^\" and_expr\nor_expr: xor_expr | or_expr \"|\" xor_expr |  |  |  |\n|  |  | & 运算符将输出对其参数按位 AND 的结果，参数必须都为整数或者其中之一必须为重写了\n__and__() 或 __rand__() 特殊方法的自定义对象。\n^ 运算符将输出对其参数按位 XOR (异或) 的结果，参数必须都为整数或者其中之一必须为重写了\n__xor__() 或 __rxor__() 特殊方法的自定义对象。\n| 运算符将输出对其参数按位OR (非异或) 的结果，参数必须都为整数或者其中之一为重写了\n__or__() 或 __ror__() 特殊方法的自定义对象。\n6.10. 比较运算\n与 C 不同，Python 中所有比较运算的优先级相同，低于任何算术、移位或位运算。 另一个与 C 不\n同之处在于 a < b < c 这样的表达式会按传统算术法则来解读: |  |  |  |\n|  |  | comparison: or_expr (comp_operator or_expr)*\ncomp_operator: \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\"\n| \"is\" [\"not\"] | [\"not\"] \"in\" |  |  |  |\n|  |  | 比较运算会产生布尔值: True 或 False。 自定义的 富比较方法 可能返回非布尔值。 在此情况下\nPython 将在布尔运算上下文中对该值调用 bool()。\n比较运算可以任意串连，例如 x < y <= z 等价于 x < y and y <= z，除了 y 只被求值一次（但\n在两种写法下当 x < y 值为假时 z 都不会被求值）。\n正式的说法是这样：如果 a, b, c, ..., y, z 为表达式而 op1, op2, ..., opN 为比较运算符，则 a op1 b\nop2 c ... y opN z 就等价于 a op1 b and b op2 c and ... y opN z，不同点在于每个表达式\n最多只被求值一次。 |  |  |  |\n|  |  |  | a op1 b |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n|  |  |  |  |  |  |\n\n请注意 a op1 b op2 c 不意味着在 a 和 c 之间进行任何比较，因此，如 x < y > z 这样的写法是\n完全合法的（虽然也许不太好看）。\n6.10.1. 值比较\n运算符 <, >, ==, >=, <= 和 != 将比较两个对象的值。 两个对象不要求为相同类型。\n对象、值与类型 一章已说明对象都有相应的值（还有类型和标识号）。 对象值在 Python 中是一个\n相当抽象的概念：例如，对象值并没有一个规范的访问方法。 而且，对象值并不要求具有特定的构\n建方式，例如由其全部数据属性组成等。 比较运算符实现了一个特定的对象值概念。 人们可以认为\n这是通过实现对象比较间接地定义了对象值。\n由于所有类型都是 object 的（直接或间接）的子类型，因此它们都从 object 继承了默认的比较行\n为。 类型可以通过实现 rich comparison methods 如 __lt__() 来自定义它们的比较行为，详情参见\n基本定制。\n默认的一致性比较 (== 和 !=) 是基于对象的标识号。 因此，具有相同标识号的实例一致性比较结果\n为相等，具有不同标识号的实例一致性比较结果为不等。 规定这种默认行为的动机是希望所有对象\n都应该是自反射的 (即 x is y 就意味着 x == y)。\n次序比较 (<, >, <= 和 >=) 默认没有提供；如果尝试比较会引发 TypeError。 规定这种默认行为的\n原因是缺少与一致性比较类似的固定值。\n按照默认的一致性比较行为，具有不同标识号的实例总是不相等，这可能不适合某些对象值需要有\n合理定义并有基于值的一致性的类型。 这样的类型需要定制自己的比较行为，实际上，许多内置类\n型都是这样做的。\n以下列表描述了最主要内置类型的比较行为。\n内置数值类型 (数字类型 --- int, float, complex) 以及标准库类型 fractions.Fraction 和\ndecimal.Decimal 可进行类型内部和跨类型的比较，例外限制是复数不支持次序比较。 在类型相\n关的限制以内，它们会按数学（算法）规则正确进行比较且不会有精度损失。\n非数字值 float('NaN') 和 decimal.Decimal('NaN') 属于特例。 任何数字与非数字值的排序比\n较均返回假值。 还有一个反直觉的结果是非数字值不等于其自身。 举例来说，如果 x =\nfloat('NaN') 则 3 < x, x < 3 和 x == x 均为假值，而 x != x 则为真值。 此行为是遵循 IEEE\n754 标准的。\nNone 和 NotImplemented 都是单例对象。 PEP 8 建议单例对象的比较应当总是通过 is 或 is\nnot 来进行，绝不要使用等于运算符。\n二进制码序列 (bytes 或 bytearray 的实例) 可进行类型内部和跨类型的比较。 它们使用其元素\n的数字值按字典顺序进行比较。\n字符串 (str 的实例) 使用其字符的 Unicode 码位数字值 (内置函数 ord() 的结果) 按字典顺序进\n行比较。 [3]\n字符串和二进制码序列不能直接比较。\n\n|  | 请注意 a op1 b op2 c 不意味着在 a 和 c 之间进行任何比较，因此，如 x < y > z 这样的写法是\n完全合法的（虽然也许不太好看）。\n6.10.1. 值比较\n运算符 <, >, ==, >=, <= 和 != 将比较两个对象的值。 两个对象不要求为相同类型。\n对象、值与类型 一章已说明对象都有相应的值（还有类型和标识号）。 对象值在 Python 中是一个\n相当抽象的概念：例如，对象值并没有一个规范的访问方法。 而且，对象值并不要求具有特定的构\n建方式，例如由其全部数据属性组成等。 比较运算符实现了一个特定的对象值概念。 人们可以认为\n这是通过实现对象比较间接地定义了对象值。\n由于所有类型都是 object 的（直接或间接）的子类型，因此它们都从 object 继承了默认的比较行\n为。 类型可以通过实现 rich comparison methods 如 __lt__() 来自定义它们的比较行为，详情参见\n基本定制。\n默认的一致性比较 (== 和 !=) 是基于对象的标识号。 因此，具有相同标识号的实例一致性比较结果\n为相等，具有不同标识号的实例一致性比较结果为不等。 规定这种默认行为的动机是希望所有对象\n都应该是自反射的 (即 x is y 就意味着 x == y)。\n次序比较 (<, >, <= 和 >=) 默认没有提供；如果尝试比较会引发 TypeError。 规定这种默认行为的\n原因是缺少与一致性比较类似的固定值。\n按照默认的一致性比较行为，具有不同标识号的实例总是不相等，这可能不适合某些对象值需要有\n合理定义并有基于值的一致性的类型。 这样的类型需要定制自己的比较行为，实际上，许多内置类\n型都是这样做的。\n以下列表描述了最主要内置类型的比较行为。\n内置数值类型 (数字类型 --- int, float, complex) 以及标准库类型 fractions.Fraction 和\ndecimal.Decimal 可进行类型内部和跨类型的比较，例外限制是复数不支持次序比较。 在类型相\n关的限制以内，它们会按数学（算法）规则正确进行比较且不会有精度损失。\n非数字值 float('NaN') 和 decimal.Decimal('NaN') 属于特例。 任何数字与非数字值的排序比\n较均返回假值。 还有一个反直觉的结果是非数字值不等于其自身。 举例来说，如果 x =\nfloat('NaN') 则 3 < x, x < 3 和 x == x 均为假值，而 x != x 则为真值。 此行为是遵循 IEEE\n754 标准的。\nNone 和 NotImplemented 都是单例对象。 PEP 8 建议单例对象的比较应当总是通过 is 或 is\nnot 来进行，绝不要使用等于运算符。\n二进制码序列 (bytes 或 bytearray 的实例) 可进行类型内部和跨类型的比较。 它们使用其元素\n的数字值按字典顺序进行比较。\n字符串 (str 的实例) 使用其字符的 Unicode 码位数字值 (内置函数 ord() 的结果) 按字典顺序进\n行比较。 [3]\n字符串和二进制码序列不能直接比较。 |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | x = |  |  |\n|  |  |  |  |  |\n\n|  | float('NaN') |\n| --- | --- |\n\n序列 (tuple, list 或 range 的实例) 只可进行类型内部的比较，range 还有一个限制是不支持次\n序比较。 以上对象的跨类型一致性比较结果将是不相等，跨类型次序比较将引发 TypeError。\n序列比较是按字典序对相应元素进行逐个比较。 内置容器通常设定同一对象与其自身是相等的。\n这使得它们能跳过同一对象的相等性检测以提升运行效率并保持它们的内部不变性。\n内置多项集间的字典序比较规则如下:\n两个多项集若要相等，它们必须为相同类型、相同长度，并且每对相应的元素都必须相等（例\n如，[1,2] == (1,2) 为假值，因为类型不同）。\n对于支持次序比较的多项集，排序与其第一个不相等元素的排序相同（例如 [1,2,x] <=\n[1,2,y] 的值与 x <= y 相同）。 如果对应元素不存在，较短的多项集排序在前（例如 [1,2]\n< [1,2,3] 为真值）。\n两个映射 (dict 的实例) 若要相等则必须当且仅当它们具有相等的 (key, value) 对。 键和值的\n相相等性比较强制要求自反射性。\n次序比较 (<, >, <= 和 >=) 将引发 TypeError。\n集合 (set 或 frozenset 的实例) 可进行类型内部和跨类型的比较。\n它们将比较运算符定义为子集和超集检测。 这类关系没有定义完全排序（例如 {1,2} 和 {2,3}\n两个集合不相等，即不为彼此的子集，也不为彼此的超集。 相应地，集合不适宜作为依赖于完全\n排序的函数的参数（例如如果给出一个集合列表作为 min(), max() 和 sorted() 的输入将产生未\n定义的结果）。\n集合的比较强制规定其元素的自反射性。\n大多数其他内置类型没有实现比较方法，因此它们会继承默认的比较行为。\n在可能的情况下，用户定义类在定制其比较行为时应当遵循一些一致性规则:\n相等比较应该是自反射的。 换句话说，相同的对象比较时应该相等:\nx is y 意味着 x == y\n比较应该是对称的。 换句话说，下列表达式应该有相同的结果:\nx == y 和 y == x\nx != y 和 y != x\nx < y 和 y > x\nx <= y 和 y >= x\n比较应该是可传递的。 下列（简要的）例子显示了这一点:\nx > y and y > z 意味着 x > z\n\n|  |  | 序列 (tuple, list 或 range 的实例) 只可进行类型内部的比较，range 还有一个限制是不支持次\n序比较。 以上对象的跨类型一致性比较结果将是不相等，跨类型次序比较将引发 TypeError。\n序列比较是按字典序对相应元素进行逐个比较。 内置容器通常设定同一对象与其自身是相等的。\n这使得它们能跳过同一对象的相等性检测以提升运行效率并保持它们的内部不变性。\n内置多项集间的字典序比较规则如下:\n两个多项集若要相等，它们必须为相同类型、相同长度，并且每对相应的元素都必须相等（例\n如，[1,2] == (1,2) 为假值，因为类型不同）。\n对于支持次序比较的多项集，排序与其第一个不相等元素的排序相同（例如 [1,2,x] <=\n[1,2,y] 的值与 x <= y 相同）。 如果对应元素不存在，较短的多项集排序在前（例如 [1,2]\n< [1,2,3] 为真值）。\n两个映射 (dict 的实例) 若要相等则必须当且仅当它们具有相等的 (key, value) 对。 键和值的\n相相等性比较强制要求自反射性。\n次序比较 (<, >, <= 和 >=) 将引发 TypeError。\n集合 (set 或 frozenset 的实例) 可进行类型内部和跨类型的比较。\n它们将比较运算符定义为子集和超集检测。 这类关系没有定义完全排序（例如 {1,2} 和 {2,3}\n两个集合不相等，即不为彼此的子集，也不为彼此的超集。 相应地，集合不适宜作为依赖于完全\n排序的函数的参数（例如如果给出一个集合列表作为 min(), max() 和 sorted() 的输入将产生未\n定义的结果）。\n集合的比较强制规定其元素的自反射性。\n大多数其他内置类型没有实现比较方法，因此它们会继承默认的比较行为。\n在可能的情况下，用户定义类在定制其比较行为时应当遵循一些一致性规则:\n相等比较应该是自反射的。 换句话说，相同的对象比较时应该相等:\nx is y 意味着 x == y\n比较应该是对称的。 换句话说，下列表达式应该有相同的结果:\nx == y 和 y == x\nx != y 和 y != x\nx < y 和 y > x\nx <= y 和 y >= x\n比较应该是可传递的。 下列（简要的）例子显示了这一点:\nx > y and y > z 意味着 x > z |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  |  |  | [1,2,x] <= |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  | [1,2,y] |  | [1,2] |  |  |\n|  |  |  |  |  |  |  |\n\n|  | < [1,2,3] |\n| --- | --- |\n\nx < y and y <= z 意味着 x < z\n反向比较应该导致布尔值取反。 换句话说，下列表达式应该有相同的结果:\nx == y 和 not x != y\nx < y 和 not x >= y (对于完全排序)\nx > y 和 not x <= y (对于完全排序)\n最后两个表达式适用于完全排序的多项集（即序列而非集合或映射）。 另请参阅\ntotal_ordering() 装饰器。\nhash() 的结果应该与是否相等一致。 相等的对象应该或者具有相同的哈希值，或者标记为不可\n哈希。\nPython 并不强制要求这些一致性规则。 实际上，非数字值就是一个不遵循这些规则的例子。\n6.10.2. 成员检测运算\n运算符 in 和 not in 用于成员检测。 如果 x 是 s 的成员则 x in s 求值为 True，否则为 False。\nx not in s 返回 x in s 取反后的值。 所有内置序列和集合类型以及字典都支持此运算，对于字\n典来说 in 检测其是否有给定的键。 对于 list, tuple, set, frozenset, dict 或 collections.deque 这样的\n容器类型，表达式 x in y 等价于 any(x is e or x == e for e in y)。\n对于字符串和字节串类型来说，当且仅当 x 是 y 的子串时 x in y 为 True。 一个等价的检测是\ny.find(x) != -1。 空字符串总是被视为任何其他字符串的子串，因此 \"\" in \"abc\" 将返回\nTrue。\n对于定义了For user-defined classes which define the __contains__() 方法来用户自定义类来说，\n如果 y.__contains__(x) 返回真值则 x in y 将返回 True，否则返回 False。\n对于未定义 __contains__() 但定义了 __iter__() 的用户自定义类来说，如果在迭代 y 期间产生\n了值 z 使得表达式 x is z or x == z 为真值，则 x in y 将为 True。 如果在迭代期间引发了异\n常，则将等同于 in 引发了该异常。\n最后，将会尝试旧式的迭代协议：如果一个类定义了 __getitem__()，则当且仅当存在非负整数索\n引号 i 使得 x is y[i] or x == y[i] 并且没有更小的索引号引发 IndexError 异常时 x in y 才\n为 True。 （如果引发了任何其他异常，则等同于 in 引发了该异常。）\n运算符 not in 被定义为具有与 in 相反的逻辑值。\n6.10.3. 标识号比较\n运算符 is 和 is not 用于检测对象的标识号：当且仅当 x 和 y 是同一对象时 x is y 为真。 一个对\n象的标识号可使用 id() 函数来确定。 x is not y 会产生相反的逻辑值。 [4]\n6.11. 布尔运算\n\n|  | x < y and y <= z 意味着 x < z\n反向比较应该导致布尔值取反。 换句话说，下列表达式应该有相同的结果:\nx == y 和 not x != y\nx < y 和 not x >= y (对于完全排序)\nx > y 和 not x <= y (对于完全排序)\n最后两个表达式适用于完全排序的多项集（即序列而非集合或映射）。 另请参阅\ntotal_ordering() 装饰器。\nhash() 的结果应该与是否相等一致。 相等的对象应该或者具有相同的哈希值，或者标记为不可\n哈希。\nPython 并不强制要求这些一致性规则。 实际上，非数字值就是一个不遵循这些规则的例子。\n6.10.2. 成员检测运算\n运算符 in 和 not in 用于成员检测。 如果 x 是 s 的成员则 x in s 求值为 True，否则为 False。\nx not in s 返回 x in s 取反后的值。 所有内置序列和集合类型以及字典都支持此运算，对于字\n典来说 in 检测其是否有给定的键。 对于 list, tuple, set, frozenset, dict 或 collections.deque 这样的\n容器类型，表达式 x in y 等价于 any(x is e or x == e for e in y)。\n对于字符串和字节串类型来说，当且仅当 x 是 y 的子串时 x in y 为 True。 一个等价的检测是\ny.find(x) != -1。 空字符串总是被视为任何其他字符串的子串，因此 \"\" in \"abc\" 将返回\nTrue。\n对于定义了For user-defined classes which define the __contains__() 方法来用户自定义类来说，\n如果 y.__contains__(x) 返回真值则 x in y 将返回 True，否则返回 False。\n对于未定义 __contains__() 但定义了 __iter__() 的用户自定义类来说，如果在迭代 y 期间产生\n了值 z 使得表达式 x is z or x == z 为真值，则 x in y 将为 True。 如果在迭代期间引发了异\n常，则将等同于 in 引发了该异常。\n最后，将会尝试旧式的迭代协议：如果一个类定义了 __getitem__()，则当且仅当存在非负整数索\n引号 i 使得 x is y[i] or x == y[i] 并且没有更小的索引号引发 IndexError 异常时 x in y 才\n为 True。 （如果引发了任何其他异常，则等同于 in 引发了该异常。）\n运算符 not in 被定义为具有与 in 相反的逻辑值。\n6.10.3. 标识号比较\n运算符 is 和 is not 用于检测对象的标识号：当且仅当 x 和 y 是同一对象时 x is y 为真。 一个对\n象的标识号可使用 id() 函数来确定。 x is not y 会产生相反的逻辑值。 [4]\n6.11. 布尔运算 |  |\n| --- | --- | --- |\n\nor_test: and_test | or_test \"or\" and_test\nand_test: not_test | and_test \"and\" not_test\nnot_test: comparison | \"not\" not_test\n在执行布尔运算的情况下，或是当表达式被用于流程控制语句时，以下值会被解读为假值: False,\nNone, 所有类型的数字零，以及空字符串和空容器（包括字符串、元组、列表、字典、集合与冻结集\n合）。 所有其他值都会被解读为真值。 用户自定义对象可通过提供 __bool__() 方法来定制其逻辑\n值。\n运算符 not 将在其参数为假值时产生 True，否则产生 False。\n表达式 x and y 首先对 x 求值；如果 x 为假则返回该值；否则对 y 求值并返回其结果值。\n表达式 x or y 首先对 x 求值；如果 x 为真则返回该值；否则对 y 求值并返回其结果值。\n请注意 and 和 or 都不限制其返回的值和类型必须为 False 和 True，而是返回最后被求值的操作\n数。 此行为是有必要的，例如假设 s 为一个当其为空时应被替换为某个默认值的字符串，表达式 s\nor 'foo' 将产生希望的值。 由于 not 必须创建一个新值，不论其参数为何种类型它都会返回一个\n布尔值（例如，not 'foo' 结果为 False 而非 ''。）\n6.12. 赋值表达式\nassignment_expression: [identifier \":=\"] expression\n赋值表达式（有时又被称为“命名表达式”或“海象表达式”）将一个 expression 赋值给一个\nidentifier，同时还会返回 expression 的值。\n一个常见用例是在处理匹配的正则表达式的时候:\nif matching := pattern.search(data):\ndo_something(matching)\n或者是在处理分块的文件流的时候:\nwhile chunk := file.read(9000):\nprocess(chunk)\n赋值表达式在被用作表达式语句及在被用作切片、条件表达式、lambda 表达式、关键字参数和推导\n式中的 if 表达式以及在 assert, with 和 assignment 语句中的子表达式时必须用圆括号括起来。\n在其可使用的其他场合，圆括号则不是必须的，包括在 if 和 while 语句中。\nAdded in version 3.8: 请参阅 PEP 572 了解有关赋值表达式的详情。\n6.13. 条件表达式\nconditional_expression: or_test [\"if\" or_test \"else\" expression]\nexpression: conditional_expression | lambda_expr\n\n|  | or_test: and_test | or_test \"or\" and_test\nand_test: not_test | and_test \"and\" not_test\nnot_test: comparison | \"not\" not_test |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | 在执行布尔运算的情况下，或是当表达式被用于流程控制语句时，以下值会被解读为假值: False,\nNone, 所有类型的数字零，以及空字符串和空容器（包括字符串、元组、列表、字典、集合与冻结集\n合）。 所有其他值都会被解读为真值。 用户自定义对象可通过提供 __bool__() 方法来定制其逻辑\n值。\n运算符 not 将在其参数为假值时产生 True，否则产生 False。\n表达式 x and y 首先对 x 求值；如果 x 为假则返回该值；否则对 y 求值并返回其结果值。\n表达式 x or y 首先对 x 求值；如果 x 为真则返回该值；否则对 y 求值并返回其结果值。\n请注意 and 和 or 都不限制其返回的值和类型必须为 False 和 True，而是返回最后被求值的操作\n数。 此行为是有必要的，例如假设 s 为一个当其为空时应被替换为某个默认值的字符串，表达式 s\nor 'foo' 将产生希望的值。 由于 not 必须创建一个新值，不论其参数为何种类型它都会返回一个\n布尔值（例如，not 'foo' 结果为 False 而非 ''。）\n6.12. 赋值表达式 |  |  |  |\n|  |  | s |  |  |\n|  |  |  |  |  |\n|  | assignment_expression: [identifier \":=\"] expression |  |  |  |\n|  | 赋值表达式（有时又被称为“命名表达式”或“海象表达式”）将一个 expression 赋值给一个\nidentifier，同时还会返回 expression 的值。\n一个常见用例是在处理匹配的正则表达式的时候: |  |  |  |\n|  | if matching := pattern.search(data):\ndo_something(matching) |  |  |  |\n|  | 或者是在处理分块的文件流的时候: |  |  |  |\n|  | while chunk := file.read(9000):\nprocess(chunk) |  |  |  |\n|  | 赋值表达式在被用作表达式语句及在被用作切片、条件表达式、lambda 表达式、关键字参数和推导\n式中的 if 表达式以及在 assert, with 和 assignment 语句中的子表达式时必须用圆括号括起来。\n在其可使用的其他场合，圆括号则不是必须的，包括在 if 和 while 语句中。\nAdded in version 3.8: 请参阅 PEP 572 了解有关赋值表达式的详情。\n6.13. 条件表达式 |  |  |  |\n|  | conditional_expression: or_test [\"if\" or_test \"else\" expression]\nexpression: conditional_expression | lambda_expr |  |  |  |\n|  |  |  |  |  |\n\n|  | or 'foo' |\n| --- | --- |\n\nA conditional expression (sometimes called a \"ternary operator\") is an alternative to the if-else\nstatement. As it is an expression, it returns a value and can appear as a sub-expression.\n表达式 x if C else y 首先是对条件 C 而非 x 求值。 如果 C 为真，x 将被求值并返回其值；否则\n将对 y 求值并返回其值。\n请参阅 PEP 308 了解有关条件表达式的详情。\n6.14. lambda 表达式\nlambda_expr: \"lambda\" [parameter_list] \":\" expression\nlambda 表达式（有时称为 lambda 构型）被用于创建匿名函数。 表达式 lambda parameters:\nexpression 会产生一个函数对象 。 该未命名对象的行为类似于用以下方式定义的函数:\ndef <lambda>(parameters):\nreturn expression\n请参阅 函数定义 了解有关参数列表的句法。 请注意通过 lambda 表达式创建的函数不能包含语句或\n标注。\n6.15. 表达式列表\nstarred_expression: \"*\" or_expr | expression\nflexible_expression: assignment_expression | starred_expression\nflexible_expression_list: flexible_expression (\",\" flexible_expression)* [\",\"]\nstarred_expression_list: starred_expression (\",\" starred_expression)* [\",\"]\nexpression_list: expression (\",\" expression)* [\",\"]\nyield_list: expression_list | starred_expression \",\" [starred_express\n除了作为列表或集合显示的一部分，包含至少一个逗号的表达式列表将生成一个元组。 元组的长度\n就是列表中表达式的数量。 表达式将从左至右被求值。\n一个星号 * 表示 可迭代拆包。 其操作数必须为一个 iterable。 该可迭代对象将被拆解为迭代项的序\n列，并被包含于在拆包位置上新建的元组、列表或集合之中。\nAdded in version 3.5: 表达式列表中的可迭代对象拆包，最初由 PEP 448 提出。\nAdded in version 3.11: 一个表达式列表中的任何条目都可以带星号。 参见 PEP 646。\n末尾的逗号仅在创建单条目元组，比如 1, 时才是必需的；在所有其他情况下它都是可选项。 没有\n末尾逗号的单独表达式不会创建一个元组，而是产生该表达式的值。 （要创建一个空元组，应使用\n一对内容为空的圆括号: ()。）\n6.16. 求值顺序\nPython 按从左至右的顺序对表达式求值。 但注意在对赋值操作求值时，右侧会先于左侧被求值。\n在以下几行中，表达式将按其后缀的算术优先顺序被求值。:\n\n|  |  | A conditional expression (sometimes called a \"ternary operator\") is an alternative to the if-else\nstatement. As it is an expression, it returns a value and can appear as a sub-expression.\n表达式 x if C else y 首先是对条件 C 而非 x 求值。 如果 C 为真，x 将被求值并返回其值；否则\n将对 y 求值并返回其值。\n请参阅 PEP 308 了解有关条件表达式的详情。\n6.14. lambda 表达式 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | lambda_expr: \"lambda\" [parameter_list] \":\" expression |  |  |  |\n|  |  | lambda 表达式（有时称为 lambda 构型）被用于创建匿名函数。 表达式 lambda parameters:\nexpression 会产生一个函数对象 。 该未命名对象的行为类似于用以下方式定义的函数: |  |  |  |\n|  |  |  | lambda parameters: |  |  |\n|  |  |  |  |  |  |\n|  |  | expression |  |  |  |\n|  |  |  |  |  |  |\n|  |  | def <lambda>(parameters):\nreturn expression |  |  |  |\n|  |  | 请参阅 函数定义 了解有关参数列表的句法。 请注意通过 lambda 表达式创建的函数不能包含语句或\n标注。\n6.15. 表达式列表 |  |  |  |\n|  |  | starred_expression: \"*\" or_expr | expression\nflexible_expression: assignment_expression | starred_expression\nflexible_expression_list: flexible_expression (\",\" flexible_expression)* [\",\"]\nstarred_expression_list: starred_expression (\",\" starred_expression)* [\",\"]\nexpression_list: expression (\",\" expression)* [\",\"]\nyield_list: expression_list | starred_expression \",\" [starred_express |  |  |  |\n|  |  |  |  |  |  |\n|  |  | 除了作为列表或集合显示的一部分，包含至少一个逗号的表达式列表将生成一个元组。 元组的长度\n就是列表中表达式的数量。 表达式将从左至右被求值。\n一个星号 * 表示 可迭代拆包。 其操作数必须为一个 iterable。 该可迭代对象将被拆解为迭代项的序\n列，并被包含于在拆包位置上新建的元组、列表或集合之中。\nAdded in version 3.5: 表达式列表中的可迭代对象拆包，最初由 PEP 448 提出。\nAdded in version 3.11: 一个表达式列表中的任何条目都可以带星号。 参见 PEP 646。\n末尾的逗号仅在创建单条目元组，比如 1, 时才是必需的；在所有其他情况下它都是可选项。 没有\n末尾逗号的单独表达式不会创建一个元组，而是产生该表达式的值。 （要创建一个空元组，应使用\n一对内容为空的圆括号: ()。）\n6.16. 求值顺序\nPython 按从左至右的顺序对表达式求值。 但注意在对赋值操作求值时，右侧会先于左侧被求值。\n在以下几行中，表达式将按其后缀的算术优先顺序被求值。: |  |  |  |\n\nexpr1, expr2, expr3, expr4\n(expr1, expr2, expr3, expr4)\n{expr1: expr2, expr3: expr4}\nexpr1 + expr2 * (expr3 - expr4)\nexpr1(expr2, expr3, *expr4, **expr5)\nexpr3, expr4 = expr1, expr2\n6.17. 运算符优先级\n下表对 Python 中运算符的优先顺序进行了总结，从最高优先级（最先绑定）到最低优先级（最后绑\n定）。 相同单元格内的运算符具有相同优先级。 除非语法显式地指明，否则运算符均为双目运算\n符。 相同单元格内的运算符从左至右组合的（只有幂运算符是从右至左组合的）。\n请注意比较、成员检测和标识号检测均为相同优先级，并具有如 比较运算 一节所描述的从左至右串\n连特性。\n运算符 描述\n(expressions...),\n绑定或加圆括号的表达式，列表显示，字典\n[expressions...], {key: value...}, 显示，集合显示\n{expressions...}\nx[index], x[index:index], x(arguments...),\n抽取，切片，调用，属性引用\nx.attribute\nawait x await 表达式\n** 乘方 [5]\n+x, -x, ~x 正，负，按位非 NOT\n*, @, /, //, % 乘，矩阵乘，除，整除，取余 [6]\n+, - 加和减\n<<, >> 移位\n& 按位与 AND\n^ 按位异或 XOR\n| 按位或 OR\nin, not in, is, is not, <, <=, >, >=, !=, == 比较运算，包括成员检测和标识号检测\nnot x 布尔逻辑非 NOT\nand 布尔逻辑与 AND\nor 布尔逻辑或 OR\nif -- else 条件表达式\nlambda lambda 表达式\n\n|  | expr1, expr2, expr3, expr4\n(expr1, expr2, expr3, expr4)\n{expr1: expr2, expr3: expr4}\nexpr1 + expr2 * (expr3 - expr4)\nexpr1(expr2, expr3, *expr4, **expr5)\nexpr3, expr4 = expr1, expr2 |  |  |\n| --- | --- | --- | --- |\n|  | 6.17. 运算符优先级\n下表对 Python 中运算符的优先顺序进行了总结，从最高优先级（最先绑定）到最低优先级（最后绑\n定）。 相同单元格内的运算符具有相同优先级。 除非语法显式地指明，否则运算符均为双目运算\n符。 相同单元格内的运算符从左至右组合的（只有幂运算符是从右至左组合的）。\n请注意比较、成员检测和标识号检测均为相同优先级，并具有如 比较运算 一节所描述的从左至右串\n连特性。 |  |  |\n|  | 运算符 | 描述 |  |\n|  | (expressions...),\n[expressions...], {key: value...},\n{expressions...} | 绑定或加圆括号的表达式，列表显示，字典\n显示，集合显示 |  |\n|  | x[index], x[index:index], x(arguments...),\nx.attribute | 抽取，切片，调用，属性引用 |  |\n|  | await x | await 表达式 |  |\n|  | ** | 乘方 [5] |  |\n|  | +x, -x, ~x | 正，负，按位非 NOT |  |\n|  | *, @, /, //, % | 乘，矩阵乘，除，整除，取余 [6] |  |\n|  | +, - | 加和减 |  |\n|  | <<, >> | 移位 |  |\n|  | & | 按位与 AND |  |\n|  | ^ | 按位异或 XOR |  |\n|  | | | 按位或 OR |  |\n|  | in, not in, is, is not, <, <=, >, >=, !=, == | 比较运算，包括成员检测和标识号检测 |  |\n|  | not x | 布尔逻辑非 NOT |  |\n|  | and | 布尔逻辑与 AND |  |\n|  | or | 布尔逻辑或 OR |  |\n|  | if -- else | 条件表达式 |  |\n|  | lambda | lambda 表达式 |  |\n\n运算符 描述\n:= 赋值表达式\n备注\n[1] 虽然 abs(x%y) < abs(y) 在数学中必为真，但对于浮点数而言，由于舍入的存在，其在数值上\n未必为真。 例如，假设在某个平台上的 Python 浮点数为一个 IEEE 754 双精度数值，为了使\n-1e-100 % 1e100 具有与 1e100 相同的正负性，计算结果将是 -1e-100 + 1e100，这在数值\n上正好等于 1e100。 函数 math.fmod() 返回的结果则会具有与第一个参数相同的正负性，因\n此在这种情况下将返回 -1e-100。 何种方式更适宜取决于具体的应用。\n[2] 如果 x 恰好非常接近于 y 的整数倍，则由于舍入的存在 x//y 可能会比 (x-x%y)//y 大。 在这\n种情况下，Python 会返回后一个结果，以便保持令 divmod(x,y)[0] * y + x % y 尽量接近\nx.\n[3] Unicode 标准明确区分 码位 (例如 U+0041) 和 抽象字符 (例如 \"大写拉丁字母 A\")。 虽然\nUnicode 中的大多数抽象字符都只用一个码位来代表，但也存在一些抽象字符可使用由多个码\n位组成的序列来表示。 例如，抽象字符 \"带有下加符的大写拉丁字母 C\" 可以用 U+00C7 码位上\n的单个 预设字符 来表示，也可以用一个 U+0043 码位上的 基础字符 (大写拉丁字母 C) 加上一\n个 U+0327 码位上的 组合字符 (组合下加符) 组成的序列来表示。\n对于字符串，比较运算符会按 Unicode 码位级别进行比较。 这可能会违反人类的直觉。 例\n如，\"\\u00C7\" == \"\\u0043\\u0327\" 为 False，虽然两个字符串都代表同一个抽象字符 \"带有\n下加符的大写拉丁字母 C\"。\n要按抽象字符级别（即对人类来说更直观的方式）对字符串进行比较，应使用\nunicodedata.normalize()。\n[4] 由于存在自动垃圾收集、空闲列表以及描述器的动态特性，你可能会注意到在特定情况下使用\nis 运算符会出现看似不正常的行为，例如涉及到实例方法或常量之间的比较时就是如此。 更多\n信息请查看有关它们的文档。\n[5] 幂运算符 ** 绑定的紧密程度低于在其右侧的算术或按位一元运算符，也就是说 2**-1 为\n0.5。\n[6] % 运算符也被用于字符串格式化；在此场合下会使用同样的优先级。\n\n| 运算符 | 描述 |\n| --- | --- |\n| := | 赋值表达式 |\n| 备注\n[1] 虽然 abs(x%y) < abs(y) 在数学中必为真，但对于浮点数而言，由于舍入的存在，其在数值上\n未必为真。 例如，假设在某个平台上的 Python 浮点数为一个 IEEE 754 双精度数值，为了使\n-1e-100 % 1e100 具有与 1e100 相同的正负性，计算结果将是 -1e-100 + 1e100，这在数值\n上正好等于 1e100。 函数 math.fmod() 返回的结果则会具有与第一个参数相同的正负性，因\n此在这种情况下将返回 -1e-100。 何种方式更适宜取决于具体的应用。\n[2] 如果 x 恰好非常接近于 y 的整数倍，则由于舍入的存在 x//y 可能会比 (x-x%y)//y 大。 在这\n种情况下，Python 会返回后一个结果，以便保持令 divmod(x,y)[0] * y + x % y 尽量接近\nx.\n[3] Unicode 标准明确区分 码位 (例如 U+0041) 和 抽象字符 (例如 \"大写拉丁字母 A\")。 虽然\nUnicode 中的大多数抽象字符都只用一个码位来代表，但也存在一些抽象字符可使用由多个码\n位组成的序列来表示。 例如，抽象字符 \"带有下加符的大写拉丁字母 C\" 可以用 U+00C7 码位上\n的单个 预设字符 来表示，也可以用一个 U+0043 码位上的 基础字符 (大写拉丁字母 C) 加上一\n个 U+0327 码位上的 组合字符 (组合下加符) 组成的序列来表示。\n对于字符串，比较运算符会按 Unicode 码位级别进行比较。 这可能会违反人类的直觉。 例\n如，\"\\u00C7\" == \"\\u0043\\u0327\" 为 False，虽然两个字符串都代表同一个抽象字符 \"带有\n下加符的大写拉丁字母 C\"。\n要按抽象字符级别（即对人类来说更直观的方式）对字符串进行比较，应使用\nunicodedata.normalize()。\n[4] 由于存在自动垃圾收集、空闲列表以及描述器的动态特性，你可能会注意到在特定情况下使用\nis 运算符会出现看似不正常的行为，例如涉及到实例方法或常量之间的比较时就是如此。 更多\n信息请查看有关它们的文档。\n[5] 幂运算符 ** 绑定的紧密程度低于在其右侧的算术或按位一元运算符，也就是说 2**-1 为\n0.5。\n[6] % 运算符也被用于字符串格式化；在此场合下会使用同样的优先级。 |  |", "metadata": {"title": "06_表达式", "source": "md_docs\\python_reference_md\\06_表达式.md", "doc_type": "语言参考", "language": "中文", "doc_id": "9597aea9"}}
{"doc_id": "57e95a70", "content": "7. 简单语句\n简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的\n句法为:\nsimple_stmt: expression_stmt\n| assert_stmt\n| assignment_stmt\n| augmented_assignment_stmt\n| annotated_assignment_stmt\n| pass_stmt\n| del_stmt\n| return_stmt\n| yield_stmt\n| raise_stmt\n| break_stmt\n| continue_stmt\n| import_stmt\n| future_stmt\n| global_stmt\n| nonlocal_stmt\n| type_stmt\n7.1. 表达式语句\n表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是\n不返回有意义结果的函数；在 Python 中，过程的返回值为 None)。 表达式语句的其他使用方式也是\n允许且有特定用处的。 表达式语句的句法为:\nexpression_stmt: starred_expression\n表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。\n在交互模式下，如果结果值不为 None，它会通过内置的 repr() 函数转换为一个字符串，该结果字\n符串将以单独一行的形式写入标准输出（例外情况是如果结果为 None，则该过程调用不产生任何输\n出。）\n7.2. 赋值语句\n赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项:\nassignment_stmt: (target_list \"=\")+ (starred_expression | yield_expression)\ntarget_list: target (\",\" target)* [\",\"]\ntarget: identifier\n| \"(\" [target_list] \")\"\n| \"[\" [target_list] \"]\"\n| attributeref\n| subscription\n\n| 7. 简单语句\n简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的\n句法为: |\n| --- |\n| simple_stmt: expression_stmt\n| assert_stmt\n| assignment_stmt\n| augmented_assignment_stmt\n| annotated_assignment_stmt\n| pass_stmt\n| del_stmt\n| return_stmt\n| yield_stmt\n| raise_stmt\n| break_stmt\n| continue_stmt\n| import_stmt\n| future_stmt\n| global_stmt\n| nonlocal_stmt\n| type_stmt |\n| 7.1. 表达式语句\n表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是\n不返回有意义结果的函数；在 Python 中，过程的返回值为 None)。 表达式语句的其他使用方式也是\n允许且有特定用处的。 表达式语句的句法为: |\n| expression_stmt: starred_expression |\n| 表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。\n在交互模式下，如果结果值不为 None，它会通过内置的 repr() 函数转换为一个字符串，该结果字\n符串将以单独一行的形式写入标准输出（例外情况是如果结果为 None，则该过程调用不产生任何输\n出。）\n7.2. 赋值语句\n赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项: |\n| assignment_stmt: (target_list \"=\")+ (starred_expression | yield_expression)\ntarget_list: target (\",\" target)* [\",\"]\ntarget: identifier\n| \"(\" [target_list] \")\"\n| \"[\" [target_list] \"]\"\n| attributeref\n| subscription |\n\n| slicing\n| \"*\" target\n(请参阅 原型 一节了解 属性引用, 抽取 和 切片 的句法定义。)\n赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者\n将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。\n赋值是根据目标（列表）的格式递归地定义的。 当目标为一个可变对象（属性引用、抽取或切片）\n的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发\n异常。 各种类型可用的规则和引发的异常通过对象类型的定义给出（参见 标准类型层级结构 一\n节）。\n对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。\n如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。\n否则:\n如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标\n列表项数减一相同项数的可迭代对象。 该可迭代对象前面的项将按从左至右的顺序被赋值给加\n星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 然后该可迭代对\n象中剩余项的列表将被赋值给加星目标（该列表可以为空）。\n否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋\n值给对应的目标。\n对象赋值给单个目标的操作按以下方式递归地定义。\n如果目标为标识符（名称）:\n如果该名称未出现于当前代码块的 global 或 nonlocal 语句中：该名称将被绑定到当前局部\n命名空间的对象。\n否则：该名称将被分别绑定到全局命名空间或由 nonlocal 所确定的外层命名空间的对象。\n如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为\n零，造成该对象进入释放过程并调用其析构器（如果存在）。\n如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对\n象；否则将引发 TypeError。 该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行\n赋值，则会引发异常 (通常应为 AttributeError 但并不强制要求)。\n注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 a.x 可以访\n问实例属性或（如果实例属性不存在）类属性。 左侧目标 a.x 将总是设定为实例属性，并在必要\n时创建该实例属性。 因此 a.x 的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属\n性，则左侧会创建一个新的实例属性作为赋值的目标:\nclass Cls:\nx = 3 # 类变量\ninst = Cls()\ninst.x = inst.x + 1 # 将 inst.x 改为 4 而 Cls.x 仍为 3\n\n|  | | slicing\n| \"*\" target |  |\n| --- | --- | --- |\n|  | (请参阅 原型 一节了解 属性引用, 抽取 和 切片 的句法定义。)\n赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者\n将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。\n赋值是根据目标（列表）的格式递归地定义的。 当目标为一个可变对象（属性引用、抽取或切片）\n的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发\n异常。 各种类型可用的规则和引发的异常通过对象类型的定义给出（参见 标准类型层级结构 一\n节）。\n对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。\n如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。\n否则:\n如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标\n列表项数减一相同项数的可迭代对象。 该可迭代对象前面的项将按从左至右的顺序被赋值给加\n星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 然后该可迭代对\n象中剩余项的列表将被赋值给加星目标（该列表可以为空）。\n否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋\n值给对应的目标。\n对象赋值给单个目标的操作按以下方式递归地定义。\n如果目标为标识符（名称）:\n如果该名称未出现于当前代码块的 global 或 nonlocal 语句中：该名称将被绑定到当前局部\n命名空间的对象。\n否则：该名称将被分别绑定到全局命名空间或由 nonlocal 所确定的外层命名空间的对象。\n如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为\n零，造成该对象进入释放过程并调用其析构器（如果存在）。\n如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对\n象；否则将引发 TypeError。 该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行\n赋值，则会引发异常 (通常应为 AttributeError 但并不强制要求)。\n注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 a.x 可以访\n问实例属性或（如果实例属性不存在）类属性。 左侧目标 a.x 将总是设定为实例属性，并在必要\n时创建该实例属性。 因此 a.x 的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属\n性，则左侧会创建一个新的实例属性作为赋值的目标:\nclass Cls:\nx = 3 # 类变量\ninst = Cls()\ninst.x = inst.x + 1 # 将 inst.x 改为 4 而 Cls.x 仍为 3 |  |\n\n此描述不一定作用于描述器属性，例如通过 property() 创建的特征属性。\n如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列\n表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。\n如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列\n长度。 结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引\n号的项。 如果索引超出范围，将会引发 IndexError (给被抽取序列赋值不能向列表添加新项)。\n如果原型为一个映射对象（例如字典），下标必须具有与该映射的键类型相兼容的类型，然后映\n射中会创建一个将下标映射到被赋值对象的键/值对。 这可以是替换一个现有键/值对并保持相同\n键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。\n对于用户自定义对象，会调用 __setitem__() 方法并附带适当的参数。\n如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列\n表）。 被赋值对象应当是一个相同类型的序列对象。 接下来，下界与上界表达式如果存在的话将\n被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上\n序列长度。 求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋\n值序列的项替换该切片。 切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况\n下改变目标序列的长度。\n在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导\n致不太详细的错误信息。\n虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 a, b = b, a 会交换两个变量\n的值），但在赋值给变量的多项集 之内 的重叠是从左至右进行的，这有时会令人混淆。 例如，以下\n程序将会打印出 [0, 2]:\nx = [0, 1]\ni = 0\ni, x[i] = 1, 2 # 先更新 i，再更新 x[i]\nprint(x)\n参见:\nPEP 3132 - 扩展的可迭代对象拆包\n对 *target 特性的规范说明。\n7.2.1. 增强赋值语句\n增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体:\naugmented_assignment_stmt: augtarget augop (expression_list | yield_expression)\naugtarget: identifier | attributeref | subscription | slicing\naugop: \"+=\" | \"-=\" | \"*=\" | \"@=\" | \"/=\" | \"//=\" | \"%=\" | \"**=\"\n| \">>=\" | \"<<=\" | \"&=\" | \"^=\" | \"|=\"\n\n|  | 此描述不一定作用于描述器属性，例如通过 property() 创建的特征属性。\n如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列\n表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。\n如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列\n长度。 结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引\n号的项。 如果索引超出范围，将会引发 IndexError (给被抽取序列赋值不能向列表添加新项)。\n如果原型为一个映射对象（例如字典），下标必须具有与该映射的键类型相兼容的类型，然后映\n射中会创建一个将下标映射到被赋值对象的键/值对。 这可以是替换一个现有键/值对并保持相同\n键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。\n对于用户自定义对象，会调用 __setitem__() 方法并附带适当的参数。\n如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列\n表）。 被赋值对象应当是一个相同类型的序列对象。 接下来，下界与上界表达式如果存在的话将\n被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上\n序列长度。 求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋\n值序列的项替换该切片。 切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况\n下改变目标序列的长度。\n在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导\n致不太详细的错误信息。\n虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 a, b = b, a 会交换两个变量\n的值），但在赋值给变量的多项集 之内 的重叠是从左至右进行的，这有时会令人混淆。 例如，以下\n程序将会打印出 [0, 2]: |  |\n| --- | --- | --- |\n|  | x = [0, 1]\ni = 0\ni, x[i] = 1, 2 # 先更新 i，再更新 x[i]\nprint(x) |  |\n|  |  |  |\n|  | 参见:\nPEP 3132 - 扩展的可迭代对象拆包\n对 *target 特性的规范说明。 |  |\n|  | 7.2.1. 增强赋值语句\n增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体: |  |\n|  | augmented_assignment_stmt: augtarget augop (expression_list | yield_expression)\naugtarget: identifier | attributeref | subscription | slicing\naugop: \"+=\" | \"-=\" | \"*=\" | \"@=\" | \"/=\" | \"//=\" | \"%=\" | \"**=\"\n| \">>=\" | \"<<=\" | \"&=\" | \"^=\" | \"|=\" |  |\n|  |  |  |\n\n（请参阅 原型 一节了解最后三种符号的句法定义。）\n增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆\n包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。 目标仅会被\n求值一次。\n增强赋值语句如 x += 1 可以被改写为 x = x + 1 以获得类似的、但并非完全等价的效果。 在增强\n赋值版本中，x 仅会被求值一次。 而且，在可能的情况下，实际的运算是 原地 执行的，这意味着并\n不是创建一个新对象并将其赋值给目标，而是直接修改原对象。\n不同于普通赋值，增强赋值会在对右手边求值 之前 对左手边求值。 例如，a[i] += f(x) 首先查找\na[i]，然后对 f(x) 求值并执行加法操作，最后将结果写回到 a[i]。\n除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋\n值相同。 类似地，除了可能存在 原地 操作行为的例外情况，增强赋值语句执行的二元运算也与普通\n二元运算相同。\n对于属性引用类目标，针对常规赋值的 关于类和实例属性的警告 也同样适用。\n7.2.2. 带标注的赋值语句\n标注 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体:\nannotated_assignment_stmt: augtarget \":\" expression\n[\"=\" (starred_expression | yield_expression)]\n与普通 赋值语句 的差别在于仅允许单个目标。\n如果赋值目标由不带圆括号的单个名称组成则被视为“简单型”。 对于简单型赋值目标，如果处于类\n或模块作用域中，标注将被收集到一个惰性求值的 标注作用域 中。 这些标注的求值可使用类或模块\n的 __annotations__ 属性，或是使用 annotationlib 模块中的工具。\n如果赋值目标不是简单型的（即属性、下标节点或带圆括号的名称），则标注将永远不会被求值。\n如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域\n内被求值和保存。\n如果存在右手边，带标注的赋值会执行实际的赋值就像不存在任何标注一样。 如果不存在作为表达\n式目标的右手边，那么解释器会对目标求值但最后的 __setitem__() 或 __setattr__() 调用除\n外。\n参见:\nPEP 526 - 变量标注的语法\n该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行\n表达。\nPEP 484 - 类型提示\n\n|  | （请参阅 原型 一节了解最后三种符号的句法定义。）\n增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆\n包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。 目标仅会被\n求值一次。\n增强赋值语句如 x += 1 可以被改写为 x = x + 1 以获得类似的、但并非完全等价的效果。 在增强\n赋值版本中，x 仅会被求值一次。 而且，在可能的情况下，实际的运算是 原地 执行的，这意味着并\n不是创建一个新对象并将其赋值给目标，而是直接修改原对象。\n不同于普通赋值，增强赋值会在对右手边求值 之前 对左手边求值。 例如，a[i] += f(x) 首先查找\na[i]，然后对 f(x) 求值并执行加法操作，最后将结果写回到 a[i]。\n除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋\n值相同。 类似地，除了可能存在 原地 操作行为的例外情况，增强赋值语句执行的二元运算也与普通\n二元运算相同。\n对于属性引用类目标，针对常规赋值的 关于类和实例属性的警告 也同样适用。\n7.2.2. 带标注的赋值语句\n标注 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体: |  |\n| --- | --- | --- |\n|  | annotated_assignment_stmt: augtarget \":\" expression\n[\"=\" (starred_expression | yield_expression)] |  |\n|  | 与普通 赋值语句 的差别在于仅允许单个目标。\n如果赋值目标由不带圆括号的单个名称组成则被视为“简单型”。 对于简单型赋值目标，如果处于类\n或模块作用域中，标注将被收集到一个惰性求值的 标注作用域 中。 这些标注的求值可使用类或模块\n的 __annotations__ 属性，或是使用 annotationlib 模块中的工具。\n如果赋值目标不是简单型的（即属性、下标节点或带圆括号的名称），则标注将永远不会被求值。\n如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域\n内被求值和保存。\n如果存在右手边，带标注的赋值会执行实际的赋值就像不存在任何标注一样。 如果不存在作为表达\n式目标的右手边，那么解释器会对目标求值但最后的 __setitem__() 或 __setattr__() 调用除\n外。 |  |\n|  | 参见:\nPEP 526 - 变量标注的语法\n该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行\n表达。\nPEP 484 - 类型提示 |  |\n\n该提议增加了 typing 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使\n用。\n在 3.8 版本发生变更: 现在带有标注的赋值允许在右边以同样的表达式作为常规赋值。 之前某\n些表达式（例如未加圆括号的元组表达式）会导致语法错误。\n在 3.14 版本发生变更: 现在标注会在单独的 标注作用域 中被惰性求值。 如果赋值目标不是简\n单型的，则标注永远不会被求值。\n7.3. assert 语句\nassert 语句是在程序中插入调试性断言的简便方式:\nassert_stmt: \"assert\" expression [\",\" expression]\n简单形式 assert expression 等价于\nif __debug__:\nif not expression: raise AssertionError\n扩展形式 assert expression1, expression2 等价于\nif __debug__:\nif not expression1: raise AssertionError(expression2)\n这些等价形式假定 __debug__ 和 AssertionError 指向具有指定名称的内置变量。 在当前实现\n中，内置变量 __debug__ 在正常情况下为 True，在请求优化时为 False (对应命令行选项为 -O)。\n如果在编译时请求优化则当前代码生成器不会为 assert 语句发出任何代码。 请注意不需要在错误\n信息中包括失败的表达式的源代码；它会作为栈回溯的一部分被显示。\n赋值给 __debug__ 是非法的。 该内置变量的值会在解释器启动时确定。\n7.4. pass 语句\npass_stmt: \"pass\"\npass 是一个空操作 --- 当它被执行时，什么都不发生。 它适合当语法上需要一条语句但并不需要执\n行任何代码时用来临时占位，例如:\ndef f(arg): pass # 一个（目前）不做任何事的函数\nclass C: pass # 一个（目前）没有任何方法的类\n7.5. del 语句\ndel_stmt: \"del\" target_list\n\n|  | 该提议增加了 typing 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使\n用。 |  |\n| --- | --- | --- |\n|  | 在 3.8 版本发生变更: 现在带有标注的赋值允许在右边以同样的表达式作为常规赋值。 之前某\n些表达式（例如未加圆括号的元组表达式）会导致语法错误。\n在 3.14 版本发生变更: 现在标注会在单独的 标注作用域 中被惰性求值。 如果赋值目标不是简\n单型的，则标注永远不会被求值。\n7.3. assert 语句\nassert 语句是在程序中插入调试性断言的简便方式: |  |\n|  | assert_stmt: \"assert\" expression [\",\" expression] |  |\n|  | 简单形式 assert expression 等价于 |  |\n|  | if __debug__:\nif not expression: raise AssertionError |  |\n|  | 扩展形式 assert expression1, expression2 等价于 |  |\n|  | if __debug__:\nif not expression1: raise AssertionError(expression2) |  |\n|  | 这些等价形式假定 __debug__ 和 AssertionError 指向具有指定名称的内置变量。 在当前实现\n中，内置变量 __debug__ 在正常情况下为 True，在请求优化时为 False (对应命令行选项为 -O)。\n如果在编译时请求优化则当前代码生成器不会为 assert 语句发出任何代码。 请注意不需要在错误\n信息中包括失败的表达式的源代码；它会作为栈回溯的一部分被显示。\n赋值给 __debug__ 是非法的。 该内置变量的值会在解释器启动时确定。\n7.4. pass 语句 |  |\n|  | pass_stmt: \"pass\" |  |\n|  | pass 是一个空操作 --- 当它被执行时，什么都不发生。 它适合当语法上需要一条语句但并不需要执\n行任何代码时用来临时占位，例如: |  |\n|  | def f(arg): pass # 一个（目前）不做任何事的函数\nclass C: pass # 一个（目前）没有任何方法的类 |  |\n|  | 7.5. del 语句 |  |\n|  | del_stmt: \"del\" target_list |  |\n|  |  |  |\n\n删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。\n目标列表的删除将从左至右递归地删除每一个目标。\n删除名称会从局部或全局命名空间中移除该名称的绑定，具体取决于该名称是否出现在同一代码块\n中的 global 语句中。尝试删除未绑定的名称会引发 NameError 异常。\n属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右\n侧类型的空切片（但即便这一点也是由切片对象决定的）。\n在 3.2 版本发生变更: 在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将\n其从局部命名空间中删除是非法的。\n7.6. return 语句\nreturn_stmt: \"return\" [expression_list]\nreturn 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。\n如果提供了表达式列表，它将被求值，否则以 None 替代。\nreturn 会离开当前函数调用，并以表达式列表 (或 None) 作为返回值。\n当 return 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后\n再真正离开该函数。\n在一个生成器函数中，return 语句表示生成器已完成并将导致 StopIteration 被引发。 返回值\n（如果有的话）会被当作一个参数用来构建 StopIteration 并成为 StopIteration.value 属性。\n在一个异步生成器函数中，一个空的 return 语句表示异步生成器已完成并将导致\nStopAsyncIteration 被引发。 一个非空的 return 语句在异步生成器函数中会导致语法错误。\n7.7. yield 语句\nyield_stmt: yield_expression\nyield 语句在语义上等同于 yield 表达式。 yield 语句可用来省略在使用等效的 yield 表达式语句时\n所必须的圆括号。 例如，以下 yield 语句\nyield <expr>\nyield from <expr>\n等同于以下 yield 表达式语句\n(yield <expr>)\n(yield from <expr>)\nyield 表达式和语句仅在定义 generator 函数时使用，并且仅被用于生成器函数的函数体内部。 在函\n数定义中使用 yield 就足以使得该定义创建的是生成器函数而非普通函数。\n\n|  | 删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。\n目标列表的删除将从左至右递归地删除每一个目标。\n删除名称会从局部或全局命名空间中移除该名称的绑定，具体取决于该名称是否出现在同一代码块\n中的 global 语句中。尝试删除未绑定的名称会引发 NameError 异常。\n属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右\n侧类型的空切片（但即便这一点也是由切片对象决定的）。\n在 3.2 版本发生变更: 在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将\n其从局部命名空间中删除是非法的。\n7.6. return 语句 |  |\n| --- | --- | --- |\n|  | return_stmt: \"return\" [expression_list] |  |\n|  | return 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。\n如果提供了表达式列表，它将被求值，否则以 None 替代。\nreturn 会离开当前函数调用，并以表达式列表 (或 None) 作为返回值。\n当 return 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后\n再真正离开该函数。\n在一个生成器函数中，return 语句表示生成器已完成并将导致 StopIteration 被引发。 返回值\n（如果有的话）会被当作一个参数用来构建 StopIteration 并成为 StopIteration.value 属性。\n在一个异步生成器函数中，一个空的 return 语句表示异步生成器已完成并将导致\nStopAsyncIteration 被引发。 一个非空的 return 语句在异步生成器函数中会导致语法错误。\n7.7. yield 语句 |  |\n|  | yield_stmt: yield_expression |  |\n|  | yield 语句在语义上等同于 yield 表达式。 yield 语句可用来省略在使用等效的 yield 表达式语句时\n所必须的圆括号。 例如，以下 yield 语句 |  |\n|  | yield <expr>\nyield from <expr> |  |\n|  | 等同于以下 yield 表达式语句 |  |\n|  | (yield <expr>)\n(yield from <expr>) |  |\n|  | yield 表达式和语句仅在定义 generator 函数时使用，并且仅被用于生成器函数的函数体内部。 在函\n数定义中使用 yield 就足以使得该定义创建的是生成器函数而非普通函数。 |  |\n\n有关 yield 语义的完整细节请参看 yield 表达式 一节。\n7.8. raise 语句\nraise_stmt: \"raise\" [expression [\"from\" expression]]\n如果没有提供表达式，则 raise 会重新引发当前正在处理的异常，它也被称为 活动的异常。 如果\n当前没有活动的异常，则会引发 RuntimeError 来提示发生了错误。\n否则的话，raise 会将第一个表达式求值为异常对象。 它必须为 BaseException 的子类或实例。\n如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。\n异常的 类型 为异常实例的类，值 为实例本身。\n当有异常被引发时通常会自动创建一个回溯对象并将其关联到它的 __traceback__ 属性。 你可以\n创建一个异常并使用 with_traceback() 异常方法直接设置你的回溯对象（该方法将返回同一异常\n实例，并将回溯对象设为其参数），就像这样:\nraise Exception(\"foo occurred\").with_traceback(tracebackobj)\nfrom 子句用于异常串连：如果给出该子句，则第二个 表达式 必须为另一个异常类或实例。 如果第\n二个表达式是一个异常实例，它将作为 __cause__ 属性（为一个可写属性）被关联到所引发的异\n常。 如果该表达式是一个异常类，这个类将被实例化且所生成的异常实例将作为 __cause__ 属性被\n关联到所引发的异常。 如果所引发的异常未被处理，则两个异常都将被打印：\n>>> try:\n... print(1 / 0)\n... except Exception as exc:\n... raise RuntimeError(\"Something bad happened\") from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nprint(1 / 0)\n~~^~~\nZeroDivisionError: division by zero\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"Something bad happened\") from exc\nRuntimeError: Something bad happened\n当已经有一个异常在处理时如果有新的异常被引发则类似的机制会隐式地起作用。 异常可以通过使\n用 except 或 finally 子句或者 with 语句来处理。 之前的异常将被关联至新异常的 __context__\n属性：\n>>> try:\n... print(1 / 0)\n... except:\n... raise RuntimeError(\"Something bad happened\")\n...\n\n|  | 有关 yield 语义的完整细节请参看 yield 表达式 一节。\n7.8. raise 语句 |  |\n| --- | --- | --- |\n|  | raise_stmt: \"raise\" [expression [\"from\" expression]] |  |\n|  | 如果没有提供表达式，则 raise 会重新引发当前正在处理的异常，它也被称为 活动的异常。 如果\n当前没有活动的异常，则会引发 RuntimeError 来提示发生了错误。\n否则的话，raise 会将第一个表达式求值为异常对象。 它必须为 BaseException 的子类或实例。\n如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。\n异常的 类型 为异常实例的类，值 为实例本身。\n当有异常被引发时通常会自动创建一个回溯对象并将其关联到它的 __traceback__ 属性。 你可以\n创建一个异常并使用 with_traceback() 异常方法直接设置你的回溯对象（该方法将返回同一异常\n实例，并将回溯对象设为其参数），就像这样: |  |\n|  | raise Exception(\"foo occurred\").with_traceback(tracebackobj) |  |\n|  | from 子句用于异常串连：如果给出该子句，则第二个 表达式 必须为另一个异常类或实例。 如果第\n二个表达式是一个异常实例，它将作为 __cause__ 属性（为一个可写属性）被关联到所引发的异\n常。 如果该表达式是一个异常类，这个类将被实例化且所生成的异常实例将作为 __cause__ 属性被\n关联到所引发的异常。 如果所引发的异常未被处理，则两个异常都将被打印： |  |\n|  | >>> try:\n... print(1 / 0)\n... except Exception as exc:\n... raise RuntimeError(\"Something bad happened\") from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nprint(1 / 0)\n~~^~~\nZeroDivisionError: division by zero\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"Something bad happened\") from exc\nRuntimeError: Something bad happened |  |\n|  | 当已经有一个异常在处理时如果有新的异常被引发则类似的机制会隐式地起作用。 异常可以通过使\n用 except 或 finally 子句或者 with 语句来处理。 之前的异常将被关联至新异常的 __context__\n属性： |  |\n|  | >>> try:\n... print(1 / 0)\n... except:\n... raise RuntimeError(\"Something bad happened\")\n... |  |\n\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nprint(1 / 0)\n~~^~~\nZeroDivisionError: division by zero\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"Something bad happened\")\nRuntimeError: Something bad happened\n异常串连可通过在 from 子句中指定 None 来显式地加以抑制：\n>>> try:\n... print(1 / 0)\n... except:\n... raise RuntimeError(\"Something bad happened\") from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Something bad happened\n有关异常的更多信息可在 异常 一节查看，有关处理异常的信息可在 try 语句 一节查看。\n在 3.3 版本发生变更: None 现在允许被用作 raise X from Y 中的 Y。\n增加了 __suppress_context__ 属性向来抑制异常上下文的自动显示。\n在 3.11 版本发生变更: 如果活动异常的回溯在 except 子句中被修改，则会有后续的 raise 语\n句重新引发该异常并附带被修改的回溯。 在之前版本中，重新引发该异常则会附带它被捕获时\n的回溯。\n7.9. break 语句\nbreak_stmt: \"break\"\nbreak 在语法上只会出现于 for 或 while 循环所嵌套的代码，但不会出现于该循环内部的函数或类\n定义所嵌套的代码。\n它会终结最近的外层循环，如果循环有可选的 else 子句，也会跳过该子句。\n如果一个 for 循环被 break 所终结，该循环的控制目标会保持其当前值。\n当 break 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后再\n真正离开该循环。\n7.10. continue 语句\ncontinue_stmt: \"continue\"\n\n|  | Traceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nprint(1 / 0)\n~~^~~\nZeroDivisionError: division by zero\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"Something bad happened\")\nRuntimeError: Something bad happened |  |\n| --- | --- | --- |\n|  | 异常串连可通过在 from 子句中指定 None 来显式地加以抑制： |  |\n|  | >>> try:\n... print(1 / 0)\n... except:\n... raise RuntimeError(\"Something bad happened\") from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Something bad happened |  |\n|  | 有关异常的更多信息可在 异常 一节查看，有关处理异常的信息可在 try 语句 一节查看。\n在 3.3 版本发生变更: None 现在允许被用作 raise X from Y 中的 Y。\n增加了 __suppress_context__ 属性向来抑制异常上下文的自动显示。\n在 3.11 版本发生变更: 如果活动异常的回溯在 except 子句中被修改，则会有后续的 raise 语\n句重新引发该异常并附带被修改的回溯。 在之前版本中，重新引发该异常则会附带它被捕获时\n的回溯。\n7.9. break 语句 |  |\n|  | break_stmt: \"break\" |  |\n|  | break 在语法上只会出现于 for 或 while 循环所嵌套的代码，但不会出现于该循环内部的函数或类\n定义所嵌套的代码。\n它会终结最近的外层循环，如果循环有可选的 else 子句，也会跳过该子句。\n如果一个 for 循环被 break 所终结，该循环的控制目标会保持其当前值。\n当 break 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然后再\n真正离开该循环。\n7.10. continue 语句 |  |\n|  | continue_stmt: \"continue\" |  |\n|  |  |  |\n\ncontinue 在语法上只会出现于 for 或 while 循环所嵌套的代码中，但不会出现于该循环内部的函\n数或类定义中。 它会继续执行最近的外层循环的下一个轮次。\n当 continue 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然\n后再真正开始循环的下一个轮次。\n7.11. import 语句\nimport_stmt: \"import\" module [\"as\" identifier] (\",\" module [\"as\" identifier])*\n| \"from\" relative_module \"import\" identifier [\"as\" identifier]\n(\",\" identifier [\"as\" identifier])*\n| \"from\" relative_module \"import\" \"(\" identifier [\"as\" identifier\n(\",\" identifier [\"as\" identifier])* [\",\"] \")\"\n| \"from\" relative_module \"import\" \"*\"\nmodule: (identifier \".\")* identifier\nrelative_module: \".\"* module | \".\"+\n基本的 import 语句（不带 from 子句）会分两步执行:\n1. 查找一个模块，如果有必要还会加载并初始化模块。\n2. 在局部命名空间中为 import 语句发生位置所处的作用域定义一个或多个名称。\n当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独\n立的 import 语句一样。\n第一个步骤，即查找和加载模块的细节在 导入系统 一节中有更详细的描述，其中也描述了可被导入\n的多种类型的包和模块，以及可用于定制导入系统的所有钩子对象。 请注意如果这一步失败，则可\n能说明模块无法找到，或者 是在初始化模块，包括执行模块代码期间发生了错误。\n如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:\n模块名后使用 as 时，直接把 as 后的名称与导入模块绑定。\n如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空\n间作为对所导入模块的引用。\n如果被导入的模块 不是 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空\n间作为对该最高层级包的引用。 所导入的模块必须使用其完整限定名称来访问而不能直接访问。\nfrom 形式使用的过程略微繁复一些:\n1. 查找 from 子句中指定的模块，如有必要还会加载并初始化模块；\n2. 对于 import 子句中指定的每个标识符：\n1. 检查被导入模块是否有该名称的属性\n2. 如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性\n3. 如果未找到该属性，则引发 ImportError。\n4. 否则的话，将对该值的引用存入局部命名空间，如果有 as 子句则使用其指定的名称，\n否则使用该属性的名称\n示例:\n\n|  | continue 在语法上只会出现于 for 或 while 循环所嵌套的代码中，但不会出现于该循环内部的函\n数或类定义中。 它会继续执行最近的外层循环的下一个轮次。\n当 continue 将控制流传出一个带有 finally 子句的 try 语句时，该 finally 子句会先被执行然\n后再真正开始循环的下一个轮次。\n7.11. import 语句 |  |\n| --- | --- | --- |\n|  | import_stmt: \"import\" module [\"as\" identifier] (\",\" module [\"as\" identifier])*\n| \"from\" relative_module \"import\" identifier [\"as\" identifier]\n(\",\" identifier [\"as\" identifier])*\n| \"from\" relative_module \"import\" \"(\" identifier [\"as\" identifier\n(\",\" identifier [\"as\" identifier])* [\",\"] \")\"\n| \"from\" relative_module \"import\" \"*\"\nmodule: (identifier \".\")* identifier\nrelative_module: \".\"* module | \".\"+ |  |\n|  | 基本的 import 语句（不带 from 子句）会分两步执行:\n1. 查找一个模块，如果有必要还会加载并初始化模块。\n2. 在局部命名空间中为 import 语句发生位置所处的作用域定义一个或多个名称。\n当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独\n立的 import 语句一样。\n第一个步骤，即查找和加载模块的细节在 导入系统 一节中有更详细的描述，其中也描述了可被导入\n的多种类型的包和模块，以及可用于定制导入系统的所有钩子对象。 请注意如果这一步失败，则可\n能说明模块无法找到，或者 是在初始化模块，包括执行模块代码期间发生了错误。\n如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:\n模块名后使用 as 时，直接把 as 后的名称与导入模块绑定。\n如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空\n间作为对所导入模块的引用。\n如果被导入的模块 不是 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空\n间作为对该最高层级包的引用。 所导入的模块必须使用其完整限定名称来访问而不能直接访问。\nfrom 形式使用的过程略微繁复一些:\n1. 查找 from 子句中指定的模块，如有必要还会加载并初始化模块；\n2. 对于 import 子句中指定的每个标识符：\n1. 检查被导入模块是否有该名称的属性\n2. 如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性\n3. 如果未找到该属性，则引发 ImportError。\n4. 否则的话，将对该值的引用存入局部命名空间，如果有 as 子句则使用其指定的名称，\n否则使用该属性的名称\n示例: |  |\n\nimport foo # foo 被导入并且被局部绑定\nimport foo.bar.baz # foo, foo.bar 和 foo.bar.baz 被导入，foo 被局部绑定\nimport foo.bar.baz as fbb # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定\nfrom foo.bar import baz # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定\nfrom foo import attr # foo 被导入并且 foo.attr 被绑定为 attr\n如果标识符列表改为一个星号 ('*')，则在模块中定义的全部公有名称都将按 import 语句所在的作\n用域被绑定到局部命名空间。\n一个模块所定义的 公有名称 是由在模块的命名空间中检测一个名为 __all__ 的变量来确定的；如\n果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 __all__ 中所给\n出的名称都会被视为公有并且应当存在。 如果 __all__ 没有被定义，则公有名称的集合将包含在模\n块的命名空间中找到的所有不以下划线字符 ('_') 打头的名称。 __all__ 应当包括整个公有 API。\n它的目标是避免意外地导出不属于 API 的一部分的项（例如在模块内部被导入和使用的库模块）。\n通配符形式的导入 --- from module import * --- 仅在模块层级上被允许。 尝试在类或函数定义中\n使用它将引发 SyntaxError。\n当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中\n时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 通过在 from 之后指定的模块\n或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。\n一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示\n上溯两级，依此类推。 因此如果你执行 from . import mod 时所处位置为 pkg 包内的一个模块，\n则最终你将导入 pkg.mod。 如果你执行 from ..subpkg2 import mod 时所处位置为 pkg.subpkg1\n则你将导入 pkg.subpkg2.mod。 有关相对导入的规范说明包含在 包相对导入 一节中。\nimportlib.import_module() 被提供用来为动态地确定要导入模块的应用提供支持。\n引发一个 审计事件 import 并附带参数 module, filename, sys.path, sys.meta_path,\nsys.path_hooks。\n7.11.1. future 语句\nfuture 语句 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版\n中成为标准特性的语法或语义。\nfuture 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 它允许\n基于每个模块在某种新特性成为标准之前的发行版中使用该特性。\nfuture_stmt: \"from\" \"__future__\" \"import\" feature [\"as\" identifier]\n(\",\" feature [\"as\" identifier])*\n| \"from\" \"__future__\" \"import\" \"(\" feature [\"as\" identifier]\n(\",\" feature [\"as\" identifier])* [\",\"] \")\"\nfeature: identifier\nfuture 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:\n模块的文档字符串（如果存在），\n注释，\n\n|  | import foo # foo 被导入并且被局部绑定\nimport foo.bar.baz # foo, foo.bar 和 foo.bar.baz 被导入，foo 被局部绑定\nimport foo.bar.baz as fbb # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定\nfrom foo.bar import baz # foo, foo.bar 和 foo.bar.baz 被导入，foo.bar.baz 被绑定\nfrom foo import attr # foo 被导入并且 foo.attr 被绑定为 attr |  |  |\n| --- | --- | --- | --- |\n|  | 如果标识符列表改为一个星号 ('*')，则在模块中定义的全部公有名称都将按 import 语句所在的作\n用域被绑定到局部命名空间。\n一个模块所定义的 公有名称 是由在模块的命名空间中检测一个名为 __all__ 的变量来确定的；如\n果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 __all__ 中所给\n出的名称都会被视为公有并且应当存在。 如果 __all__ 没有被定义，则公有名称的集合将包含在模\n块的命名空间中找到的所有不以下划线字符 ('_') 打头的名称。 __all__ 应当包括整个公有 API。\n它的目标是避免意外地导出不属于 API 的一部分的项（例如在模块内部被导入和使用的库模块）。\n通配符形式的导入 --- from module import * --- 仅在模块层级上被允许。 尝试在类或函数定义中\n使用它将引发 SyntaxError。\n当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中\n时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 通过在 from 之后指定的模块\n或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。\n一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示\n上溯两级，依此类推。 因此如果你执行 from . import mod 时所处位置为 pkg 包内的一个模块，\n则最终你将导入 pkg.mod。 如果你执行 from ..subpkg2 import mod 时所处位置为 pkg.subpkg1\n则你将导入 pkg.subpkg2.mod。 有关相对导入的规范说明包含在 包相对导入 一节中。\nimportlib.import_module() 被提供用来为动态地确定要导入模块的应用提供支持。\n引发一个 审计事件 import 并附带参数 module, filename, sys.path, sys.meta_path,\nsys.path_hooks。\n7.11.1. future 语句\nfuture 语句 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版\n中成为标准特性的语法或语义。\nfuture 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 它允许\n基于每个模块在某种新特性成为标准之前的发行版中使用该特性。 |  |  |\n|  | future_stmt: \"from\" \"__future__\" \"import\" feature [\"as\" identifier]\n(\",\" feature [\"as\" identifier])*\n| \"from\" \"__future__\" \"import\" \"(\" feature [\"as\" identifier]\n(\",\" feature [\"as\" identifier])* [\",\"] \")\"\nfeature: identifier |  |  |\n|  | future 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:\n模块的文档字符串（如果存在），\n注释， |  |  |\n\n空行，以及\n其他 future 语句。\n唯一需要使用 future 语句的特性是 annotations (参见 PEP 563)。\nfuture 语句所启用的所有历史特性仍然为 Python 3 所认可。 其中包括 absolute_import,\ndivision, generators, generator_stop, unicode_literals, print_function, nested_scopes\n和 with_statement。 它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后\n兼容。\nfuture 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来\n实现。 新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需\n要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。\n对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的\n特性则会引发编译时错误。\n直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 __future__，它\n会在执行 future 语句时以通常的方式被导入。\n相应的运行时语义取决于 future 语句所启用的指定特性。\n请注意以下语句没有任何特别之处:\nimport __future__ [as name]\n这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。\n在默认情况下，通过对内置函数 exec() 和 compile() 的调用编译的代码如果出现于一个包含有\nfuture 语句的模块 M 之中，就会使用该 future 语句所关联的语法和语义。 此行为可以通过传给\ncompile() 的可选参数来控制 --- 请参阅该函数的文档了解详情。\n在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的\n启动使用了 -i 选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互\n式会话开始执行脚本之后保持有效。\n参见:\nPEP 236 - 回到 __future__\n有关 __future__ 机制的最初提议。\n7.12. global 语句\nglobal_stmt: \"global\" identifier (\",\" identifier)*\nglobal 语句将使其所列出的标识符被解读为全局变量。 要给全局变量赋值不可能不用到 global 关\n键字，不过自由变量也可以指向全局变量而不必声明为全局变量。\n\n|  | 空行，以及\n其他 future 语句。\n唯一需要使用 future 语句的特性是 annotations (参见 PEP 563)。\nfuture 语句所启用的所有历史特性仍然为 Python 3 所认可。 其中包括 absolute_import,\ndivision, generators, generator_stop, unicode_literals, print_function, nested_scopes\n和 with_statement。 它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后\n兼容。\nfuture 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来\n实现。 新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需\n要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。\n对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的\n特性则会引发编译时错误。\n直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 __future__，它\n会在执行 future 语句时以通常的方式被导入。\n相应的运行时语义取决于 future 语句所启用的指定特性。\n请注意以下语句没有任何特别之处: |  |\n| --- | --- | --- |\n|  | import __future__ [as name] |  |\n|  | 这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。\n在默认情况下，通过对内置函数 exec() 和 compile() 的调用编译的代码如果出现于一个包含有\nfuture 语句的模块 M 之中，就会使用该 future 语句所关联的语法和语义。 此行为可以通过传给\ncompile() 的可选参数来控制 --- 请参阅该函数的文档了解详情。\n在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的\n启动使用了 -i 选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互\n式会话开始执行脚本之后保持有效。 |  |\n|  | 参见:\nPEP 236 - 回到 __future__\n有关 __future__ 机制的最初提议。 |  |\n|  | 7.12. global 语句 |  |\n|  | global_stmt: \"global\" identifier (\",\" identifier)* |  |\n|  | global 语句将使其所列出的标识符被解读为全局变量。 要给全局变量赋值不可能不用到 global 关\n键字，不过自由变量也可以指向全局变量而不必声明为全局变量。 |  |\n\nglobal 语句将应用于整个当前作用域（模块、函数体或类定义）。 如果一个变量在本作用域的\nglobal 声明之前被使用或赋值则会引发 SyntaxError。\n在模块层级上，所有变量都是全局变量，因此 global 语句将没有用处。 不过，变量仍然不能在其\nglobal 声明之前被使用或赋值。 此项要求在交互式提示符 (REPL) 中被取消。\n程序员注意事项: global 是对解析器的指令。 它仅对与 global 语句同时被解析的代码起作用。 特\n别地，包含在提供给内置 exec() 函数字符串或代码对象中的 global 语句并不会影响 包含 该函数\n调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 global 语句\n影响。 这同样适用于 eval() 和 compile() 函数。\n7.13. nonlocal 语句\nnonlocal_stmt: \"nonlocal\" identifier (\",\" identifier)*\n当一个函数或类的定义嵌套（被包围）在其他函数的定义中时，其非局部作用域就是包围它的函数\n的局部作用域 。 nonlocal 语句会使其所列出的标识符指向之前在非局部作用域中绑定的名称。 它\n允许封装的代码重新绑定这样的非局部标识符。 如果一个名称在多个非局部作用域中都被绑定，则\n会使用最近的绑定。 如果一个名称在任何非局部作用域中都未被绑定，或者不存在非局部作用域，\n则会引发 SyntaxError。\nnonlocal 语句将应用于函数或类语句体的整个作用域。 如果一个变量在本作用域的 nonlocal 声明\n之前被使用或赋值则会引发 SyntaxError。\n参见:\nPEP 3104 - 访问外层作用域中的名称\n有关 nonlocal 语句的规范说明。\n程序员注意事项: nonlocal 是对解析器的指令并且仅会在与其一同被解析的代码上应用。 参见\nglobal 语句的相关注意事项。\n7.14. type 语句\ntype_stmt: 'type' identifier [type_params] \"=\" expression\ntype 语句声明一个类型别名，即 typing.TypeAliasType 的实例。\n例如，以下语句创建了一个类型别名:\ntype Point = tuple[float, float]\n此代码大致等价于:\nannotation-def VALUE_OF_Point():\nreturn tuple[float, float]\nPoint = typing.TypeAliasType(\"Point\", VALUE_OF_Point())\n\n|  | global 语句将应用于整个当前作用域（模块、函数体或类定义）。 如果一个变量在本作用域的\nglobal 声明之前被使用或赋值则会引发 SyntaxError。\n在模块层级上，所有变量都是全局变量，因此 global 语句将没有用处。 不过，变量仍然不能在其\nglobal 声明之前被使用或赋值。 此项要求在交互式提示符 (REPL) 中被取消。\n程序员注意事项: global 是对解析器的指令。 它仅对与 global 语句同时被解析的代码起作用。 特\n别地，包含在提供给内置 exec() 函数字符串或代码对象中的 global 语句并不会影响 包含 该函数\n调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 global 语句\n影响。 这同样适用于 eval() 和 compile() 函数。\n7.13. nonlocal 语句 |  |\n| --- | --- | --- |\n|  | nonlocal_stmt: \"nonlocal\" identifier (\",\" identifier)* |  |\n|  | 当一个函数或类的定义嵌套（被包围）在其他函数的定义中时，其非局部作用域就是包围它的函数\n的局部作用域 。 nonlocal 语句会使其所列出的标识符指向之前在非局部作用域中绑定的名称。 它\n允许封装的代码重新绑定这样的非局部标识符。 如果一个名称在多个非局部作用域中都被绑定，则\n会使用最近的绑定。 如果一个名称在任何非局部作用域中都未被绑定，或者不存在非局部作用域，\n则会引发 SyntaxError。\nnonlocal 语句将应用于函数或类语句体的整个作用域。 如果一个变量在本作用域的 nonlocal 声明\n之前被使用或赋值则会引发 SyntaxError。 |  |\n|  | 参见:\nPEP 3104 - 访问外层作用域中的名称\n有关 nonlocal 语句的规范说明。 |  |\n|  | 程序员注意事项: nonlocal 是对解析器的指令并且仅会在与其一同被解析的代码上应用。 参见\nglobal 语句的相关注意事项。\n7.14. type 语句 |  |\n|  | type_stmt: 'type' identifier [type_params] \"=\" expression |  |\n|  | type 语句声明一个类型别名，即 typing.TypeAliasType 的实例。\n例如，以下语句创建了一个类型别名: |  |\n|  | type Point = tuple[float, float] |  |\n|  | 此代码大致等价于: |  |\n|  | annotation-def VALUE_OF_Point():\nreturn tuple[float, float]\nPoint = typing.TypeAliasType(\"Point\", VALUE_OF_Point()) |  |\n|  |  |  |\n\nannotation-def 指定一个 标注作用域，其行为很像是一个函数，但有几个小差别。\n类型别名的值是在标注作用域中被求值的。 当创建类型别名时它不会被求值，只有当通过该类型别\n名的 __value__ 属性访问时它才会被求值 (参见 惰性求值)。 这允许类型别名引用尚未被定义的名\n称。\n类型别名可以通过在名称之后添加 类型形参列表 来泛型化。 请参阅 泛型类型别名 了解详情。\ntype 是一个 软关键字。\nAdded in version 3.12.\n参见:\nPEP 695 - 类型形参语法\n引入了 type 语句和用于泛型类和函数的语法。\n\n| annotation-def 指定一个 标注作用域，其行为很像是一个函数，但有几个小差别。\n类型别名的值是在标注作用域中被求值的。 当创建类型别名时它不会被求值，只有当通过该类型别\n名的 __value__ 属性访问时它才会被求值 (参见 惰性求值)。 这允许类型别名引用尚未被定义的名\n称。\n类型别名可以通过在名称之后添加 类型形参列表 来泛型化。 请参阅 泛型类型别名 了解详情。\ntype 是一个 软关键字。\nAdded in version 3.12. |\n| --- |\n| 参见:\nPEP 695 - 类型形参语法\n引入了 type 语句和用于泛型类和函数的语法。 |", "metadata": {"title": "07_简单语句", "source": "md_docs\\python_reference_md\\07_简单语句.md", "doc_type": "语言参考", "language": "中文", "doc_id": "57e95a70"}}
{"doc_id": "3dbeeab1", "content": "8. 复合语句\n复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它语句的执\n行。 通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能包含于一行之内。\nif, while 和 for 语句用来实现传统的控制流程构造。 try 语句为一组语句指定异常处理和/和清理\n代码，而 with 语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上也属\n于复合语句。\n一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特定复合语句的子\n句头都处于相同的缩进层级。 每个子句头以一个作为唯一标识的关键字开始并以一个冒号结束。 子\n句体是由一个子句控制的一组语句。 子句体可以是在子句头的冒号之后与其同处一行的一条或由分\n号分隔的多条简单语句，或者也可以是在其之后缩进的一行或多行语句。 只有后一种形式的子句体\n才能包含嵌套的复合语句；以下形式是不合法的，这主要是因为无法分清某个后续的 else 子句应该\n属于哪个 if 子句:\nif test1: if test2: print(x)\n还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 print() 调用或者\n都不执行，或者都执行:\nif x < y < z: print(x); print(y); print(z)\n总结:\ncompound_stmt: if_stmt\n| while_stmt\n| for_stmt\n| try_stmt\n| with_stmt\n| match_stmt\n| funcdef\n| classdef\n| async_with_stmt\n| async_for_stmt\n| async_funcdef\nsuite: stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT\nstatement: stmt_list NEWLINE | compound_stmt\nstmt_list: simple_stmt (\";\" simple_stmt)* [\";\"]\n请注意语句总是以 NEWLINE 结束，之后可能跟随一个 DEDENT。 还要注意可选的后续子句总是以一\n个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空的 else’问题在 Python 中是通过\n要求嵌套的 if 语句必须缩进来解决的)。\n为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。\n\n| 8. 复合语句\n复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它语句的执\n行。 通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能包含于一行之内。\nif, while 和 for 语句用来实现传统的控制流程构造。 try 语句为一组语句指定异常处理和/和清理\n代码，而 with 语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上也属\n于复合语句。\n一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特定复合语句的子\n句头都处于相同的缩进层级。 每个子句头以一个作为唯一标识的关键字开始并以一个冒号结束。 子\n句体是由一个子句控制的一组语句。 子句体可以是在子句头的冒号之后与其同处一行的一条或由分\n号分隔的多条简单语句，或者也可以是在其之后缩进的一行或多行语句。 只有后一种形式的子句体\n才能包含嵌套的复合语句；以下形式是不合法的，这主要是因为无法分清某个后续的 else 子句应该\n属于哪个 if 子句: |\n| --- |\n| if test1: if test2: print(x) |\n| 还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 print() 调用或者\n都不执行，或者都执行: |\n| if x < y < z: print(x); print(y); print(z) |\n| 总结: |\n| compound_stmt: if_stmt\n| while_stmt\n| for_stmt\n| try_stmt\n| with_stmt\n| match_stmt\n| funcdef\n| classdef\n| async_with_stmt\n| async_for_stmt\n| async_funcdef\nsuite: stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT\nstatement: stmt_list NEWLINE | compound_stmt\nstmt_list: simple_stmt (\";\" simple_stmt)* [\";\"] |\n| 请注意语句总是以 NEWLINE 结束，之后可能跟随一个 DEDENT。 还要注意可选的后续子句总是以一\n个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空的 else’问题在 Python 中是通过\n要求嵌套的 if 语句必须缩进来解决的)。\n为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。 |\n\n8.1. if 语句\nif 语句用于有条件的执行:\nif_stmt: \"if\" assignment_expression \":\" suite\n(\"elif\" assignment_expression \":\" suite)*\n[\"else\" \":\" suite]\n它通过对表达式逐个求值直至找到一个真值（请参阅 布尔运算 了解真值与假值的定义）在子句体中\n选择唯一匹配的一个；然后执行该子句体（而且 if 语句的其他部分不会被执行或求值）。 如果所\n有表达式均为假值，则如果 else 子句体如果存在就会被执行。\n8.2. while 语句\nwhile 语句用于在表达式保持为真的情况下重复地执行:\nwhile_stmt: \"while\" assignment_expression \":\" suite\n[\"else\" \":\" suite]\n这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第\n一次检验时就发生）则如果 else 子句体存在就会被执行并终止循环。\n第一个子句体中的 break 语句在执行时将终止循环且不执行 else 子句体。 第一个子句体中的\ncontinue 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。\n8.3. for 语句\nfor 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代:\nfor_stmt: \"for\" target_list \"in\" starred_expression_list \":\" suite\n[\"else\" \":\" suite]\nstarred_expression_list 表达式会被求值一次；它应当产生一个 iterable 对象。 将针对该可迭代\n对象创建一个 iterator。 随后该迭代器所提供的第一个条目将使用标准的赋值规则被赋值给目标列表\n(参见 赋值语句)，而代码块将被执行。 此过程将针对该迭代器所提供每个条目重复进行。 当迭代器\n被耗尽时，如果存在 else 子句中的代码块，则它将被执行，并终结循环。\n第一个子句体中的 break 语句在执行时将终止循环且不执行 else 子句体。 第一个子句体中的\ncontinue 语句在执行时将跳过子句体中的剩余部分并转往下一项继续执行，或者在没有下一项时转\n往 else 子句执行。\nfor 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括在 for 循环体\n中的赋值:\nfor i in range(10):\nprint(i)\ni = 5 # 这不会影响 for 循环\n\n|  | 8.1. if 语句\nif 语句用于有条件的执行: |  |\n| --- | --- | --- |\n|  | if_stmt: \"if\" assignment_expression \":\" suite\n(\"elif\" assignment_expression \":\" suite)*\n[\"else\" \":\" suite] |  |\n|  | 它通过对表达式逐个求值直至找到一个真值（请参阅 布尔运算 了解真值与假值的定义）在子句体中\n选择唯一匹配的一个；然后执行该子句体（而且 if 语句的其他部分不会被执行或求值）。 如果所\n有表达式均为假值，则如果 else 子句体如果存在就会被执行。\n8.2. while 语句\nwhile 语句用于在表达式保持为真的情况下重复地执行: |  |\n|  | while_stmt: \"while\" assignment_expression \":\" suite\n[\"else\" \":\" suite] |  |\n|  | 这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第\n一次检验时就发生）则如果 else 子句体存在就会被执行并终止循环。\n第一个子句体中的 break 语句在执行时将终止循环且不执行 else 子句体。 第一个子句体中的\ncontinue 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。\n8.3. for 语句\nfor 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代: |  |\n|  | for_stmt: \"for\" target_list \"in\" starred_expression_list \":\" suite\n[\"else\" \":\" suite] |  |\n|  | starred_expression_list 表达式会被求值一次；它应当产生一个 iterable 对象。 将针对该可迭代\n对象创建一个 iterator。 随后该迭代器所提供的第一个条目将使用标准的赋值规则被赋值给目标列表\n(参见 赋值语句)，而代码块将被执行。 此过程将针对该迭代器所提供每个条目重复进行。 当迭代器\n被耗尽时，如果存在 else 子句中的代码块，则它将被执行，并终结循环。\n第一个子句体中的 break 语句在执行时将终止循环且不执行 else 子句体。 第一个子句体中的\ncontinue 语句在执行时将跳过子句体中的剩余部分并转往下一项继续执行，或者在没有下一项时转\n往 else 子句执行。\nfor 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括在 for 循环体\n中的赋值: |  |\n|  | for i in range(10):\nprint(i)\ni = 5 # 这不会影响 for 循环 |  |\n\n# 因为它将被 range 对象中的下一个索引\n# 所覆盖\n目标列表中的名称在循环结束时不会被删除，但是如果序列为空，则它们将根本不会被循环所赋\n值。 提示：内置类型 range() 代表由整数组成的不可变算数序列。 例如，迭代 range(3) 将依次\n产生 0, 1 和 2。\n在 3.11 版本发生变更: 现在允许在表达式列表中使用带星号的元素。\n8.4. try 语句\ntry 语句可为一组语句指定异常处理器和/或清理代码:\ntry_stmt: try1_stmt | try2_stmt | try3_stmt\ntry1_stmt: \"try\" \":\" suite\n(\"except\" [expression [\"as\" identifier]] \":\" suite)+\n[\"else\" \":\" suite]\n[\"finally\" \":\" suite]\ntry2_stmt: \"try\" \":\" suite\n(\"except\" \"*\" expression [\"as\" identifier] \":\" suite)+\n[\"else\" \":\" suite]\n[\"finally\" \":\" suite]\ntry3_stmt: \"try\" \":\" suite\n\"finally\" \":\" suite\n有关异常的更多信息可以在 异常 一节找到，有关使用 raise 语句生成异常的信息可以在 raise 语句\n一节找到。\n在 3.14 版本发生变更: 支持在使用多个异常类型时可以选择略去分组圆括号。 参见 PEP 758。\n8.4.1. except 子句\nexcept 子句指定一个或多个异常处理器。 当在 try 子句中未发生异常时，将不会执行任何异常处\n理器。 当在 try 语句块中发生异常时，将启动对异常处理器的搜索。 此搜索会依次检查 except 子\n句直至找到与异常相匹配的处理器。 不带表达式的 except 子句如果存在，则它必须是最后一个；\n它将匹配任何异常。\n对于带有表达式的 except 子句，该表达式必须被求值为一个异常类型或是由异常类型组成的元\n组。 如果提供了多个异常类型并且没有使用``as``子句，则可以去掉括号。引发的异常匹配一个\nexcept 子句，其表达式的计算结果为异常对象的类或 非虚基类，或包含此类的元组。\n如果没有 except 子句与异常相匹配，则会在周边代码和唤起栈上继续搜索异常处理器。 [1]\n如果在对 except 子句头部的表达式求值时引发了异常，则对处理器的原始搜索会被取消并在周边\n代码和调用栈上启动对新异常的搜索（它会被视作是整个 try 语句所引发的异常）。\n当代到一个匹配的 except 子句时，异常将被赋值给该 except 子句在 as 关键字之后指定的目标，\n如果存在此关键字的话，并且该 except 子句的代码块将被执行。 所有 except 子句都必须有可执\n行的代码块。 当到达此类代码块的末尾时，通常会转到整个 try 语句之后继续执行。 （这意味着如\n\n|  | # 因为它将被 range 对象中的下一个索引\n# 所覆盖 |  |\n| --- | --- | --- |\n|  | 目标列表中的名称在循环结束时不会被删除，但是如果序列为空，则它们将根本不会被循环所赋\n值。 提示：内置类型 range() 代表由整数组成的不可变算数序列。 例如，迭代 range(3) 将依次\n产生 0, 1 和 2。\n在 3.11 版本发生变更: 现在允许在表达式列表中使用带星号的元素。\n8.4. try 语句\ntry 语句可为一组语句指定异常处理器和/或清理代码: |  |\n|  | try_stmt: try1_stmt | try2_stmt | try3_stmt\ntry1_stmt: \"try\" \":\" suite\n(\"except\" [expression [\"as\" identifier]] \":\" suite)+\n[\"else\" \":\" suite]\n[\"finally\" \":\" suite]\ntry2_stmt: \"try\" \":\" suite\n(\"except\" \"*\" expression [\"as\" identifier] \":\" suite)+\n[\"else\" \":\" suite]\n[\"finally\" \":\" suite]\ntry3_stmt: \"try\" \":\" suite\n\"finally\" \":\" suite |  |\n|  | 有关异常的更多信息可以在 异常 一节找到，有关使用 raise 语句生成异常的信息可以在 raise 语句\n一节找到。\n在 3.14 版本发生变更: 支持在使用多个异常类型时可以选择略去分组圆括号。 参见 PEP 758。\n8.4.1. except 子句\nexcept 子句指定一个或多个异常处理器。 当在 try 子句中未发生异常时，将不会执行任何异常处\n理器。 当在 try 语句块中发生异常时，将启动对异常处理器的搜索。 此搜索会依次检查 except 子\n句直至找到与异常相匹配的处理器。 不带表达式的 except 子句如果存在，则它必须是最后一个；\n它将匹配任何异常。\n对于带有表达式的 except 子句，该表达式必须被求值为一个异常类型或是由异常类型组成的元\n组。 如果提供了多个异常类型并且没有使用``as``子句，则可以去掉括号。引发的异常匹配一个\nexcept 子句，其表达式的计算结果为异常对象的类或 非虚基类，或包含此类的元组。\n如果没有 except 子句与异常相匹配，则会在周边代码和唤起栈上继续搜索异常处理器。 [1]\n如果在对 except 子句头部的表达式求值时引发了异常，则对处理器的原始搜索会被取消并在周边\n代码和调用栈上启动对新异常的搜索（它会被视作是整个 try 语句所引发的异常）。\n当代到一个匹配的 except 子句时，异常将被赋值给该 except 子句在 as 关键字之后指定的目标，\n如果存在此关键字的话，并且该 except 子句的代码块将被执行。 所有 except 子句都必须有可执\n行的代码块。 当到达此类代码块的末尾时，通常会转到整个 try 语句之后继续执行。 （这意味着如 |  |\n\n果对同一异常存在两个嵌套的处理器，并且异常发生在内层处理器的 try 子句中，则外层处理器将\n不会处理该异常。）\n当使用 as target 来为异常赋值时，它将在 except 子句结束时被清除。 这就相当于\nexcept E as N:\nfoo\n被转写为\nexcept E as N:\ntry:\nfoo\nfinally:\ndel N\n这意味着异常必须被赋值给一个不同的名称才能在 except 子句之后引用它。 异常会被清除是因为\n在附加了回溯信息的情况下它们会形成栈帧的循环引用，使得帧中的所有局部变量保持存活直到发\n生下一次垃圾回收。\n在 except 子句的代码块被执行之前，异常将保存在 sys 模块中，在那里它可以从 except 子句的\n语句体内部通过 sys.exception() 被访问。 当离开一个异常处理器时，保存在 sys 模块中的异常\n将被重置为在此之前的值:\n>>> print(sys.exception())\nNone\n>>> try:\n... raise TypeError\n... except:\n... print(repr(sys.exception()))\n... try:\n... raise ValueError\n... except:\n... print(repr(sys.exception()))\n... print(repr(sys.exception()))\n...\nTypeError()\nValueError()\nTypeError()\n>>> print(sys.exception())\nNone\n8.4.2. except* 子句\nexcept* 子句针对异常组 (BaseExceptionGroup 实例) 指定一个或多个处理器。 一条 try 语句可以\n具有 except 或 except* 子句，但不可同时存在。 用于匹配的异常类型对于 except* 来说是强制\n性的，因此 except*: 将导致语法错误。 异常类型将如在 except 中一样被解读，但匹配则是在包\n含于被处理分组中的异常上执行的。 如果匹配类型为 BaseExceptionGroup 的子类则会引发\nTypeError，因为其中存在模糊的语义。\n当一个异常分组在 try 代码块中被引发时，每个 except* 子句会将其拆分 (参见 split()) 为匹配和\n不匹配异常的子分组。 如果匹配子分组不为空，它将成为被处理的异常 (从 sys.exception() 返回\n\n|  | 果对同一异常存在两个嵌套的处理器，并且异常发生在内层处理器的 try 子句中，则外层处理器将\n不会处理该异常。）\n当使用 as target 来为异常赋值时，它将在 except 子句结束时被清除。 这就相当于 |  |\n| --- | --- | --- |\n|  | except E as N:\nfoo |  |\n|  | 被转写为 |  |\n|  | except E as N:\ntry:\nfoo\nfinally:\ndel N |  |\n|  | 这意味着异常必须被赋值给一个不同的名称才能在 except 子句之后引用它。 异常会被清除是因为\n在附加了回溯信息的情况下它们会形成栈帧的循环引用，使得帧中的所有局部变量保持存活直到发\n生下一次垃圾回收。\n在 except 子句的代码块被执行之前，异常将保存在 sys 模块中，在那里它可以从 except 子句的\n语句体内部通过 sys.exception() 被访问。 当离开一个异常处理器时，保存在 sys 模块中的异常\n将被重置为在此之前的值: |  |\n|  | >>> print(sys.exception())\nNone\n>>> try:\n... raise TypeError\n... except:\n... print(repr(sys.exception()))\n... try:\n... raise ValueError\n... except:\n... print(repr(sys.exception()))\n... print(repr(sys.exception()))\n...\nTypeError()\nValueError()\nTypeError()\n>>> print(sys.exception())\nNone |  |\n|  | 8.4.2. except* 子句\nexcept* 子句针对异常组 (BaseExceptionGroup 实例) 指定一个或多个处理器。 一条 try 语句可以\n具有 except 或 except* 子句，但不可同时存在。 用于匹配的异常类型对于 except* 来说是强制\n性的，因此 except*: 将导致语法错误。 异常类型将如在 except 中一样被解读，但匹配则是在包\n含于被处理分组中的异常上执行的。 如果匹配类型为 BaseExceptionGroup 的子类则会引发\nTypeError，因为其中存在模糊的语义。\n当一个异常分组在 try 代码块中被引发时，每个 except* 子句会将其拆分 (参见 split()) 为匹配和\n不匹配异常的子分组。 如果匹配子分组不为空，它将成为被处理的异常 (从 sys.exception() 返回 |  |\n\n的值) 并分配给 except* 子句 (如果存在) 的目标。 随后，except* 子句体将被执行。 如果不匹配分\n组不为空，它将由下一个 except* 以同样的方式进行处理。 此过程将持续至分组中的所有异常都已\n被匹配，或者最后一个 except* 子句运行完成。\nAfter all except* clauses execute, the group of unhandled exceptions is merged with any\nexceptions that were raised or re-raised from within except* clauses. This merged exception group\npropagates on.:\n>>> try:\n... raise ExceptionGroup(\"eg\",\n... [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n... except* TypeError as e:\n... print(f'caught {type(e)} with nested {e.exceptions}')\n... except* OSError as e:\n... print(f'caught {type(e)} with nested {e.exceptions}')\n...\ncaught <class 'ExceptionGroup'> with nested (TypeError(2),)\ncaught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n+ Exception Group Traceback (most recent call last):\n| File \"<doctest default[0]>\", line 2, in <module>\n| raise ExceptionGroup(\"eg\",\n| [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n| ExceptionGroup: eg (1 sub-exception)\n+-+---------------- 1 ----------------\n| ValueError: 1\n+------------------------------------\n如果从 try 代码块引发的异常不是一个异常组并且其类型与某个 except* 子句相匹配，它将被捕获\n并由附带空消息字符串的异常组来包装。 这将确保目标 e 的类型与一定为 BaseExceptionGroup:\n>>> try:\n... raise BlockingIOError\n... except* BlockingIOError as e:\n... print(repr(e))\n...\nExceptionGroup('', (BlockingIOError()))\nbreak, continue 和 return 不可在 except* 子句中出现。\n8.4.3. else 子句\n如果控制流离开 try 子句体时没有引发异常，并且没有执行 return, continue 或 break 语句，可\n选的 else 子句将被执行。 else 语句中的异常不会由之前的 except 子句处理。\n8.4.4. finally 子句\n如果存在 finally，它将指定一个“清理”处理器。 try 子句会被执行，包括任何 except 和 else 子\n句。 如果在这些子句中发生任何未处理的异常，该异常会被临时保存。 finally 子句将被执行。\n如果存在被保存的异常，它会在 finally 子句的末尾被重新引发。 如果 finally 子句引发了另一\n个异常，被保存的异常会被设为新异常的上下文。 如果 finally 子句执行了 return, break 或\ncontinue 语句，则被保存的异常会被丢弃。例如，这个函数返回42。\n\n|  | 的值) 并分配给 except* 子句 (如果存在) 的目标。 随后，except* 子句体将被执行。 如果不匹配分\n组不为空，它将由下一个 except* 以同样的方式进行处理。 此过程将持续至分组中的所有异常都已\n被匹配，或者最后一个 except* 子句运行完成。\nAfter all except* clauses execute, the group of unhandled exceptions is merged with any\nexceptions that were raised or re-raised from within except* clauses. This merged exception group\npropagates on.: |  |\n| --- | --- | --- |\n|  | >>> try:\n... raise ExceptionGroup(\"eg\",\n... [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n... except* TypeError as e:\n... print(f'caught {type(e)} with nested {e.exceptions}')\n... except* OSError as e:\n... print(f'caught {type(e)} with nested {e.exceptions}')\n...\ncaught <class 'ExceptionGroup'> with nested (TypeError(2),)\ncaught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n+ Exception Group Traceback (most recent call last):\n| File \"<doctest default[0]>\", line 2, in <module>\n| raise ExceptionGroup(\"eg\",\n| [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n| ExceptionGroup: eg (1 sub-exception)\n+-+---------------- 1 ----------------\n| ValueError: 1\n+------------------------------------ |  |\n|  | 如果从 try 代码块引发的异常不是一个异常组并且其类型与某个 except* 子句相匹配，它将被捕获\n并由附带空消息字符串的异常组来包装。 这将确保目标 e 的类型与一定为 BaseExceptionGroup: |  |\n|  | >>> try:\n... raise BlockingIOError\n... except* BlockingIOError as e:\n... print(repr(e))\n...\nExceptionGroup('', (BlockingIOError())) |  |\n|  | break, continue 和 return 不可在 except* 子句中出现。\n8.4.3. else 子句\n如果控制流离开 try 子句体时没有引发异常，并且没有执行 return, continue 或 break 语句，可\n选的 else 子句将被执行。 else 语句中的异常不会由之前的 except 子句处理。\n8.4.4. finally 子句\n如果存在 finally，它将指定一个“清理”处理器。 try 子句会被执行，包括任何 except 和 else 子\n句。 如果在这些子句中发生任何未处理的异常，该异常会被临时保存。 finally 子句将被执行。\n如果存在被保存的异常，它会在 finally 子句的末尾被重新引发。 如果 finally 子句引发了另一\n个异常，被保存的异常会被设为新异常的上下文。 如果 finally 子句执行了 return, break 或\ncontinue 语句，则被保存的异常会被丢弃。例如，这个函数返回42。 |  |\n\ndef f():\ntry:\n1/0\nfinally:\nreturn 42\n在 finally 子句执行期间程序将不能获取到异常信息。\n当 return, break 或 continue 语句在一个 try...finally 语句的 try 子句的代码块中被执行时，\nfinally 子句也会在‘离开时’被执行。\n函数的返回值是由最后被执行的 return 语句来决定的。 由于 finally 子句总是会被执行，因此在\nfinally 子句中被执行的 return 语句将总是最后被执行的。下面的函数返回“finally”。\ndef foo():\ntry:\nreturn 'try'\nfinally:\nreturn 'finally'\n在 3.8 版本发生变更: 在 Python 3.8 之前，continue 语句不允许在 finally 子句中使用，这\n是因为具体实现中存在一个问题。\n在 3.14 版本发生变更: 当 return, break 或 continue 在 finally 代码块中出现时编译器将\n发出 SyntaxWarning (参见 PEP 765)。\n8.5. with 语句\nwith 语句用于包装带有使用上下文管理器 (参见 with 语句上下文管理器 一节) 定义的方法的代码块\n的执行。 这允许对普通的 try...except...finally 使用模式进行封装以方便地重用。\nwith_stmt: \"with\" ( \"(\" with_stmt_contents \",\"? \")\" | with_stmt_contents )\nwith_stmt_contents: with_item (\",\" with_item)*\nwith_item: expression [\"as\" target]\n带有一个“项目”的 with 语句的执行过程如下:\n1. 对上下文表达式（在 with_item 中给出的表达式）进行求值来获得上下文管理器。\n2. 载入上下文管理器的 __enter__() 以便后续使用。\n3. 载入上下文管理器的 __exit__() 以便后续使用。\n4. 唤起上下文管理器的 __enter__() 方法。\n5. 如果一个目标被包括在 with 语句中，则把它赋值为 __enter__() 的返回值。\n备注: with 语句会保证如果 __enter__() 方法未发生错误地返回，则 __exit__() 将一\n定被调用。 因此，如果在对目标列表赋值期间发生错误，它将被当作在语句体内部发生的\n错误来处理。 参见下面的第 7 步。\n\n|  | def f():\ntry:\n1/0\nfinally:\nreturn 42 |  |  |\n| --- | --- | --- | --- |\n|  | 在 finally 子句执行期间程序将不能获取到异常信息。\n当 return, break 或 continue 语句在一个 try...finally 语句的 try 子句的代码块中被执行时，\nfinally 子句也会在‘离开时’被执行。\n函数的返回值是由最后被执行的 return 语句来决定的。 由于 finally 子句总是会被执行，因此在\nfinally 子句中被执行的 return 语句将总是最后被执行的。下面的函数返回“finally”。 |  |  |\n|  | def foo():\ntry:\nreturn 'try'\nfinally:\nreturn 'finally' |  |  |\n|  | 在 3.8 版本发生变更: 在 Python 3.8 之前，continue 语句不允许在 finally 子句中使用，这\n是因为具体实现中存在一个问题。\n在 3.14 版本发生变更: 当 return, break 或 continue 在 finally 代码块中出现时编译器将\n发出 SyntaxWarning (参见 PEP 765)。\n8.5. with 语句\nwith 语句用于包装带有使用上下文管理器 (参见 with 语句上下文管理器 一节) 定义的方法的代码块\n的执行。 这允许对普通的 try...except...finally 使用模式进行封装以方便地重用。 |  |  |\n|  | with_stmt: \"with\" ( \"(\" with_stmt_contents \",\"? \")\" | with_stmt_contents )\nwith_stmt_contents: with_item (\",\" with_item)*\nwith_item: expression [\"as\" target] |  |  |\n|  | 带有一个“项目”的 with 语句的执行过程如下:\n1. 对上下文表达式（在 with_item 中给出的表达式）进行求值来获得上下文管理器。\n2. 载入上下文管理器的 __enter__() 以便后续使用。\n3. 载入上下文管理器的 __exit__() 以便后续使用。\n4. 唤起上下文管理器的 __enter__() 方法。\n5. 如果一个目标被包括在 with 语句中，则把它赋值为 __enter__() 的返回值。\n备注: with 语句会保证如果 __enter__() 方法未发生错误地返回，则 __exit__() 将一\n定被调用。 因此，如果在对目标列表赋值期间发生错误，它将被当作在语句体内部发生的\n错误来处理。 参见下面的第 7 步。 |  |  |\n\n6. 执行语句体。\n7. 唤起上下文管理器的 __exit__() 方法。 如果语句体的退出是由异常导致的，则其类型、值\n和回溯信息将被作为参数传递给 __exit__()。 否则的话，将提供三个 None 参数。\n如果语句体的退出是由异常导致的，并且来自 __exit__() 方法的返回值为假，则该异常会被\n重新引发。 如果返回值为真，则该异常会被抑制，并会继续执行 with 语句之后的语句。\n如果语句体由于异常以外的任何原因退出，则来自 __exit__() 的返回值会被忽略，并会在该\n类退出正常的发生位置继续执行。\n以下代码:\nwith EXPRESSION as TARGET:\nSUITE\n在语义上等价于:\nmanager = (EXPRESSION)\nenter = type(manager).__enter__\nexit = type(manager).__exit__\nvalue = enter(manager)\nhit_except = False\ntry:\nTARGET = value\nSUITE\nexcept:\nhit_except = True\nif not exit(manager, *sys.exc_info()):\nraise\nfinally:\nif not hit_except:\nexit(manager, None, None, None)\n如果有多个项目，则会视作存在多个 with 语句嵌套来处理多个上下文管理器:\nwith A() as a, B() as b:\nSUITE\n在语义上等价于:\nwith A() as a:\nwith B() as b:\nSUITE\n也可以用圆括号包围的多行形式的多项目上下文管理器。例如:\nwith (\nA() as a,\nB() as b,\n):\nSUITE\n\n|  | 6. 执行语句体。\n7. 唤起上下文管理器的 __exit__() 方法。 如果语句体的退出是由异常导致的，则其类型、值\n和回溯信息将被作为参数传递给 __exit__()。 否则的话，将提供三个 None 参数。\n如果语句体的退出是由异常导致的，并且来自 __exit__() 方法的返回值为假，则该异常会被\n重新引发。 如果返回值为真，则该异常会被抑制，并会继续执行 with 语句之后的语句。\n如果语句体由于异常以外的任何原因退出，则来自 __exit__() 的返回值会被忽略，并会在该\n类退出正常的发生位置继续执行。\n以下代码: |  |\n| --- | --- | --- |\n|  | with EXPRESSION as TARGET:\nSUITE |  |\n|  | 在语义上等价于: |  |\n|  | manager = (EXPRESSION)\nenter = type(manager).__enter__\nexit = type(manager).__exit__\nvalue = enter(manager)\nhit_except = False\ntry:\nTARGET = value\nSUITE\nexcept:\nhit_except = True\nif not exit(manager, *sys.exc_info()):\nraise\nfinally:\nif not hit_except:\nexit(manager, None, None, None) |  |\n|  | 如果有多个项目，则会视作存在多个 with 语句嵌套来处理多个上下文管理器: |  |\n|  | with A() as a, B() as b:\nSUITE |  |\n|  | 在语义上等价于: |  |\n|  | with A() as a:\nwith B() as b:\nSUITE |  |\n|  | 也可以用圆括号包围的多行形式的多项目上下文管理器。例如: |  |\n|  | with (\nA() as a,\nB() as b,\n):\nSUITE |  |\n|  |  |  |\n\n在 3.1 版本发生变更: 支持多个上下文表达式。\n在 3.10 版本发生变更: Support for using grouping parentheses to break the statement in\nmultiple lines.\n参见:\nPEP 343 - \"with\" 语句\nPython with 语句的规范描述、背景和示例。\n8.6. match 语句\nAdded in version 3.10.\n匹配语句用于进行模式匹配。语法如下：\nmatch_stmt: 'match' subject_expr \":\" NEWLINE INDENT case_block+ DEDENT\nsubject_expr: `!star_named_expression` \",\" `!star_named_expressions`?\n| `!named_expression`\ncase_block: 'case' patterns [guard] \":\" `!block`\n备注: 本节使用单引号来表示 软关键字。\n模式匹配接受一个模式作为输入（跟在 case 后），一个目标值（跟在 match 后）。该模式（可能\n包含子模式）将与目标值进行匹配。输出是：\n匹配成功或失败（也被称为模式成功或失败）。\n可能将匹配的值绑定到一个名字上。 这方面的先决条件将在下面进一步讨论。\n关键字 match 和 case 是 soft keywords 。\n参见:\nPEP 634 —— 结构化模式匹配：规范\nPEP 636 —— 结构化模式匹配：教程\n8.6.1. 概述\n匹配语句逻辑流程的概述如下：\n1. 对目标表达式 subject_expr 求值后将结果作为匹配用的目标值。 如果目标表达式包含逗\n号，则使用 the standard rules 构建一个元组。\n2. 目标值将依次与 case_block 中的每个模式进行匹配。匹配成功或失败的具体规则在下面描\n述。匹配尝试也可以与模式中的一些或所有的独立名称绑定。准确的模式绑定规则因模式类型\n而异，具体规定见下文。成功的模式匹配过程中产生的名称绑定将超越所执行的块的范围，可\n以在匹配语句之后使用。\n\n|  | 在 3.1 版本发生变更: 支持多个上下文表达式。\n在 3.10 版本发生变更: Support for using grouping parentheses to break the statement in\nmultiple lines. |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 343 - \"with\" 语句\nPython with 语句的规范描述、背景和示例。 |  |\n|  | 8.6. match 语句\nAdded in version 3.10.\n匹配语句用于进行模式匹配。语法如下： |  |\n|  | match_stmt: 'match' subject_expr \":\" NEWLINE INDENT case_block+ DEDENT\nsubject_expr: `!star_named_expression` \",\" `!star_named_expressions`?\n| `!named_expression`\ncase_block: 'case' patterns [guard] \":\" `!block` |  |\n|  |  |  |\n|  | 备注: 本节使用单引号来表示 软关键字。 |  |\n|  | 模式匹配接受一个模式作为输入（跟在 case 后），一个目标值（跟在 match 后）。该模式（可能\n包含子模式）将与目标值进行匹配。输出是：\n匹配成功或失败（也被称为模式成功或失败）。\n可能将匹配的值绑定到一个名字上。 这方面的先决条件将在下面进一步讨论。\n关键字 match 和 case 是 soft keywords 。 |  |\n|  | 参见:\nPEP 634 —— 结构化模式匹配：规范\nPEP 636 —— 结构化模式匹配：教程 |  |\n|  | 8.6.1. 概述\n匹配语句逻辑流程的概述如下：\n1. 对目标表达式 subject_expr 求值后将结果作为匹配用的目标值。 如果目标表达式包含逗\n号，则使用 the standard rules 构建一个元组。\n2. 目标值将依次与 case_block 中的每个模式进行匹配。匹配成功或失败的具体规则在下面描\n述。匹配尝试也可以与模式中的一些或所有的独立名称绑定。准确的模式绑定规则因模式类型\n而异，具体规定见下文。成功的模式匹配过程中产生的名称绑定将超越所执行的块的范围，可\n以在匹配语句之后使用。 |  |\n\n备注: 在模式匹配失败时，一些子模式可能会成功。 不要依赖于失败匹配进行的绑定。 反\n过来说，不要认为变量在匹配失败后保持不变。 确切的行为取决于实现，可能会有所不\n同。 这是一个有意的决定，允许不同的实现添加优化。\n3. 如果该模式匹配成功，并且完成了对相应的约束项（如果存在）的求值。在这种情况下，保证\n完成所有的名称绑定。\n如果约束项求值为真或缺失，执行 case_block 中的 block 。\n否则，将按照上述方法尝试下一个 case_block 。\n如果没有进一步的 case 块，匹配语句终止。\n备注: 用户一般不应依赖正在求值的模式。 根据不同的实现方式，解释器可能会缓存数值或使用\n其他优化方法来避免重复求值。\n匹配语句示例:\n>>> flag = False\n>>> match (100, 200):\n... case (100, 300): # 不匹配: 200 != 300\n... print('Case 1')\n... case (100, 200) if flag: # 成功匹配，但防护检查失败\n... print('Case 2')\n... case (100, y): # 匹配并将 y 绑定到 200\n... print(f'Case 3, y: {y}')\n... case _: # 未尝试的模式\n... print('Case 4, I match anything!')\n...\nCase 3, y: 200\n在这个示例中，if flag 是约束项。请阅读下一节以了解更多相关内容。\n8.6.2. 约束项\nguard: \"if\" `!named_expression`\nguard (它是 case 的一部分) 必须成立才能让 case 语句块中的代码被执行。 它所采用的形式为: if\n之后跟一个表达式。\n拥有 guard 的 case 块的逻辑流程如下：\n1. 检查 case 块中的模式是否匹配成功。如果该模式匹配失败，则不对 guard 进行求值，检查\n下一个 case 块。\n2. 如果该模式匹配成功，对 guard 求值。\n如果 guard 求值为真，则选用该 case 块。\n如果 guard 求值为假，则不选用该 case 块。\n如果在对 guard 求值过程中引发了异常，则异常将被抛出。\n允许约束项产生副作用，因为他们是表达式。约束项求值必须从第一个 case 块到最后一个 case 块\n依次逐个进行，模式匹配失败的 case 块将被跳过。（也就是说，约束项求值必须按顺序进行。）一\n\n|  | 备注: 在模式匹配失败时，一些子模式可能会成功。 不要依赖于失败匹配进行的绑定。 反\n过来说，不要认为变量在匹配失败后保持不变。 确切的行为取决于实现，可能会有所不\n同。 这是一个有意的决定，允许不同的实现添加优化。\n3. 如果该模式匹配成功，并且完成了对相应的约束项（如果存在）的求值。在这种情况下，保证\n完成所有的名称绑定。\n如果约束项求值为真或缺失，执行 case_block 中的 block 。\n否则，将按照上述方法尝试下一个 case_block 。\n如果没有进一步的 case 块，匹配语句终止。 | 备注: 在模式匹配失败时，一些子模式可能会成功。 不要依赖于失败匹配进行的绑定。 反\n过来说，不要认为变量在匹配失败后保持不变。 确切的行为取决于实现，可能会有所不\n同。 这是一个有意的决定，允许不同的实现添加优化。 |  |\n| --- | --- | --- | --- |\n|  | 备注: 用户一般不应依赖正在求值的模式。 根据不同的实现方式，解释器可能会缓存数值或使用\n其他优化方法来避免重复求值。 |  |  |\n|  | 匹配语句示例: |  |  |\n|  | >>> flag = False\n>>> match (100, 200):\n... case (100, 300): # 不匹配: 200 != 300\n... print('Case 1')\n... case (100, 200) if flag: # 成功匹配，但防护检查失败\n... print('Case 2')\n... case (100, y): # 匹配并将 y 绑定到 200\n... print(f'Case 3, y: {y}')\n... case _: # 未尝试的模式\n... print('Case 4, I match anything!')\n...\nCase 3, y: 200 |  |  |\n|  | 在这个示例中，if flag 是约束项。请阅读下一节以了解更多相关内容。\n8.6.2. 约束项 |  |  |\n|  | guard: \"if\" `!named_expression` |  |  |\n|  | guard (它是 case 的一部分) 必须成立才能让 case 语句块中的代码被执行。 它所采用的形式为: if\n之后跟一个表达式。\n拥有 guard 的 case 块的逻辑流程如下：\n1. 检查 case 块中的模式是否匹配成功。如果该模式匹配失败，则不对 guard 进行求值，检查\n下一个 case 块。\n2. 如果该模式匹配成功，对 guard 求值。\n如果 guard 求值为真，则选用该 case 块。\n如果 guard 求值为假，则不选用该 case 块。\n如果在对 guard 求值过程中引发了异常，则异常将被抛出。\n允许约束项产生副作用，因为他们是表达式。约束项求值必须从第一个 case 块到最后一个 case 块\n依次逐个进行，模式匹配失败的 case 块将被跳过。（也就是说，约束项求值必须按顺序进行。）一 |  |  |\n\n旦选用了一个 case 块，约束项求值必须由此终止。\n8.6.3. 必定匹配的 case 块\n必定匹配的 case 块是能匹配所有情况的 case 块。一个匹配语句最多可以有一个必定匹配的 case\n块，而且必须是最后一个。\n如果一个 case 块没有约束项，并且其模式是必定匹配的，那么它就被认为是必定匹配的。 如果我们\n可以仅从语法上证明一个模式总是能匹配成功，那么这个模式就被认为是必定匹配的。 只有以下模\n式是必定匹配的：\n左侧模式是必定匹配的 AS 模式\n包含至少一个必定匹配模式的 或模式\n捕获模式\n通配符模式\n括号内的必定匹配模式\n8.6.4. 模式\n备注: 本节使用了超出标准 EBNF 的语法符号。\n符号 SEP.RULE+ 是 RULE (SEP RULE)* 的简写\n符号 !RULE 是前向否定断言的简写\npatterns 的顶层语法是：\npatterns: open_sequence_pattern | pattern\npattern: as_pattern | or_pattern\nclosed_pattern: | literal_pattern\n| capture_pattern\n| wildcard_pattern\n| value_pattern\n| group_pattern\n| sequence_pattern\n| mapping_pattern\n| class_pattern\n下面的描述将包括一个“简而言之”以描述模式的作用，便于说明问题（感谢 Raymond Hettinger 提\n供的一份文件，大部分的描述受其启发）。请注意，这些描述纯粹是为了说明问题，可能不 反映底\n层的实现。此外，它们并没有涵盖所有有效的形式。\n8.6.4.1. 或模式\n或模式是由竖杠 | 分隔的两个或更多的模式。语法：\nor_pattern: \"|\".closed_pattern+\n只有最后的子模式可以是 必定匹配的，且每个子模式必须绑定相同的名字集以避免歧义。\n\n|  | 旦选用了一个 case 块，约束项求值必须由此终止。\n8.6.3. 必定匹配的 case 块\n必定匹配的 case 块是能匹配所有情况的 case 块。一个匹配语句最多可以有一个必定匹配的 case\n块，而且必须是最后一个。\n如果一个 case 块没有约束项，并且其模式是必定匹配的，那么它就被认为是必定匹配的。 如果我们\n可以仅从语法上证明一个模式总是能匹配成功，那么这个模式就被认为是必定匹配的。 只有以下模\n式是必定匹配的：\n左侧模式是必定匹配的 AS 模式\n包含至少一个必定匹配模式的 或模式\n捕获模式\n通配符模式\n括号内的必定匹配模式\n8.6.4. 模式 |  |\n| --- | --- | --- |\n|  | 备注: 本节使用了超出标准 EBNF 的语法符号。\n符号 SEP.RULE+ 是 RULE (SEP RULE)* 的简写\n符号 !RULE 是前向否定断言的简写 |  |\n|  | patterns 的顶层语法是： |  |\n|  | patterns: open_sequence_pattern | pattern\npattern: as_pattern | or_pattern\nclosed_pattern: | literal_pattern\n| capture_pattern\n| wildcard_pattern\n| value_pattern\n| group_pattern\n| sequence_pattern\n| mapping_pattern\n| class_pattern |  |\n|  | 下面的描述将包括一个“简而言之”以描述模式的作用，便于说明问题（感谢 Raymond Hettinger 提\n供的一份文件，大部分的描述受其启发）。请注意，这些描述纯粹是为了说明问题，可能不 反映底\n层的实现。此外，它们并没有涵盖所有有效的形式。\n8.6.4.1. 或模式\n或模式是由竖杠 | 分隔的两个或更多的模式。语法： |  |\n|  | or_pattern: \"|\".closed_pattern+ |  |\n|  | 只有最后的子模式可以是 必定匹配的，且每个子模式必须绑定相同的名字集以避免歧义。 |  |\n\n或模式将目标值依次与其每个子模式尝试匹配，直到有一个匹配成功，然后该或模式被视作匹配成\n功。 否则，如果没有任何子模式匹配成功，则或模式匹配失败。\n简而言之，P1 | P2 | ... 会首先尝试匹配 P1 ，如果失败将接着尝试匹配 P2 ，如果出现成功的匹\n配则立即结束且模式匹配成功，否则模式匹配失败。\n8.6.4.2. AS 模式\nAS 模式将关键字 as 左侧的或模式与目标值进行匹配。语法：\nas_pattern: or_pattern \"as\" capture_pattern\n如果 OR 模式匹配失败，则 AS 模式也会失败。 在其他情况下，AS 模块会将目标与 as 关键字右边的\n名称绑定并匹配成功。 capture_pattern 不可为 _。\n简而言之， P as NAME 将与 P 匹配，成功后将设置 NAME = <subject> 。\n8.6.4.3. 字面值模式\n字面值模式对应 Python 中的大多数 字面值。 语法为:\nliteral_pattern: signed_number\n| signed_number \"+\" NUMBER\n| signed_number \"-\" NUMBER\n| strings\n| \"None\"\n| \"True\"\n| \"False\"\nsigned_number: [\"-\"] NUMBER\n规则 strings 和标记 NUMBER 在 标准 Python 语法 中有定义。支持三引号字符串、原生字符串和字\n节字符串，但不支持 f-字符串 和 t-strings。\nsigned_number '+' NUMBER 和 signed_number '-' NUMBER 形式是用于表示 复数；它们要求左边\n是一个实数而右边是一个虚数。 例如 3 + 4j。\n简而言之， LITERAL 只会在 <subject> == LITERAL 时匹配成功。对于单例 None 、 True 和\nFalse ，会使用 is 运算符。\n8.6.4.4. 捕获模式\n捕获模式将目标值与一个名称绑定。语法：\ncapture_pattern: !'_' NAME\n单独的一个下划线 _ 不是捕获模式（ !'_' 表达的就是这个含义）。 它会被当作\nwildcard_pattern 。\n在给定的模式中，一个名字只能被绑定一次。例如 case x, x: ... 时无效的，但 case [x] | x:\n... 是被允许的。\n\n|  |  | 或模式将目标值依次与其每个子模式尝试匹配，直到有一个匹配成功，然后该或模式被视作匹配成\n功。 否则，如果没有任何子模式匹配成功，则或模式匹配失败。\n简而言之，P1 | P2 | ... 会首先尝试匹配 P1 ，如果失败将接着尝试匹配 P2 ，如果出现成功的匹\n配则立即结束且模式匹配成功，否则模式匹配失败。\n8.6.4.2. AS 模式\nAS 模式将关键字 as 左侧的或模式与目标值进行匹配。语法： |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | as_pattern: or_pattern \"as\" capture_pattern |  |  |\n|  |  | 如果 OR 模式匹配失败，则 AS 模式也会失败。 在其他情况下，AS 模块会将目标与 as 关键字右边的\n名称绑定并匹配成功。 capture_pattern 不可为 _。\n简而言之， P as NAME 将与 P 匹配，成功后将设置 NAME = <subject> 。\n8.6.4.3. 字面值模式\n字面值模式对应 Python 中的大多数 字面值。 语法为: |  |  |\n|  |  | literal_pattern: signed_number\n| signed_number \"+\" NUMBER\n| signed_number \"-\" NUMBER\n| strings\n| \"None\"\n| \"True\"\n| \"False\"\nsigned_number: [\"-\"] NUMBER |  |  |\n|  |  | 规则 strings 和标记 NUMBER 在 标准 Python 语法 中有定义。支持三引号字符串、原生字符串和字\n节字符串，但不支持 f-字符串 和 t-strings。\nsigned_number '+' NUMBER 和 signed_number '-' NUMBER 形式是用于表示 复数；它们要求左边\n是一个实数而右边是一个虚数。 例如 3 + 4j。\n简而言之， LITERAL 只会在 <subject> == LITERAL 时匹配成功。对于单例 None 、 True 和\nFalse ，会使用 is 运算符。\n8.6.4.4. 捕获模式\n捕获模式将目标值与一个名称绑定。语法： |  |  |\n|  |  | capture_pattern: !'_' NAME |  |  |\n|  |  | 单独的一个下划线 _ 不是捕获模式（ !'_' 表达的就是这个含义）。 它会被当作\nwildcard_pattern 。\n在给定的模式中，一个名字只能被绑定一次。例如 case x, x: ... 时无效的，但 case [x] | x:\n... 是被允许的。 |  |  |\n|  |  |  | case [x] | x: |  |\n|  |  |  |  |  |\n|  |  | ... |  |  |\n|  |  |  |  |  |\n\n捕获模式总是能匹配成功。绑定遵循 PEP 572 中赋值表达式运算符设立的作用域规则；名字在最接\n近的包含函数作用域内成为一个局部变量，除非有适用的 global 或 nonlocal 语句。\n简而言之， NAME 总是会匹配成功且将设置 NAME = <subject> 。\n8.6.4.5. 通配符模式\n通配符模式总是会匹配成功（匹配任何内容）并且不绑定任何名称。语法：\nwildcard_pattern: '_'\n在且仅在任何模式中 _ 是一个 软关键字。 通常情况下它是一个标识符，即使是在 match 的目标表\n达式、guard 和 case 代码块中也是如此。\n简而言之，_ 总是会匹配成功。\n8.6.4.6. 值模式\n值模式代表 Python 中具有名称的值。语法：\nvalue_pattern: attr\nattr: name_or_attr \".\" NAME\nname_or_attr: attr | NAME\n模式中带点的名称会使用标准的 Python 名称解析规则 来查找。 如果找到的值与目标值比较结果相\n等则模式匹配成功（使用 == 相等运算符）。\n简而言之， NAME1.NAME2 仅在 <subject> == NAME1.NAME2 时匹配成功。\n备注: 如果相同的值在同一个匹配语句中出现多次，解释器可能会缓存找到的第一个值并重新使\n用它，而不是重复查找。 这种缓存与特定匹配语句的执行严格挂钩。\n8.6.4.7. 组模式\n组模式允许用户在模式周围添加括号，以强调预期的分组。 除此之外，它没有额外的语法。语法：\ngroup_pattern: \"(\" pattern \")\"\n简单来说 (P) 具有与 P 相同的效果。\n8.6.4.8. 序列模式\n一个序列模式包含数个将与序列元素进行匹配的子模式。其语法类似于列表或元组的解包。\nsequence_pattern: \"[\" [maybe_sequence_pattern] \"]\"\n| \"(\" [open_sequence_pattern] \")\"\nopen_sequence_pattern: maybe_star_pattern \",\" [maybe_sequence_pattern]\nmaybe_sequence_pattern: \",\".maybe_star_pattern+ \",\"?\nmaybe_star_pattern: star_pattern | pattern\nstar_pattern: \"*\" (capture_pattern | wildcard_pattern)\n\n|  | 捕获模式总是能匹配成功。绑定遵循 PEP 572 中赋值表达式运算符设立的作用域规则；名字在最接\n近的包含函数作用域内成为一个局部变量，除非有适用的 global 或 nonlocal 语句。\n简而言之， NAME 总是会匹配成功且将设置 NAME = <subject> 。\n8.6.4.5. 通配符模式\n通配符模式总是会匹配成功（匹配任何内容）并且不绑定任何名称。语法： |  |\n| --- | --- | --- |\n|  | wildcard_pattern: '_' |  |\n|  | 在且仅在任何模式中 _ 是一个 软关键字。 通常情况下它是一个标识符，即使是在 match 的目标表\n达式、guard 和 case 代码块中也是如此。\n简而言之，_ 总是会匹配成功。\n8.6.4.6. 值模式\n值模式代表 Python 中具有名称的值。语法： |  |\n|  | value_pattern: attr\nattr: name_or_attr \".\" NAME\nname_or_attr: attr | NAME |  |\n|  | 模式中带点的名称会使用标准的 Python 名称解析规则 来查找。 如果找到的值与目标值比较结果相\n等则模式匹配成功（使用 == 相等运算符）。\n简而言之， NAME1.NAME2 仅在 <subject> == NAME1.NAME2 时匹配成功。 |  |\n|  | 备注: 如果相同的值在同一个匹配语句中出现多次，解释器可能会缓存找到的第一个值并重新使\n用它，而不是重复查找。 这种缓存与特定匹配语句的执行严格挂钩。 |  |\n|  | 8.6.4.7. 组模式\n组模式允许用户在模式周围添加括号，以强调预期的分组。 除此之外，它没有额外的语法。语法： |  |\n|  | group_pattern: \"(\" pattern \")\" |  |\n|  | 简单来说 (P) 具有与 P 相同的效果。\n8.6.4.8. 序列模式\n一个序列模式包含数个将与序列元素进行匹配的子模式。其语法类似于列表或元组的解包。 |  |\n|  | sequence_pattern: \"[\" [maybe_sequence_pattern] \"]\"\n| \"(\" [open_sequence_pattern] \")\"\nopen_sequence_pattern: maybe_star_pattern \",\" [maybe_sequence_pattern]\nmaybe_sequence_pattern: \",\".maybe_star_pattern+ \",\"?\nmaybe_star_pattern: star_pattern | pattern\nstar_pattern: \"*\" (capture_pattern | wildcard_pattern) |  |\n\n序列模式中使用圆括号或方括号没有区别（例如 (...) 和 [...] ）。\n备注: 用圆括号括起来且没有跟随逗号的单个模式 (例如 (3 | 4)) 是一个 分组模式。 而用方括\n号括起来的单个模式 (例如 [3 | 4]) 则仍是一个序列模式。\n一个序列模式中最多可以有一个星号子模式。星号子模式可以出现在任何位置。如果没有星号子模\n式，该序列模式是固定长度的序列模式；否则，其是一个可变长度的序列模式。\n下面是将一个序列模式与一个目标值相匹配的逻辑流程：\n1. 如果目标值不是一个序列 [2] ，该序列模式匹配失败。\n2. 如果目标值是 str 、 bytes 或 bytearray 的实例，则该序列模式匹配失败。\n3. 随后的步骤取决于序列模式是固定长度还是可变长度的。\n如果序列模式是固定长度的：\n1. 如果目标序列的长度与子模式的数量不相等，则该序列模式匹配失败\n2. 序列模式中的子模式与目标序列中的相应项目从左到右进行匹配。 一旦一个子模式匹\n配失败，就停止匹配。 如果所有的子模式都成功地与它们的对应项相匹配，那么该序\n列模式就匹配成功了。\n否则，如果序列模式是变长的：\n1. 如果目标序列的长度小于非星号子模式的数量，则该序列模式匹配失败。\n2. 与固定长度的序列一样，靠前的非星形子模式与其相应的项目进行匹配。\n3. 如果上一步成功，星号子模式与剩余的目标项形成的列表相匹配，不包括星号子模式之\n后的非星号子模式所对应的剩余项。\n4. 剩余的非星号子模式将与相应的目标项匹配，就像固定长度的序列一样。\n备注: 目标序列的长度可通过 len() (即通过 __len__() 协议) 获得。 解释器可能会以类\n似于 值模式 的方式缓存这个长度信息。\n简而言之， [P1, P2, P3, ... , P<N>] 仅在满足以下情况时匹配成功：\n检查 <subject> 是一个序列\nlen(subject) == <N>\n将 P1 与 <subject>[0] 进行匹配（请注意此匹配可以绑定名称）\n将 P2 与 <subject>[1] 进行匹配（请注意此匹配可以绑定名称）\n…… 剩余对应的模式/元素也以此类推。\n8.6.4.9. 映射模式\n映射模式包含一个或多个键值模式。其语法类似于字典的构造。语法：\nmapping_pattern: \"{\" [items_pattern] \"}\"\nitems_pattern: \",\".key_value_pattern+ \",\"?\nkey_value_pattern: (literal_pattern | value_pattern) \":\" pattern\n\n|  | 序列模式中使用圆括号或方括号没有区别（例如 (...) 和 [...] ）。 |  |\n| --- | --- | --- |\n|  | 备注: 用圆括号括起来且没有跟随逗号的单个模式 (例如 (3 | 4)) 是一个 分组模式。 而用方括\n号括起来的单个模式 (例如 [3 | 4]) 则仍是一个序列模式。 |  |\n|  | 一个序列模式中最多可以有一个星号子模式。星号子模式可以出现在任何位置。如果没有星号子模\n式，该序列模式是固定长度的序列模式；否则，其是一个可变长度的序列模式。\n下面是将一个序列模式与一个目标值相匹配的逻辑流程：\n1. 如果目标值不是一个序列 [2] ，该序列模式匹配失败。\n2. 如果目标值是 str 、 bytes 或 bytearray 的实例，则该序列模式匹配失败。\n3. 随后的步骤取决于序列模式是固定长度还是可变长度的。\n如果序列模式是固定长度的：\n1. 如果目标序列的长度与子模式的数量不相等，则该序列模式匹配失败\n2. 序列模式中的子模式与目标序列中的相应项目从左到右进行匹配。 一旦一个子模式匹\n配失败，就停止匹配。 如果所有的子模式都成功地与它们的对应项相匹配，那么该序\n列模式就匹配成功了。\n否则，如果序列模式是变长的：\n1. 如果目标序列的长度小于非星号子模式的数量，则该序列模式匹配失败。\n2. 与固定长度的序列一样，靠前的非星形子模式与其相应的项目进行匹配。\n3. 如果上一步成功，星号子模式与剩余的目标项形成的列表相匹配，不包括星号子模式之\n后的非星号子模式所对应的剩余项。\n4. 剩余的非星号子模式将与相应的目标项匹配，就像固定长度的序列一样。\n备注: 目标序列的长度可通过 len() (即通过 __len__() 协议) 获得。 解释器可能会以类\n似于 值模式 的方式缓存这个长度信息。\n简而言之， [P1, P2, P3, ... , P<N>] 仅在满足以下情况时匹配成功：\n检查 <subject> 是一个序列\nlen(subject) == <N>\n将 P1 与 <subject>[0] 进行匹配（请注意此匹配可以绑定名称）\n将 P2 与 <subject>[1] 进行匹配（请注意此匹配可以绑定名称）\n…… 剩余对应的模式/元素也以此类推。\n8.6.4.9. 映射模式\n映射模式包含一个或多个键值模式。其语法类似于字典的构造。语法： |  |\n|  | mapping_pattern: \"{\" [items_pattern] \"}\"\nitems_pattern: \",\".key_value_pattern+ \",\"?\nkey_value_pattern: (literal_pattern | value_pattern) \":\" pattern |  |\n\n| double_star_pattern\ndouble_star_pattern: \"**\" capture_pattern\n一个映射模式中最多可以有一个双星号模式。双星号模式必须是映射模式中的最后一个子模式。\n映射模式中不允许出现重复的键。重复的字面值键会引发 SyntaxError 。若是两个键有相同的值将\n会在运行时引发 ValueError 。\n以下是映射模式与目标值匹配的逻辑流程：\n1. 如果目标值不是一个映射 [3]，则映射模式匹配失败。\n2. 若映射模式中给出的每个键都存在于目标映射中，且每个键的模式都与目标映射的相应项匹配\n成功，则该映射模式匹配成功。\n3. 如果在映射模式中检测到重复的键，该模式将被视作无效。对于重复的字面值，会引发\nSyntaxError ；对于相同值的命名键，会引发 ValueError 。\n备注: 键值对使用映射目标的 get() 方法的双参数形式进行匹配。 匹配的键值对必须已经存在\n于映射中，而不是通过 __missing__() 或 __getitem__() 即时创建。\n简而言之， {KEY1: P1, KEY2: P2, ... } 仅在满足以下情况时匹配成功：\n检查 <subject> 是映射\nKEY1 in <subject>\nP1 与 <subject>[KEY1] 相匹配\n…… 剩余对应的键/模式对也以此类推。\n8.6.4.10. 类模式\n类模式表示一个类以及它的位置参数和关键字参数（如果有的话）。语法：\nclass_pattern: name_or_attr \"(\" [pattern_arguments \",\"?] \")\"\npattern_arguments: positional_patterns [\",\" keyword_patterns]\n| keyword_patterns\npositional_patterns: \",\".pattern+\nkeyword_patterns: \",\".keyword_pattern+\nkeyword_pattern: NAME \"=\" pattern\n同一个关键词不应该在类模式中重复出现。\n以下是类模式与目标值匹配的逻辑流程：\n1. 如果 name_or_attr 不是内置 type 的实例，引发 TypeError 。\n2. 如果目标值不是 name_or_attr 的实例（通过 isinstance() 测试），该类模式匹配失败。\n3. 如果没有模式参数存在，则该模式匹配成功。 否则，后面的步骤取决于是否有关键字或位置\n参数模式存在。\n对于一些内置的类型（将在后文详述），接受一个位置子模式，它将与整个目标值相匹配；对\n于这些类型，关键字模式也像其他类型一样工作。\n\n|  | | double_star_pattern\ndouble_star_pattern: \"**\" capture_pattern |  |\n| --- | --- | --- |\n|  | 一个映射模式中最多可以有一个双星号模式。双星号模式必须是映射模式中的最后一个子模式。\n映射模式中不允许出现重复的键。重复的字面值键会引发 SyntaxError 。若是两个键有相同的值将\n会在运行时引发 ValueError 。\n以下是映射模式与目标值匹配的逻辑流程：\n1. 如果目标值不是一个映射 [3]，则映射模式匹配失败。\n2. 若映射模式中给出的每个键都存在于目标映射中，且每个键的模式都与目标映射的相应项匹配\n成功，则该映射模式匹配成功。\n3. 如果在映射模式中检测到重复的键，该模式将被视作无效。对于重复的字面值，会引发\nSyntaxError ；对于相同值的命名键，会引发 ValueError 。 |  |\n|  | 备注: 键值对使用映射目标的 get() 方法的双参数形式进行匹配。 匹配的键值对必须已经存在\n于映射中，而不是通过 __missing__() 或 __getitem__() 即时创建。 |  |\n|  | 简而言之， {KEY1: P1, KEY2: P2, ... } 仅在满足以下情况时匹配成功：\n检查 <subject> 是映射\nKEY1 in <subject>\nP1 与 <subject>[KEY1] 相匹配\n…… 剩余对应的键/模式对也以此类推。\n8.6.4.10. 类模式\n类模式表示一个类以及它的位置参数和关键字参数（如果有的话）。语法： |  |\n|  | class_pattern: name_or_attr \"(\" [pattern_arguments \",\"?] \")\"\npattern_arguments: positional_patterns [\",\" keyword_patterns]\n| keyword_patterns\npositional_patterns: \",\".pattern+\nkeyword_patterns: \",\".keyword_pattern+\nkeyword_pattern: NAME \"=\" pattern |  |\n|  | 同一个关键词不应该在类模式中重复出现。\n以下是类模式与目标值匹配的逻辑流程：\n1. 如果 name_or_attr 不是内置 type 的实例，引发 TypeError 。\n2. 如果目标值不是 name_or_attr 的实例（通过 isinstance() 测试），该类模式匹配失败。\n3. 如果没有模式参数存在，则该模式匹配成功。 否则，后面的步骤取决于是否有关键字或位置\n参数模式存在。\n对于一些内置的类型（将在后文详述），接受一个位置子模式，它将与整个目标值相匹配；对\n于这些类型，关键字模式也像其他类型一样工作。 |  |\n\n如果只存在关键词模式，它们将被逐一处理，如下所示：\n一. 该关键词被视作主体的一个属性进行查找。\n如果这引发了除 AttributeError 以外的异常，该异常会被抛出。\n如果这引发了 AttributeError ，该类模式匹配失败。\n否则，与关键词模式相关的子模式将与目标的属性值进行匹配。 如果失败，则类模式匹\n配失败；如果成功，则继续对下一个关键词进行匹配。\n二. 如果所有的关键词模式匹配成功，该类模式匹配成功。\n如果存在位置模式，在匹配前会用类 name_or_attr 的 __match_args__ 属性将其转换为关\n键词模式。\n一. 进行与 getattr(cls, \"__match_args__\", ()) 等价的调用。\n如果这引发一个异常，该异常将被抛出。\n如果返回值不是一个元组，则转换失败且引发 TypeError 。\n若位置模式的数量超出 len(cls.__match_args__) ，将引发 TypeError 。\n否则，位置模式 i 会使用 __match_args__[i] 转换为关键词。 __match_args__[i] 必\n须是一个字符串；如果不是则引发 TypeError 。\n如果有重复的关键词，引发 TypeError 。\n参见: 定制类模式匹配中的位置参数\n二. 若所有的位置模式都被转换为关键词模式，\n匹配的过程就像只有关键词模式一样。\n对于以下内置类型，位置子模式的处理是不同的：\nbool\nbytearray\nbytes\ndict\nfloat\nfrozenset\nint\nlist\nset\nstr\ntuple\n这些类接受一个位置参数，其模式是针对整个对象而不是某个属性进行匹配。 例如，\nint(0|1) 匹配值 0，但不匹配值 0.0。\n简而言之， CLS(P1, attr=P2) 仅在满足以下情况时匹配成功：\n\n|  | 如果只存在关键词模式，它们将被逐一处理，如下所示：\n一. 该关键词被视作主体的一个属性进行查找。\n如果这引发了除 AttributeError 以外的异常，该异常会被抛出。\n如果这引发了 AttributeError ，该类模式匹配失败。\n否则，与关键词模式相关的子模式将与目标的属性值进行匹配。 如果失败，则类模式匹\n配失败；如果成功，则继续对下一个关键词进行匹配。\n二. 如果所有的关键词模式匹配成功，该类模式匹配成功。\n如果存在位置模式，在匹配前会用类 name_or_attr 的 __match_args__ 属性将其转换为关\n键词模式。\n一. 进行与 getattr(cls, \"__match_args__\", ()) 等价的调用。\n如果这引发一个异常，该异常将被抛出。\n如果返回值不是一个元组，则转换失败且引发 TypeError 。\n若位置模式的数量超出 len(cls.__match_args__) ，将引发 TypeError 。\n否则，位置模式 i 会使用 __match_args__[i] 转换为关键词。 __match_args__[i] 必\n须是一个字符串；如果不是则引发 TypeError 。\n如果有重复的关键词，引发 TypeError 。\n参见: 定制类模式匹配中的位置参数\n二. 若所有的位置模式都被转换为关键词模式，\n匹配的过程就像只有关键词模式一样。\n对于以下内置类型，位置子模式的处理是不同的：\nbool\nbytearray\nbytes\ndict\nfloat\nfrozenset\nint\nlist\nset\nstr\ntuple\n这些类接受一个位置参数，其模式是针对整个对象而不是某个属性进行匹配。 例如，\nint(0|1) 匹配值 0，但不匹配值 0.0。\n简而言之， CLS(P1, attr=P2) 仅在满足以下情况时匹配成功： |  |\n| --- | --- | --- |\n\nisinstance(<subject>, CLS)\n用 CLS.__match_args__ 将 P1 转换为关键词模式\n对于每个关键词参数 attr=P2 ：\nhasattr(<subject>, \"attr\")\n将 P2 与 <subject>.attr 进行匹配\n…… 剩余对应的关键字参数/模式对也以此类推。\n参见:\nPEP 634 —— 结构化模式匹配：规范\nPEP 636 —— 结构化模式匹配：教程\n8.7. 函数定义\n函数定义就是对用户自定义函数的定义（参见 标准类型层级结构 一节）:\nfuncdef: [decorators] \"def\" funcname [type_params] \"(\" [paramete\n[\"->\" expression] \":\" suite\ndecorators: decorator+\ndecorator: \"@\" assignment_expression NEWLINE\nparameter_list: defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [paramete\n| parameter_list_no_posonly\nparameter_list_no_posonly: defparameter (\",\" defparameter)* [\",\" [parameter_list_st\n| parameter_list_starargs\nparameter_list_starargs: \"*\" [star_parameter] (\",\" defparameter)* [\",\" [parameter\n| \"*\" (\",\" defparameter)+ [\",\" [parameter_star_kwargs]]\n| parameter_star_kwargs\nparameter_star_kwargs: \"**\" parameter [\",\"]\nparameter: identifier [\":\" expression]\nstar_parameter: identifier [\":\" [\"*\"] expression]\ndefparameter: parameter [\"=\" expression]\nfuncname: identifier\n函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个函数对象\n（函数可执行代码的包装器）。 这个函数对象包含对当前全局命名空间的引用，作为函数被调用时\n所使用的全局命名空间。\n函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。 [4]\n一个函数定义可以被一个或多个 decorator 表达式所包装。 当函数被定义时将在包含该函数定义的\n作用域中对装饰器表达式求值。 求值结果必须是一个可调用对象，它会以该函数对象作为唯一参数\n被唤起。 其返回值将被绑定到函数名称而非函数对象。 多个装饰器会以嵌套方式被应用。 例如以下\n代码\n@f1(arg)\n@f2\ndef func(): pass\n大致等价于\n\n|  | isinstance(<subject>, CLS)\n用 CLS.__match_args__ 将 P1 转换为关键词模式\n对于每个关键词参数 attr=P2 ：\nhasattr(<subject>, \"attr\")\n将 P2 与 <subject>.attr 进行匹配\n…… 剩余对应的关键字参数/模式对也以此类推。 |  |  |\n| --- | --- | --- | --- |\n|  | 参见:\nPEP 634 —— 结构化模式匹配：规范\nPEP 636 —— 结构化模式匹配：教程 |  |  |\n|  | 8.7. 函数定义\n函数定义就是对用户自定义函数的定义（参见 标准类型层级结构 一节）: |  |  |\n|  | funcdef: [decorators] \"def\" funcname [type_params] \"(\" [paramete\n[\"->\" expression] \":\" suite\ndecorators: decorator+\ndecorator: \"@\" assignment_expression NEWLINE\nparameter_list: defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [paramete\n| parameter_list_no_posonly\nparameter_list_no_posonly: defparameter (\",\" defparameter)* [\",\" [parameter_list_st\n| parameter_list_starargs\nparameter_list_starargs: \"*\" [star_parameter] (\",\" defparameter)* [\",\" [paramete\n| \"*\" (\",\" defparameter)+ [\",\" [parameter_star_kwargs]]\n| parameter_star_kwargs\nparameter_star_kwargs: \"**\" parameter [\",\"]\nparameter: identifier [\":\" expression]\nstar_parameter: identifier [\":\" [\"*\"] expression]\ndefparameter: parameter [\"=\" expression]\nfuncname: identifier |  |  |\n|  |  |  |  |\n|  |  |  |  |\n|  |  | r |  |\n|  |  |  |  |\n|  | 函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个函数对象\n（函数可执行代码的包装器）。 这个函数对象包含对当前全局命名空间的引用，作为函数被调用时\n所使用的全局命名空间。\n函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。 [4]\n一个函数定义可以被一个或多个 decorator 表达式所包装。 当函数被定义时将在包含该函数定义的\n作用域中对装饰器表达式求值。 求值结果必须是一个可调用对象，它会以该函数对象作为唯一参数\n被唤起。 其返回值将被绑定到函数名称而非函数对象。 多个装饰器会以嵌套方式被应用。 例如以下\n代码 |  |  |\n|  | @f1(arg)\n@f2\ndef func(): pass |  |  |\n|  | 大致等价于 |  |  |\n\ndef func(): pass\nfunc = f1(arg)(f2(func))\n不同之处在于原始函数并不会被临时绑定到名称 func。\n在 3.9 版本发生变更: 函数可使用任何有效的 assignment_expression 来装饰。 在之前版本\n中，此语法则更为受限，详情参见 PEP 614。\n可以在函数名及其形参列表开头圆括号之间加方括号给出一个 类型形参 的列表。 这将向静态类型检\n查器指明该函数是泛型尾数。 在运行时，类型形参可以从函数的 __type_params__ 属性中提取。\n请参阅 泛型函数 了解详情。\n在 3.12 版本发生变更: 类型形参列表是在 Python 3.12 中新增的。\n当一个或多个 形参 具有 形参 = 表达式 这样的形式时，该函数就被称为具有“默认形参值”。 对于一\n个具有默认值的形参，其对应的 argument 可以在调用中被省略，在此情况下会用形参的默认值来替\n代。 如果一个形参具有默认值，后续所有在 \"*\" 之前的形参也必须具有默认值 --- 这个句法限制并\n未在语法中明确表达。\n默认形参值会在执行函数定义时按从左至右的顺序被求值。 这意味着当函数被定义时将对表达式求\n值一次，相同的“预计算”值将在每次调用时被使用。 这一点在默认形参为可变对象，例如列表或字\n典的时候尤其需要重点理解：如果函数修改了该对象（例如向列表添加了一项），则实际上默认值\n也会被修改。 这通常不是人们所想要的。 绕过此问题的一个方法是使用 None 作为默认值，并在函\n数体中显式地对其进测试，例如:\ndef whats_on_the_telly(penguin=None):\nif penguin is None:\npenguin = []\npenguin.append(\"property of the zoo\")\nreturn penguin\n函数调用的语义在 调用 一节中有更详细的描述。 函数调用总是会给形参列表中列出的所有形参赋\n值，或是用位置参数，或是用关键字参数，或是用默认值。 如果存在 \"*identifier\" 这样的形式，\n它会被初始化为一个元组来接收任何额外的位置参数，默认为一个空元组。 如果存在\n\"**identifier\" 这样的形式，它会被初始化为一个新的有序映射来接收任何额外的关键字参数，默\n认为一个相同类型的空映射。 在 \"*\" 或 \"*identifier\" 之后的形参都是仅限关键字形参因而只能通\n过关键字参数传入。 在 \"/\" 之前的形参都是仅限位置形参因而只能通过位置参数传入。\n在 3.8 版本发生变更: 可以使用 / 函数形参语法来标示仅限位置形参。 请参阅 PEP 570 了解详\n情。\n形参可以带有 注解，其形式为在形参名后加 \": expression\"。 任何形参都可以带注解，甚至\n*identifier 或 **identifier 这样的形参也可以。 （作为特例，*identifier 这样的形参可以有\n\": *expression\" 形式的注解。） 函数可以带有“返回”注解，其形式为在形参列表后加 \"->\nexpression\"。 这些注解可以是任何有效的 Python 表达式。 注解的存在不会改变函数的语义。 有\n关注解的更多信息，请参阅 标注。\n\n|  | def func(): pass\nfunc = f1(arg)(f2(func)) |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | 不同之处在于原始函数并不会被临时绑定到名称 func。\n在 3.9 版本发生变更: 函数可使用任何有效的 assignment_expression 来装饰。 在之前版本\n中，此语法则更为受限，详情参见 PEP 614。\n可以在函数名及其形参列表开头圆括号之间加方括号给出一个 类型形参 的列表。 这将向静态类型检\n查器指明该函数是泛型尾数。 在运行时，类型形参可以从函数的 __type_params__ 属性中提取。\n请参阅 泛型函数 了解详情。\n在 3.12 版本发生变更: 类型形参列表是在 Python 3.12 中新增的。\n当一个或多个 形参 具有 形参 = 表达式 这样的形式时，该函数就被称为具有“默认形参值”。 对于一\n个具有默认值的形参，其对应的 argument 可以在调用中被省略，在此情况下会用形参的默认值来替\n代。 如果一个形参具有默认值，后续所有在 \"*\" 之前的形参也必须具有默认值 --- 这个句法限制并\n未在语法中明确表达。\n默认形参值会在执行函数定义时按从左至右的顺序被求值。 这意味着当函数被定义时将对表达式求\n值一次，相同的“预计算”值将在每次调用时被使用。 这一点在默认形参为可变对象，例如列表或字\n典的时候尤其需要重点理解：如果函数修改了该对象（例如向列表添加了一项），则实际上默认值\n也会被修改。 这通常不是人们所想要的。 绕过此问题的一个方法是使用 None 作为默认值，并在函\n数体中显式地对其进测试，例如: |  |  |  |\n|  | def whats_on_the_telly(penguin=None):\nif penguin is None:\npenguin = []\npenguin.append(\"property of the zoo\")\nreturn penguin |  |  |  |\n|  | 函数调用的语义在 调用 一节中有更详细的描述。 函数调用总是会给形参列表中列出的所有形参赋\n值，或是用位置参数，或是用关键字参数，或是用默认值。 如果存在 \"*identifier\" 这样的形式，\n它会被初始化为一个元组来接收任何额外的位置参数，默认为一个空元组。 如果存在\n\"**identifier\" 这样的形式，它会被初始化为一个新的有序映射来接收任何额外的关键字参数，默\n认为一个相同类型的空映射。 在 \"*\" 或 \"*identifier\" 之后的形参都是仅限关键字形参因而只能通\n过关键字参数传入。 在 \"/\" 之前的形参都是仅限位置形参因而只能通过位置参数传入。\n在 3.8 版本发生变更: 可以使用 / 函数形参语法来标示仅限位置形参。 请参阅 PEP 570 了解详\n情。\n形参可以带有 注解，其形式为在形参名后加 \": expression\"。 任何形参都可以带注解，甚至\n*identifier 或 **identifier 这样的形参也可以。 （作为特例，*identifier 这样的形参可以有\n\": *expression\" 形式的注解。） 函数可以带有“返回”注解，其形式为在形参列表后加 \"->\nexpression\"。 这些注解可以是任何有效的 Python 表达式。 注解的存在不会改变函数的语义。 有\n关注解的更多信息，请参阅 标注。 |  |  |  |\n|  |  | -> |  |  |\n|  |  |  |  |  |\n|  | expression |  |  |  |\n|  |  |  |  |  |\n\n在 3.11 版本发生变更: 形式为 \"*identifier\" 的形参可以带有 \": *expression\" 标注。 参见\nPEP 646。\n创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需要使用\nlambda 表达式，具体描述见 lambda 表达式 一节。 请注意 lambda 只是简单函数定义的一种简化写\n法；在 \"def\" 语句中定义的函数也可以像用 lambda 表达式定义的函数一样被传递或赋值给其他名\n称。 \"def\" 形式实际上更为强大，因为它允许执行多条语句和使用标注。\n程序员注意事项: 函数属于一类对象。 在一个函数内部执行的 \"def\" 语句会定义一个局部函数并可\n被返回或传递。 在嵌套函数中使用的自由变量可以访问包含该 def 语句的函数的局部变量。 详情参\n见 命名与绑定 一节。\n参见:\nPEP 3107 - 函数标注\n最初的函数标注规范说明。\nPEP 484 —— 类型注解\n标注的标准含意定义：类型提示。\nPEP 526 - 变量标注的语法\n变量声明的类型提示功能，包括类变量和实例变量。\nPEP 563 - 延迟的标注求值\n支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。\nPEP 318 - 函数和方法的装饰器\n引入了函数和方法的装饰器。 类装饰器是在 PEP 3129 中引入的。\n8.8. 类定义\n类定义就是对类对象的定义 (参见 标准类型层级结构 一节):\nclassdef: [decorators] \"class\" classname [type_params] [inheritance] \":\" suite\ninheritance: \"(\" [argument_list] \")\"\nclassname: identifier\n类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 元类)，列表中的每\n一项都应当被求值为一个允许子类的类对象。 没有继承列表的类默认继承自基类 object；因此，:\nclass Foo:\npass\n等价于\nclass Foo(object):\npass\n\n|  | 在 3.11 版本发生变更: 形式为 \"*identifier\" 的形参可以带有 \": *expression\" 标注。 参见\nPEP 646。\n创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需要使用\nlambda 表达式，具体描述见 lambda 表达式 一节。 请注意 lambda 只是简单函数定义的一种简化写\n法；在 \"def\" 语句中定义的函数也可以像用 lambda 表达式定义的函数一样被传递或赋值给其他名\n称。 \"def\" 形式实际上更为强大，因为它允许执行多条语句和使用标注。\n程序员注意事项: 函数属于一类对象。 在一个函数内部执行的 \"def\" 语句会定义一个局部函数并可\n被返回或传递。 在嵌套函数中使用的自由变量可以访问包含该 def 语句的函数的局部变量。 详情参\n见 命名与绑定 一节。 |  |\n| --- | --- | --- |\n|  | 参见:\nPEP 3107 - 函数标注\n最初的函数标注规范说明。\nPEP 484 —— 类型注解\n标注的标准含意定义：类型提示。\nPEP 526 - 变量标注的语法\n变量声明的类型提示功能，包括类变量和实例变量。\nPEP 563 - 延迟的标注求值\n支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。\nPEP 318 - 函数和方法的装饰器\n引入了函数和方法的装饰器。 类装饰器是在 PEP 3129 中引入的。 |  |\n|  | 8.8. 类定义\n类定义就是对类对象的定义 (参见 标准类型层级结构 一节): |  |\n|  | classdef: [decorators] \"class\" classname [type_params] [inheritance] \":\" suite\ninheritance: \"(\" [argument_list] \")\"\nclassname: identifier |  |\n|  | 类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 元类)，列表中的每\n一项都应当被求值为一个允许子类的类对象。 没有继承列表的类默认继承自基类 object；因此，: |  |\n|  | class Foo:\npass |  |\n|  | 等价于 |  |\n|  | class Foo(object):\npass |  |\n|  |  |  |\n\n随后类体将在一个新的执行帧 (参见 命名与绑定) 中被执行，使用新创建的局部命名空间和原有的全\n局命名空间。 （通常，类体主要包含函数定义。） 当类体结束执行时，其执行帧将被丢弃而其局部\n命名空间会被保存。 [5] 一个类对象随后会被创建，其基类使用给定的继承列表，属性字典使用保存\n的局部命名空间。 类名称将在原有的全局命名空间中绑定到该类对象。\n在类体内定义的属性的顺序保存在新类的 __dict__ 中。 请注意此顺序的可靠性只限于类刚被创建\n时，并且只适用于定义语法所定义的类。\n类的创建可使用 元类 进行重度定制。\n类也可以被装饰：就像装饰函数一样，:\n@f1(arg)\n@f2\nclass Foo: pass\n大致等价于\nclass Foo: pass\nFoo = f1(arg)(f2(Foo))\n装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。\n在 3.9 版本发生变更: 类可使用任何有效的 assignment_expression 来装饰。 在之前版本\n中，此语法则更为受限，详情参见 PEP 614。\n可以在类名之后的方括号中列出 类型形参。 这将向静态类型检查器指明该类是泛型类。 在运行时，\n可以从类的 __type_params__ 属性中获取类型形参。 请参阅 泛型类 了解详情。\n在 3.12 版本发生变更: 类型形参列表是在 Python 3.12 中新增的。\n程序员注意事项: 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例属性可通过\nself.name = value 在方法中设定。 类和实例属性均可通过 \"self.name\" 表示法来访问，当通过\n此方式访问时实例属性会隐藏同名的类属性。 类属性可被用作实例属性的默认值，但在此场景下使\n用可变值可能导致未预期的结果。 可以使用 描述器 来创建具有不同实现细节的实例变量。\n参见:\nPEP 3115 - Python 3000 中的元类\n将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。\nPEP 3129 - 类装饰器\n增加类装饰器的提议。 函数和方法装饰器是在 PEP 318 中被引入的。\n8.9. 协程\nAdded in version 3.5.\n8.9.1. 协程函数定义\n\n|  | 随后类体将在一个新的执行帧 (参见 命名与绑定) 中被执行，使用新创建的局部命名空间和原有的全\n局命名空间。 （通常，类体主要包含函数定义。） 当类体结束执行时，其执行帧将被丢弃而其局部\n命名空间会被保存。 [5] 一个类对象随后会被创建，其基类使用给定的继承列表，属性字典使用保存\n的局部命名空间。 类名称将在原有的全局命名空间中绑定到该类对象。\n在类体内定义的属性的顺序保存在新类的 __dict__ 中。 请注意此顺序的可靠性只限于类刚被创建\n时，并且只适用于定义语法所定义的类。\n类的创建可使用 元类 进行重度定制。\n类也可以被装饰：就像装饰函数一样，: |  |\n| --- | --- | --- |\n|  | @f1(arg)\n@f2\nclass Foo: pass |  |\n|  | 大致等价于 |  |\n|  | class Foo: pass\nFoo = f1(arg)(f2(Foo)) |  |\n|  | 装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。\n在 3.9 版本发生变更: 类可使用任何有效的 assignment_expression 来装饰。 在之前版本\n中，此语法则更为受限，详情参见 PEP 614。\n可以在类名之后的方括号中列出 类型形参。 这将向静态类型检查器指明该类是泛型类。 在运行时，\n可以从类的 __type_params__ 属性中获取类型形参。 请参阅 泛型类 了解详情。\n在 3.12 版本发生变更: 类型形参列表是在 Python 3.12 中新增的。\n程序员注意事项: 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例属性可通过\nself.name = value 在方法中设定。 类和实例属性均可通过 \"self.name\" 表示法来访问，当通过\n此方式访问时实例属性会隐藏同名的类属性。 类属性可被用作实例属性的默认值，但在此场景下使\n用可变值可能导致未预期的结果。 可以使用 描述器 来创建具有不同实现细节的实例变量。 |  |\n|  | 参见:\nPEP 3115 - Python 3000 中的元类\n将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。\nPEP 3129 - 类装饰器\n增加类装饰器的提议。 函数和方法装饰器是在 PEP 318 中被引入的。 |  |\n|  | 8.9. 协程\nAdded in version 3.5.\n8.9.1. 协程函数定义 |  |\n\nasync_funcdef: [decorators] \"async\" \"def\" funcname \"(\" [parameter_list] \")\"\n[\"->\" expression] \":\" suite\nPython 协程的执行可以在多个位置上被挂起和恢复 (参见 coroutine)。 await 表达式，async for\n以及 async with 只能在协程函数体中使用。\n使用 async def 语法定义的函数总是为协程函数，即使它们不包含 await 或 async 关键字。\n在协程函数体中使用 yield from 表达式将引发 SyntaxError。\n协程函数的例子:\nasync def func(param1, param2):\ndo_stuff()\nawait some_coroutine()\n在 3.7 版本发生变更: await 和 async 现在是保留关键字；在之前版本中它们仅在协程函数内\n被当作保留关键字。\n8.9.2. async for 语句\nasync_for_stmt: \"async\" for_stmt\nasynchronous iterable 提供了 __aiter__ 方法，该方法会直接返回 asynchronous iterator，它可以\n在其 __anext__ 方法中调用异步代码。\nasync for 语句允许方便地对异步可迭代对象进行迭代。\n以下代码:\nasync for TARGET in ITER:\nSUITE\nelse:\nSUITE2\n在语义上等价于:\niter = (ITER)\niter = type(iter).__aiter__(iter)\nrunning = True\nwhile running:\ntry:\nTARGET = await type(iter).__anext__(iter)\nexcept StopAsyncIteration:\nrunning = False\nelse:\nSUITE\nelse:\nSUITE2\n另请参阅 __aiter__() 和 __anext__() 了解详情。\n\n|  | async_funcdef: [decorators] \"async\" \"def\" funcname \"(\" [parameter_list] \")\"\n[\"->\" expression] \":\" suite |  |\n| --- | --- | --- |\n|  | Python 协程的执行可以在多个位置上被挂起和恢复 (参见 coroutine)。 await 表达式，async for\n以及 async with 只能在协程函数体中使用。\n使用 async def 语法定义的函数总是为协程函数，即使它们不包含 await 或 async 关键字。\n在协程函数体中使用 yield from 表达式将引发 SyntaxError。\n协程函数的例子: |  |\n|  | async def func(param1, param2):\ndo_stuff()\nawait some_coroutine() |  |\n|  | 在 3.7 版本发生变更: await 和 async 现在是保留关键字；在之前版本中它们仅在协程函数内\n被当作保留关键字。\n8.9.2. async for 语句 |  |\n|  | async_for_stmt: \"async\" for_stmt |  |\n|  | asynchronous iterable 提供了 __aiter__ 方法，该方法会直接返回 asynchronous iterator，它可以\n在其 __anext__ 方法中调用异步代码。\nasync for 语句允许方便地对异步可迭代对象进行迭代。\n以下代码: |  |\n|  | async for TARGET in ITER:\nSUITE\nelse:\nSUITE2 |  |\n|  | 在语义上等价于: |  |\n|  | iter = (ITER)\niter = type(iter).__aiter__(iter)\nrunning = True\nwhile running:\ntry:\nTARGET = await type(iter).__anext__(iter)\nexcept StopAsyncIteration:\nrunning = False\nelse:\nSUITE\nelse:\nSUITE2 |  |\n|  | 另请参阅 __aiter__() 和 __anext__() 了解详情。 |  |\n\n在协程函数体之外使用 async for 语句将引发 SyntaxError。\n8.9.3. async with 语句\nasync_with_stmt: \"async\" with_stmt\nasynchronous context manager 是一种 context manager，能够在其 enter 和 exit 方法中暂停执行。\n以下代码:\nasync with EXPRESSION as TARGET:\nSUITE\n在语义上等价于:\nmanager = (EXPRESSION)\naenter = type(manager).__aenter__\naexit = type(manager).__aexit__\nvalue = await aenter(manager)\nhit_except = False\ntry:\nTARGET = value\nSUITE\nexcept:\nhit_except = True\nif not await aexit(manager, *sys.exc_info()):\nraise\nfinally:\nif not hit_except:\nawait aexit(manager, None, None, None)\n另请参阅 __aenter__() 和 __aexit__() 了解详情。\n在协程函数体之外使用 async with 语句将引发 SyntaxError。\n参见:\nPEP 492 - 使用 async 和 await 语法实现协程\n将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。\n8.10. 类型形参列表\nAdded in version 3.12.\n在 3.13 版本发生变更: 增加了对默认值的支持 (参见 PEP 696)。\ntype_params: \"[\" type_param (\",\" type_param)* \"]\"\ntype_param: typevar | typevartuple | paramspec\ntypevar: identifier (\":\" expression)? (\"=\" expression)?\ntypevartuple: \"*\" identifier (\"=\" expression)?\nparamspec: \"**\" identifier (\"=\" expression)?\n\n|  | 在协程函数体之外使用 async for 语句将引发 SyntaxError。\n8.9.3. async with 语句 |  |\n| --- | --- | --- |\n|  | async_with_stmt: \"async\" with_stmt |  |\n|  | asynchronous context manager 是一种 context manager，能够在其 enter 和 exit 方法中暂停执行。\n以下代码: |  |\n|  | async with EXPRESSION as TARGET:\nSUITE |  |\n|  | 在语义上等价于: |  |\n|  | manager = (EXPRESSION)\naenter = type(manager).__aenter__\naexit = type(manager).__aexit__\nvalue = await aenter(manager)\nhit_except = False\ntry:\nTARGET = value\nSUITE\nexcept:\nhit_except = True\nif not await aexit(manager, *sys.exc_info()):\nraise\nfinally:\nif not hit_except:\nawait aexit(manager, None, None, None) |  |\n|  | 另请参阅 __aenter__() 和 __aexit__() 了解详情。\n在协程函数体之外使用 async with 语句将引发 SyntaxError。 |  |\n|  | 参见:\nPEP 492 - 使用 async 和 await 语法实现协程\n将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。 |  |\n|  | 8.10. 类型形参列表\nAdded in version 3.12.\n在 3.13 版本发生变更: 增加了对默认值的支持 (参见 PEP 696)。 |  |\n|  | type_params: \"[\" type_param (\",\" type_param)* \"]\"\ntype_param: typevar | typevartuple | paramspec\ntypevar: identifier (\":\" expression)? (\"=\" expression)?\ntypevartuple: \"*\" identifier (\"=\" expression)?\nparamspec: \"**\" identifier (\"=\" expression)? |  |\n|  |  |  |\n\n函数 (包括 协程), 类 和 类型别名 可能包含类型形参列表:\ndef max[T](args: list[T]) -> T:\n...\nasync def amax[T](args: list[T]) -> T:\n...\nclass Bag[T]:\ndef __iter__(self) -> Iterator[T]:\n...\ndef add(self, arg: T) -> None:\n...\ntype ListOrSet[T] = list[T] | set[T]\n从语义上讲，这表明函数、类或类型别名是类型变量的泛型。 此信息主要供静态类型检查器使用，\n并且在运行时，泛型对象的行为与其对应的非泛型对象非常相似。\n类型参数是紧接在函数、类或类型别名的名称之后的方括号 ([]) 中声明的。 类型参数可在泛型对象\n的作用域内访问，但不能在其他地方访问。 因此，在声明 def func[T](): pass 之后，模块作用\n域中就不能再使用 T 这个名称。 在下文中，将更精确地描述泛型对象的语义。 类型形参的作用域是\n用一个特殊函数 (从技术上说，是一个 标注作用域) 来模拟的，它封装了泛型对象的创建操作。\n泛型函数、类和类型别名都有一个 __type_params__ 属性用来列出它们的类型形参。\n类型形参可分为三种:\ntyping.TypeVar，由一个普通名称 (例如 T) 引入。 从语义上讲，这对类型检查器来说代表了一\n个单独类型。\ntyping.TypeVarTuple，通过在前面添加一个星号的名称来引入 (例如 *Ts)。 从语义上讲，它代\n表由任意多个类型组成的元组。\ntyping.ParamSpec，通过在前面添加两个星号的名称来引入 (例如 **P)。 从语义上讲，它代表\n一个可调用对象的形参。\ntyping.TypeVar 声明可以通过在冒号 (: ) 后跟一个表达式来定义 范围 和 约束。 冒号后的单独表\n达式表示一个范围 (例如 T: int)。 从语义上讲，这意味着 typing.TypeVar 能表示的类型只能是\n该范围的子类型。 冒号后在圆括号内的表达式元组指定了一组约束 (例如 T: (str, bytes))。 元组\n中的每个成员都应为一个类型 (同样，在运行时并不强制要求这一点)。 约束的类型变量只能使用约\n束列表内的类型中选择一种。\n对于使用类型形参列表语法声明的 typing.TypeVar，范围和约束在创建泛型对象时并不会被求值，\n只有在通过属性 __bound__ 和 __constraints__ 显式地访问它时才会被求值。 要做到这一点，需\n要在单独的 标注作用域 中对范围和约束进行求值。\ntyping.TypeVarTuple 和 typing.ParamSpec 不能拥有范围或约束。\n所有三种风格的类型形参都还可以具有 默认值，它会在未显式提供类型形参值时被使用。 这是通过\n添加单个等号 (=) 跟一个表达式来添加的。 与类型变量的绑定和约束类似，默认值不是在创建对象\n\n|  | 函数 (包括 协程), 类 和 类型别名 可能包含类型形参列表: |  |\n| --- | --- | --- |\n|  | def max[T](args: list[T]) -> T:\n...\nasync def amax[T](args: list[T]) -> T:\n...\nclass Bag[T]:\ndef __iter__(self) -> Iterator[T]:\n...\ndef add(self, arg: T) -> None:\n...\ntype ListOrSet[T] = list[T] | set[T] |  |\n|  | 从语义上讲，这表明函数、类或类型别名是类型变量的泛型。 此信息主要供静态类型检查器使用，\n并且在运行时，泛型对象的行为与其对应的非泛型对象非常相似。\n类型参数是紧接在函数、类或类型别名的名称之后的方括号 ([]) 中声明的。 类型参数可在泛型对象\n的作用域内访问，但不能在其他地方访问。 因此，在声明 def func[T](): pass 之后，模块作用\n域中就不能再使用 T 这个名称。 在下文中，将更精确地描述泛型对象的语义。 类型形参的作用域是\n用一个特殊函数 (从技术上说，是一个 标注作用域) 来模拟的，它封装了泛型对象的创建操作。\n泛型函数、类和类型别名都有一个 __type_params__ 属性用来列出它们的类型形参。\n类型形参可分为三种:\ntyping.TypeVar，由一个普通名称 (例如 T) 引入。 从语义上讲，这对类型检查器来说代表了一\n个单独类型。\ntyping.TypeVarTuple，通过在前面添加一个星号的名称来引入 (例如 *Ts)。 从语义上讲，它代\n表由任意多个类型组成的元组。\ntyping.ParamSpec，通过在前面添加两个星号的名称来引入 (例如 **P)。 从语义上讲，它代表\n一个可调用对象的形参。\ntyping.TypeVar 声明可以通过在冒号 (: ) 后跟一个表达式来定义 范围 和 约束。 冒号后的单独表\n达式表示一个范围 (例如 T: int)。 从语义上讲，这意味着 typing.TypeVar 能表示的类型只能是\n该范围的子类型。 冒号后在圆括号内的表达式元组指定了一组约束 (例如 T: (str, bytes))。 元组\n中的每个成员都应为一个类型 (同样，在运行时并不强制要求这一点)。 约束的类型变量只能使用约\n束列表内的类型中选择一种。\n对于使用类型形参列表语法声明的 typing.TypeVar，范围和约束在创建泛型对象时并不会被求值，\n只有在通过属性 __bound__ 和 __constraints__ 显式地访问它时才会被求值。 要做到这一点，需\n要在单独的 标注作用域 中对范围和约束进行求值。\ntyping.TypeVarTuple 和 typing.ParamSpec 不能拥有范围或约束。\n所有三种风格的类型形参都还可以具有 默认值，它会在未显式提供类型形参值时被使用。 这是通过\n添加单个等号 (=) 跟一个表达式来添加的。 与类型变量的绑定和约束类似，默认值不是在创建对象 |  |\n\n时被求值的，而是在类型形参的 __default__ 属性被访问的时候。 为此，默认值将在单独的 标注\n作用域 中被求值。 如果没有为类型形参指定默认值，__default__ 属性将被设为特殊的哨兵对象\ntyping.NoDefault。\n下面的例子显示了所有被允许的类型形参声明:\ndef overly_generic[\nSimpleTypeVar,\nTypeVarWithDefault = int,\nTypeVarWithBound: int,\nTypeVarWithConstraints: (str, bytes),\n*SimpleTypeVarTuple = (int, float),\n**SimpleParamSpec = (str, bytearray),\n](\na: SimpleTypeVar,\nb: TypeVarWithDefault,\nc: TypeVarWithBound,\nd: Callable[SimpleParamSpec, TypeVarWithConstraints],\n*e: SimpleTypeVarTuple,\n): ...\n8.10.1. 泛型函数\n泛型函数的声明方式如下:\ndef func[T](arg: T): ...\n该语法等价于:\nannotation-def TYPE_PARAMS_OF_func():\nT = typing.TypeVar(\"T\")\ndef func(arg: T): ...\nfunc.__type_params__ = (T,)\nreturn func\nfunc = TYPE_PARAMS_OF_func()\n这里 annotation-def 指定了一个 标注作用域，它在运行时并不会实际绑定到任何名称。 （另一项\n自由是在翻译中达成的：该语法没有通过 typing 模块的属性访问，而是直接创建了一个\ntyping.TypeVar 的实例）。\n泛型函数的标注会在用于声明类型形参的标注作用域内进行求值，但函数的默认值和装饰器则不\n会。\n下面的例子演示了针对这些场景，以及类型形参的变化形式的作用域规则:\n@decorator\ndef func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n...\n除了 TypeVar 绑定的 惰性求值 以外，这等同于:\n\n|  | 时被求值的，而是在类型形参的 __default__ 属性被访问的时候。 为此，默认值将在单独的 标注\n作用域 中被求值。 如果没有为类型形参指定默认值，__default__ 属性将被设为特殊的哨兵对象\ntyping.NoDefault。\n下面的例子显示了所有被允许的类型形参声明: |  |\n| --- | --- | --- |\n|  | def overly_generic[\nSimpleTypeVar,\nTypeVarWithDefault = int,\nTypeVarWithBound: int,\nTypeVarWithConstraints: (str, bytes),\n*SimpleTypeVarTuple = (int, float),\n**SimpleParamSpec = (str, bytearray),\n](\na: SimpleTypeVar,\nb: TypeVarWithDefault,\nc: TypeVarWithBound,\nd: Callable[SimpleParamSpec, TypeVarWithConstraints],\n*e: SimpleTypeVarTuple,\n): ... |  |\n|  | 8.10.1. 泛型函数\n泛型函数的声明方式如下: |  |\n|  | def func[T](arg: T): ... |  |\n|  | 该语法等价于: |  |\n|  | annotation-def TYPE_PARAMS_OF_func():\nT = typing.TypeVar(\"T\")\ndef func(arg: T): ...\nfunc.__type_params__ = (T,)\nreturn func\nfunc = TYPE_PARAMS_OF_func() |  |\n|  | 这里 annotation-def 指定了一个 标注作用域，它在运行时并不会实际绑定到任何名称。 （另一项\n自由是在翻译中达成的：该语法没有通过 typing 模块的属性访问，而是直接创建了一个\ntyping.TypeVar 的实例）。\n泛型函数的标注会在用于声明类型形参的标注作用域内进行求值，但函数的默认值和装饰器则不\n会。\n下面的例子演示了针对这些场景，以及类型形参的变化形式的作用域规则: |  |\n|  | @decorator\ndef func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n... |  |\n|  | 除了 TypeVar 绑定的 惰性求值 以外，这等同于: |  |\n\nDEFAULT_OF_arg = some_default\nannotation-def TYPE_PARAMS_OF_func():\nannotation-def BOUND_OF_T():\nreturn int\n# 在现实中，BOUND_OF_T() 仅会在需要时被求值。\nT = typing.TypeVar(\"T\", bound=BOUND_OF_T())\nTs = typing.TypeVarTuple(\"Ts\")\nP = typing.ParamSpec(\"P\")\ndef func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n...\nfunc.__type_params__ = (T, Ts, P)\nreturn func\nfunc = decorator(TYPE_PARAMS_OF_func())\n大写形式的名称如 DEFAULT_OF_arg 在运行时不会被实际绑定。\n8.10.2. 泛型类\n泛型类的声明方式如下:\nclass Bag[T]: ...\n该语法等价于:\nannotation-def TYPE_PARAMS_OF_Bag():\nT = typing.TypeVar(\"T\")\nclass Bag(typing.Generic[T]):\n__type_params__ = (T,)\n...\nreturn Bag\nBag = TYPE_PARAMS_OF_Bag()\n这里还是用 annotation-def (不是真正的关键字) 指明 标注作用域，而名称 TYPE_PARAMS_OF_Bag\n在不会运行时实际被绑定。\n泛型类隐式地继承自 typing.Generic。 泛型类的基类和关键字参数在类型形参的类型作用域内进\n行求值，而装饰器则在该作用域之外进行求值。 以下示例对此进行了说明:\n@decorator\nclass Bag(Base[T], arg=T): ...\n这相当于：\nannotation-def TYPE_PARAMS_OF_Bag():\nT = typing.TypeVar(\"T\")\nclass Bag(Base[T], typing.Generic[T], arg=T):\n__type_params__ = (T,)\n...\n\n|  | DEFAULT_OF_arg = some_default\nannotation-def TYPE_PARAMS_OF_func():\nannotation-def BOUND_OF_T():\nreturn int\n# 在现实中，BOUND_OF_T() 仅会在需要时被求值。\nT = typing.TypeVar(\"T\", bound=BOUND_OF_T())\nTs = typing.TypeVarTuple(\"Ts\")\nP = typing.ParamSpec(\"P\")\ndef func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n...\nfunc.__type_params__ = (T, Ts, P)\nreturn func\nfunc = decorator(TYPE_PARAMS_OF_func()) |  |\n| --- | --- | --- |\n|  | 大写形式的名称如 DEFAULT_OF_arg 在运行时不会被实际绑定。\n8.10.2. 泛型类\n泛型类的声明方式如下: |  |\n|  | class Bag[T]: ... |  |\n|  | 该语法等价于: |  |\n|  | annotation-def TYPE_PARAMS_OF_Bag():\nT = typing.TypeVar(\"T\")\nclass Bag(typing.Generic[T]):\n__type_params__ = (T,)\n...\nreturn Bag\nBag = TYPE_PARAMS_OF_Bag() |  |\n|  | 这里还是用 annotation-def (不是真正的关键字) 指明 标注作用域，而名称 TYPE_PARAMS_OF_Bag\n在不会运行时实际被绑定。\n泛型类隐式地继承自 typing.Generic。 泛型类的基类和关键字参数在类型形参的类型作用域内进\n行求值，而装饰器则在该作用域之外进行求值。 以下示例对此进行了说明: |  |\n|  | @decorator\nclass Bag(Base[T], arg=T): ... |  |\n|  | 这相当于： |  |\n|  | annotation-def TYPE_PARAMS_OF_Bag():\nT = typing.TypeVar(\"T\")\nclass Bag(Base[T], typing.Generic[T], arg=T):\n__type_params__ = (T,)\n... |  |\n\nreturn Bag\nBag = decorator(TYPE_PARAMS_OF_Bag())\n8.10.3. 泛型类型别名\ntype 语句也可被用来创建泛型类型别名:\ntype ListOrSet[T] = list[T] | set[T]\n除了会对值执行 惰性求值 以外，这等同于:\nannotation-def TYPE_PARAMS_OF_ListOrSet():\nT = typing.TypeVar(\"T\")\nannotation-def VALUE_OF_ListOrSet():\nreturn list[T] | set[T]\n# 在现实中，该值将被惰性地求值\nreturn typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), type_params=(T,\nListOrSet = TYPE_PARAMS_OF_ListOrSet()\n这里，annotation-def (不是一个真正的关键字) 指明 标注作用域。 像\nTYPE_PARAMS_OF_ListOrSet 这样的大写名称不会在运行时实际被绑定。\n8.11. 标注\n在 3.14 版本发生变更: 标注现在默认将被惰性求值。\n变量和函数形参可能带有 标注，创建方式是在名称后加一个冒号，后面再跟一个表达式:\nx: annotation = 1\ndef f(param: annotation): ...\n函数也可能带有加在一个箭头后的返回值标注:\ndef f() -> annotation: ...\n注解通常用于 类型提示，但语言不强制这样做，并且通常注解可能包含任意表达式。 注解的存在不\n会改变代码的运行时语义，除非使用了一些自省和使用注解的机制 (例如 dataclasses 或\nfunctools.singledispatch())。\n默认情况下，注解在 注解范围 中惰性求值。 这意味着当包含注解的代码被求值时，它们不会被求\n值。 相反，解释器会保存信息，以便在以后需要时用于注解求值。 annotationlib 模块提供了注\n解求值的工具。\n如果存在 future 语句 from __future__ import annotations，则所有注解将被存储为字符串:\n>>> from __future__ import annotations\n>>> def f(param: annotation): ...\n>>> f.__annotations__\n{'param': 'annotation'}\n\n|  | return Bag\nBag = decorator(TYPE_PARAMS_OF_Bag()) |  |  |\n| --- | --- | --- | --- |\n|  | 8.10.3. 泛型类型别名\ntype 语句也可被用来创建泛型类型别名: |  |  |\n|  | type ListOrSet[T] = list[T] | set[T] |  |  |\n|  | 除了会对值执行 惰性求值 以外，这等同于: |  |  |\n|  | annotation-def TYPE_PARAMS_OF_ListOrSet():\nT = typing.TypeVar(\"T\")\nannotation-def VALUE_OF_ListOrSet():\nreturn list[T] | set[T]\n# 在现实中，该值将被惰性地求值\nreturn typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), type_params=(T,\nListOrSet = TYPE_PARAMS_OF_ListOrSet() |  |  |\n|  | 这里，annotation-def (不是一个真正的关键字) 指明 标注作用域。 像\nTYPE_PARAMS_OF_ListOrSet 这样的大写名称不会在运行时实际被绑定。\n8.11. 标注\n在 3.14 版本发生变更: 标注现在默认将被惰性求值。\n变量和函数形参可能带有 标注，创建方式是在名称后加一个冒号，后面再跟一个表达式: |  |  |\n|  | x: annotation = 1\ndef f(param: annotation): ... |  |  |\n|  | 函数也可能带有加在一个箭头后的返回值标注: |  |  |\n|  | def f() -> annotation: ... |  |  |\n|  | 注解通常用于 类型提示，但语言不强制这样做，并且通常注解可能包含任意表达式。 注解的存在不\n会改变代码的运行时语义，除非使用了一些自省和使用注解的机制 (例如 dataclasses 或\nfunctools.singledispatch())。\n默认情况下，注解在 注解范围 中惰性求值。 这意味着当包含注解的代码被求值时，它们不会被求\n值。 相反，解释器会保存信息，以便在以后需要时用于注解求值。 annotationlib 模块提供了注\n解求值的工具。\n如果存在 future 语句 from __future__ import annotations，则所有注解将被存储为字符串: |  |  |\n|  | >>> from __future__ import annotations\n>>> def f(param: annotation): ...\n>>> f.__annotations__\n{'param': 'annotation'} |  |  |\n|  |  |  |  |\n\n这个 future语 句将在 Python 的未来版本中被弃用并删除，但不会在 Python 3.13 达到其生命周期结\n束之前 (参见 PEP 749)。 当它被使用时，内省工具，如 annotationlib.get_annotations() 和\ntyping.get_type_hints() 不太可能在运行时解析注解。\n备注\n[1] 异常会被传播给唤起栈，除非存在一个 finally 子句正好引发了另一个异常。 新引发的异常将\n导致旧异常的丢失。\n[2] 在模式匹配中，序列被定义为以下几种之一:\n继承自 collections.abc.Sequence 的类\n注册为 collections.abc.Sequence 的 Python 类\n设置了 (CPython) Py_TPFLAGS_SEQUENCE 比特位的内置类\n继承自上述任何一个类的类\n下列标准库中的类都是序列:\narray.array\ncollections.deque\nlist\nmemoryview\nrange\ntuple\n备注: 类型为 str, bytes 和 bytearray 的目标值不能匹配序列模式。\n[3] 在模式匹配中，映射被定义为以下几种之一:\n继承自 collections.abc.Mapping 的类\n注册为 collections.abc.Mapping 的 Python 类\n设置了 (CPython) Py_TPFLAGS_MAPPING 比特位的内置类\n继承自上述任何一个类的类\n标准库中的 dict 和 types.MappingProxyType 类都属于映射。\n[4] 作为函数体的第一条语句出现的字符串字面值会被转换为函数的 __doc__ 属性也就是该函数的\ndocstring。\n[5] 作为类体的第一条语句出现的字符串字面值会被转为命名空间的 __doc__ 条目，也就是该类的\ndocstring。\n\n| 这个 future语 句将在 Python 的未来版本中被弃用并删除，但不会在 Python 3.13 达到其生命周期结\n束之前 (参见 PEP 749)。 当它被使用时，内省工具，如 annotationlib.get_annotations() 和\ntyping.get_type_hints() 不太可能在运行时解析注解。\n备注\n[1] 异常会被传播给唤起栈，除非存在一个 finally 子句正好引发了另一个异常。 新引发的异常将\n导致旧异常的丢失。\n[2] 在模式匹配中，序列被定义为以下几种之一:\n继承自 collections.abc.Sequence 的类\n注册为 collections.abc.Sequence 的 Python 类\n设置了 (CPython) Py_TPFLAGS_SEQUENCE 比特位的内置类\n继承自上述任何一个类的类\n下列标准库中的类都是序列:\narray.array\ncollections.deque\nlist\nmemoryview\nrange\ntuple |\n| --- |\n| 备注: 类型为 str, bytes 和 bytearray 的目标值不能匹配序列模式。 |\n| [3] 在模式匹配中，映射被定义为以下几种之一:\n继承自 collections.abc.Mapping 的类\n注册为 collections.abc.Mapping 的 Python 类\n设置了 (CPython) Py_TPFLAGS_MAPPING 比特位的内置类\n继承自上述任何一个类的类\n标准库中的 dict 和 types.MappingProxyType 类都属于映射。\n[4] 作为函数体的第一条语句出现的字符串字面值会被转换为函数的 __doc__ 属性也就是该函数的\ndocstring。\n[5] 作为类体的第一条语句出现的字符串字面值会被转为命名空间的 __doc__ 条目，也就是该类的\ndocstring。 |", "metadata": {"title": "08_复合语句", "source": "md_docs\\python_reference_md\\08_复合语句.md", "doc_type": "语言参考", "language": "中文", "doc_id": "3dbeeab1"}}
{"doc_id": "caa5fca0", "content": "9. 顶级组件\nPython 解释器可以从多种源获得输入：作为标准输入或程序参数传入的脚本，以交互方式键入的语\n句，导入的模块源文件等等。 这一章将给出在这些情况下所用的语法。\n9.1. 完整的 Python 程序\n虽然语言规范描述不必规定如何唤起语言解释器，但对完整的 Python 程序加以说明还是很有用的。\n一个完整的 Python 程序会在最小初始化环境中被执行：所有内置和标准模块均为可用，但均处于未\n初始化状态，只有 sys (各种系统服务), builtins (内置函数、异常以及 None) 和 __main__ 除外。\n最后一个模块用于为完整程序的执行提供局部和全局命名空间。\n适用于一个完整 Python 程序的语法即下节所描述的文件输入。\n解释器也可以通过交互模式被唤起；在此情况下，它并不读取和执行一个完整程序，而是每次读取\n和执行一条语句（可能为复合语句）。 此时的初始环境与一个完整程序的相同；每条语句会在\n__main__ 的命名空间中被执行。\n一个完整程序可通过三种形式被传递给解释器：使用 -c 字符串 命令行选项，使用一个文件作为第\n一个命令行参数，或者使用标准输入。 如果文件或标准输入是一个 tty 设置，解释器会进入交互模\n式；否则的话，它会将文件当作一个完整程序来执行。\n9.2. 文件输入\n所有从非交互式文件读取的输入都具有相同的形式:\nfile_input: (NEWLINE | statement)* ENDMARKER\n此语法用于下列几种情况:\n解析一个完整 Python 程序时（从文件或字符串）；\n解析一个模块时；\n解析一个传递给 exec() 函数的字符串时；\n9.3. 交互式输入\n交互模式下的输入使用以下语法进行解析:\ninteractive_input: [stmt_list] NEWLINE | compound_stmt NEWLINE | ENDMARKER\n请注意在交互模式下一条（最高层级）复合语句必须带有一个空行；这对于帮助解析器确定输入的\n结束是必须的。\n\n| 9. 顶级组件\nPython 解释器可以从多种源获得输入：作为标准输入或程序参数传入的脚本，以交互方式键入的语\n句，导入的模块源文件等等。 这一章将给出在这些情况下所用的语法。\n9.1. 完整的 Python 程序\n虽然语言规范描述不必规定如何唤起语言解释器，但对完整的 Python 程序加以说明还是很有用的。\n一个完整的 Python 程序会在最小初始化环境中被执行：所有内置和标准模块均为可用，但均处于未\n初始化状态，只有 sys (各种系统服务), builtins (内置函数、异常以及 None) 和 __main__ 除外。\n最后一个模块用于为完整程序的执行提供局部和全局命名空间。\n适用于一个完整 Python 程序的语法即下节所描述的文件输入。\n解释器也可以通过交互模式被唤起；在此情况下，它并不读取和执行一个完整程序，而是每次读取\n和执行一条语句（可能为复合语句）。 此时的初始环境与一个完整程序的相同；每条语句会在\n__main__ 的命名空间中被执行。\n一个完整程序可通过三种形式被传递给解释器：使用 -c 字符串 命令行选项，使用一个文件作为第\n一个命令行参数，或者使用标准输入。 如果文件或标准输入是一个 tty 设置，解释器会进入交互模\n式；否则的话，它会将文件当作一个完整程序来执行。\n9.2. 文件输入\n所有从非交互式文件读取的输入都具有相同的形式: |\n| --- |\n| file_input: (NEWLINE | statement)* ENDMARKER |\n| 此语法用于下列几种情况:\n解析一个完整 Python 程序时（从文件或字符串）；\n解析一个模块时；\n解析一个传递给 exec() 函数的字符串时；\n9.3. 交互式输入\n交互模式下的输入使用以下语法进行解析: |\n| interactive_input: [stmt_list] NEWLINE | compound_stmt NEWLINE | ENDMARKER |\n| 请注意在交互模式下一条（最高层级）复合语句必须带有一个空行；这对于帮助解析器确定输入的\n结束是必须的。 |\n\n9.4. 表达式输入\neval() 被用于表达式输入。 它会忽略开头的空白。 传递给 eval() 的字符串参数必须具有以下形\n式:\neval_input: expression_list NEWLINE* ENDMARKER\n\n| 9.4. 表达式输入\neval() 被用于表达式输入。 它会忽略开头的空白。 传递给 eval() 的字符串参数必须具有以下形\n式: |\n| --- |\n| eval_input: expression_list NEWLINE* ENDMARKER |", "metadata": {"title": "09_顶级组件", "source": "md_docs\\python_reference_md\\09_顶级组件.md", "doc_type": "语言参考", "language": "中文", "doc_id": "caa5fca0"}}
{"doc_id": "bf60811d", "content": "10. 完整的语法规范\n这是完整的 Python 语法规范，直接提取自用于生成 CPython 解析器的语法 (参见\nGrammar/python.gram)。 这里显示的版本省略了有关代码生成和错误恢复的细节。\n此处使用的标记法与前述文档一致，其说明详见 notation 节，但存在一个额外复杂情况：\n~ (\"cut\"): 提交到当前替代项并且即使此项解析失败也不适用规则\n# PEG grammar for Python\n# ========================= START OF THE GRAMMAR =========================\n# General grammatical elements and rules:\n#\n# * Strings with double quotes (\") denote SOFT KEYWORDS\n# * Strings with single quotes (') denote KEYWORDS\n# * Upper case names (NAME) denote tokens in the Grammar/Tokens file\n# * Rule names starting with \"invalid_\" are used for specialized syntax errors\n# - These rules are NOT used in the first pass of the parser.\n# - Only if the first pass fails to parse, a second pass including the invalid\n# rules will be executed.\n# - If the parser fails in the second phase with a generic syntax error, the\n# location of the generic failure of the first pass will be used (this avoid\n# reporting incorrect locations due to the invalid rules).\n# - The order of the alternatives involving invalid rules matter\n# (like any rule in PEG).\n#\n# Grammar Syntax (see PEP 617 for more information):\n#\n# rule_name: expression\n# Optionally, a type can be included right after the rule name, which\n# specifies the return type of the C or Python function corresponding to the\n# rule:\n# rule_name[return_type]: expression\n# If the return type is omitted, then a void * is returned in C and an Any in\n# Python.\n# e1 e2\n# Match e1, then match e2.\n# e1 | e2\n# Match e1 or e2.\n# The first alternative can also appear on the line after the rule name for\n# formatting purposes. In that case, a | must be used before the first\n# alternative, like so:\n# rule_name[return_type]:\n# | first_alt\n# | second_alt\n# ( e )\n# Match e (allows also to use other operators in the group like '(e)*')\n# [ e ] or e?\n# Optionally match e.\n# e*\n\n| 10. 完整的语法规范\n这是完整的 Python 语法规范，直接提取自用于生成 CPython 解析器的语法 (参见\nGrammar/python.gram)。 这里显示的版本省略了有关代码生成和错误恢复的细节。\n此处使用的标记法与前述文档一致，其说明详见 notation 节，但存在一个额外复杂情况：\n~ (\"cut\"): 提交到当前替代项并且即使此项解析失败也不适用规则\n# PEG grammar for Python\n# ========================= START OF THE GRAMMAR =========================\n# General grammatical elements and rules:\n#\n# * Strings with double quotes (\") denote SOFT KEYWORDS\n# * Strings with single quotes (') denote KEYWORDS\n# * Upper case names (NAME) denote tokens in the Grammar/Tokens file\n# * Rule names starting with \"invalid_\" are used for specialized syntax errors\n# - These rules are NOT used in the first pass of the parser.\n# - Only if the first pass fails to parse, a second pass including the invalid\n# rules will be executed.\n# - If the parser fails in the second phase with a generic syntax error, the\n# location of the generic failure of the first pass will be used (this avoid\n# reporting incorrect locations due to the invalid rules).\n# - The order of the alternatives involving invalid rules matter\n# (like any rule in PEG).\n#\n# Grammar Syntax (see PEP 617 for more information):\n#\n# rule_name: expression\n# Optionally, a type can be included right after the rule name, which\n# specifies the return type of the C or Python function corresponding to the\n# rule:\n# rule_name[return_type]: expression\n# If the return type is omitted, then a void * is returned in C and an Any in\n# Python.\n# e1 e2\n# Match e1, then match e2.\n# e1 | e2\n# Match e1 or e2.\n# The first alternative can also appear on the line after the rule name for\n# formatting purposes. In that case, a | must be used before the first\n# alternative, like so:\n# rule_name[return_type]:\n# | first_alt\n# | second_alt\n# ( e )\n# Match e (allows also to use other operators in the group like '(e)*')\n# [ e ] or e?\n# Optionally match e.\n# e* |  |  |\n| --- | --- | --- |\n|  | 10. 完整的语法规范\n这是完整的 Python 语法规范，直接提取自用于生成 CPython 解析器的语法 (参见\nGrammar/python.gram)。 这里显示的版本省略了有关代码生成和错误恢复的细节。\n此处使用的标记法与前述文档一致，其说明详见 notation 节，但存在一个额外复杂情况：\n~ (\"cut\"): 提交到当前替代项并且即使此项解析失败也不适用规则 |  |\n|  | # PEG grammar for Python\n# ========================= START OF THE GRAMMAR =========================\n# General grammatical elements and rules:\n#\n# * Strings with double quotes (\") denote SOFT KEYWORDS\n# * Strings with single quotes (') denote KEYWORDS\n# * Upper case names (NAME) denote tokens in the Grammar/Tokens file\n# * Rule names starting with \"invalid_\" are used for specialized syntax errors\n# - These rules are NOT used in the first pass of the parser.\n# - Only if the first pass fails to parse, a second pass including the invalid\n# rules will be executed.\n# - If the parser fails in the second phase with a generic syntax error, the\n# location of the generic failure of the first pass will be used (this avoid\n# reporting incorrect locations due to the invalid rules).\n# - The order of the alternatives involving invalid rules matter\n# (like any rule in PEG).\n#\n# Grammar Syntax (see PEP 617 for more information):\n#\n# rule_name: expression\n# Optionally, a type can be included right after the rule name, which\n# specifies the return type of the C or Python function corresponding to the\n# rule:\n# rule_name[return_type]: expression\n# If the return type is omitted, then a void * is returned in C and an Any in\n# Python.\n# e1 e2\n# Match e1, then match e2.\n# e1 | e2\n# Match e1 or e2.\n# The first alternative can also appear on the line after the rule name for\n# formatting purposes. In that case, a | must be used before the first\n# alternative, like so:\n# rule_name[return_type]:\n# | first_alt\n# | second_alt\n# ( e )\n# Match e (allows also to use other operators in the group like '(e)*')\n# [ e ] or e?\n# Optionally match e.\n# e* |  |\n\n# Match zero or more occurrences of e.\n# e+\n# Match one or more occurrences of e.\n# s.e+\n# Match one or more occurrences of e, separated by s. The generated parse tree\n# does not include the separator. This is otherwise identical to (e (s e)*).\n# &e\n# Succeed if e can be parsed, without consuming any input.\n# !e\n# Fail if e can be parsed, without consuming any input.\n# ~\n# Commit to the current alternative, even if it fails to parse.\n# &&e\n# Eager parse e. The parser will not backtrack and will immediately\n# fail with SyntaxError if e cannot be parsed.\n#\n# STARTING RULES\n# ==============\nfile: [statements] ENDMARKER\ninteractive: statement_newline\neval: expressions NEWLINE* ENDMARKER\nfunc_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER\n# GENERAL STATEMENTS\n# ==================\nstatements: statement+\nstatement:\n| compound_stmt\n| simple_stmts\nsingle_compound_stmt:\n| compound_stmt\nstatement_newline:\n| single_compound_stmt NEWLINE\n| simple_stmts\n| NEWLINE\n| ENDMARKER\nsimple_stmts:\n| simple_stmt !';' NEWLINE # Not needed, there for speedup\n| ';'.simple_stmt+ [';'] NEWLINE\n# NOTE: assignment MUST precede expression, else parsing a simple assignment\n# will throw a SyntaxError.\nsimple_stmt:\n| assignment\n| type_alias\n| star_expressions\n| return_stmt\n| import_stmt\n| raise_stmt\n| pass_stmt\n| del_stmt\n| yield_stmt\n| assert_stmt\n\n|  | # Match zero or more occurrences of e.\n# e+\n# Match one or more occurrences of e.\n# s.e+\n# Match one or more occurrences of e, separated by s. The generated parse tree\n# does not include the separator. This is otherwise identical to (e (s e)*).\n# &e\n# Succeed if e can be parsed, without consuming any input.\n# !e\n# Fail if e can be parsed, without consuming any input.\n# ~\n# Commit to the current alternative, even if it fails to parse.\n# &&e\n# Eager parse e. The parser will not backtrack and will immediately\n# fail with SyntaxError if e cannot be parsed.\n#\n# STARTING RULES\n# ==============\nfile: [statements] ENDMARKER\ninteractive: statement_newline\neval: expressions NEWLINE* ENDMARKER\nfunc_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER\n# GENERAL STATEMENTS\n# ==================\nstatements: statement+\nstatement:\n| compound_stmt\n| simple_stmts\nsingle_compound_stmt:\n| compound_stmt\nstatement_newline:\n| single_compound_stmt NEWLINE\n| simple_stmts\n| NEWLINE\n| ENDMARKER\nsimple_stmts:\n| simple_stmt !';' NEWLINE # Not needed, there for speedup\n| ';'.simple_stmt+ [';'] NEWLINE\n# NOTE: assignment MUST precede expression, else parsing a simple assignment\n# will throw a SyntaxError.\nsimple_stmt:\n| assignment\n| type_alias\n| star_expressions\n| return_stmt\n| import_stmt\n| raise_stmt\n| pass_stmt\n| del_stmt\n| yield_stmt\n| assert_stmt |  |\n| --- | --- | --- |\n\n| break_stmt\n| continue_stmt\n| global_stmt\n| nonlocal_stmt\ncompound_stmt:\n| function_def\n| if_stmt\n| class_def\n| with_stmt\n| for_stmt\n| try_stmt\n| while_stmt\n| match_stmt\n# SIMPLE STATEMENTS\n# =================\n# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'\nassignment:\n| NAME ':' expression ['=' annotated_rhs ]\n| ('(' single_target ')'\n| single_subscript_attribute_target) ':' expression ['=' annotated_rhs ]\n| (star_targets '=' )+ annotated_rhs !'=' [TYPE_COMMENT]\n| single_target augassign ~ annotated_rhs\nannotated_rhs: yield_expr | star_expressions\naugassign:\n| '+='\n| '-='\n| '*='\n| '@='\n| '/='\n| '%='\n| '&='\n| '|='\n| '^='\n| '<<='\n| '>>='\n| '**='\n| '//='\nreturn_stmt:\n| 'return' [star_expressions]\nraise_stmt:\n| 'raise' expression ['from' expression ]\n| 'raise'\npass_stmt:\n| 'pass'\nbreak_stmt:\n| 'break'\ncontinue_stmt:\n| 'continue'\nglobal_stmt: 'global' ','.NAME+\n\n|  | | break_stmt\n| continue_stmt\n| global_stmt\n| nonlocal_stmt\ncompound_stmt:\n| function_def\n| if_stmt\n| class_def\n| with_stmt\n| for_stmt\n| try_stmt\n| while_stmt\n| match_stmt\n# SIMPLE STATEMENTS\n# =================\n# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'\nassignment:\n| NAME ':' expression ['=' annotated_rhs ]\n| ('(' single_target ')'\n| single_subscript_attribute_target) ':' expression ['=' annotated_rhs ]\n| (star_targets '=' )+ annotated_rhs !'=' [TYPE_COMMENT]\n| single_target augassign ~ annotated_rhs\nannotated_rhs: yield_expr | star_expressions\naugassign:\n| '+='\n| '-='\n| '*='\n| '@='\n| '/='\n| '%='\n| '&='\n| '|='\n| '^='\n| '<<='\n| '>>='\n| '**='\n| '//='\nreturn_stmt:\n| 'return' [star_expressions]\nraise_stmt:\n| 'raise' expression ['from' expression ]\n| 'raise'\npass_stmt:\n| 'pass'\nbreak_stmt:\n| 'break'\ncontinue_stmt:\n| 'continue'\nglobal_stmt: 'global' ','.NAME+ |  |\n| --- | --- | --- |\n\nnonlocal_stmt: 'nonlocal' ','.NAME+\ndel_stmt:\n| 'del' del_targets &(';' | NEWLINE)\nyield_stmt: yield_expr\nassert_stmt: 'assert' expression [',' expression ]\nimport_stmt:\n| import_name\n| import_from\n# Import statements\n# -----------------\nimport_name: 'import' dotted_as_names\n# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSI\nimport_from:\n| 'from' ('.' | '...')* dotted_name 'import' import_from_targets\n| 'from' ('.' | '...')+ 'import' import_from_targets\nimport_from_targets:\n| '(' import_from_as_names [','] ')'\n| import_from_as_names !','\n| '*'\nimport_from_as_names:\n| ','.import_from_as_name+\nimport_from_as_name:\n| NAME ['as' NAME ]\ndotted_as_names:\n| ','.dotted_as_name+\ndotted_as_name:\n| dotted_name ['as' NAME ]\ndotted_name:\n| dotted_name '.' NAME\n| NAME\n# COMPOUND STATEMENTS\n# ===================\n# Common elements\n# ---------------\nblock:\n| NEWLINE INDENT statements DEDENT\n| simple_stmts\ndecorators: ('@' named_expression NEWLINE )+\n# Class definitions\n# -----------------\nclass_def:\n| decorators class_def_raw\n| class_def_raw\nclass_def_raw:\n\n|  | nonlocal_stmt: 'nonlocal' ','.NAME+\ndel_stmt:\n| 'del' del_targets &(';' | NEWLINE)\nyield_stmt: yield_expr\nassert_stmt: 'assert' expression [',' expression ]\nimport_stmt:\n| import_name\n| import_from\n# Import statements\n# -----------------\nimport_name: 'import' dotted_as_names\n# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSI\nimport_from:\n| 'from' ('.' | '...')* dotted_name 'import' import_from_targets\n| 'from' ('.' | '...')+ 'import' import_from_targets\nimport_from_targets:\n| '(' import_from_as_names [','] ')'\n| import_from_as_names !','\n| '*'\nimport_from_as_names:\n| ','.import_from_as_name+\nimport_from_as_name:\n| NAME ['as' NAME ]\ndotted_as_names:\n| ','.dotted_as_name+\ndotted_as_name:\n| dotted_name ['as' NAME ]\ndotted_name:\n| dotted_name '.' NAME\n| NAME\n# COMPOUND STATEMENTS\n# ===================\n# Common elements\n# ---------------\nblock:\n| NEWLINE INDENT statements DEDENT\n| simple_stmts\ndecorators: ('@' named_expression NEWLINE )+\n# Class definitions\n# -----------------\nclass_def:\n| decorators class_def_raw\n| class_def_raw\nclass_def_raw: |  |\n| --- | --- | --- |\n\n| 'class' NAME [type_params] ['(' [arguments] ')' ] ':' block\n# Function definitions\n# --------------------\nfunction_def:\n| decorators function_def_raw\n| function_def_raw\nfunction_def_raw:\n| 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_\n| 'async' 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [fu\n# Function parameters\n# -------------------\nparams:\n| parameters\nparameters:\n| slash_no_default param_no_default* param_with_default* [star_etc]\n| slash_with_default param_with_default* [star_etc]\n| param_no_default+ param_with_default* [star_etc]\n| param_with_default+ [star_etc]\n| star_etc\n# Some duplication here because we can't write (',' | &')'),\n# which is because we don't support empty alternatives (yet).\nslash_no_default:\n| param_no_default+ '/' ','\n| param_no_default+ '/' &')'\nslash_with_default:\n| param_no_default* param_with_default+ '/' ','\n| param_no_default* param_with_default+ '/' &')'\nstar_etc:\n| '*' param_no_default param_maybe_default* [kwds]\n| '*' param_no_default_star_annotation param_maybe_default* [kwds]\n| '*' ',' param_maybe_default+ [kwds]\n| kwds\nkwds:\n| '**' param_no_default\n# One parameter. This *includes* a following comma and type comment.\n#\n# There are three styles:\n# - No default\n# - With default\n# - Maybe with default\n#\n# There are two alternative forms of each, to deal with type comments:\n# - Ends in a comma followed by an optional type comment\n# - No comma, optional type comment, must be followed by close paren\n# The latter form is for a final parameter without trailing comma.\n#\nparam_no_default:\n| param ',' TYPE_COMMENT?\n\n|  | | 'class' NAME [type_params] ['(' [arguments] ')' ] ':' block\n# Function definitions\n# --------------------\nfunction_def:\n| decorators function_def_raw\n| function_def_raw\nfunction_def_raw:\n| 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_\n| 'async' 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [fu\n# Function parameters\n# -------------------\nparams:\n| parameters\nparameters:\n| slash_no_default param_no_default* param_with_default* [star_etc]\n| slash_with_default param_with_default* [star_etc]\n| param_no_default+ param_with_default* [star_etc]\n| param_with_default+ [star_etc]\n| star_etc\n# Some duplication here because we can't write (',' | &')'),\n# which is because we don't support empty alternatives (yet).\nslash_no_default:\n| param_no_default+ '/' ','\n| param_no_default+ '/' &')'\nslash_with_default:\n| param_no_default* param_with_default+ '/' ','\n| param_no_default* param_with_default+ '/' &')'\nstar_etc:\n| '*' param_no_default param_maybe_default* [kwds]\n| '*' param_no_default_star_annotation param_maybe_default* [kwds]\n| '*' ',' param_maybe_default+ [kwds]\n| kwds\nkwds:\n| '**' param_no_default\n# One parameter. This *includes* a following comma and type comment.\n#\n# There are three styles:\n# - No default\n# - With default\n# - Maybe with default\n#\n# There are two alternative forms of each, to deal with type comments:\n# - Ends in a comma followed by an optional type comment\n# - No comma, optional type comment, must be followed by close paren\n# The latter form is for a final parameter without trailing comma.\n#\nparam_no_default:\n| param ',' TYPE_COMMENT? |  |\n| --- | --- | --- |\n\n| param TYPE_COMMENT? &')'\nparam_no_default_star_annotation:\n| param_star_annotation ',' TYPE_COMMENT?\n| param_star_annotation TYPE_COMMENT? &')'\nparam_with_default:\n| param default ',' TYPE_COMMENT?\n| param default TYPE_COMMENT? &')'\nparam_maybe_default:\n| param default? ',' TYPE_COMMENT?\n| param default? TYPE_COMMENT? &')'\nparam: NAME annotation?\nparam_star_annotation: NAME star_annotation\nannotation: ':' expression\nstar_annotation: ':' star_expression\ndefault: '=' expression | invalid_default\n# If statement\n# ------------\nif_stmt:\n| 'if' named_expression ':' block elif_stmt\n| 'if' named_expression ':' block [else_block]\nelif_stmt:\n| 'elif' named_expression ':' block elif_stmt\n| 'elif' named_expression ':' block [else_block]\nelse_block:\n| 'else' ':' block\n# While statement\n# ---------------\nwhile_stmt:\n| 'while' named_expression ':' block [else_block]\n# For statement\n# -------------\nfor_stmt:\n| 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_bl\n| 'async' 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block\n# With statement\n# --------------\nwith_stmt:\n| 'with' '(' ','.with_item+ ','? ')' ':' [TYPE_COMMENT] block\n| 'with' ','.with_item+ ':' [TYPE_COMMENT] block\n| 'async' 'with' '(' ','.with_item+ ','? ')' ':' block\n| 'async' 'with' ','.with_item+ ':' [TYPE_COMMENT] block\nwith_item:\n| expression 'as' star_target &(',' | ')' | ':')\n| expression\n# Try statement\n# -------------\ntry_stmt:\n| 'try' ':' block finally_block\n| 'try' ':' block except_block+ [else_block] [finally_block]\n\n|  | | param TYPE_COMMENT? &')'\nparam_no_default_star_annotation:\n| param_star_annotation ',' TYPE_COMMENT?\n| param_star_annotation TYPE_COMMENT? &')'\nparam_with_default:\n| param default ',' TYPE_COMMENT?\n| param default TYPE_COMMENT? &')'\nparam_maybe_default:\n| param default? ',' TYPE_COMMENT?\n| param default? TYPE_COMMENT? &')'\nparam: NAME annotation?\nparam_star_annotation: NAME star_annotation\nannotation: ':' expression\nstar_annotation: ':' star_expression\ndefault: '=' expression | invalid_default\n# If statement\n# ------------\nif_stmt:\n| 'if' named_expression ':' block elif_stmt\n| 'if' named_expression ':' block [else_block]\nelif_stmt:\n| 'elif' named_expression ':' block elif_stmt\n| 'elif' named_expression ':' block [else_block]\nelse_block:\n| 'else' ':' block\n# While statement\n# ---------------\nwhile_stmt:\n| 'while' named_expression ':' block [else_block]\n# For statement\n# -------------\nfor_stmt:\n| 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_bl\n| 'async' 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block\n# With statement\n# --------------\nwith_stmt:\n| 'with' '(' ','.with_item+ ','? ')' ':' [TYPE_COMMENT] block\n| 'with' ','.with_item+ ':' [TYPE_COMMENT] block\n| 'async' 'with' '(' ','.with_item+ ','? ')' ':' block\n| 'async' 'with' ','.with_item+ ':' [TYPE_COMMENT] block\nwith_item:\n| expression 'as' star_target &(',' | ')' | ':')\n| expression\n# Try statement\n# -------------\ntry_stmt:\n| 'try' ':' block finally_block\n| 'try' ':' block except_block+ [else_block] [finally_block] |  |\n| --- | --- | --- |\n\n| 'try' ':' block except_star_block+ [else_block] [finally_block]\n# Except statement\n# ----------------\nexcept_block:\n| 'except' expression ':' block\n| 'except' expression 'as' NAME ':' block\n| 'except' expressions ':' block\n| 'except' ':' block\nexcept_star_block:\n| 'except' '*' expression ':' block\n| 'except' '*' expression 'as' NAME ':' block\n| 'except' '*' expressions ':' block\nfinally_block:\n| 'finally' ':' block\n# Match statement\n# ---------------\nmatch_stmt:\n| \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\nsubject_expr:\n| star_named_expression ',' star_named_expressions?\n| named_expression\ncase_block:\n| \"case\" patterns guard? ':' block\nguard: 'if' named_expression\npatterns:\n| open_sequence_pattern\n| pattern\npattern:\n| as_pattern\n| or_pattern\nas_pattern:\n| or_pattern 'as' pattern_capture_target\nor_pattern:\n| '|'.closed_pattern+\nclosed_pattern:\n| literal_pattern\n| capture_pattern\n| wildcard_pattern\n| value_pattern\n| group_pattern\n| sequence_pattern\n| mapping_pattern\n| class_pattern\n# Literal patterns are used for equality and identity constraints\nliteral_pattern:\n| signed_number !('+' | '-')\n\n|  | | 'try' ':' block except_star_block+ [else_block] [finally_block]\n# Except statement\n# ----------------\nexcept_block:\n| 'except' expression ':' block\n| 'except' expression 'as' NAME ':' block\n| 'except' expressions ':' block\n| 'except' ':' block\nexcept_star_block:\n| 'except' '*' expression ':' block\n| 'except' '*' expression 'as' NAME ':' block\n| 'except' '*' expressions ':' block\nfinally_block:\n| 'finally' ':' block\n# Match statement\n# ---------------\nmatch_stmt:\n| \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\nsubject_expr:\n| star_named_expression ',' star_named_expressions?\n| named_expression\ncase_block:\n| \"case\" patterns guard? ':' block\nguard: 'if' named_expression\npatterns:\n| open_sequence_pattern\n| pattern\npattern:\n| as_pattern\n| or_pattern\nas_pattern:\n| or_pattern 'as' pattern_capture_target\nor_pattern:\n| '|'.closed_pattern+\nclosed_pattern:\n| literal_pattern\n| capture_pattern\n| wildcard_pattern\n| value_pattern\n| group_pattern\n| sequence_pattern\n| mapping_pattern\n| class_pattern\n# Literal patterns are used for equality and identity constraints\nliteral_pattern:\n| signed_number !('+' | '-') |  |\n| --- | --- | --- |\n\n| complex_number\n| strings\n| 'None'\n| 'True'\n| 'False'\n# Literal expressions are used to restrict permitted mapping pattern keys\nliteral_expr:\n| signed_number !('+' | '-')\n| complex_number\n| strings\n| 'None'\n| 'True'\n| 'False'\ncomplex_number:\n| signed_real_number '+' imaginary_number\n| signed_real_number '-' imaginary_number\nsigned_number:\n| NUMBER\n| '-' NUMBER\nsigned_real_number:\n| real_number\n| '-' real_number\nreal_number:\n| NUMBER\nimaginary_number:\n| NUMBER\ncapture_pattern:\n| pattern_capture_target\npattern_capture_target:\n| !\"_\" NAME !('.' | '(' | '=')\nwildcard_pattern:\n| \"_\"\nvalue_pattern:\n| attr !('.' | '(' | '=')\nattr:\n| name_or_attr '.' NAME\nname_or_attr:\n| attr\n| NAME\ngroup_pattern:\n| '(' pattern ')'\nsequence_pattern:\n| '[' maybe_sequence_pattern? ']'\n| '(' open_sequence_pattern? ')'\nopen_sequence_pattern:\n\n|  | | complex_number\n| strings\n| 'None'\n| 'True'\n| 'False'\n# Literal expressions are used to restrict permitted mapping pattern keys\nliteral_expr:\n| signed_number !('+' | '-')\n| complex_number\n| strings\n| 'None'\n| 'True'\n| 'False'\ncomplex_number:\n| signed_real_number '+' imaginary_number\n| signed_real_number '-' imaginary_number\nsigned_number:\n| NUMBER\n| '-' NUMBER\nsigned_real_number:\n| real_number\n| '-' real_number\nreal_number:\n| NUMBER\nimaginary_number:\n| NUMBER\ncapture_pattern:\n| pattern_capture_target\npattern_capture_target:\n| !\"_\" NAME !('.' | '(' | '=')\nwildcard_pattern:\n| \"_\"\nvalue_pattern:\n| attr !('.' | '(' | '=')\nattr:\n| name_or_attr '.' NAME\nname_or_attr:\n| attr\n| NAME\ngroup_pattern:\n| '(' pattern ')'\nsequence_pattern:\n| '[' maybe_sequence_pattern? ']'\n| '(' open_sequence_pattern? ')'\nopen_sequence_pattern: |  |\n| --- | --- | --- |\n\n| maybe_star_pattern ',' maybe_sequence_pattern?\nmaybe_sequence_pattern:\n| ','.maybe_star_pattern+ ','?\nmaybe_star_pattern:\n| star_pattern\n| pattern\nstar_pattern:\n| '*' pattern_capture_target\n| '*' wildcard_pattern\nmapping_pattern:\n| '{' '}'\n| '{' double_star_pattern ','? '}'\n| '{' items_pattern ',' double_star_pattern ','? '}'\n| '{' items_pattern ','? '}'\nitems_pattern:\n| ','.key_value_pattern+\nkey_value_pattern:\n| (literal_expr | attr) ':' pattern\ndouble_star_pattern:\n| '**' pattern_capture_target\nclass_pattern:\n| name_or_attr '(' ')'\n| name_or_attr '(' positional_patterns ','? ')'\n| name_or_attr '(' keyword_patterns ','? ')'\n| name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'\npositional_patterns:\n| ','.pattern+\nkeyword_patterns:\n| ','.keyword_pattern+\nkeyword_pattern:\n| NAME '=' pattern\n# Type statement\n# ---------------\ntype_alias:\n| \"type\" NAME [type_params] '=' expression\n# Type parameter declaration\n# --------------------------\ntype_params:\n| '[' type_param_seq ']'\ntype_param_seq: ','.type_param+ [',']\ntype_param:\n| NAME [type_param_bound] [type_param_default]\n| '*' NAME [type_param_starred_default]\n\n|  | | maybe_star_pattern ',' maybe_sequence_pattern?\nmaybe_sequence_pattern:\n| ','.maybe_star_pattern+ ','?\nmaybe_star_pattern:\n| star_pattern\n| pattern\nstar_pattern:\n| '*' pattern_capture_target\n| '*' wildcard_pattern\nmapping_pattern:\n| '{' '}'\n| '{' double_star_pattern ','? '}'\n| '{' items_pattern ',' double_star_pattern ','? '}'\n| '{' items_pattern ','? '}'\nitems_pattern:\n| ','.key_value_pattern+\nkey_value_pattern:\n| (literal_expr | attr) ':' pattern\ndouble_star_pattern:\n| '**' pattern_capture_target\nclass_pattern:\n| name_or_attr '(' ')'\n| name_or_attr '(' positional_patterns ','? ')'\n| name_or_attr '(' keyword_patterns ','? ')'\n| name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'\npositional_patterns:\n| ','.pattern+\nkeyword_patterns:\n| ','.keyword_pattern+\nkeyword_pattern:\n| NAME '=' pattern\n# Type statement\n# ---------------\ntype_alias:\n| \"type\" NAME [type_params] '=' expression\n# Type parameter declaration\n# --------------------------\ntype_params:\n| '[' type_param_seq ']'\ntype_param_seq: ','.type_param+ [',']\ntype_param:\n| NAME [type_param_bound] [type_param_default]\n| '*' NAME [type_param_starred_default] |  |\n| --- | --- | --- |\n\n| '**' NAME [type_param_default]\ntype_param_bound: ':' expression\ntype_param_default: '=' expression\ntype_param_starred_default: '=' star_expression\n# EXPRESSIONS\n# -----------\nexpressions:\n| expression (',' expression )+ [',']\n| expression ','\n| expression\nexpression:\n| disjunction 'if' disjunction 'else' expression\n| disjunction\n| lambdef\nyield_expr:\n| 'yield' 'from' expression\n| 'yield' [star_expressions]\nstar_expressions:\n| star_expression (',' star_expression )+ [',']\n| star_expression ','\n| star_expression\nstar_expression:\n| '*' bitwise_or\n| expression\nstar_named_expressions: ','.star_named_expression+ [',']\nstar_named_expression:\n| '*' bitwise_or\n| named_expression\nassignment_expression:\n| NAME ':=' ~ expression\nnamed_expression:\n| assignment_expression\n| expression !':='\ndisjunction:\n| conjunction ('or' conjunction )+\n| conjunction\nconjunction:\n| inversion ('and' inversion )+\n| inversion\ninversion:\n| 'not' inversion\n| comparison\n# Comparison operators\n# --------------------\n\n|  | | '**' NAME [type_param_default]\ntype_param_bound: ':' expression\ntype_param_default: '=' expression\ntype_param_starred_default: '=' star_expression\n# EXPRESSIONS\n# -----------\nexpressions:\n| expression (',' expression )+ [',']\n| expression ','\n| expression\nexpression:\n| disjunction 'if' disjunction 'else' expression\n| disjunction\n| lambdef\nyield_expr:\n| 'yield' 'from' expression\n| 'yield' [star_expressions]\nstar_expressions:\n| star_expression (',' star_expression )+ [',']\n| star_expression ','\n| star_expression\nstar_expression:\n| '*' bitwise_or\n| expression\nstar_named_expressions: ','.star_named_expression+ [',']\nstar_named_expression:\n| '*' bitwise_or\n| named_expression\nassignment_expression:\n| NAME ':=' ~ expression\nnamed_expression:\n| assignment_expression\n| expression !':='\ndisjunction:\n| conjunction ('or' conjunction )+\n| conjunction\nconjunction:\n| inversion ('and' inversion )+\n| inversion\ninversion:\n| 'not' inversion\n| comparison\n# Comparison operators\n# -------------------- |  |\n| --- | --- | --- |\n\ncomparison:\n| bitwise_or compare_op_bitwise_or_pair+\n| bitwise_or\ncompare_op_bitwise_or_pair:\n| eq_bitwise_or\n| noteq_bitwise_or\n| lte_bitwise_or\n| lt_bitwise_or\n| gte_bitwise_or\n| gt_bitwise_or\n| notin_bitwise_or\n| in_bitwise_or\n| isnot_bitwise_or\n| is_bitwise_or\neq_bitwise_or: '==' bitwise_or\nnoteq_bitwise_or:\n| ('!=' ) bitwise_or\nlte_bitwise_or: '<=' bitwise_or\nlt_bitwise_or: '<' bitwise_or\ngte_bitwise_or: '>=' bitwise_or\ngt_bitwise_or: '>' bitwise_or\nnotin_bitwise_or: 'not' 'in' bitwise_or\nin_bitwise_or: 'in' bitwise_or\nisnot_bitwise_or: 'is' 'not' bitwise_or\nis_bitwise_or: 'is' bitwise_or\n# Bitwise operators\n# -----------------\nbitwise_or:\n| bitwise_or '|' bitwise_xor\n| bitwise_xor\nbitwise_xor:\n| bitwise_xor '^' bitwise_and\n| bitwise_and\nbitwise_and:\n| bitwise_and '&' shift_expr\n| shift_expr\nshift_expr:\n| shift_expr '<<' sum\n| shift_expr '>>' sum\n| sum\n# Arithmetic operators\n# --------------------\nsum:\n| sum '+' term\n| sum '-' term\n| term\nterm:\n| term '*' factor\n| term '/' factor\n| term '//' factor\n\n|  | comparison:\n| bitwise_or compare_op_bitwise_or_pair+\n| bitwise_or\ncompare_op_bitwise_or_pair:\n| eq_bitwise_or\n| noteq_bitwise_or\n| lte_bitwise_or\n| lt_bitwise_or\n| gte_bitwise_or\n| gt_bitwise_or\n| notin_bitwise_or\n| in_bitwise_or\n| isnot_bitwise_or\n| is_bitwise_or\neq_bitwise_or: '==' bitwise_or\nnoteq_bitwise_or:\n| ('!=' ) bitwise_or\nlte_bitwise_or: '<=' bitwise_or\nlt_bitwise_or: '<' bitwise_or\ngte_bitwise_or: '>=' bitwise_or\ngt_bitwise_or: '>' bitwise_or\nnotin_bitwise_or: 'not' 'in' bitwise_or\nin_bitwise_or: 'in' bitwise_or\nisnot_bitwise_or: 'is' 'not' bitwise_or\nis_bitwise_or: 'is' bitwise_or\n# Bitwise operators\n# -----------------\nbitwise_or:\n| bitwise_or '|' bitwise_xor\n| bitwise_xor\nbitwise_xor:\n| bitwise_xor '^' bitwise_and\n| bitwise_and\nbitwise_and:\n| bitwise_and '&' shift_expr\n| shift_expr\nshift_expr:\n| shift_expr '<<' sum\n| shift_expr '>>' sum\n| sum\n# Arithmetic operators\n# --------------------\nsum:\n| sum '+' term\n| sum '-' term\n| term\nterm:\n| term '*' factor\n| term '/' factor\n| term '//' factor |  |\n| --- | --- | --- |\n\n| term '%' factor\n| term '@' factor\n| factor\nfactor:\n| '+' factor\n| '-' factor\n| '~' factor\n| power\npower:\n| await_primary '**' factor\n| await_primary\n# Primary elements\n# ----------------\n# Primary elements are things like \"obj.something.something\", \"obj[something]\", \"o\nawait_primary:\n| 'await' primary\n| primary\nprimary:\n| primary '.' NAME\n| primary genexp\n| primary '(' [arguments] ')'\n| primary '[' slices ']'\n| atom\nslices:\n| slice !','\n| ','.(slice | starred_expression)+ [',']\nslice:\n| [expression] ':' [expression] [':' [expression] ]\n| named_expression\natom:\n| NAME\n| 'True'\n| 'False'\n| 'None'\n| strings\n| NUMBER\n| (tuple | group | genexp)\n| (list | listcomp)\n| (dict | set | dictcomp | setcomp)\n| '...'\ngroup:\n| '(' (yield_expr | named_expression) ')'\n# Lambda functions\n# ----------------\nlambdef:\n| 'lambda' [lambda_params] ':' expression\nlambda_params:\n\n|  | | term '%' factor\n| term '@' factor\n| factor\nfactor:\n| '+' factor\n| '-' factor\n| '~' factor\n| power\npower:\n| await_primary '**' factor\n| await_primary\n# Primary elements\n# ----------------\n# Primary elements are things like \"obj.something.something\", \"obj[something]\", \"o\nawait_primary:\n| 'await' primary\n| primary\nprimary:\n| primary '.' NAME\n| primary genexp\n| primary '(' [arguments] ')'\n| primary '[' slices ']'\n| atom\nslices:\n| slice !','\n| ','.(slice | starred_expression)+ [',']\nslice:\n| [expression] ':' [expression] [':' [expression] ]\n| named_expression\natom:\n| NAME\n| 'True'\n| 'False'\n| 'None'\n| strings\n| NUMBER\n| (tuple | group | genexp)\n| (list | listcomp)\n| (dict | set | dictcomp | setcomp)\n| '...'\ngroup:\n| '(' (yield_expr | named_expression) ')'\n# Lambda functions\n# ----------------\nlambdef:\n| 'lambda' [lambda_params] ':' expression\nlambda_params: |  |\n| --- | --- | --- |\n\n| lambda_parameters\n# lambda_parameters etc. duplicates parameters but without annotations\n# or type comments, and if there's no comma after a parameter, we expect\n# a colon, not a close parenthesis. (For more, see parameters above.)\n#\nlambda_parameters:\n| lambda_slash_no_default lambda_param_no_default* lambda_param_with_default*\n| lambda_slash_with_default lambda_param_with_default* [lambda_star_etc]\n| lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc]\n| lambda_param_with_default+ [lambda_star_etc]\n| lambda_star_etc\nlambda_slash_no_default:\n| lambda_param_no_default+ '/' ','\n| lambda_param_no_default+ '/' &':'\nlambda_slash_with_default:\n| lambda_param_no_default* lambda_param_with_default+ '/' ','\n| lambda_param_no_default* lambda_param_with_default+ '/' &':'\nlambda_star_etc:\n| '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds]\n| '*' ',' lambda_param_maybe_default+ [lambda_kwds]\n| lambda_kwds\nlambda_kwds:\n| '**' lambda_param_no_default\nlambda_param_no_default:\n| lambda_param ','\n| lambda_param &':'\nlambda_param_with_default:\n| lambda_param default ','\n| lambda_param default &':'\nlambda_param_maybe_default:\n| lambda_param default? ','\n| lambda_param default? &':'\nlambda_param: NAME\n# LITERALS\n# ========\nfstring_middle:\n| fstring_replacement_field\n| FSTRING_MIDDLE\nfstring_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [fstring_full_format_spec] '}'\nfstring_conversion:\n| \"!\" NAME\nfstring_full_format_spec:\n| ':' fstring_format_spec*\nfstring_format_spec:\n| FSTRING_MIDDLE\n| fstring_replacement_field\nfstring:\n| FSTRING_START fstring_middle* FSTRING_END\ntstring_format_spec_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [tstring_full_format_spec] '}'\n\n|  | | lambda_parameters\n# lambda_parameters etc. duplicates parameters but without annotations\n# or type comments, and if there's no comma after a parameter, we expect\n# a colon, not a close parenthesis. (For more, see parameters above.)\n#\nlambda_parameters:\n| lambda_slash_no_default lambda_param_no_default* lambda_param_with_default*\n| lambda_slash_with_default lambda_param_with_default* [lambda_star_etc]\n| lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc]\n| lambda_param_with_default+ [lambda_star_etc]\n| lambda_star_etc\nlambda_slash_no_default:\n| lambda_param_no_default+ '/' ','\n| lambda_param_no_default+ '/' &':'\nlambda_slash_with_default:\n| lambda_param_no_default* lambda_param_with_default+ '/' ','\n| lambda_param_no_default* lambda_param_with_default+ '/' &':'\nlambda_star_etc:\n| '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds]\n| '*' ',' lambda_param_maybe_default+ [lambda_kwds]\n| lambda_kwds\nlambda_kwds:\n| '**' lambda_param_no_default\nlambda_param_no_default:\n| lambda_param ','\n| lambda_param &':'\nlambda_param_with_default:\n| lambda_param default ','\n| lambda_param default &':'\nlambda_param_maybe_default:\n| lambda_param default? ','\n| lambda_param default? &':'\nlambda_param: NAME\n# LITERALS\n# ========\nfstring_middle:\n| fstring_replacement_field\n| FSTRING_MIDDLE\nfstring_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [fstring_full_format_spec] '}'\nfstring_conversion:\n| \"!\" NAME\nfstring_full_format_spec:\n| ':' fstring_format_spec*\nfstring_format_spec:\n| FSTRING_MIDDLE\n| fstring_replacement_field\nfstring:\n| FSTRING_START fstring_middle* FSTRING_END\ntstring_format_spec_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [tstring_full_format_spec] '}' |  |\n| --- | --- | --- |\n\ntstring_format_spec:\n| TSTRING_MIDDLE\n| tstring_format_spec_replacement_field\ntstring_full_format_spec:\n| ':' tstring_format_spec*\ntstring_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [tstring_full_format_spec] '}'\ntstring_middle:\n| tstring_replacement_field\n| TSTRING_MIDDLE\ntstring:\n| TSTRING_START tstring_middle* TSTRING_END\nstring: STRING\nstrings:\n| (fstring|string)+\n| tstring+\nlist:\n| '[' [star_named_expressions] ']'\ntuple:\n| '(' [star_named_expression ',' [star_named_expressions] ] ')'\nset: '{' star_named_expressions '}'\n# Dicts\n# -----\ndict:\n| '{' [double_starred_kvpairs] '}'\ndouble_starred_kvpairs: ','.double_starred_kvpair+ [',']\ndouble_starred_kvpair:\n| '**' bitwise_or\n| kvpair\nkvpair: expression ':' expression\n# Comprehensions & Generators\n# ---------------------------\nfor_if_clauses:\n| for_if_clause+\nfor_if_clause:\n| 'async' 'for' star_targets 'in' ~ disjunction ('if' disjunction )*\n| 'for' star_targets 'in' ~ disjunction ('if' disjunction )*\nlistcomp:\n| '[' named_expression for_if_clauses ']'\nsetcomp:\n| '{' named_expression for_if_clauses '}'\ngenexp:\n| '(' ( assignment_expression | expression !':=') for_if_clauses ')'\ndictcomp:\n\n|  | tstring_format_spec:\n| TSTRING_MIDDLE\n| tstring_format_spec_replacement_field\ntstring_full_format_spec:\n| ':' tstring_format_spec*\ntstring_replacement_field:\n| '{' annotated_rhs '='? [fstring_conversion] [tstring_full_format_spec] '}'\ntstring_middle:\n| tstring_replacement_field\n| TSTRING_MIDDLE\ntstring:\n| TSTRING_START tstring_middle* TSTRING_END\nstring: STRING\nstrings:\n| (fstring|string)+\n| tstring+\nlist:\n| '[' [star_named_expressions] ']'\ntuple:\n| '(' [star_named_expression ',' [star_named_expressions] ] ')'\nset: '{' star_named_expressions '}'\n# Dicts\n# -----\ndict:\n| '{' [double_starred_kvpairs] '}'\ndouble_starred_kvpairs: ','.double_starred_kvpair+ [',']\ndouble_starred_kvpair:\n| '**' bitwise_or\n| kvpair\nkvpair: expression ':' expression\n# Comprehensions & Generators\n# ---------------------------\nfor_if_clauses:\n| for_if_clause+\nfor_if_clause:\n| 'async' 'for' star_targets 'in' ~ disjunction ('if' disjunction )*\n| 'for' star_targets 'in' ~ disjunction ('if' disjunction )*\nlistcomp:\n| '[' named_expression for_if_clauses ']'\nsetcomp:\n| '{' named_expression for_if_clauses '}'\ngenexp:\n| '(' ( assignment_expression | expression !':=') for_if_clauses ')'\ndictcomp: |  |\n| --- | --- | --- |\n\n| '{' kvpair for_if_clauses '}'\n# FUNCTION CALL ARGUMENTS\n# =======================\narguments:\n| args [','] &')'\nargs:\n| ','.(starred_expression | ( assignment_expression | expression !':=') !'=')+\n| kwargs\nkwargs:\n| ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n| ','.kwarg_or_starred+\n| ','.kwarg_or_double_starred+\nstarred_expression:\n| '*' expression\nkwarg_or_starred:\n| NAME '=' expression\n| starred_expression\nkwarg_or_double_starred:\n| NAME '=' expression\n| '**' expression\n# ASSIGNMENT TARGETS\n# ==================\n# Generic targets\n# ---------------\n# NOTE: star_targets may contain *bitwise_or, targets may not.\nstar_targets:\n| star_target !','\n| star_target (',' star_target )* [',']\nstar_targets_list_seq: ','.star_target+ [',']\nstar_targets_tuple_seq:\n| star_target (',' star_target )+ [',']\n| star_target ','\nstar_target:\n| '*' (!'*' star_target)\n| target_with_star_atom\ntarget_with_star_atom:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\n| star_atom\nstar_atom:\n| NAME\n| '(' target_with_star_atom ')'\n| '(' [star_targets_tuple_seq] ')'\n| '[' [star_targets_list_seq] ']'\n\n|  | | '{' kvpair for_if_clauses '}'\n# FUNCTION CALL ARGUMENTS\n# =======================\narguments:\n| args [','] &')'\nargs:\n| ','.(starred_expression | ( assignment_expression | expression !':=') !'=')+\n| kwargs\nkwargs:\n| ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n| ','.kwarg_or_starred+\n| ','.kwarg_or_double_starred+\nstarred_expression:\n| '*' expression\nkwarg_or_starred:\n| NAME '=' expression\n| starred_expression\nkwarg_or_double_starred:\n| NAME '=' expression\n| '**' expression\n# ASSIGNMENT TARGETS\n# ==================\n# Generic targets\n# ---------------\n# NOTE: star_targets may contain *bitwise_or, targets may not.\nstar_targets:\n| star_target !','\n| star_target (',' star_target )* [',']\nstar_targets_list_seq: ','.star_target+ [',']\nstar_targets_tuple_seq:\n| star_target (',' star_target )+ [',']\n| star_target ','\nstar_target:\n| '*' (!'*' star_target)\n| target_with_star_atom\ntarget_with_star_atom:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\n| star_atom\nstar_atom:\n| NAME\n| '(' target_with_star_atom ')'\n| '(' [star_targets_tuple_seq] ')'\n| '[' [star_targets_list_seq] ']' |  |\n| --- | --- | --- |\n\nsingle_target:\n| single_subscript_attribute_target\n| NAME\n| '(' single_target ')'\nsingle_subscript_attribute_target:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\nt_primary:\n| t_primary '.' NAME &t_lookahead\n| t_primary '[' slices ']' &t_lookahead\n| t_primary genexp &t_lookahead\n| t_primary '(' [arguments] ')' &t_lookahead\n| atom &t_lookahead\nt_lookahead: '(' | '[' | '.'\n# Targets for del statements\n# --------------------------\ndel_targets: ','.del_target+ [',']\ndel_target:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\n| del_t_atom\ndel_t_atom:\n| NAME\n| '(' del_target ')'\n| '(' [del_targets] ')'\n| '[' [del_targets] ']'\n# TYPING ELEMENTS\n# ---------------\n# type_expressions allow */** but ignore them\ntype_expressions:\n| ','.expression+ ',' '*' expression ',' '**' expression\n| ','.expression+ ',' '*' expression\n| ','.expression+ ',' '**' expression\n| '*' expression ',' '**' expression\n| '*' expression\n| '**' expression\n| ','.expression+\nfunc_type_comment:\n| NEWLINE TYPE_COMMENT &(NEWLINE INDENT) # Must be followed by indented bloc\n| TYPE_COMMENT\n# ========================= END OF THE GRAMMAR ===========================\n# ========================= START OF INVALID RULES =======================\n\n|  | single_target:\n| single_subscript_attribute_target\n| NAME\n| '(' single_target ')'\nsingle_subscript_attribute_target:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\nt_primary:\n| t_primary '.' NAME &t_lookahead\n| t_primary '[' slices ']' &t_lookahead\n| t_primary genexp &t_lookahead\n| t_primary '(' [arguments] ')' &t_lookahead\n| atom &t_lookahead\nt_lookahead: '(' | '[' | '.'\n# Targets for del statements\n# --------------------------\ndel_targets: ','.del_target+ [',']\ndel_target:\n| t_primary '.' NAME !t_lookahead\n| t_primary '[' slices ']' !t_lookahead\n| del_t_atom\ndel_t_atom:\n| NAME\n| '(' del_target ')'\n| '(' [del_targets] ')'\n| '[' [del_targets] ']'\n# TYPING ELEMENTS\n# ---------------\n# type_expressions allow */** but ignore them\ntype_expressions:\n| ','.expression+ ',' '*' expression ',' '**' expression\n| ','.expression+ ',' '*' expression\n| ','.expression+ ',' '**' expression\n| '*' expression ',' '**' expression\n| '*' expression\n| '**' expression\n| ','.expression+\nfunc_type_comment:\n| NEWLINE TYPE_COMMENT &(NEWLINE INDENT) # Must be followed by indented bloc\n| TYPE_COMMENT\n# ========================= END OF THE GRAMMAR ===========================\n# ========================= START OF INVALID RULES ======================= |\n| --- | --- |", "metadata": {"title": "10_完整的语法规范", "source": "md_docs\\python_reference_md\\10_完整的语法规范.md", "doc_type": "语言参考", "language": "中文", "doc_id": "bf60811d"}}
