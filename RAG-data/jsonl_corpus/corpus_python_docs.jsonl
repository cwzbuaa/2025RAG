{"doc_id": "52df96f7", "content": "1. 课前甜点\n如果您的工作主要是用电脑完成的，总有一天您会想能不能自动执行一些任务。比如，对大量文本\n文件执行查找、替换操作；利用复杂的规则重命名、重排序一堆照片文件；也可能您想编写一个小\n型数据库、或开发专用的图形界面应用，甚至是开发一个简单的游戏。\n作为一名专业软件开发人员，您可能要处理 C/C++/Java 库，但编码、编译、测试、再编译这些开发\n流程太慢了；也许您正在给这些库开发测试套件，但总觉得这项工作真是枯燥乏味。又或许，您开\n发了个使用扩展语言的软件，却不想为这个软件专门设计一种新语言。\n那么，Python 正好能满足您的需要。\n你可以针对这些任务编写 Unix shell 脚本或 Windows 批处理文件，但 shell 脚本擅长的是移动文件\n和改变文本数据，而不适合编写 GUI 应用或游戏。 你可以编写 C/C++/Java 程序，但即使只完成一\n个初始版程序也需要耗费很长的开发时间。 Python 则更为简单易用，同时支持 Windows, macOS\n和 Unix 操作系统，并能帮助你更快速地完成工作。\nPython 虽然简单易用，但它可是真正的编程语言，提供了大量的数据结构，也支持开发大型程序，\n远超 shell 脚本或批处理文件；Python 提供的错误检查比 C 还多；作为一种“非常高级的语言”，它内\n置了灵活的数组与字典等高级数据类型。正因为配备了更通用的数据类型，Python 比 Awk，甚至\nPerl 能解决更多问题，而且，很多时候，Python 比这些语言更简单。\nPython 支持把程序分割为模块，以便在其他 Python 程序中复用。它还内置了大量标准模块，作为\n开发程序的基础 —— 您还可以把这些模块当作学习 Python 编程的实例。这些模块包括 I/O、系统\n调用、套接字，甚至还包括 Tk 图形用户界面工作套件。\nPython 是一种解释型语言，不需要编译和链接，可以节省大量开发时间。它的解释器实现了交互式\n操作，轻而易举地就能试用各种语言功能，编写临时程序，或在自底向上的程序开发中测试功能。\n同时，它还是一个超好用的计算器。\nPython 程序简洁、易读，通常比实现同种功能的 C、C++、Java 代码短很多，原因如下：\n高级数据类型允许在单一语句中表述复杂操作；\n使用缩进，而不是括号实现代码块分组；\n无需预声明变量或参数。\nPython “可以扩展”：会开发 C 语言程序，就能快速上手为解释器增加新的内置函数或模块，不论是\n让核心程序以最高速度运行，还是把 Python 程序链接到只提供预编译程序的库（比如，硬件图形\n库）。只要下点功夫，就能把 Python 解释器和用 C 开发的应用链接在一起，用它来扩展和控制该应\n用。\n顺便提一句，本语言的命名源自 BBC 的 “Monty Python 飞行马戏团”，与爬行动物无关（Python 原\n义为“蟒蛇”）。欢迎大家在文档中引用 Monty Python 小品短篇集，多多益善！\n\n现在，您已经对 Python 跃跃欲试，想深入了解一些细节了吧。要知道，学习语言的最佳方式是上手\n实践，建议您边阅读本教程，边在 Python 解释器中练习。\n下一章介绍解释器的用法。这部分内容有些单调乏味，但对上手实践后面的例子来说却至关重要。\n本教程的其他部分将利用各种示例，介绍 Python 语言、系统的功能，开始只是简单的表达式、语句\n和数据类型，然后是函数、模块，最后，介绍一些高级概念，如，异常、用户定义的类等功能。", "metadata": {"title": "01_课前甜点", "source": "md_docs\\python_docs_md\\01_课前甜点.md", "doc_type": "教程", "language": "中文", "doc_id": "52df96f7"}}
{"doc_id": "717b1fdd", "content": "2. 使用 Python 的解释器\n2.1. 唤出解释器\n在可用的机器上 Python 解释器通常被安装为 /usr/local/bin/python3.14；将 /usr/local/bin\n加入你的 Unix shell 搜索路径就可以通过键入以下命令来启动它：\npython3.14\n这样，就可以在 shell 中运行 Python 了 [1] 。因为可以选择安装目录，解释器也有可能安装在别的\n位置；如果还不明白，就去问问身边的 Python 大神或系统管理员。（例如，常见备选路径还有\n/usr/local/python。）\n在 Windows 机器上当你从 Microsoft Store 安装 Python 之后，python3.14 命令将可使用。 如果你\n安装了 py.exe 启动器，你将可以使用 py 命令。 请参阅 Python 安装管理器 了解其他启动 Python\n的方式。\n在主提示符中，输入文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z），就会退出解\n释器，退出状态码为 0。如果不能退出，还可以输入这个命令：quit()。\n在支持 GNU Readline 库的系统中，解释器的行编辑功能包括交互式编辑、历史替换、代码补全等。\n检测是否支持命令行编辑最快速的方式是，在首次出现 Python 提示符时，输入 Control-P。听到\n“哔”提示音，说明支持行编辑；请参阅附录 交互式编辑和编辑历史，了解功能键。如果没有反应，\n或回显了 ^P，则说明不支持行编辑；只能用退格键删除当前行的字符。\n解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行\n命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 脚本。\n另一种启动解释器的方式是 python -c command [arg] ...，这将执行 command 中的语句，相当\n于 shell 的 -c 选项。 由于 Python 语句经常包含空格或其他会被 shell 特殊对待的字符，通常建议用\n引号将整个 command 括起来。\nPython 模块也可以当作脚本使用。输入：python -m module [arg] ...，会执行 module 的源文\n件，这跟在命令行把路径写全了一样。\n在交互模式下运行脚本文件，只要在脚本名称参数前，加上选项 -i 就可以了。\n命令行的所有选项详见 命令行与环境。\n2.1.1. 传入参数\n解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 sys 模块的 argv 变量里。执\n行 import sys，可以导入这个模块，并访问该列表。该列表最少有一个元素；未给定输入参数时，\nsys.argv[0] 是空字符串。给定脚本名是 '-' （标准输入）时，sys.argv[0] 是 '-'。使用 -c\n\n| 2. 使用 Python 的解释器\n2.1. 唤出解释器\n在可用的机器上 Python 解释器通常被安装为 /usr/local/bin/python3.14；将 /usr/local/bin\n加入你的 Unix shell 搜索路径就可以通过键入以下命令来启动它： |\n| --- |\n| python3.14 |\n| 这样，就可以在 shell 中运行 Python 了 [1] 。因为可以选择安装目录，解释器也有可能安装在别的\n位置；如果还不明白，就去问问身边的 Python 大神或系统管理员。（例如，常见备选路径还有\n/usr/local/python。）\n在 Windows 机器上当你从 Microsoft Store 安装 Python 之后，python3.14 命令将可使用。 如果你\n安装了 py.exe 启动器，你将可以使用 py 命令。 请参阅 Python 安装管理器 了解其他启动 Python\n的方式。\n在主提示符中，输入文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z），就会退出解\n释器，退出状态码为 0。如果不能退出，还可以输入这个命令：quit()。\n在支持 GNU Readline 库的系统中，解释器的行编辑功能包括交互式编辑、历史替换、代码补全等。\n检测是否支持命令行编辑最快速的方式是，在首次出现 Python 提示符时，输入 Control-P。听到\n“哔”提示音，说明支持行编辑；请参阅附录 交互式编辑和编辑历史，了解功能键。如果没有反应，\n或回显了 ^P，则说明不支持行编辑；只能用退格键删除当前行的字符。\n解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行\n命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 脚本。\n另一种启动解释器的方式是 python -c command [arg] ...，这将执行 command 中的语句，相当\n于 shell 的 -c 选项。 由于 Python 语句经常包含空格或其他会被 shell 特殊对待的字符，通常建议用\n引号将整个 command 括起来。\nPython 模块也可以当作脚本使用。输入：python -m module [arg] ...，会执行 module 的源文\n件，这跟在命令行把路径写全了一样。\n在交互模式下运行脚本文件，只要在脚本名称参数前，加上选项 -i 就可以了。\n命令行的所有选项详见 命令行与环境。\n2.1.1. 传入参数\n解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 sys 模块的 argv 变量里。执\n行 import sys，可以导入这个模块，并访问该列表。该列表最少有一个元素；未给定输入参数时，\nsys.argv[0] 是空字符串。给定脚本名是 '-' （标准输入）时，sys.argv[0] 是 '-'。使用 -c |\n\ncommand 时，sys.argv[0] 是 '-c'。如果使用选项 -m module，sys.argv[0] 就是包含目录的模\n块全名。解释器不处理 -c command 或 -m module 之后的选项，而是直接留在 sys.argv 中由命令\n或模块来处理。\n2.1.2. 交互模式\n在终端（tty）输入并执行指令时，解释器在 交互模式（interactive mode） 中运行。在这种模式\n中，会显示 主提示符，提示输入下一条指令，主提示符通常用三个大于号（>>>）表示；输入连续\n行时，显示 次要提示符，默认是三个点（...）。进入解释器时，首先显示欢迎信息、版本信息、\n版权声明，然后才是提示符：\n$ python3.14\nPython 3.14 (default, April 4 2024, 09:25:04)\n[GCC 10.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n输入多行架构的语句时，要用连续行。以 if 为例：\n>>> the_world_is_flat = True\n>>> if the_world_is_flat:\n... print(\"Be careful not to fall off!\")\n...\nBe careful not to fall off!\n交互模式的内容详见 交互模式。\n2.2. 解释器的运行环境\n2.2.1. 源文件的字符编码\n默认情况下，Python 源码文件的编码是 UTF-8。这种编码支持世界上大多数语言的字符，可以用于\n字符串字面值、变量、函数名及注释 —— 尽管标准库只用常规的 ASCII 字符作为变量名或函数名，\n可移植代码都应遵守此约定。要正确显示这些字符，编辑器必须能识别 UTF-8 编码，而且必须使用\n支持文件中所有字符的字体。\n如果不使用默认编码，则要声明文件的编码，文件的 第一 行要写成特殊注释。句法如下：\n# -*- coding: encoding -*-\n其中，encoding 可以是 Python 支持的任意一种 codecs。\n比如，声明使用 Windows-1252 编码，源码文件要写成：\n# -*- coding: cp1252 -*-\n第一行 的规则也有一种例外情况，源码以 UNIX \"shebang\" 行 开头。此时，编码声明要写在文件的\n第二行。例如：\n#!/usr/bin/env python3\n# -*- coding: cp1252 -*-\n\n|  | command 时，sys.argv[0] 是 '-c'。如果使用选项 -m module，sys.argv[0] 就是包含目录的模\n块全名。解释器不处理 -c command 或 -m module 之后的选项，而是直接留在 sys.argv 中由命令\n或模块来处理。\n2.1.2. 交互模式\n在终端（tty）输入并执行指令时，解释器在 交互模式（interactive mode） 中运行。在这种模式\n中，会显示 主提示符，提示输入下一条指令，主提示符通常用三个大于号（>>>）表示；输入连续\n行时，显示 次要提示符，默认是三个点（...）。进入解释器时，首先显示欢迎信息、版本信息、\n版权声明，然后才是提示符： |  |\n| --- | --- | --- |\n|  | $ python3.14\nPython 3.14 (default, April 4 2024, 09:25:04)\n[GCC 10.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> |  |\n|  | 输入多行架构的语句时，要用连续行。以 if 为例： |  |\n|  | >>> the_world_is_flat = True\n>>> if the_world_is_flat:\n... print(\"Be careful not to fall off!\")\n...\nBe careful not to fall off! |  |\n|  | 交互模式的内容详见 交互模式。\n2.2. 解释器的运行环境\n2.2.1. 源文件的字符编码\n默认情况下，Python 源码文件的编码是 UTF-8。这种编码支持世界上大多数语言的字符，可以用于\n字符串字面值、变量、函数名及注释 —— 尽管标准库只用常规的 ASCII 字符作为变量名或函数名，\n可移植代码都应遵守此约定。要正确显示这些字符，编辑器必须能识别 UTF-8 编码，而且必须使用\n支持文件中所有字符的字体。\n如果不使用默认编码，则要声明文件的编码，文件的 第一 行要写成特殊注释。句法如下： |  |\n|  | # -*- coding: encoding -*- |  |\n|  | 其中，encoding 可以是 Python 支持的任意一种 codecs。\n比如，声明使用 Windows-1252 编码，源码文件要写成： |  |\n|  | # -*- coding: cp1252 -*- |  |\n|  | 第一行 的规则也有一种例外情况，源码以 UNIX \"shebang\" 行 开头。此时，编码声明要写在文件的\n第二行。例如： |  |\n|  | #!/usr/bin/env python3\n# -*- coding: cp1252 -*- |  |\n\n备注\n[1] Unix 系统中，为了不与同时安装的 Python 2.x 冲突，Python 3.x 解释器默认安装的执行文件名\n不是 python。", "metadata": {"title": "02_使用_Python_的解释器", "source": "md_docs\\python_docs_md\\02_使用_Python_的解释器.md", "doc_type": "教程", "language": "中文", "doc_id": "717b1fdd"}}
{"doc_id": "571ab068", "content": "3. Python 速览\n下面的例子以是否显示提示符（>>> 与 ...）区分输入与输出：输入例子中的代码时，要键入以提示\n符开头的行中提示符后的所有内容；未以提示符开头的行是解释器的输出。注意，例子中的某行出\n现的第二个提示符是用来结束多行命令的，此时，要键入一个空白行。\n你可以使用 \"Copy\" 按钮（它会在悬停或点击代码示例时显示于右上角），它会去除提示符并省略输\n出，以将输入行复制粘贴到你的解释器。\n本手册中的许多例子，甚至交互式命令都包含注释。Python 注释以 # 开头，直到该物理行结束。注\n释可以在行开头，或空白符与代码之后，但不能在字符串里面。字符串中的 # 号就是 # 号。注释用\n于阐明代码，Python 不解释注释，键入例子时，可以不输入注释。\n示例如下：\n# 这是第一条注释\nspam = 1 # 而这是第二条注释\n# ... 而这是第三条！\ntext = \"# 这不是注释因为它是在引号之内。\"\n3.1. Python 用作计算器\n现在，尝试一些简单的 Python 命令。启动解释器，等待主提示符（>>> ）出现。\n3.1.1. 数字\n解释器像一个简单的计算器：你可以输入一个表达式，它将给出结果值。 表达式语法很直观：运算\n符 +, -, * 和 / 可被用来执行算术运算；圆括号 (()) 可被用来进行分组。 例如:\n>>> 2 + 2\n4\n>>> 50 - 5*6\n20\n>>> (50 - 5*6) / 4\n5.0\n>>> 8 / 5 # 除法运算总是返回一个浮点数\n1.6\n整数（如，2、4、20 ）的类型是 int，带小数（如，5.0、1.6 ）的类型是 float。本教程后半部\n分将介绍更多数字类型。\n除法运算 (/) 总是返回浮点数。 如果要做 floor division 得到一个整数结果你可以使用 // 运算符；\n要计算余数你可以使用 %:\n>>> 17 / 3 # 经典除法运算返回一个浮点数\n5.666666666666667\n\n| 3. Python 速览\n下面的例子以是否显示提示符（>>> 与 ...）区分输入与输出：输入例子中的代码时，要键入以提示\n符开头的行中提示符后的所有内容；未以提示符开头的行是解释器的输出。注意，例子中的某行出\n现的第二个提示符是用来结束多行命令的，此时，要键入一个空白行。\n你可以使用 \"Copy\" 按钮（它会在悬停或点击代码示例时显示于右上角），它会去除提示符并省略输\n出，以将输入行复制粘贴到你的解释器。\n本手册中的许多例子，甚至交互式命令都包含注释。Python 注释以 # 开头，直到该物理行结束。注\n释可以在行开头，或空白符与代码之后，但不能在字符串里面。字符串中的 # 号就是 # 号。注释用\n于阐明代码，Python 不解释注释，键入例子时，可以不输入注释。\n示例如下： |\n| --- |\n| # 这是第一条注释\nspam = 1 # 而这是第二条注释\n# ... 而这是第三条！\ntext = \"# 这不是注释因为它是在引号之内。\" |\n| 3.1. Python 用作计算器\n现在，尝试一些简单的 Python 命令。启动解释器，等待主提示符（>>> ）出现。\n3.1.1. 数字\n解释器像一个简单的计算器：你可以输入一个表达式，它将给出结果值。 表达式语法很直观：运算\n符 +, -, * 和 / 可被用来执行算术运算；圆括号 (()) 可被用来进行分组。 例如: |\n| >>> 2 + 2\n4\n>>> 50 - 5*6\n20\n>>> (50 - 5*6) / 4\n5.0\n>>> 8 / 5 # 除法运算总是返回一个浮点数\n1.6 |\n| 整数（如，2、4、20 ）的类型是 int，带小数（如，5.0、1.6 ）的类型是 float。本教程后半部\n分将介绍更多数字类型。\n除法运算 (/) 总是返回浮点数。 如果要做 floor division 得到一个整数结果你可以使用 // 运算符；\n要计算余数你可以使用 %: |\n| >>> 17 / 3 # 经典除法运算返回一个浮点数\n5.666666666666667 |\n\n>>>\n>>> 17 // 3 # 向下取整除法运算会丢弃小数部分\n5\n>>> 17 % 3 # % 运算返回相除的余数\n2\n>>> 5 * 3 + 2 # 向下取整的商 * 除数 + 余数\n17\nPython 用 ** 运算符计算乘方 [1]：\n>>> 5 ** 2 # 5 的平方\n25\n>>> 2 ** 7 # 2 的 7 次方\n128\n等号（=）用于给变量赋值。赋值后，下一个交互提示符的位置不显示任何结果：\n>>> width = 20\n>>> height = 5 * 9\n>>> width * height\n900\n如果变量未定义（即，未赋值），使用该变量会提示错误：\n>>> n # 试图访问一个未定义的变量\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined\nPython 全面支持浮点数；混合类型运算数的运算会把整数转换为浮点数：\n>>> 4 * 3.75 - 1\n14.0\n交互模式下，上次输出的表达式会赋给变量 _。把 Python 当作计算器时，用该变量实现下一步计算\n更简单，例如：\n>>> tax = 12.5 / 100\n>>> price = 100.50\n>>> price * tax\n12.5625\n>>> price + _\n113.0625\n>>> round(_, 2)\n113.06\n最好把该变量当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用\n它的魔法行为屏蔽内置变量。\n除了 int 和 float，Python 还支持其他数字类型，例如 Decimal 或 Fraction。Python 还内置支\n持 复数，后缀 j 或 J 用于表示虚数（例如 3+5j ）。\n3.1.2. 文本\n\n|  | >>>\n>>> 17 // 3 # 向下取整除法运算会丢弃小数部分\n5\n>>> 17 % 3 # % 运算返回相除的余数\n2\n>>> 5 * 3 + 2 # 向下取整的商 * 除数 + 余数\n17 |  |\n| --- | --- | --- |\n|  | Python 用 ** 运算符计算乘方 [1]： |  |\n|  | >>> 5 ** 2 # 5 的平方\n25\n>>> 2 ** 7 # 2 的 7 次方\n128 |  |\n|  | 等号（=）用于给变量赋值。赋值后，下一个交互提示符的位置不显示任何结果： |  |\n|  | >>> width = 20\n>>> height = 5 * 9\n>>> width * height\n900 |  |\n|  | 如果变量未定义（即，未赋值），使用该变量会提示错误： |  |\n|  | >>> n # 试图访问一个未定义的变量\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined |  |\n|  | Python 全面支持浮点数；混合类型运算数的运算会把整数转换为浮点数： |  |\n|  | >>> 4 * 3.75 - 1\n14.0 |  |\n|  | 交互模式下，上次输出的表达式会赋给变量 _。把 Python 当作计算器时，用该变量实现下一步计算\n更简单，例如： |  |\n|  | >>> tax = 12.5 / 100\n>>> price = 100.50\n>>> price * tax\n12.5625\n>>> price + _\n113.0625\n>>> round(_, 2)\n113.06 |  |\n|  | 最好把该变量当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用\n它的魔法行为屏蔽内置变量。\n除了 int 和 float，Python 还支持其他数字类型，例如 Decimal 或 Fraction。Python 还内置支\n持 复数，后缀 j 或 J 用于表示虚数（例如 3+5j ）。\n3.1.2. 文本 |  |\n\n除了数字 Python 还可以操作文本（由 str 类型表示，称为“字符串”）。 这包括字符 \"!\", 单词\n\"rabbit\", 名称 \"Paris\", 句子 \"Got your back.\" 等等. \"Yay! :)\"。 它们可以用成对的单引号\n('...') 或双引号 (\"...\") 来标示，结果完全相同 [2]。\n>>> 'spam eggs' # 单引号\n'spam eggs'\n>>> \"Paris rabbit got your back :)! Yay!\" # 双引号\n'Paris rabbit got your back :)! Yay!'\n>>> '1975' # 引号中的数字也是字符串\n'1975'\n要标示引号本身，我们需要对它进行“转义”，即在前面加一个 \\。 或者，我们也可以使用不同类型\n的引号:\n>>> 'doesn\\'t' # 使用 \\' 来转义单引号...\n\"doesn't\"\n>>> \"doesn't\" # ...或者改用双引号\n\"doesn't\"\n>>> '\"Yes,\" they said.'\n'\"Yes,\" they said.'\n>>> \"\\\"Yes,\\\" they said.\"\n'\"Yes,\" they said.'\n>>> '\"Isn\\'t,\" they said.'\n'\"Isn\\'t,\" they said.'\n在 Python shell 中，字符串定义和输出字符串看起来可能不同。 print() 函数会略去标示用的引\n号，并打印经过转义的特殊字符，产生更为易读的输出:\n>>> s = 'First line.\\nSecond line.' # \\n 表示换行符\n>>> s # 不用 print()，特殊字符将包括在字符串中\n'First line.\\nSecond line.'\n>>> print(s) # 用 print()，特殊字符会被转写，因此 \\n 将产生一个新行\nFirst line.\nSecond line.\n如果不希望前置 \\ 的字符转义成特殊字符，可以使用 原始字符串，在引号前添加 r 即可：\n>>> print('C:\\some\\name') # 这里 \\n 表示换行符！\nC:\\some\name\n>>> print(r'C:\\some\\name') # 请注意引号前的 r\nC:\\some\\name\n原始字符串还有一个微妙的限制：一个原始字符串不能以奇数个 \\ 字符结束；请参阅 此 FAQ 条目\n了解更多信息及绕过的办法。\n字符串字面值可以跨越多行。 一种做法是使用三重引号: \"\"\"...\"\"\" 或 '''...'''。 行结束符会自\n动包括在字符串中，但可以通过在行尾添加 \\ 来避免此行为。 在下面的例子中，开头的换行符将不\n会被包括:\n>>> print(\"\"\"\\\n... Usage: thingy [OPTIONS]\n... -h Display this usage message\n\n|  | 除了数字 Python 还可以操作文本（由 str 类型表示，称为“字符串”）。 这包括字符 \"!\", 单词\n\"rabbit\", 名称 \"Paris\", 句子 \"Got your back.\" 等等. \"Yay! :)\"。 它们可以用成对的单引号\n('...') 或双引号 (\"...\") 来标示，结果完全相同 [2]。 |  |\n| --- | --- | --- |\n|  | >>> 'spam eggs' # 单引号\n'spam eggs'\n>>> \"Paris rabbit got your back :)! Yay!\" # 双引号\n'Paris rabbit got your back :)! Yay!'\n>>> '1975' # 引号中的数字也是字符串\n'1975' |  |\n|  | 要标示引号本身，我们需要对它进行“转义”，即在前面加一个 \\。 或者，我们也可以使用不同类型\n的引号: |  |\n|  | >>> 'doesn\\'t' # 使用 \\' 来转义单引号...\n\"doesn't\"\n>>> \"doesn't\" # ...或者改用双引号\n\"doesn't\"\n>>> '\"Yes,\" they said.'\n'\"Yes,\" they said.'\n>>> \"\\\"Yes,\\\" they said.\"\n'\"Yes,\" they said.'\n>>> '\"Isn\\'t,\" they said.'\n'\"Isn\\'t,\" they said.' |  |\n|  | 在 Python shell 中，字符串定义和输出字符串看起来可能不同。 print() 函数会略去标示用的引\n号，并打印经过转义的特殊字符，产生更为易读的输出: |  |\n|  | >>> s = 'First line.\\nSecond line.' # \\n 表示换行符\n>>> s # 不用 print()，特殊字符将包括在字符串中\n'First line.\\nSecond line.'\n>>> print(s) # 用 print()，特殊字符会被转写，因此 \\n 将产生一个新行\nFirst line.\nSecond line. |  |\n|  | 如果不希望前置 \\ 的字符转义成特殊字符，可以使用 原始字符串，在引号前添加 r 即可： |  |\n|  | >>> print('C:\\some\\name') # 这里 \\n 表示换行符！\nC:\\some\name\n>>> print(r'C:\\some\\name') # 请注意引号前的 r\nC:\\some\\name |  |\n|  | 原始字符串还有一个微妙的限制：一个原始字符串不能以奇数个 \\ 字符结束；请参阅 此 FAQ 条目\n了解更多信息及绕过的办法。\n字符串字面值可以跨越多行。 一种做法是使用三重引号: \"\"\"...\"\"\" 或 '''...'''。 行结束符会自\n动包括在字符串中，但可以通过在行尾添加 \\ 来避免此行为。 在下面的例子中，开头的换行符将不\n会被包括: |  |\n|  | >>> print(\"\"\"\\\n... Usage: thingy [OPTIONS]\n... -h Display this usage message |  |\n\n... -H hostname Hostname to connect to\n... \"\"\")\nUsage: thingy [OPTIONS]\n-h Display this usage message\n-H hostname Hostname to connect to\n>>>\n字符串可以用 + 合并（粘到一起），也可以用 * 重复：\n>>> # 3 乘以 'un'，再加 'ium'\n>>> 3 * 'un' + 'ium'\n'unununium'\n相邻的两个或多个 字符串字面值 （引号标注的字符）会自动合并：\n>>> 'Py' 'thon'\n'Python'\n拼接分隔开的长字符串时，这个功能特别实用：\n>>> text = ('Put several strings within parentheses '\n... 'to have them joined together.')\n>>> text\n'Put several strings within parentheses to have them joined together.'\n这项功能只能用于两个字面值，不能用于变量或表达式：\n>>> prefix = 'Py'\n>>> prefix 'thon' # 不能拼接变量和字符串字面值\nFile \"<stdin>\", line 1\nprefix 'thon'\n^^^^^^\nSyntaxError: invalid syntax\n>>> ('un' * 3) 'ium'\nFile \"<stdin>\", line 1\n('un' * 3) 'ium'\n^^^^^\nSyntaxError: invalid syntax\n合并多个变量，或合并变量与字面值，要用 +：\n>>> prefix + 'thon'\n'Python'\n字符串支持 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的\n字符串：\n>>> word = 'Python'\n>>> word[0] # 0 号位的字符\n'P'\n>>> word[5] # 5 号位的字符\n'n'\n\n|  | ... -H hostname Hostname to connect to\n... \"\"\")\nUsage: thingy [OPTIONS]\n-h Display this usage message\n-H hostname Hostname to connect to\n>>> |  |\n| --- | --- | --- |\n|  | 字符串可以用 + 合并（粘到一起），也可以用 * 重复： |  |\n|  | >>> # 3 乘以 'un'，再加 'ium'\n>>> 3 * 'un' + 'ium'\n'unununium' |  |\n|  | 相邻的两个或多个 字符串字面值 （引号标注的字符）会自动合并： |  |\n|  | >>> 'Py' 'thon'\n'Python' |  |\n|  | 拼接分隔开的长字符串时，这个功能特别实用： |  |\n|  | >>> text = ('Put several strings within parentheses '\n... 'to have them joined together.')\n>>> text\n'Put several strings within parentheses to have them joined together.' |  |\n|  | 这项功能只能用于两个字面值，不能用于变量或表达式： |  |\n|  | >>> prefix = 'Py'\n>>> prefix 'thon' # 不能拼接变量和字符串字面值\nFile \"<stdin>\", line 1\nprefix 'thon'\n^^^^^^\nSyntaxError: invalid syntax\n>>> ('un' * 3) 'ium'\nFile \"<stdin>\", line 1\n('un' * 3) 'ium'\n^^^^^\nSyntaxError: invalid syntax |  |\n|  | 合并多个变量，或合并变量与字面值，要用 +： |  |\n|  | >>> prefix + 'thon'\n'Python' |  |\n|  | 字符串支持 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的\n字符串： |  |\n|  | >>> word = 'Python'\n>>> word[0] # 0 号位的字符\n'P'\n>>> word[5] # 5 号位的字符\n'n' |  |\n|  |  |  |\n\n索引还支持负数，用负数索引时，从右边开始计数：\n>>> word[-1] # 最后一个字符\n'n'\n>>> word[-2] # 倒数第二个字符\n'o'\n>>> word[-6]\n'P'\n注意，-0 和 0 一样，因此，负数索引从 -1 开始。\n除了索引操作，还支持 切片。 索引用来获取单个字符，而 切片 允许你获取子字符串:\n>>> word[0:2] # 从 0 号位 (含) 到 2 号位 (不含) 的字符\n'Py'\n>>> word[2:5] # 从 2 号位 (含) 到 5 号位 (不含) 的字符\n'tho'\n切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结\n尾：\n>>> word[:2] # 从开头到 2 号位 (不含) 的字符\n'Py'\n>>> word[4:] # 从 4 号位 (含) 到末尾\n'on'\n>>> word[-2:] # 从倒数第二个 (含) 到末尾\n'on'\n注意，输出结果包含切片开始，但不包含切片结束。因此，s[:i] + s[i:] 总是等于 s：\n>>> word[:2] + word[2:]\n'Python'\n>>> word[:4] + word[4:]\n'Python'\n还可以这样理解切片，索引指向的是字符 之间 ，第一个字符的左侧标为 0，最后一个字符的右侧标\n为 n ，n 是字符串长度。例如：\n+---+---+---+---+---+---+\n| P | y | t | h | o | n |\n+---+---+---+---+---+---+\n0 1 2 3 4 5 6\n-6 -5 -4 -3 -2 -1\n第一行数字是字符串中索引 0...6 的位置，第二行数字是对应的负数索引位置。i 到 j 的切片由 i 和 j\n之间所有对应的字符组成。\n对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如，\nword[1:3] 的长度是 2。\n索引越界会报错：\n\n|  | 索引还支持负数，用负数索引时，从右边开始计数： |  |\n| --- | --- | --- |\n|  | >>> word[-1] # 最后一个字符\n'n'\n>>> word[-2] # 倒数第二个字符\n'o'\n>>> word[-6]\n'P' |  |\n|  | 注意，-0 和 0 一样，因此，负数索引从 -1 开始。\n除了索引操作，还支持 切片。 索引用来获取单个字符，而 切片 允许你获取子字符串: |  |\n|  | >>> word[0:2] # 从 0 号位 (含) 到 2 号位 (不含) 的字符\n'Py'\n>>> word[2:5] # 从 2 号位 (含) 到 5 号位 (不含) 的字符\n'tho' |  |\n|  | 切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结\n尾： |  |\n|  | >>> word[:2] # 从开头到 2 号位 (不含) 的字符\n'Py'\n>>> word[4:] # 从 4 号位 (含) 到末尾\n'on'\n>>> word[-2:] # 从倒数第二个 (含) 到末尾\n'on' |  |\n|  | 注意，输出结果包含切片开始，但不包含切片结束。因此，s[:i] + s[i:] 总是等于 s： |  |\n|  | >>> word[:2] + word[2:]\n'Python'\n>>> word[:4] + word[4:]\n'Python' |  |\n|  | 还可以这样理解切片，索引指向的是字符 之间 ，第一个字符的左侧标为 0，最后一个字符的右侧标\n为 n ，n 是字符串长度。例如： |  |\n|  | +---+---+---+---+---+---+\n| P | y | t | h | o | n |\n+---+---+---+---+---+---+\n0 1 2 3 4 5 6\n-6 -5 -4 -3 -2 -1 |  |\n|  | 第一行数字是字符串中索引 0...6 的位置，第二行数字是对应的负数索引位置。i 到 j 的切片由 i 和 j\n之间所有对应的字符组成。\n对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如，\nword[1:3] 的长度是 2。\n索引越界会报错： |  |\n\n>>> word[42] # word 只有 6 个字符\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n但是，切片会自动处理越界索引：\n>>> word[4:42]\n'on'\n>>> word[42:]\n''\nPython 字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错：\n>>> word[0] = 'J'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n>>> word[2:] = 'py'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n要生成不同的字符串，应新建一个字符串：\n>>> 'J' + word[1:]\n'Jython'\n>>> word[:2] + 'py'\n'Pypy'\n内置函数 len() 返回字符串的长度：\n>>> s = 'supercalifragilisticexpialidocious'\n>>> len(s)\n34\n参见:\n文本序列类型 --- str\n字符串是 序列类型 ，支持序列类型的各种操作。\n字符串的方法\n字符串支持很多变形与查找方法。\nf-字符串\n内嵌表达式的字符串字面值。\n格式字符串语法\n使用 str.format() 格式化字符串。\nprintf 风格的字符串格式化\n这里详述了用 % 运算符格式化字符串的操作。\n\n|  | >>> word[42] # word 只有 6 个字符\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError: string index out of range |  |\n| --- | --- | --- |\n|  | 但是，切片会自动处理越界索引： |  |\n|  | >>> word[4:42]\n'on'\n>>> word[42:]\n'' |  |\n|  | Python 字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错： |  |\n|  | >>> word[0] = 'J'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n>>> word[2:] = 'py'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment |  |\n|  | 要生成不同的字符串，应新建一个字符串： |  |\n|  | >>> 'J' + word[1:]\n'Jython'\n>>> word[:2] + 'py'\n'Pypy' |  |\n|  | 内置函数 len() 返回字符串的长度： |  |\n|  | >>> s = 'supercalifragilisticexpialidocious'\n>>> len(s)\n34 |  |\n|  |  |  |\n|  | 参见:\n文本序列类型 --- str\n字符串是 序列类型 ，支持序列类型的各种操作。\n字符串的方法\n字符串支持很多变形与查找方法。\nf-字符串\n内嵌表达式的字符串字面值。\n格式字符串语法\n使用 str.format() 格式化字符串。\nprintf 风格的字符串格式化\n这里详述了用 % 运算符格式化字符串的操作。 |  |\n|  |  |  |\n\n3.1.3. 列表\nPython 支持多种 复合 数据类型，可将不同值组合在一起。最常用的 列表 ，是用方括号标注，逗号\n分隔的一组值。列表 可以包含不同类型的元素，但一般情况下，各个元素的类型相同：\n>>> squares = [1, 4, 9, 16, 25]\n>>> squares\n[1, 4, 9, 16, 25]\n和字符串（及其他内置 sequence 类型）一样，列表也支持索引和切片：\n>>> squares[0] # 索引操作将返回条目\n1\n>>> squares[-1]\n25\n>>> squares[-3:] # 切片操作将返回一个新列表\n[9, 16, 25]\n列表还支持合并操作：\n>>> squares + [36, 49, 64, 81, 100]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n与 immutable 字符串不同, 列表是 mutable 类型，其内容可以改变：\n>>> cubes = [1, 8, 27, 65, 125] # 这里有点问题\n>>> 4 ** 3 # 4 的立方是 64，不是 65！\n64\n>>> cubes[3] = 64 # 替换错误的值\n>>> cubes\n[1, 8, 27, 64, 125]\n你也可以通过使用 list.append() 方法，在列表末尾添加新条目（我们将在后文看到有关方法的更\n多介绍）:\n>>> cubes.append(216) # 添加 6 的立方\n>>> cubes.append(7 ** 3) # 和 7 的立方\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\nPython 中的简单赋值绝不会复制数据。 当你将一个列表赋值给一个变量时，该变量将引用 现有的\n列表。你通过一个变量对列表所做的任何更改都会被引用它的所有其他变量看到。:\n>>> rgb = [\"Red\", \"Green\", \"Blue\"]\n>>> rgba = rgb\n>>> id(rgb) == id(rgba) # 它们指向同一个对象\nTrue\n>>> rgba.append(\"Alph\")\n>>> rgb\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n切片操作返回包含请求元素的新列表。以下切片操作会返回列表的 浅拷贝：\n\n|  | 3.1.3. 列表\nPython 支持多种 复合 数据类型，可将不同值组合在一起。最常用的 列表 ，是用方括号标注，逗号\n分隔的一组值。列表 可以包含不同类型的元素，但一般情况下，各个元素的类型相同： |  |\n| --- | --- | --- |\n|  | >>> squares = [1, 4, 9, 16, 25]\n>>> squares\n[1, 4, 9, 16, 25] |  |\n|  | 和字符串（及其他内置 sequence 类型）一样，列表也支持索引和切片： |  |\n|  | >>> squares[0] # 索引操作将返回条目\n1\n>>> squares[-1]\n25\n>>> squares[-3:] # 切片操作将返回一个新列表\n[9, 16, 25] |  |\n|  | 列表还支持合并操作： |  |\n|  | >>> squares + [36, 49, 64, 81, 100]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] |  |\n|  | 与 immutable 字符串不同, 列表是 mutable 类型，其内容可以改变： |  |\n|  | >>> cubes = [1, 8, 27, 65, 125] # 这里有点问题\n>>> 4 ** 3 # 4 的立方是 64，不是 65！\n64\n>>> cubes[3] = 64 # 替换错误的值\n>>> cubes\n[1, 8, 27, 64, 125] |  |\n|  | 你也可以通过使用 list.append() 方法，在列表末尾添加新条目（我们将在后文看到有关方法的更\n多介绍）: |  |\n|  | >>> cubes.append(216) # 添加 6 的立方\n>>> cubes.append(7 ** 3) # 和 7 的立方\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343] |  |\n|  | Python 中的简单赋值绝不会复制数据。 当你将一个列表赋值给一个变量时，该变量将引用 现有的\n列表。你通过一个变量对列表所做的任何更改都会被引用它的所有其他变量看到。: |  |\n|  | >>> rgb = [\"Red\", \"Green\", \"Blue\"]\n>>> rgba = rgb\n>>> id(rgb) == id(rgba) # 它们指向同一个对象\nTrue\n>>> rgba.append(\"Alph\")\n>>> rgb\n[\"Red\", \"Green\", \"Blue\", \"Alph\"] |  |\n|  | 切片操作返回包含请求元素的新列表。以下切片操作会返回列表的 浅拷贝： |  |\n\n>>> correct_rgba = rgba[:]\n>>> correct_rgba[-1] = \"Alpha\"\n>>> correct_rgba\n[\"Red\", \"Green\", \"Blue\", \"Alpha\"]\n>>> rgba\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n为切片赋值可以改变列表大小，甚至清空整个列表：\n>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> letters\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> # 替换一些值\n>>> letters[2:5] = ['C', 'D', 'E']\n>>> letters\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n>>> # 现在移除它们\n>>> letters[2:5] = []\n>>> letters\n['a', 'b', 'f', 'g']\n>>> # 通过用一个空列表替代所有元素来清空列表\n>>> letters[:] = []\n>>> letters\n[]\n内置函数 len() 也支持列表：\n>>> letters = ['a', 'b', 'c', 'd']\n>>> len(letters)\n4\n还可以嵌套列表（创建包含其他列表的列表），例如：\n>>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b'\n3.2. 走向编程的第一步\n当然，我们还能用 Python 完成比二加二更复杂的任务。 例如，我们可以像下面这样写出 斐波那契\n数列 初始部分的子序列:\n>>> # 斐波那契数列：\n>>> # 前两项之和即下一项的值\n>>> a, b = 0, 1\n>>> while a < 10:\n... print(a)\n... a, b = b, a+b\n...\n\n|  | >>> correct_rgba = rgba[:]\n>>> correct_rgba[-1] = \"Alpha\"\n>>> correct_rgba\n[\"Red\", \"Green\", \"Blue\", \"Alpha\"]\n>>> rgba\n[\"Red\", \"Green\", \"Blue\", \"Alph\"] |  |\n| --- | --- | --- |\n|  | 为切片赋值可以改变列表大小，甚至清空整个列表： |  |\n|  | >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> letters\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> # 替换一些值\n>>> letters[2:5] = ['C', 'D', 'E']\n>>> letters\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n>>> # 现在移除它们\n>>> letters[2:5] = []\n>>> letters\n['a', 'b', 'f', 'g']\n>>> # 通过用一个空列表替代所有元素来清空列表\n>>> letters[:] = []\n>>> letters\n[] |  |\n|  | 内置函数 len() 也支持列表： |  |\n|  | >>> letters = ['a', 'b', 'c', 'd']\n>>> len(letters)\n4 |  |\n|  | 还可以嵌套列表（创建包含其他列表的列表），例如： |  |\n|  | >>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b' |  |\n|  | 3.2. 走向编程的第一步\n当然，我们还能用 Python 完成比二加二更复杂的任务。 例如，我们可以像下面这样写出 斐波那契\n数列 初始部分的子序列: |  |\n|  | >>> # 斐波那契数列：\n>>> # 前两项之和即下一项的值\n>>> a, b = 0, 1\n>>> while a < 10:\n... print(a)\n... a, b = b, a+b\n... |  |\n\n0\n1\n1\n2\n3\n5\n8\n本例引入了几个新功能。\n第一行中的 多重赋值 ：变量 a 和 b 同时获得新值 0 和 1 。最后一行又用了一次多重赋值，体现\n了，等号右边的所有表达式的值，都是在这一语句对任何变量赋新值之前求出来的——求值顺序\n为从左到右。\nwhile 循环只要条件（这里是 a < 10）为真就会一直执行。Python 和 C 一样，任何非零整数都\n为真，零为假。这个条件也可以是字符串或列表类型的值，事实上，任何序列都可以：长度非零\n就为真，空序列则为假。示例中的判断只是最简单的比较。比较操作符的写法和 C 语言一样： <\n（小于）、 > （大于）、 == （等于）、 <= （小于等于)、 >= （大于等于）及 != （不等于）。\n循环体 是 缩进的 ：缩进是 Python 组织语句的方式。在交互式命令行里，得为每个缩进的行输入\n空格（或制表符）。使用文本编辑器可以实现更复杂的输入方式；所有像样的文本编辑器都支持\n自动缩进。交互式输入复合语句时，要在最后输入空白行表示完成（因为解析器不知道哪一行代\n码是代码块的最后一行）。注意，同一块语句的每一行的缩进相同。\nprint() 函数输出给定参数的值。 除了可以以单一的表达式作为参数（比如，前面的计算器的例\n子），它还能处理多个参数，包括浮点数与字符串。 它输出的字符串不带引号，且各参数项之间\n会插入一个空格，这样可以实现更好的格式化操作，就像这样:\n>>> i = 256*256\n>>> print('The value of i is', i)\nThe value of i is 65536\n关键字参数 end 可以取消输出后面的换行, 或用另一个字符串结尾：\n>>> a, b = 0, 1\n>>> while a < 1000:\n... print(a, end=',')\n... a, b = b, a+b\n...\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n备注\n[1] ** 比 - 的优先级更高, 所以 -3**2 会被解释成 -(3**2) ，因此，结果是 -9。要避免这个问\n题，并且得到 9, 可以用 (-3)**2。\n[2] 与其他语言不同，特殊字符如 \\n 在单引号（'...' ）和双引号（\"...\" ）里的意义一样。这\n两种引号唯一的区别是，不需要在单引号里转义双引号 \" （但此时必须把单引号转义成 \\'\n），反之亦然。\n\n| 0\n1\n1\n2\n3\n5\n8 |\n| --- |\n| 本例引入了几个新功能。\n第一行中的 多重赋值 ：变量 a 和 b 同时获得新值 0 和 1 。最后一行又用了一次多重赋值，体现\n了，等号右边的所有表达式的值，都是在这一语句对任何变量赋新值之前求出来的——求值顺序\n为从左到右。\nwhile 循环只要条件（这里是 a < 10）为真就会一直执行。Python 和 C 一样，任何非零整数都\n为真，零为假。这个条件也可以是字符串或列表类型的值，事实上，任何序列都可以：长度非零\n就为真，空序列则为假。示例中的判断只是最简单的比较。比较操作符的写法和 C 语言一样： <\n（小于）、 > （大于）、 == （等于）、 <= （小于等于)、 >= （大于等于）及 != （不等于）。\n循环体 是 缩进的 ：缩进是 Python 组织语句的方式。在交互式命令行里，得为每个缩进的行输入\n空格（或制表符）。使用文本编辑器可以实现更复杂的输入方式；所有像样的文本编辑器都支持\n自动缩进。交互式输入复合语句时，要在最后输入空白行表示完成（因为解析器不知道哪一行代\n码是代码块的最后一行）。注意，同一块语句的每一行的缩进相同。\nprint() 函数输出给定参数的值。 除了可以以单一的表达式作为参数（比如，前面的计算器的例\n子），它还能处理多个参数，包括浮点数与字符串。 它输出的字符串不带引号，且各参数项之间\n会插入一个空格，这样可以实现更好的格式化操作，就像这样:\n>>> i = 256*256\n>>> print('The value of i is', i)\nThe value of i is 65536\n关键字参数 end 可以取消输出后面的换行, 或用另一个字符串结尾：\n>>> a, b = 0, 1\n>>> while a < 1000:\n... print(a, end=',')\n... a, b = b, a+b\n...\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n备注\n[1] ** 比 - 的优先级更高, 所以 -3**2 会被解释成 -(3**2) ，因此，结果是 -9。要避免这个问\n题，并且得到 9, 可以用 (-3)**2。\n[2] 与其他语言不同，特殊字符如 \\n 在单引号（'...' ）和双引号（\"...\" ）里的意义一样。这\n两种引号唯一的区别是，不需要在单引号里转义双引号 \" （但此时必须把单引号转义成 \\'\n），反之亦然。 |", "metadata": {"title": "03_Python_速览", "source": "md_docs\\python_docs_md\\03_Python_速览.md", "doc_type": "教程", "language": "中文", "doc_id": "571ab068"}}
{"doc_id": "95bf8892", "content": "4. 更多控制流工具\n除了刚介绍的 while 语句，Python 还用了一些别的。我们将在本章中遇到它们。\n4.1. if 语句\n最让人耳熟能详的语句应当是 if 语句：\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n... x = 0\n... print('Negative changed to zero')\n... elif x == 0:\n... print('Zero')\n... elif x == 1:\n... print('Single')\n... else:\n... print('More')\n...\n更多\n可有零个或多个 elif 部分，else 部分也是可选的。关键字 'elif' 是 'else if' 的缩写，用于避免过\n多的缩进。if ... elif ... elif ... 序列可以当作其它语言中 switch 或 case 语句的替代品。\n如果是把一个值与多个常量进行比较，或者检查特定类型或属性，match 语句更有用。详见 match\n语句。\n4.2. for 语句\nPython 的 for 语句与 C 或 Pascal 中的不同。Python 的 for 语句不迭代算术递增数值（如\nPascal），或是给予用户定义迭代步骤和结束条件的能力（如 C），而是在列表或字符串等任意序列\n的元素上迭代，按它们在序列中出现的顺序。 例如（这不是有意要暗指什么）：\n>>> # 度量一些字符串：\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n... print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\n很难正确地在迭代多项集的同时修改多项集的内容。更简单的方法是迭代多项集的副本或者创建新\n的多项集：\n# 创建示例多项集\nusers = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n\n| 4. 更多控制流工具\n除了刚介绍的 while 语句，Python 还用了一些别的。我们将在本章中遇到它们。\n4.1. if 语句\n最让人耳熟能详的语句应当是 if 语句： |\n| --- |\n| >>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n... x = 0\n... print('Negative changed to zero')\n... elif x == 0:\n... print('Zero')\n... elif x == 1:\n... print('Single')\n... else:\n... print('More')\n...\n更多 |\n| 可有零个或多个 elif 部分，else 部分也是可选的。关键字 'elif' 是 'else if' 的缩写，用于避免过\n多的缩进。if ... elif ... elif ... 序列可以当作其它语言中 switch 或 case 语句的替代品。\n如果是把一个值与多个常量进行比较，或者检查特定类型或属性，match 语句更有用。详见 match\n语句。\n4.2. for 语句\nPython 的 for 语句与 C 或 Pascal 中的不同。Python 的 for 语句不迭代算术递增数值（如\nPascal），或是给予用户定义迭代步骤和结束条件的能力（如 C），而是在列表或字符串等任意序列\n的元素上迭代，按它们在序列中出现的顺序。 例如（这不是有意要暗指什么）： |\n| >>> # 度量一些字符串：\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n... print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12 |\n| 很难正确地在迭代多项集的同时修改多项集的内容。更简单的方法是迭代多项集的副本或者创建新\n的多项集： |\n| # 创建示例多项集\nusers = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'} |\n\n# 策略：迭代一个副本\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# 策略：创建一个新多项集\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status\n4.3. range() 函数\n内置函数 range() 用于生成等差数列：\n>>> for i in range(5):\n... print(i)\n...\n0\n1\n2\n3\n4\n生成的序列绝不会包括给定的终止值；range(10) 生成 10 个值——长度为 10 的序列的所有合法索\n引。range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）：\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\n要按索引迭代序列，可以组合使用 range() 和 len()：\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n... print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\n不过大多数情况下 enumerate() 函数很方便，详见 循环的技巧。\n如果直接打印一个 range 会发生意想不到的事情：\n>>> range(10)\nrange(0, 10)\n\n|  | # 策略：迭代一个副本\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# 策略：创建一个新多项集\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status |  |\n| --- | --- | --- |\n|  | 4.3. range() 函数\n内置函数 range() 用于生成等差数列： |  |\n|  | >>> for i in range(5):\n... print(i)\n...\n0\n1\n2\n3\n4 |  |\n|  | 生成的序列绝不会包括给定的终止值；range(10) 生成 10 个值——长度为 10 的序列的所有合法索\n引。range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）： |  |\n|  | >>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70] |  |\n|  | 要按索引迭代序列，可以组合使用 range() 和 len()： |  |\n|  | >>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n... print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb |  |\n|  | 不过大多数情况下 enumerate() 函数很方便，详见 循环的技巧。\n如果直接打印一个 range 会发生意想不到的事情： |  |\n|  | >>> range(10)\nrange(0, 10) |  |\n\nrange() 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代\n时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空\n间。\n这种对象称为可迭代对象 iterable，适合作为需要获取一系列值的函数或程序构件的参数。for 语句\n就是这样的程序构件；以可迭代对象作为参数的函数例如 sum()：\n>>> sum(range(4)) # 0 + 1 + 2 + 3\n6\n之后我们会看到更多返回可迭代对象，或以可迭代对象作为参数的函数。在 数据结构 这一章中，我\n们将讨论 list() 的更多细节。\n4.4. break 和 continue 语句\nbreak 语句将跳出最近的一层 for 或 while 循环:\n>>> for n in range(2, 10):\n... for x in range(2, n):\n... if n % x == 0:\n... print(f\"{n} equals {x} * {n//x}\")\n... break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\ncontinue 语句将继续执行循环的下一次迭代:\n>>> for num in range(2, 10):\n... if num % 2 == 0:\n... print(f\"Found an even number {num}\")\n... continue\n... print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n4.5. 循环的 else 子句\n在 for 或 while 循环中 break 语句可能对应一个 else 子句。 如果循环在未执行 break 的情况下\n结束，else 子句将会执行。\n在 for 循环中，else 子句会在循环结束其他最后一次迭代之后，即未执行 break 的情况下被执行。\n\n|  | range() 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代\n时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空\n间。\n这种对象称为可迭代对象 iterable，适合作为需要获取一系列值的函数或程序构件的参数。for 语句\n就是这样的程序构件；以可迭代对象作为参数的函数例如 sum()： |  |\n| --- | --- | --- |\n|  | >>> sum(range(4)) # 0 + 1 + 2 + 3\n6 |  |\n|  | 之后我们会看到更多返回可迭代对象，或以可迭代对象作为参数的函数。在 数据结构 这一章中，我\n们将讨论 list() 的更多细节。\n4.4. break 和 continue 语句\nbreak 语句将跳出最近的一层 for 或 while 循环: |  |\n|  | >>> for n in range(2, 10):\n... for x in range(2, n):\n... if n % x == 0:\n... print(f\"{n} equals {x} * {n//x}\")\n... break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3 |  |\n|  | continue 语句将继续执行循环的下一次迭代: |  |\n|  | >>> for num in range(2, 10):\n... if num % 2 == 0:\n... print(f\"Found an even number {num}\")\n... continue\n... print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9 |  |\n|  | 4.5. 循环的 else 子句\n在 for 或 while 循环中 break 语句可能对应一个 else 子句。 如果循环在未执行 break 的情况下\n结束，else 子句将会执行。\n在 for 循环中，else 子句会在循环结束其他最后一次迭代之后，即未执行 break 的情况下被执行。 |  |\n\n在 while 循环中，它会在循环条件变为假值后执行。\n在这两类循环中，当在循环被 break 终结时 else 子句 不会 被执行。 当然，其他提前结束循环的\n方式，如 return 或是引发异常，也会跳过 else 子句的执行。\n下面的搜索质数的 for 循环就是一个例子：\n>>> for n in range(2, 10):\n... for x in range(2, n):\n... if n % x == 0:\n... print(n, 'equals', x, '*', n//x)\n... break\n... else:\n... # 循环到底未找到一个因数\n... print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n（对，这是正确的代码。 仔细看：其中 else 子句属于 for 循环，而 不属于 if 语句。）\n分析 else 子句的一种方式是想象它对应于循环内的 if。 当循环执行时，它将运行一系列的\nif/if/if/else。 if 位于循环内部，会出现多次。 当出现条件为真的情况时，将发生 break。 如果条\n件一直不为真，则循环外的 else 子句将被执行。\n当配合循环使用时，else 子句更像是 try 语句的 else 子句而不像 if 语句的相应子句：一个 try\n语句的 else 子句会在未发生异常时运行，而一个循环的 else 子句会在未发生 break 时运行。 有\n关 try 语句和异常的详情，请参阅 异常的处理。\n4.6. pass 语句\npass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。\n例如：\n>>> while True:\n... pass # 无限等待键盘中断 (Ctrl+C)\n...\n这常用于创建一个最小的类：\n>>> class MyEmptyClass:\n... pass\n...\npass 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。pass 会被默默地\n忽略：\n\n|  | 在 while 循环中，它会在循环条件变为假值后执行。\n在这两类循环中，当在循环被 break 终结时 else 子句 不会 被执行。 当然，其他提前结束循环的\n方式，如 return 或是引发异常，也会跳过 else 子句的执行。\n下面的搜索质数的 for 循环就是一个例子： |  |\n| --- | --- | --- |\n|  | >>> for n in range(2, 10):\n... for x in range(2, n):\n... if n % x == 0:\n... print(n, 'equals', x, '*', n//x)\n... break\n... else:\n... # 循环到底未找到一个因数\n... print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3 |  |\n|  | （对，这是正确的代码。 仔细看：其中 else 子句属于 for 循环，而 不属于 if 语句。）\n分析 else 子句的一种方式是想象它对应于循环内的 if。 当循环执行时，它将运行一系列的\nif/if/if/else。 if 位于循环内部，会出现多次。 当出现条件为真的情况时，将发生 break。 如果条\n件一直不为真，则循环外的 else 子句将被执行。\n当配合循环使用时，else 子句更像是 try 语句的 else 子句而不像 if 语句的相应子句：一个 try\n语句的 else 子句会在未发生异常时运行，而一个循环的 else 子句会在未发生 break 时运行。 有\n关 try 语句和异常的详情，请参阅 异常的处理。\n4.6. pass 语句\npass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。\n例如： |  |\n|  | >>> while True:\n... pass # 无限等待键盘中断 (Ctrl+C)\n... |  |\n|  | 这常用于创建一个最小的类： |  |\n|  | >>> class MyEmptyClass:\n... pass\n... |  |\n|  | pass 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。pass 会被默默地\n忽略： |  |\n\n>>> def initlog(*args):\n... pass # 记得实现这个！\n...\n对于这后一种情况，许多人会使用省略符字面值 ... 而不是 pass。 这种用法在 Python 中没有特殊\n含义，也不是语言定义的一部分（这里你可以使用任意常量表达式），但 ... 在传统上也被用作占\n位符号。 参见 省略符对象。\n4.7. match 语句\nmatch 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上\n像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或\nHaskell 中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的\n元素或对象的属性）赋给变量。如果没有匹配的case，则不执行任何分支。\n最简单的形式是将一个主语值与一个或多个字面值进行比较：\ndef http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\"\n注意最后一个代码块：“变量名” _ 被作为 通配符 并必定会匹配成功。\n你可以用 | （“或”）将多个字面值组合到一个模式中：\ncase 401 | 403 | 404:\nreturn \"Not allowed\"\n形如解包赋值的模式可被用于绑定变量：\n# point 是一个 (x, y) 元组\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\")\n请仔细学习此代码！第一个模式有两个字面值，可视为前述字面值模式的扩展。接下来的两个模式\n结合了一个字面值和一个变量，变量 绑定 了来自主语（point）的一个值。第四个模式捕获了两个\n\n|  | >>> def initlog(*args):\n... pass # 记得实现这个！\n... |  |\n| --- | --- | --- |\n|  | 对于这后一种情况，许多人会使用省略符字面值 ... 而不是 pass。 这种用法在 Python 中没有特殊\n含义，也不是语言定义的一部分（这里你可以使用任意常量表达式），但 ... 在传统上也被用作占\n位符号。 参见 省略符对象。\n4.7. match 语句\nmatch 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上\n像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或\nHaskell 中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的\n元素或对象的属性）赋给变量。如果没有匹配的case，则不执行任何分支。\n最简单的形式是将一个主语值与一个或多个字面值进行比较： |  |\n|  | def http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\" |  |\n|  | 注意最后一个代码块：“变量名” _ 被作为 通配符 并必定会匹配成功。\n你可以用 | （“或”）将多个字面值组合到一个模式中： |  |\n|  | case 401 | 403 | 404:\nreturn \"Not allowed\" |  |\n|  | 形如解包赋值的模式可被用于绑定变量： |  |\n|  | # point 是一个 (x, y) 元组\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\") |  |\n|  | 请仔细学习此代码！第一个模式有两个字面值，可视为前述字面值模式的扩展。接下来的两个模式\n结合了一个字面值和一个变量，变量 绑定 了来自主语（point）的一个值。第四个模式捕获了两个 |  |\n\n值，使其在概念上与解包赋值 (x, y) = point 类似。\n如果用类组织数据，可以用“类名后接一个参数列表”这种很像构造器的形式，把属性捕获到变量里：\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\")\n一些内置类（如 dataclass）为属性提供了一个顺序，此时，可以使用位置参数。自定义类可通过在\n类中设置特殊属性 __match_args__，为属性指定其在模式中对应的位置。若设为 (\"x\", \"y\")，则以下\n模式相互等价（且都把属性 y 绑定到变量 var）：\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\n建议这样来阅读一个模式——通过将其视为赋值语句等号左边的一种扩展形式，来理解各个变量被\n设为何值。match 语句只会为单一的名称（如上面的 var）赋值，而不会赋值给带点号的名称（如\nfoo.bar）、属性名（如上面的 x= 和 y=）和类名（是通过其后的 \"(...)\" 来识别的，如上面的\nPoint）。\n模式可以任意嵌套。举例来说，如果我们有一个由 Point 组成的列表，且 Point 添加了\n__match_args__ 时，我们可以这样来匹配它：\nclass Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\")\n\n|  | 值，使其在概念上与解包赋值 (x, y) = point 类似。\n如果用类组织数据，可以用“类名后接一个参数列表”这种很像构造器的形式，把属性捕获到变量里： |  |\n| --- | --- | --- |\n|  | class Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\") |  |\n|  | 一些内置类（如 dataclass）为属性提供了一个顺序，此时，可以使用位置参数。自定义类可通过在\n类中设置特殊属性 __match_args__，为属性指定其在模式中对应的位置。若设为 (\"x\", \"y\")，则以下\n模式相互等价（且都把属性 y 绑定到变量 var）： |  |\n|  | Point(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1) |  |\n|  | 建议这样来阅读一个模式——通过将其视为赋值语句等号左边的一种扩展形式，来理解各个变量被\n设为何值。match 语句只会为单一的名称（如上面的 var）赋值，而不会赋值给带点号的名称（如\nfoo.bar）、属性名（如上面的 x= 和 y=）和类名（是通过其后的 \"(...)\" 来识别的，如上面的\nPoint）。\n模式可以任意嵌套。举例来说，如果我们有一个由 Point 组成的列表，且 Point 添加了\n__match_args__ 时，我们可以这样来匹配它： |  |\n|  | class Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\") |  |\n\ncase _:\nprint(\"Something else\")\n我们可以为模式添加 if 作为守卫子句。如果守卫子句的值为假，那么 match 会继续尝试匹配下一\n个 case 块。注意是先将值捕获，再对守卫子句求值：\nmatch point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\")\n该语句的一些其它关键特性：\n与解包赋值类似，元组和列表模式具有完全相同的含义并且实际上都能匹配任意序列，区别是它\n们不能匹配迭代器或字符串。\n序列模式支持扩展解包：[x, y, *rest] 和 (x, y, *rest) 和相应的解包赋值做的事是一样\n的。接在 * 后的名称也可以为 _，所以 (x, y, *_) 匹配含至少两项的序列，而不必绑定剩余的\n项。\n映射模式：{\"bandwidth\": b, \"latency\": l} 从字典中捕获 \"bandwidth\" 和 \"latency\" 的\n值。额外的键会被忽略，这一点与序列模式不同。**rest 这样的解包也支持。（但 **_ 将会是\n冗余的，故不允许使用。）\n使用 as 关键字可以捕获子模式：\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\n将把输入中的第二个元素捕获为 p2 （只要输入是包含两个点的序列）\n大多数字面值是按相等性比较的，但是单例对象 True、False 和 None 则是按 id 比较的。\n模式可以使用具名常量。它们必须作为带点号的名称出现，以防止它们被解释为用于捕获的变\n量：\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\")\n\n|  | case _:\nprint(\"Something else\") |  |\n| --- | --- | --- |\n|  | 我们可以为模式添加 if 作为守卫子句。如果守卫子句的值为假，那么 match 会继续尝试匹配下一\n个 case 块。注意是先将值捕获，再对守卫子句求值： |  |\n|  | match point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\") |  |\n|  | 该语句的一些其它关键特性：\n与解包赋值类似，元组和列表模式具有完全相同的含义并且实际上都能匹配任意序列，区别是它\n们不能匹配迭代器或字符串。\n序列模式支持扩展解包：[x, y, *rest] 和 (x, y, *rest) 和相应的解包赋值做的事是一样\n的。接在 * 后的名称也可以为 _，所以 (x, y, *_) 匹配含至少两项的序列，而不必绑定剩余的\n项。\n映射模式：{\"bandwidth\": b, \"latency\": l} 从字典中捕获 \"bandwidth\" 和 \"latency\" 的\n值。额外的键会被忽略，这一点与序列模式不同。**rest 这样的解包也支持。（但 **_ 将会是\n冗余的，故不允许使用。）\n使用 as 关键字可以捕获子模式：\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\n将把输入中的第二个元素捕获为 p2 （只要输入是包含两个点的序列）\n大多数字面值是按相等性比较的，但是单例对象 True、False 和 None 则是按 id 比较的。\n模式可以使用具名常量。它们必须作为带点号的名称出现，以防止它们被解释为用于捕获的变\n量：\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\") |  |\n\n更详细的说明和更多示例，可参阅以教程格式撰写的 PEP 636。\n4.8. 定义函数\n下列代码创建一个可以输出限定数值内的斐波那契数列函数：\n>>> def fib(n): # 打印小于 n 的斐波那契数列\n... \"\"\"Print a Fibonacci series less than n.\"\"\"\n... a, b = 0, 1\n... while a < n:\n... print(a, end=' ')\n... a, b = b, a+b\n... print()\n...\n>>> # 现在调用我们刚定义的函数：\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩\n进。\n函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring，详见 文档字符串。\n利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文\n档；Python 开发者最好养成在代码中加入文档字符串的好习惯。\n函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首\n先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称\n符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是\nglobal 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）。\n在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调\n用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 [1] 当一个函数调用另外一个函数\n时，会为该调用创建一个新的局部符号表。\n函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自\n定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n如果你用过其他语言，你可能会认为 fib 不是函数而是一个过程，因为它没有返回值。 事实上，即\n使没有 return 语句的函数也有返回值，尽管这个值可能相当无聊。 这个值被称为 None (是一个内\n置名称)。 通常解释器会屏蔽单独的返回值 None。 如果你确有需要可以使用 print() 查看它:\n>>> fib(0)\n>>> print(fib(0))\nNone\n\n|  | 更详细的说明和更多示例，可参阅以教程格式撰写的 PEP 636。\n4.8. 定义函数\n下列代码创建一个可以输出限定数值内的斐波那契数列函数： |  |\n| --- | --- | --- |\n|  | >>> def fib(n): # 打印小于 n 的斐波那契数列\n... \"\"\"Print a Fibonacci series less than n.\"\"\"\n... a, b = 0, 1\n... while a < n:\n... print(a, end=' ')\n... a, b = b, a+b\n... print()\n...\n>>> # 现在调用我们刚定义的函数：\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 |  |\n|  | 定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩\n进。\n函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring，详见 文档字符串。\n利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文\n档；Python 开发者最好养成在代码中加入文档字符串的好习惯。\n函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首\n先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称\n符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是\nglobal 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）。\n在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调\n用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 [1] 当一个函数调用另外一个函数\n时，会为该调用创建一个新的局部符号表。\n函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自\n定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数： |  |\n|  | >>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89 |  |\n|  | 如果你用过其他语言，你可能会认为 fib 不是函数而是一个过程，因为它没有返回值。 事实上，即\n使没有 return 语句的函数也有返回值，尽管这个值可能相当无聊。 这个值被称为 None (是一个内\n置名称)。 通常解释器会屏蔽单独的返回值 None。 如果你确有需要可以使用 print() 查看它: |  |\n|  | >>> fib(0)\n>>> print(fib(0))\nNone |  |\n|  |  |  |\n\n编写不直接输出斐波那契数列运算结果，而是返回运算结果列表的函数也非常简单：\n>>> def fib2(n): # 返回斐波那契数组直到 n\n... \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n... result = []\n... a, b = 0, 1\n... while a < n:\n... result.append(a) # 见下\n... a, b = b, a+b\n... return result\n...\n>>> f100 = fib2(100) # 调用它\n>>> f100 # 输出结果\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n本例也新引入了一些 Python 功能：\nreturn 语句返回函数的值。return 语句不带表达式参数时，返回 None。函数执行完毕退出也\n返回 None。\n语句 result.append(a) 调用了列表对象 result 的 方法。 方法是‘从属于’对象的函数，其名称\n为 obj.methodname，其中 obj 是某个对象（可以是一个表达式），methodname 是由对象的类\n型定义的方法名称。 不同的类型定义了不同的方法。 不同的类型的方法可以使用相同的名称而不\n会产生歧义。 （使用 类 可以定义自己的对象类型和方法，参见 类。） 在示例中显示的方法\nappend() 是由列表对象定义的；它会在列表的末尾添加一个新元素。 在本例中它等同于 result\n= result + [a]，但效率更高。\n4.9. 函数定义详解\n函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。\n4.9.1. 默认值参数\n为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder)\n该函数可以用以下方式调用：\n只给出必选实参：ask_ok('Do you really want to quit?')\n给出一个可选实参：ask_ok('OK to overwrite the file?', 2)\n给出所有实参：ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\n\n|  |  | 编写不直接输出斐波那契数列运算结果，而是返回运算结果列表的函数也非常简单： |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | >>> def fib2(n): # 返回斐波那契数组直到 n\n... \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n... result = []\n... a, b = 0, 1\n... while a < n:\n... result.append(a) # 见下\n... a, b = b, a+b\n... return result\n...\n>>> f100 = fib2(100) # 调用它\n>>> f100 # 输出结果\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] |  |  |  |\n|  |  | 本例也新引入了一些 Python 功能：\nreturn 语句返回函数的值。return 语句不带表达式参数时，返回 None。函数执行完毕退出也\n返回 None。\n语句 result.append(a) 调用了列表对象 result 的 方法。 方法是‘从属于’对象的函数，其名称\n为 obj.methodname，其中 obj 是某个对象（可以是一个表达式），methodname 是由对象的类\n型定义的方法名称。 不同的类型定义了不同的方法。 不同的类型的方法可以使用相同的名称而不\n会产生歧义。 （使用 类 可以定义自己的对象类型和方法，参见 类。） 在示例中显示的方法\nappend() 是由列表对象定义的；它会在列表的末尾添加一个新元素。 在本例中它等同于 result\n= result + [a]，但效率更高。\n4.9. 函数定义详解\n函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。\n4.9.1. 默认值参数\n为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如： |  |  |  |\n|  |  |  | result |  |  |\n|  |  |  |  |  |  |\n|  |  | = result + [a] |  |  |  |\n|  |  |  |  |  |  |\n|  |  | def ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder) |  |  |  |\n|  |  | 该函数可以用以下方式调用：\n只给出必选实参：ask_ok('Do you really want to quit?')\n给出一个可选实参：ask_ok('OK to overwrite the file?', 2)\n给出所有实参：ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') |  |  |  |\n\n本例还使用了关键字 in ，用于确认序列中是否包含某个值。\n默认值在 定义 作用域里的函数定义中求值，所以：\ni = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf()\n上例输出的是 5。\n重要警告： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同\n的结果。例如，下面的函数会累积后续调用时传递的参数：\ndef f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3))\n输出结果如下：\n[1]\n[1, 2]\n[1, 2, 3]\n不想在后续调用之间共享默认值时，应以如下方式编写函数：\ndef f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L\n4.9.2. 关键字参数\nkwarg=value 形式的 关键字参数 也可以用于调用函数。函数示例如下：\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\")\n该函数接受一个必选参数（voltage）和三个可选参数（state, action 和 type）。该函数可用下\n列方式调用：\nparrot(1000) # 1 个位置参数\nparrot(voltage=1000) # 1 个关键字参数\n\n|  | 本例还使用了关键字 in ，用于确认序列中是否包含某个值。\n默认值在 定义 作用域里的函数定义中求值，所以： |  |\n| --- | --- | --- |\n|  | i = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf() |  |\n|  | 上例输出的是 5。\n重要警告： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同\n的结果。例如，下面的函数会累积后续调用时传递的参数： |  |\n|  | def f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3)) |  |\n|  | 输出结果如下： |  |\n|  | [1]\n[1, 2]\n[1, 2, 3] |  |\n|  | 不想在后续调用之间共享默认值时，应以如下方式编写函数： |  |\n|  | def f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L |  |\n|  | 4.9.2. 关键字参数\nkwarg=value 形式的 关键字参数 也可以用于调用函数。函数示例如下： |  |\n|  | def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\") |  |\n|  | 该函数接受一个必选参数（voltage）和三个可选参数（state, action 和 type）。该函数可用下\n列方式调用： |  |\n|  | parrot(1000) # 1 个位置参数\nparrot(voltage=1000) # 1 个关键字参数 |  |\n|  |  |  |\n\nparrot(voltage=1000000, action='VOOOOOM') # 2 个关键字参数\nparrot(action='VOOOOOM', voltage=1000000) # 2 个关键字参数\nparrot('a million', 'bereft of life', 'jump') # 3 个位置参数\nparrot('a thousand', state='pushing up the daisies') # 1 个位置参数，1 个关键字参数\n以下调用函数的方式都无效：\nparrot() # 缺失必需的参数\nparrot(voltage=5.0, 'dead') # 关键字参数后存在非关键字参数\nparrot(110, voltage=220) # 同一个参数重复的值\nparrot(actor='John Cleese') # 未知的关键字参数\n函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受\n的参数（比如，actor 不是函数 parrot 的有效参数），关键字参数的顺序并不重要。这也包括必\n选参数，（比如，parrot(voltage=1000) 也有效）。不能对同一个参数多次赋值，下面就是一个\n因此限制而失败的例子：\n>>> def function(a):\n... pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\n最后一个形参为 **name 形式时，接收一个字典（详见 映射类型 --- dict），该字典包含与函数中已\n定义形参对应之外的所有关键字参数。**name 形参可以与 *name 形参（下一小节介绍）组合使用\n（*name 必须在 **name 前面）， *name 形参接收一个 元组，该元组包含形参列表之外的位置参\n数。例如，可以定义下面这样的函数：\ndef cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw])\n该函数可以用如下方式调用：\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\")\n输出结果如下：\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n\n|  | parrot(voltage=1000000, action='VOOOOOM') # 2 个关键字参数\nparrot(action='VOOOOOM', voltage=1000000) # 2 个关键字参数\nparrot('a million', 'bereft of life', 'jump') # 3 个位置参数\nparrot('a thousand', state='pushing up the daisies') # 1 个位置参数，1 个关键字参数 |  |\n| --- | --- | --- |\n|  | 以下调用函数的方式都无效： |  |\n|  |  |  |\n|  | parrot() # 缺失必需的参数\nparrot(voltage=5.0, 'dead') # 关键字参数后存在非关键字参数\nparrot(110, voltage=220) # 同一个参数重复的值\nparrot(actor='John Cleese') # 未知的关键字参数 |  |\n|  | 函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受\n的参数（比如，actor 不是函数 parrot 的有效参数），关键字参数的顺序并不重要。这也包括必\n选参数，（比如，parrot(voltage=1000) 也有效）。不能对同一个参数多次赋值，下面就是一个\n因此限制而失败的例子： |  |\n|  | >>> def function(a):\n... pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a' |  |\n|  | 最后一个形参为 **name 形式时，接收一个字典（详见 映射类型 --- dict），该字典包含与函数中已\n定义形参对应之外的所有关键字参数。**name 形参可以与 *name 形参（下一小节介绍）组合使用\n（*name 必须在 **name 前面）， *name 形参接收一个 元组，该元组包含形参列表之外的位置参\n数。例如，可以定义下面这样的函数： |  |\n|  | def cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw]) |  |\n|  | 该函数可以用如下方式调用： |  |\n|  | cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\") |  |\n|  | 输出结果如下： |  |\n|  | -- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir. |  |\n\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\n注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。\n4.9.3. 特殊参数\n默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制\n参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键\n字，还是仅按关键字传递。\n函数定义如下：\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n----------- ---------- ----------\n| | |\n| 位置或关键字 |\n| - 仅限关键字\n-- 仅限位置\n/ 和 * 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关\n键字形参也叫作命名形参。\n4.9.3.1. 位置或关键字参数\n函数定义中未使用 / 和 * 时，参数可以按位置或关键字传递给函数。\n4.9.3.2. 仅位置参数\n此处再介绍一些细节，特定形参可以标记为 仅限位置。仅限位置 时，形参的顺序很重要，且这些形\n参不能用关键字传递。仅限位置形参应放在 / （正斜杠）前。/ 用于在逻辑上分割仅限位置形参与\n其它形参。如果函数定义中没有 /，则表示没有仅限位置形参。\n/ 后可以是 位置或关键字 或 仅限关键字 形参。\n4.9.3.3. 仅限关键字参数\n把形参标记为 仅限关键字，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 仅限关\n键字 形参前添加 *。\n4.9.3.4. 函数示例\n请看下面的函数定义示例，注意 / 和 * 标记：\n>>> def standard_arg(arg):\n... print(arg)\n...\n>>> def pos_only_arg(arg, /):\n... print(arg)\n\n|  | ----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch |  |\n| --- | --- | --- |\n|  | 注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。\n4.9.3. 特殊参数\n默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制\n参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键\n字，还是仅按关键字传递。\n函数定义如下： |  |\n|  | def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n----------- ---------- ----------\n| | |\n| 位置或关键字 |\n| - 仅限关键字\n-- 仅限位置 |  |\n|  | / 和 * 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关\n键字形参也叫作命名形参。\n4.9.3.1. 位置或关键字参数\n函数定义中未使用 / 和 * 时，参数可以按位置或关键字传递给函数。\n4.9.3.2. 仅位置参数\n此处再介绍一些细节，特定形参可以标记为 仅限位置。仅限位置 时，形参的顺序很重要，且这些形\n参不能用关键字传递。仅限位置形参应放在 / （正斜杠）前。/ 用于在逻辑上分割仅限位置形参与\n其它形参。如果函数定义中没有 /，则表示没有仅限位置形参。\n/ 后可以是 位置或关键字 或 仅限关键字 形参。\n4.9.3.3. 仅限关键字参数\n把形参标记为 仅限关键字，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 仅限关\n键字 形参前添加 *。\n4.9.3.4. 函数示例\n请看下面的函数定义示例，注意 / 和 * 标记： |  |\n|  | >>> def standard_arg(arg):\n... print(arg)\n...\n>>> def pos_only_arg(arg, /):\n... print(arg) |  |\n\n...\n>>> def kwd_only_arg(*, arg):\n... print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n... print(pos_only, standard, kwd_only)\n第一个函数定义 standard_arg 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按\n关键字传递参数：\n>>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2\n第二个函数 pos_only_arg 的函数定义中有 /，仅限使用位置形参：\n>>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arg\n第三个函数 kwd_only_arg 如在函数定义中通过 * 所指明的那样只允许关键字参数。\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3\n最后一个函数在同一个函数定义中，使用了全部三种调用惯例：\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword\n下面的函数定义中，kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突：\n\n|  | ...\n>>> def kwd_only_arg(*, arg):\n... print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n... print(pos_only, standard, kwd_only) |  |  |\n| --- | --- | --- | --- |\n|  | 第一个函数定义 standard_arg 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按\n关键字传递参数： |  |  |\n|  | >>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2 |  |  |\n|  | 第二个函数 pos_only_arg 的函数定义中有 /，仅限使用位置形参： |  |  |\n|  | >>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arg |  |  |\n|  | 第三个函数 kwd_only_arg 如在函数定义中通过 * 所指明的那样只允许关键字参数。 |  |  |\n|  | >>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3 |  |  |\n|  | 最后一个函数在同一个函数定义中，使用了全部三种调用惯例： |  |  |\n|  | >>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword |  |  |\n|  | 下面的函数定义中，kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突： |  |  |\n\ndef foo(name, **kwds):\nreturn 'name' in kwds\n调用该函数不可能返回 True，因为关键字 'name' 总与第一个形参绑定。例如：\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\n加上 / （仅限位置参数）后，就可以了。此时，函数定义把 name 当作位置参数，'name' 也可以作\n为关键字参数的键：\n>>> def foo(name, /, **kwds):\n... return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\n换句话说，仅限位置形参的名称可以在 **kwds 中使用，而不产生歧义。\n4.9.3.5. 小结\n以下用例决定哪些形参可以用于函数定义：\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n说明：\n使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参\n顺序时，或同时接收位置形参和关键字时，这种方式很有用。\n当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置\n时，才使用关键字。\n对于 API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的 API 变动。\n4.9.4. 任意实参列表\n调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中（详见 元组和序列 ）。\n在可变数量的实参之前，可能有若干个普通参数：\ndef write_multiple_items(file, separator, *args):\nfile.write(separator.join(args))\nvariadic 参数用于采集传递给函数的所有剩余参数，因此，它们通常在形参列表的末尾。*args 形参\n后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：\n>>> def concat(*args, sep=\"/\"):\n... return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n\n|  | def foo(name, **kwds):\nreturn 'name' in kwds |  |\n| --- | --- | --- |\n|  | 调用该函数不可能返回 True，因为关键字 'name' 总与第一个形参绑定。例如： |  |\n|  | >>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>> |  |\n|  | 加上 / （仅限位置参数）后，就可以了。此时，函数定义把 name 当作位置参数，'name' 也可以作\n为关键字参数的键： |  |\n|  | >>> def foo(name, /, **kwds):\n... return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue |  |\n|  | 换句话说，仅限位置形参的名称可以在 **kwds 中使用，而不产生歧义。\n4.9.3.5. 小结\n以下用例决定哪些形参可以用于函数定义： |  |\n|  | def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): |  |\n|  | 说明：\n使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参\n顺序时，或同时接收位置形参和关键字时，这种方式很有用。\n当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置\n时，才使用关键字。\n对于 API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的 API 变动。\n4.9.4. 任意实参列表\n调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中（详见 元组和序列 ）。\n在可变数量的实参之前，可能有若干个普通参数： |  |\n|  | def write_multiple_items(file, separator, *args):\nfile.write(separator.join(args)) |  |\n|  | variadic 参数用于采集传递给函数的所有剩余参数，因此，它们通常在形参列表的末尾。*args 形参\n后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数： |  |\n|  | >>> def concat(*args, sep=\"/\"):\n... return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus' |  |\n\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n4.9.5. 解包实参列表\n函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的\nrange() 函数要求独立的 start 和 stop 实参。如果这些参数不是独立的，则要在调用函数时，用 *\n操作符把实参从列表或元组解包出来：\n>>> list(range(3, 6)) # 附带两个参数的正常调用\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args)) # 附带从一个列表解包的参数的调用\n[3, 4, 5]\n同样，字典可以用 ** 操作符传递关键字参数：\n>>> def parrot(voltage, state='a stiff', action='voom'):\n... print(\"-- This parrot wouldn't\", action, end=' ')\n... print(\"if you put\", voltage, \"volts through it.\", end=' ')\n... print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin\n4.9.6. Lambda 表达式\nlambda 关键字用于创建小巧的匿名函数。lambda a, b: a+b 函数返回两个参数的和。Lambda 函\n数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常\n规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：\n>>> def make_incrementor(n):\n... return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\n上例用 lambda 表达式返回一个函数。 另一种用法是传入一个小函数作为参数。 例如，\nlist.sort() 接受排序键函数 key，它可以是一个 lambda 函数:\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. 文档字符串\n以下是文档字符串内容和格式的约定。\n\n|  | >>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus' |  |  |\n| --- | --- | --- | --- |\n|  | 4.9.5. 解包实参列表\n函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的\nrange() 函数要求独立的 start 和 stop 实参。如果这些参数不是独立的，则要在调用函数时，用 *\n操作符把实参从列表或元组解包出来： |  |  |\n|  | >>> list(range(3, 6)) # 附带两个参数的正常调用\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args)) # 附带从一个列表解包的参数的调用\n[3, 4, 5] |  |  |\n|  | 同样，字典可以用 ** 操作符传递关键字参数： |  |  |\n|  | >>> def parrot(voltage, state='a stiff', action='voom'):\n... print(\"-- This parrot wouldn't\", action, end=' ')\n... print(\"if you put\", voltage, \"volts through it.\", end=' ')\n... print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin |  |  |\n|  | 4.9.6. Lambda 表达式\nlambda 关键字用于创建小巧的匿名函数。lambda a, b: a+b 函数返回两个参数的和。Lambda 函\n数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常\n规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量： |  |  |\n|  | >>> def make_incrementor(n):\n... return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43 |  |  |\n|  | 上例用 lambda 表达式返回一个函数。 另一种用法是传入一个小函数作为参数。 例如，\nlist.sort() 接受排序键函数 key，它可以是一个 lambda 函数: |  |  |\n|  | >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] |  |  |\n|  | 4.9.7. 文档字符串\n以下是文档字符串内容和格式的约定。 |  |  |\n\n第一行应为对象用途的简短摘要。为保持简洁，不要在这里显式说明对象名或类型，因为可通过其\n他方式获取这些信息（除非该名称碰巧是描述函数操作的动词）。这一行应以大写字母开头，以句\n点结尾。\n文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。后面的行可包含若干\n段落，描述对象的调用约定、副作用等。\nPython 解析器不会删除 Python 中多行字符串字面值的缩进，因此，文档处理工具应在必要时删除\n缩进。这项操作遵循以下约定：文档字符串第一行 之后 的第一个非空行决定了整个文档字符串的缩\n进量（第一行通常与字符串开头的引号相邻，其缩进在字符串中并不明显，因此，不能用第一行的\n缩进），然后，删除字符串中所有行开头处与此缩进“等价”的空白符。不能有比此缩进更少的行，但\n如果出现了缩进更少的行，应删除这些行的所有前导空白符。转化制表符后（通常为 8 个空格），\n应测试空白符的等效性。\n下面是多行文档字符串的一个例子：\n>>> def my_function():\n... \"\"\"什么都不做，只是记录下来。\n...\n... 真的，它没有任何作用。\n... \"\"\"\n... pass\n...\n>>> print(my_function.__doc__)\n什么都不做，只是记录下来。\n真的，它没有任何作用。.\n4.9.8. 函数注解\n函数注解 是可选的用户自定义函数类型的元数据完整信息（详见 PEP 3107 和 PEP 484 ）。\n标注 是以字典形式存放在函数的 __annotations__ 属性中的而对函数的其他部分没有影响。 形参\n标注的定义方式是在形参名后加冒号，后面再跟一个将被求值为标注的值的表达式。 返回值标注的\n定义方式是加符号 ->，后面再跟一个表达式，它位于形参列表和表示 def 语句结束的冒号之间。\n下面的示例具有加了标注的一个必需参数、一个可选参数以及返回值:\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n... print(\"Annotations:\", f.__annotations__)\n... print(\"Arguments:\", ham, eggs)\n... return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>\nArguments: spam eggs\n'spam and eggs'\n4.10. 小插曲：编码风格\n现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 代码风格 了。 大多数语言都能以不同\n的风格被编写（或更准确地说，被格式化）；有些比其他的更具有可读性。 能让其他人轻松阅读你\n\n|  | 第一行应为对象用途的简短摘要。为保持简洁，不要在这里显式说明对象名或类型，因为可通过其\n他方式获取这些信息（除非该名称碰巧是描述函数操作的动词）。这一行应以大写字母开头，以句\n点结尾。\n文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。后面的行可包含若干\n段落，描述对象的调用约定、副作用等。\nPython 解析器不会删除 Python 中多行字符串字面值的缩进，因此，文档处理工具应在必要时删除\n缩进。这项操作遵循以下约定：文档字符串第一行 之后 的第一个非空行决定了整个文档字符串的缩\n进量（第一行通常与字符串开头的引号相邻，其缩进在字符串中并不明显，因此，不能用第一行的\n缩进），然后，删除字符串中所有行开头处与此缩进“等价”的空白符。不能有比此缩进更少的行，但\n如果出现了缩进更少的行，应删除这些行的所有前导空白符。转化制表符后（通常为 8 个空格），\n应测试空白符的等效性。\n下面是多行文档字符串的一个例子： |  |\n| --- | --- | --- |\n|  | >>> def my_function():\n... \"\"\"什么都不做，只是记录下来。\n...\n... 真的，它没有任何作用。\n... \"\"\"\n... pass\n...\n>>> print(my_function.__doc__)\n什么都不做，只是记录下来。\n真的，它没有任何作用。. |  |\n|  | 4.9.8. 函数注解\n函数注解 是可选的用户自定义函数类型的元数据完整信息（详见 PEP 3107 和 PEP 484 ）。\n标注 是以字典形式存放在函数的 __annotations__ 属性中的而对函数的其他部分没有影响。 形参\n标注的定义方式是在形参名后加冒号，后面再跟一个将被求值为标注的值的表达式。 返回值标注的\n定义方式是加符号 ->，后面再跟一个表达式，它位于形参列表和表示 def 语句结束的冒号之间。\n下面的示例具有加了标注的一个必需参数、一个可选参数以及返回值: |  |\n|  | >>> def f(ham: str, eggs: str = 'eggs') -> str:\n... print(\"Annotations:\", f.__annotations__)\n... print(\"Arguments:\", ham, eggs)\n... return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>\nArguments: spam eggs\n'spam and eggs' |  |\n|  | 4.10. 小插曲：编码风格\n现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 代码风格 了。 大多数语言都能以不同\n的风格被编写（或更准确地说，被格式化）；有些比其他的更具有可读性。 能让其他人轻松阅读你 |  |\n\n的代码总是一个好主意，采用一种好的编码风格对此有很大帮助。\nPython 项目大多都遵循 PEP 8 的风格指南；它推行的编码风格易于阅读、赏心悦目。Python 开发\n者均应抽时间悉心研读；以下是该提案中的核心要点：\n缩进，用 4 个空格，不要用制表符。\n4 个空格是小缩进（更深嵌套）和大缩进（更易阅读）之间的折中方案。制表符会引起混乱，最\n好别用。\n换行，一行不超过 79 个字符。\n这样换行的小屏阅读体验更好，还便于在大屏显示器上并排阅读多个代码文件。\n用空行分隔函数和类，及函数内较大的代码块。\n最好把注释放到单独一行。\n使用文档字符串。\n运算符前后、逗号后要用空格，但不要直接在括号内使用： a = f(1, 2) + g(3, 4)。\n类和函数的命名要一致；按惯例，命名类用 UpperCamelCase，命名函数与方法用\nlowercase_with_underscores。命名方法中第一个参数总是用 self (类和方法详见 初探类)。\n编写用于国际多语环境的代码时，不要用生僻的编码。Python 默认的 UTF-8 或纯 ASCII 可以胜任\n各种情况。\n同理，就算多语阅读、维护代码的可能再小，也不要在标识符中使用非 ASCII 字符。\n备注\n[1] 实际上，对象引用调用 这种说法更好，因为，传递的是可变对象时，调用者能发现被调者做出\n的任何更改（插入列表的元素）。", "metadata": {"title": "04_更多控制流工具", "source": "md_docs\\python_docs_md\\04_更多控制流工具.md", "doc_type": "教程", "language": "中文", "doc_id": "95bf8892"}}
{"doc_id": "b3917054", "content": "5. 数据结构\n本章深入讲解之前学过的一些内容，同时，还增加了新的知识点。\n5.1. 列表详解\n列表数据类型支持很多方法，列表对象的所有方法所示如下：\nlist.append(x)\n在列表末尾添加一项。 类似于 a[len(a):] = [x]。\nlist.extend(iterable)\n通过添加来自 iterable 的所有项来扩展列表。 类似于 a[len(a):] = iterable。\nlist.insert(i, x)\n在指定位置插入元素。第一个参数是插入元素的索引，因此，a.insert(0, x) 在列表开头插\n入元素， a.insert(len(a), x) 等同于 a.append(x) 。\nlist.remove(x)\n从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常。\nlist.pop([i])\n移除列表中给定位置上的条目，并返回该条目。 如果未指定索引号，则 a.pop() 将移除并返回\n列表中的最后一个条目。 如果列表为空或索引号在列表索引范围之外则会引发 IndexError。\nlist.clear()\n移除列表中的所有项。 类似于 del a[:]。\nlist.index(x[, start[, end]])\n返回列表中 x 首次出现位置的从零开始的索引。 如无此条目则会引发 ValueError。\n可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于\n整个序列的开始计算的，而不是 start 参数。\nlist.count(x)\n返回列表中元素 x 出现的次数。\nlist.sort(*, key=None, reverse=False)\n就地排序列表中的元素（要了解自定义排序参数，详见 sorted()）。\nlist.reverse()\n翻转列表中的元素。\nlist.copy()\n\n返回列表的浅拷贝。 类似于 a[:]。\n多数列表方法示例：\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4) # 从 4 号位开始查找下一个 banana\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\n你可能已经注意到 insert, remove 或 sort 等仅修改列表的方法都不会打印返回值 -- 它们返回默认\n值 None。 [1] 这是适用于 Python 中所有可变数据结构的设计原则。\n你可能会注意到的另一件事是并非所有数据都可以排序或比较。 举例来说，[None, 'hello', 10]\n就不可排序因为整数不能与字符串比较而 None 不能与其他类型比较。 此外，还存在一些没有定义\n顺序关系的类型。 例如，3+4j < 5+7j 就不是一个合法的比较。\n5.1.1. 用列表实现堆栈\n列表方法使得将列表作为栈来使用非常容易，最后添加的元素会最先被取出（“后时先出”）。 要将\n一个条目添加到栈顶，可使用 append()。 要从栈顶取出一个条目，则使用 pop() 而不必显式指定\n索引。 例如:\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n\n|  | 返回列表的浅拷贝。 类似于 a[:]。\n多数列表方法示例： |  |\n| --- | --- | --- |\n|  | >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4) # 从 4 号位开始查找下一个 banana\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear' |  |\n|  | 你可能已经注意到 insert, remove 或 sort 等仅修改列表的方法都不会打印返回值 -- 它们返回默认\n值 None。 [1] 这是适用于 Python 中所有可变数据结构的设计原则。\n你可能会注意到的另一件事是并非所有数据都可以排序或比较。 举例来说，[None, 'hello', 10]\n就不可排序因为整数不能与字符串比较而 None 不能与其他类型比较。 此外，还存在一些没有定义\n顺序关系的类型。 例如，3+4j < 5+7j 就不是一个合法的比较。\n5.1.1. 用列表实现堆栈\n列表方法使得将列表作为栈来使用非常容易，最后添加的元素会最先被取出（“后时先出”）。 要将\n一个条目添加到栈顶，可使用 append()。 要从栈顶取出一个条目，则使用 pop() 而不必显式指定\n索引。 例如: |  |\n|  | >>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4] |  |\n|  |  |  |\n\n5.1.2. 用列表实现队列\n列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很\n低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其\n他元素都必须移动一位）。\n实现队列最好用 collections.deque，可以快速从两端添加或删除元素。例如：\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\") # Terry 到了\n>>> queue.append(\"Graham\") # Graham 到了\n>>> queue.popleft() # 第一个到的现在走了\n'Eric'\n>>> queue.popleft() # 第二个到的现在走了\n'John'\n>>> queue # 按到达顺序排列的剩余队列\ndeque(['Michael', 'Terry', 'Graham'])\n5.1.3. 列表推导式\n列表推导式创建列表的方式更简洁。常见的用法为，对序列或可迭代对象中的每个元素应用某种操\n作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。\n例如，创建平方值的列表：\n>>> squares = []\n>>> for x in range(10):\n... squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n注意，这段代码创建（或覆盖）变量 x，该变量在循环结束后仍然存在。下述方法可以无副作用地\n计算平方列表：\nsquares = list(map(lambda x: x**2, range(10)))\n或等价于：\nsquares = [x**2 for x in range(10)]\n上面这种写法更简洁、易读。\n列表推导式的方括号内包含以下内容：一个表达式，后面为一个 for 子句，然后，是零个或多个\nfor 或 if 子句。结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。 举例来说，以\n下列表推导式将两个列表中不相等的元素组合起来：\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n\n|  | 5.1.2. 用列表实现队列\n列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很\n低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其\n他元素都必须移动一位）。\n实现队列最好用 collections.deque，可以快速从两端添加或删除元素。例如： |  |\n| --- | --- | --- |\n|  | >>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\") # Terry 到了\n>>> queue.append(\"Graham\") # Graham 到了\n>>> queue.popleft() # 第一个到的现在走了\n'Eric'\n>>> queue.popleft() # 第二个到的现在走了\n'John'\n>>> queue # 按到达顺序排列的剩余队列\ndeque(['Michael', 'Terry', 'Graham']) |  |\n|  | 5.1.3. 列表推导式\n列表推导式创建列表的方式更简洁。常见的用法为，对序列或可迭代对象中的每个元素应用某种操\n作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。\n例如，创建平方值的列表： |  |\n|  | >>> squares = []\n>>> for x in range(10):\n... squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] |  |\n|  | 注意，这段代码创建（或覆盖）变量 x，该变量在循环结束后仍然存在。下述方法可以无副作用地\n计算平方列表： |  |\n|  | squares = list(map(lambda x: x**2, range(10))) |  |\n|  | 或等价于： |  |\n|  | squares = [x**2 for x in range(10)] |  |\n|  | 上面这种写法更简洁、易读。\n列表推导式的方括号内包含以下内容：一个表达式，后面为一个 for 子句，然后，是零个或多个\nfor 或 if 子句。结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。 举例来说，以\n下列表推导式将两个列表中不相等的元素组合起来： |  |\n|  | >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] |  |\n|  |  |  |\n\n等价于：\n>>> combs = []\n>>> for x in [1,2,3]:\n... for y in [3,1,4]:\n... if x != y:\n... combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n注意，上面两段代码中，for 和 if 的顺序相同。\n表达式是元组（例如上例的 (x, y)）时，必须加上括号：\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # 新建一个将值翻倍的列表\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # 过滤列表以排除负数\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # 对所有元素应用一个函数\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # 在每个元素上调用一个方法\n>>> freshfruit = [' banana', ' loganberry ', 'passion fruit ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # 创建一个包含 (数字, 平方) 2 元组的列表\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # 元组必须加圆括号，否则会引发错误\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # 使用两个 'for' 来展平嵌套的列表\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n列表推导式可以使用复杂的表达式和嵌套函数：\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n5.1.4. 嵌套的列表推导式\n列表推导式中的初始表达式可以是任何表达式，甚至可以是另一个列表推导式。\n下面这个 3x4 矩阵，由 3 个长度为 4 的列表组成：\n\n|  | 等价于： |  |\n| --- | --- | --- |\n|  | >>> combs = []\n>>> for x in [1,2,3]:\n... for y in [3,1,4]:\n... if x != y:\n... combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] |  |\n|  | 注意，上面两段代码中，for 和 if 的顺序相同。\n表达式是元组（例如上例的 (x, y)）时，必须加上括号： |  |\n|  | >>> vec = [-4, -2, 0, 2, 4]\n>>> # 新建一个将值翻倍的列表\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # 过滤列表以排除负数\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # 对所有元素应用一个函数\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # 在每个元素上调用一个方法\n>>> freshfruit = [' banana', ' loganberry ', 'passion fruit ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # 创建一个包含 (数字, 平方) 2 元组的列表\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # 元组必须加圆括号，否则会引发错误\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # 使用两个 'for' 来展平嵌套的列表\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9] |  |\n|  | 列表推导式可以使用复杂的表达式和嵌套函数： |  |\n|  | >>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159'] |  |\n|  | 5.1.4. 嵌套的列表推导式\n列表推导式中的初始表达式可以是任何表达式，甚至可以是另一个列表推导式。\n下面这个 3x4 矩阵，由 3 个长度为 4 的列表组成： |  |\n\n>>> matrix = [\n... [1, 2, 3, 4],\n... [5, 6, 7, 8],\n... [9, 10, 11, 12],\n... ]\n下面的列表推导式可以转置行列：\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n如我们在之前小节中看到的，内部的列表推导式是在它之后的 for 的上下文中被求值的，所以这个\n例子等价于:\n>>> transposed = []\n>>> for i in range(4):\n... transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n反过来说，也等价于：\n>>> transposed = []\n>>> for i in range(4):\n... # 以下 3 行实现了嵌套的列表组\n... transposed_row = []\n... for row in matrix:\n... transposed_row.append(row[i])\n... transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n实际应用中，最好用内置函数替代复杂的流程语句。此时，zip() 函数更好用：\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\n关于本行中星号的详细说明，参见 解包实参列表。\n5.2. del 语句\n可以按索引而不是按值从一个列表移除条目：即使用 del 语句。 这不同于返回一个值的 pop() 方\n法。 del 语句还可被用来从列表移除切片或清空整个列表（之前我们通过将一个空列表赋值给切片\n实现此功能）。 例如:\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n\n|  | >>> matrix = [\n... [1, 2, 3, 4],\n... [5, 6, 7, 8],\n... [9, 10, 11, 12],\n... ] |  |\n| --- | --- | --- |\n|  | 下面的列表推导式可以转置行列： |  |\n|  | >>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] |  |\n|  | 如我们在之前小节中看到的，内部的列表推导式是在它之后的 for 的上下文中被求值的，所以这个\n例子等价于: |  |\n|  | >>> transposed = []\n>>> for i in range(4):\n... transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] |  |\n|  | 反过来说，也等价于： |  |\n|  | >>> transposed = []\n>>> for i in range(4):\n... # 以下 3 行实现了嵌套的列表组\n... transposed_row = []\n... for row in matrix:\n... transposed_row.append(row[i])\n... transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] |  |\n|  | 实际应用中，最好用内置函数替代复杂的流程语句。此时，zip() 函数更好用： |  |\n|  | >>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)] |  |\n|  | 关于本行中星号的详细说明，参见 解包实参列表。\n5.2. del 语句\n可以按索引而不是按值从一个列表移除条目：即使用 del 语句。 这不同于返回一个值的 pop() 方\n法。 del 语句还可被用来从列表移除切片或清空整个列表（之前我们通过将一个空列表赋值给切片\n实现此功能）。 例如: |  |\n|  | >>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a |  |\n\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\ndel 也可以用来删除整个变量：\n>>> del a\n此后，再引用 a 就会报错（直到为它赋与另一个值）。后文会介绍 del 的其他用法。\n5.3. 元组和序列\n列表和字符串有很多共性，例如，索引和切片操作。这两种数据类型是 序列 （参见 序列类型 ---\nlist, tuple, range）。随着 Python 语言的发展，其他的序列类型也被加入其中。本节介绍另一种标准\n序列类型：元组。\n元组由多个用逗号隔开的值组成，例如：\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # 元组可以嵌套：\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # 元组是不可变对象：\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # 但它们可以包含可变对象：\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\n输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。输入时，圆括号可有可无，不过\n经常是必须的（如果元组是更大的表达式的一部分）。不允许为元组中的单个元素赋值，当然，可\n以创建含列表等可变对象的元组。\n虽然，元组与列表很像，但使用场景不同，用途也不同。元组是 immutable （不可变的），一般可\n包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访\n问）。列表是 mutable （可变的），列表元素一般为同质类型，可迭代访问。\n构造 0 个或 1 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。用一对空圆\n括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只\n有一个值的话不够明确）。丑陋，但是有效。例如：\n>>> empty = ()\n>>> singleton = 'hello', # <-- 注意末尾的逗号\n>>> len(empty)\n\n|  | [1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[] |  |\n| --- | --- | --- |\n|  | del 也可以用来删除整个变量： |  |\n|  | >>> del a |  |\n|  | 此后，再引用 a 就会报错（直到为它赋与另一个值）。后文会介绍 del 的其他用法。\n5.3. 元组和序列\n列表和字符串有很多共性，例如，索引和切片操作。这两种数据类型是 序列 （参见 序列类型 ---\nlist, tuple, range）。随着 Python 语言的发展，其他的序列类型也被加入其中。本节介绍另一种标准\n序列类型：元组。\n元组由多个用逗号隔开的值组成，例如： |  |\n|  | >>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # 元组可以嵌套：\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # 元组是不可变对象：\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # 但它们可以包含可变对象：\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1]) |  |\n|  | 输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。输入时，圆括号可有可无，不过\n经常是必须的（如果元组是更大的表达式的一部分）。不允许为元组中的单个元素赋值，当然，可\n以创建含列表等可变对象的元组。\n虽然，元组与列表很像，但使用场景不同，用途也不同。元组是 immutable （不可变的），一般可\n包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访\n问）。列表是 mutable （可变的），列表元素一般为同质类型，可迭代访问。\n构造 0 个或 1 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。用一对空圆\n括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只\n有一个值的话不够明确）。丑陋，但是有效。例如： |  |\n|  | >>> empty = ()\n>>> singleton = 'hello', # <-- 注意末尾的逗号\n>>> len(empty) |  |\n\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\n语句 t = 12345, 54321, 'hello!' 是 元组打包 的例子：值 12345, 54321 和 'hello!' 一起被打\n包进元组。逆操作也可以：\n>>> x, y, z = t\n称之为 序列解包 也是妥妥的，适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数\n量应相等。注意，多重赋值其实只是元组打包和序列解包的组合。\n5.4. 集合\nPython 还支持 集合 这种数据类型。集合是由不重复元素组成的无序容器。基本用法包括成员检\n测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。\n创建集合用花括号或 set() 函数。注意，创建空集合只能用 set()，不能用 {}，{} 创建的是空字\n典，下一小节介绍数据结构：字典。\n以下是一些简单的示例\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket) # 显示重复项已被移除\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket # 快速成员检测\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # 演示针对两个单词中独有的字母进行集合运算\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a # a 中独有的字母\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b # 存在于 a 中但不存在于 b 中的字母\n{'r', 'd', 'b'}\n>>> a | b # 存在于 a 或 b 中或两者中皆有的字母\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b # 同时存在于 a 和 b 中的字母\n{'a', 'c'}\n>>> a ^ b # 存在于 a 或 b 中但非两者中皆有的字母\n{'r', 'd', 'b', 'm', 'z', 'l'}\n与 列表推导式 类似，集合也支持推导式：\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n\n|  | 0\n>>> len(singleton)\n1\n>>> singleton\n('hello',) |  |\n| --- | --- | --- |\n|  | 语句 t = 12345, 54321, 'hello!' 是 元组打包 的例子：值 12345, 54321 和 'hello!' 一起被打\n包进元组。逆操作也可以： |  |\n|  | >>> x, y, z = t |  |\n|  | 称之为 序列解包 也是妥妥的，适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数\n量应相等。注意，多重赋值其实只是元组打包和序列解包的组合。\n5.4. 集合\nPython 还支持 集合 这种数据类型。集合是由不重复元素组成的无序容器。基本用法包括成员检\n测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。\n创建集合用花括号或 set() 函数。注意，创建空集合只能用 set()，不能用 {}，{} 创建的是空字\n典，下一小节介绍数据结构：字典。\n以下是一些简单的示例 |  |\n|  | >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket) # 显示重复项已被移除\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket # 快速成员检测\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # 演示针对两个单词中独有的字母进行集合运算\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a # a 中独有的字母\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b # 存在于 a 中但不存在于 b 中的字母\n{'r', 'd', 'b'}\n>>> a | b # 存在于 a 或 b 中或两者中皆有的字母\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b # 同时存在于 a 和 b 中的字母\n{'a', 'c'}\n>>> a ^ b # 存在于 a 或 b 中但非两者中皆有的字母\n{'r', 'd', 'b', 'm', 'z', 'l'} |  |\n|  | 与 列表推导式 类似，集合也支持推导式： |  |\n|  | >>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'} |  |\n|  |  |  |\n\n5.5. 字典\n另一个常用的 Python 内置数据类型是 字典 (参见 映射类型 --- dict)。 字典在其他编程语言中可能称\n为“联合内存”或“联合数组”。 与以连续整数为索引的序列不同，字典是以 键 来索引的，键可以是任\n何不可变类型；字符串和数字总是可以作为键。 元组在其仅包含字符串、数字或元组时也可以作为\n键；如果一个元组直接或间接地包含了任何可变对象，则不可以用作键。 你不能使用列表作为键，\n因为列表可使用索引赋值、切片赋值或 append() 和 extend() 等方法进行原地修改。\n可以把字典理解为 键值对 的集合，但字典的键必须是唯一的。花括号 {} 用于创建空字典。另一种\n初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。\n字典的主要操作是通过键来存储值并根据给定的键来提取值。 通过 del 也可以删除键值对。 如果你\n使用已存在的键进行存储，则与该键相关联的旧值将丢失。\n通过下标操作 (d[key]) 提取不存在的键的值会引发 KeyError。 要避免在试图访问可能不存在的键\n时遇到这种错误，可改用 get() 方法，它会在字典不存在某个键时返回 None (或指定的默认值)。\n对字典执行 list(d) 操作，返回该字典中所有键的列表，按插入次序排列（如需排序，请使用\nsorted(d)）。检查字典里是否存在某个键，使用关键字 in。\n以下是一些字典的简单示例：\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> tel['irv']\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nKeyError: 'irv'\n>>> print(tel.get('irv'))\nNone\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\ndict() 构造函数可以直接用键值对序列创建字典：\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n\n|  | 5.5. 字典\n另一个常用的 Python 内置数据类型是 字典 (参见 映射类型 --- dict)。 字典在其他编程语言中可能称\n为“联合内存”或“联合数组”。 与以连续整数为索引的序列不同，字典是以 键 来索引的，键可以是任\n何不可变类型；字符串和数字总是可以作为键。 元组在其仅包含字符串、数字或元组时也可以作为\n键；如果一个元组直接或间接地包含了任何可变对象，则不可以用作键。 你不能使用列表作为键，\n因为列表可使用索引赋值、切片赋值或 append() 和 extend() 等方法进行原地修改。\n可以把字典理解为 键值对 的集合，但字典的键必须是唯一的。花括号 {} 用于创建空字典。另一种\n初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。\n字典的主要操作是通过键来存储值并根据给定的键来提取值。 通过 del 也可以删除键值对。 如果你\n使用已存在的键进行存储，则与该键相关联的旧值将丢失。\n通过下标操作 (d[key]) 提取不存在的键的值会引发 KeyError。 要避免在试图访问可能不存在的键\n时遇到这种错误，可改用 get() 方法，它会在字典不存在某个键时返回 None (或指定的默认值)。\n对字典执行 list(d) 操作，返回该字典中所有键的列表，按插入次序排列（如需排序，请使用\nsorted(d)）。检查字典里是否存在某个键，使用关键字 in。\n以下是一些字典的简单示例： |  |\n| --- | --- | --- |\n|  | >>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> tel['irv']\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nKeyError: 'irv'\n>>> print(tel.get('irv'))\nNone\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse |  |\n|  | dict() 构造函数可以直接用键值对序列创建字典： |  |\n|  | >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098} |  |\n|  |  |  |\n\n字典推导式可以用任意键值表达式创建字典：\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷：\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n5.6. 循环的技巧\n当对字典执行循环时，可以使用 items() 方法同时提取键及其对应的值。\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n... print(k, v)\n...\ngallahad the pure\nrobin the brave\n在序列中循环时，用 enumerate() 函数可以同时取出位置索引和对应的值：\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n... print(i, v)\n...\n0 tic\n1 tac\n2 toe\n同时循环两个或多个序列时，用 zip() 函数可以将其内的元素一一匹配：\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n... print('What is your {0}? It is {1}.'.format(q, a))\n...\nWhat is your name? It is lancelot.\nWhat is your quest? It is the holy grail.\nWhat is your favorite color? It is blue.\n为了逆向对序列进行循环，可以求出欲循环的正向序列，然后调用 reversed() 函数：\n>>> for i in reversed(range(1, 10, 2)):\n... print(i)\n...\n9\n7\n5\n3\n1\n按指定顺序循环序列，可以用 sorted() 函数，在不改动原序列的基础上，返回一个重新的序列：\n\n|  | 字典推导式可以用任意键值表达式创建字典： |  |\n| --- | --- | --- |\n|  | >>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36} |  |\n|  | 关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷： |  |\n|  | >>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098} |  |\n|  | 5.6. 循环的技巧\n当对字典执行循环时，可以使用 items() 方法同时提取键及其对应的值。 |  |\n|  | >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n... print(k, v)\n...\ngallahad the pure\nrobin the brave |  |\n|  | 在序列中循环时，用 enumerate() 函数可以同时取出位置索引和对应的值： |  |\n|  | >>> for i, v in enumerate(['tic', 'tac', 'toe']):\n... print(i, v)\n...\n0 tic\n1 tac\n2 toe |  |\n|  | 同时循环两个或多个序列时，用 zip() 函数可以将其内的元素一一匹配： |  |\n|  | >>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n... print('What is your {0}? It is {1}.'.format(q, a))\n...\nWhat is your name? It is lancelot.\nWhat is your quest? It is the holy grail.\nWhat is your favorite color? It is blue. |  |\n|  | 为了逆向对序列进行循环，可以求出欲循环的正向序列，然后调用 reversed() 函数： |  |\n|  | >>> for i in reversed(range(1, 10, 2)):\n... print(i)\n...\n9\n7\n5\n3\n1 |  |\n|  | 按指定顺序循环序列，可以用 sorted() 函数，在不改动原序列的基础上，返回一个重新的序列： |  |\n\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n... print(i)\n...\napple\napple\nbanana\norange\norange\npear\n使用 set() 去除序列中的重复元素。使用 sorted() 加 set() 则按排序后的顺序，循环遍历序列中\n的唯一元素：\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n... print(f)\n...\napple\nbanana\norange\npear\n一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全：\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n... if not math.isnan(value):\n... filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n5.7. 深入条件控制\nwhile 和 if 条件句不只可以进行比较，还可以使用任意运算符。\n比较运算符 in 和 not in 用于执行确定一个值是否存在（或不存在）于某个容器中的成员检测。\n运算符 is 和 is not 用于比较两个对象是否是同一个对象。 所有比较运算符的优先级都一样，且\n低于任何数值运算符。\n比较操作支持链式操作。例如，a < b == c 校验 a 是否小于 b，且 b 是否等于 c。\n比较操作可以用布尔运算符 and 和 or 组合，并且，比较操作（或其他布尔运算）的结果都可以用\nnot 取反。这些操作符的优先级低于比较操作符；not 的优先级最高， or 的优先级最低，因此，A\nand not B or C 等价于 (A and (not B)) or C。与其他运算符操作一样，此处也可以用圆括号表\n示想要的组合。\n布尔运算符 and 和 or 是所谓的 短路 运算符：其参数从左至右求值，一旦可以确定结果，求值就会\n停止。例如，如果 A 和 C 为真，B 为假，那么 A and B and C 不会对 C 求值。用作普通值而不是\n\n|  | >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n... print(i)\n...\napple\napple\nbanana\norange\norange\npear |  |  |  |\n| --- | --- | --- | --- | --- |\n|  | 使用 set() 去除序列中的重复元素。使用 sorted() 加 set() 则按排序后的顺序，循环遍历序列中\n的唯一元素： |  |  |  |\n|  | >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n... print(f)\n...\napple\nbanana\norange\npear |  |  |  |\n|  | 一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全： |  |  |  |\n|  | >>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n... if not math.isnan(value):\n... filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8] |  |  |  |\n|  | 5.7. 深入条件控制\nwhile 和 if 条件句不只可以进行比较，还可以使用任意运算符。\n比较运算符 in 和 not in 用于执行确定一个值是否存在（或不存在）于某个容器中的成员检测。\n运算符 is 和 is not 用于比较两个对象是否是同一个对象。 所有比较运算符的优先级都一样，且\n低于任何数值运算符。\n比较操作支持链式操作。例如，a < b == c 校验 a 是否小于 b，且 b 是否等于 c。\n比较操作可以用布尔运算符 and 和 or 组合，并且，比较操作（或其他布尔运算）的结果都可以用\nnot 取反。这些操作符的优先级低于比较操作符；not 的优先级最高， or 的优先级最低，因此，A\nand not B or C 等价于 (A and (not B)) or C。与其他运算符操作一样，此处也可以用圆括号表\n示想要的组合。\n布尔运算符 and 和 or 是所谓的 短路 运算符：其参数从左至右求值，一旦可以确定结果，求值就会\n停止。例如，如果 A 和 C 为真，B 为假，那么 A and B and C 不会对 C 求值。用作普通值而不是 |  |  |  |\n|  |  | A |  |  |\n|  |  |  |  |  |\n\n|  | and not B or C |\n| --- | --- |\n\n布尔值时，短路运算符的返回值通常是最后一个求了值的参数。\n还可以把比较运算或其它布尔表达式的结果赋值给变量，例如：\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\n注意，Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 :=。 这避免了 C 程序中常见\n的问题：要在表达式中写 == 时，却写成了 =。\n5.8. 序列和其他类型的比较\n序列对象可以与相同序列类型的其他对象比较。这种比较使用 字典式 顺序：首先，比较前两个对应\n元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中\n一个序列结束。如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。如\n果两个序列中所有的对应元素都相等，则两个序列相等。如果一个序列是另一个的初始子序列，则\n较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排\n序单个字符。下面列出了一些比较相同类型序列的例子：\n(1, 2, 3) < (1, 2, 4)\n[1, 2, 3] < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4) < (1, 2, 4)\n(1, 2) < (1, 2, -1)\n(1, 2, 3) == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)\n注意，当比较不同类型的对象时，只要待比较的对象提供了合适的比较方法，就可以使用 < 和 > 进\n行比较。例如，混合的数字类型通过数字值进行比较，所以，0 等于 0.0，等等。如果没有提供合适\n的比较方法，解释器不会随便给出一个比较结果，而是引发 TypeError 异常。\n备注\n[1] 别的语言可能会将可变对象返回，允许方法连续执行，例如 d->insert(\"a\")->remove(\"b\")-\n>sort();。\n\n|  |  | 布尔值时，短路运算符的返回值通常是最后一个求了值的参数。\n还可以把比较运算或其它布尔表达式的结果赋值给变量，例如： |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim' |  |  |  |\n|  |  | 注意，Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 :=。 这避免了 C 程序中常见\n的问题：要在表达式中写 == 时，却写成了 =。\n5.8. 序列和其他类型的比较\n序列对象可以与相同序列类型的其他对象比较。这种比较使用 字典式 顺序：首先，比较前两个对应\n元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中\n一个序列结束。如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。如\n果两个序列中所有的对应元素都相等，则两个序列相等。如果一个序列是另一个的初始子序列，则\n较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排\n序单个字符。下面列出了一些比较相同类型序列的例子： |  |  |  |\n|  |  | (1, 2, 3) < (1, 2, 4)\n[1, 2, 3] < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4) < (1, 2, 4)\n(1, 2) < (1, 2, -1)\n(1, 2, 3) == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4) |  |  |  |\n|  |  | 注意，当比较不同类型的对象时，只要待比较的对象提供了合适的比较方法，就可以使用 < 和 > 进\n行比较。例如，混合的数字类型通过数字值进行比较，所以，0 等于 0.0，等等。如果没有提供合适\n的比较方法，解释器不会随便给出一个比较结果，而是引发 TypeError 异常。\n备注\n[1] 别的语言可能会将可变对象返回，允许方法连续执行，例如 d->insert(\"a\")->remove(\"b\")-\n>sort();。 |  |  |  |\n|  |  |  | d->insert(\"a\")->remove(\"b\")- |  |  |\n|  |  |  |  |  |  |", "metadata": {"title": "05_数据结构", "source": "md_docs\\python_docs_md\\05_数据结构.md", "doc_type": "教程", "language": "中文", "doc_id": "b3917054"}}
{"doc_id": "7d6d0559", "content": "6. 模块\n退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，\n编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 脚本 。随着\n程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用\n同一个函数时，不用把函数定义复制到各个程序。\n为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文\n件就是 模块 ；模块中的定义可以 导入 到其他模块或 主 模块（在顶层和计算器模式下，执行脚本中\n可访问的变量集）。\n模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 .py 。在模块内部，通过全局\n变量 __name__ 可以获取模块名（即字符串）。例如，用文本编辑器在当前目录下创建 fibo.py 文\n件，输入以下内容：\n# 斐波那契数列模块\ndef fib(n):\n\"\"\"Write Fibonacci series up to n.\"\"\"\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):\n\"\"\"Return Fibonacci series up to n.\"\"\"\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result\n现在，进入 Python 解释器，用以下命令导入该模块：\n>>> import fibo\n此操作不会直接把 fibo 中定义的函数名称添加到当前 namespace 中（请参阅 Python 作用域和命\n名空间 了解详情）；它只是将模块名称 fibo 添加到那里。 使用该模块名称你可以访问其中的函数:\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n如果经常使用某个函数，可以把它赋值给局部变量：\n\n| 6. 模块\n退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，\n编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 脚本 。随着\n程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用\n同一个函数时，不用把函数定义复制到各个程序。\n为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文\n件就是 模块 ；模块中的定义可以 导入 到其他模块或 主 模块（在顶层和计算器模式下，执行脚本中\n可访问的变量集）。\n模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 .py 。在模块内部，通过全局\n变量 __name__ 可以获取模块名（即字符串）。例如，用文本编辑器在当前目录下创建 fibo.py 文\n件，输入以下内容： |\n| --- |\n| # 斐波那契数列模块\ndef fib(n):\n\"\"\"Write Fibonacci series up to n.\"\"\"\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):\n\"\"\"Return Fibonacci series up to n.\"\"\"\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result |\n| 现在，进入 Python 解释器，用以下命令导入该模块： |\n| >>> import fibo |\n| 此操作不会直接把 fibo 中定义的函数名称添加到当前 namespace 中（请参阅 Python 作用域和命\n名空间 了解详情）；它只是将模块名称 fibo 添加到那里。 使用该模块名称你可以访问其中的函数: |\n| >>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo' |\n| 如果经常使用某个函数，可以把它赋值给局部变量： |\n\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n6.1. 模块详解\n模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 第一次 遇到模块\n名时执行。[1] (文件作为脚本运行时，也会执行这些语句。)\n每个模块都有它自己的私有符号表，该表被定义在该模块里的所有函数当作全局符号表使用。 因\n此，一个模块的作者可以在模块内放心使用全局变量，而不必担心它们会和模块使用者的全局变量\n发生意外冲突。 另一方面，如果您知道自己在做什么，您可以使用与引用模块函数相同的语法去访\n问一个模块的全局变量，即 modname.itemname。\n模块可以导入其他模块。 根据惯例可以将所有 import 语句都放在模块（或者也可以说是脚本）的\n开头但这并非强制要求。 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模\n块的全局命名空间。\n还有一种 import 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间\n中。 例如:\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，fibo 将是未定义的\n名称）。\n还有一种变体可以导入模块内定义的所有名称：\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n这种方式会导入所有不以下划线（_）开头的名称。大多数情况下，不要用这个功能，这种方式向解\n释器导入了一批未知的名称，可能会覆盖已经定义的名称。\n注意，一般情况下，不建议从模块或包内导入 *，因为，这项操作经常让代码变得难以理解。不\n过，为了在交互式会话中少打几个字，这么用也没问题。\n模块名后使用 as 时，直接把 as 后的名称与导入模块绑定。\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n与 import fibo 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 fib。\nfrom 中也可以使用这种方式，效果类似：\n\n|  | >>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 |  |\n| --- | --- | --- |\n|  | 6.1. 模块详解\n模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 第一次 遇到模块\n名时执行。[1] (文件作为脚本运行时，也会执行这些语句。)\n每个模块都有它自己的私有符号表，该表被定义在该模块里的所有函数当作全局符号表使用。 因\n此，一个模块的作者可以在模块内放心使用全局变量，而不必担心它们会和模块使用者的全局变量\n发生意外冲突。 另一方面，如果您知道自己在做什么，您可以使用与引用模块函数相同的语法去访\n问一个模块的全局变量，即 modname.itemname。\n模块可以导入其他模块。 根据惯例可以将所有 import 语句都放在模块（或者也可以说是脚本）的\n开头但这并非强制要求。 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模\n块的全局命名空间。\n还有一种 import 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间\n中。 例如: |  |\n|  | >>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 |  |\n|  | 这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，fibo 将是未定义的\n名称）。\n还有一种变体可以导入模块内定义的所有名称： |  |\n|  | >>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 |  |\n|  | 这种方式会导入所有不以下划线（_）开头的名称。大多数情况下，不要用这个功能，这种方式向解\n释器导入了一批未知的名称，可能会覆盖已经定义的名称。\n注意，一般情况下，不建议从模块或包内导入 *，因为，这项操作经常让代码变得难以理解。不\n过，为了在交互式会话中少打几个字，这么用也没问题。\n模块名后使用 as 时，直接把 as 后的名称与导入模块绑定。 |  |\n|  | >>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 |  |\n|  | 与 import fibo 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 fib。\nfrom 中也可以使用这种方式，效果类似： |  |\n\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n备注: 为了保证运行效率，每次解释器会话只导入一次模块。如果更改了模块内容，必须重启解\n释器；仅交互测试一个模块时，也可以使用 importlib.reload()，例如 import importlib;\nimportlib.reload(modulename)。\n6.1.1. 以脚本方式执行模块\n可以用以下方式运行 Python 模块：\npython fibo.py <arguments>\n这项操作将执行模块里的代码，和导入模块一样，但会把 __name__ 赋值为 \"__main__\"。 也就是\n把下列代码添加到模块末尾：\nif __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1]))\n这个文件既能被用作脚本，又能被用作一个可供导入的模块，因为解析命令行参数的那两行代码只\n有在模块作为“main”文件执行时才会运行：\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\n当这个模块被导入到其它模块时，那两行代码不运行：\n>>> import fibo\n>>>\n这常用于为模块提供一个便捷的用户接口，或用于测试（把模块作为执行测试套件的脚本运行）。\n6.1.2. 模块搜索路径\n当导入一个名为 spam 的模块时，解释器首先会搜索具有该名称的内置模块。 这些模块的名称在\nsys.builtin_module_names 中列出。 如果未找到，它将在变量 sys.path 所给出的目录列表中搜\n索名为 spam.py 的文件。 sys.path 是从这些位置初始化的:\n被命令行直接运行的脚本所在的目录（或未指定文件时的当前目录）。\nPYTHONPATH （目录列表，与 shell 变量 PATH 的语法一样）。\n依赖于安装的默认值（按照惯例包括一个 site-packages 目录，由 site 模块处理）。\n更多细节请参阅 sys.path 模块搜索路径的初始化。\n备注: 在支持符号链接的文件系统中，“被命令行直接运行的脚本所在的目录”是符号链接最终指\n向的目录。换句话说，符号链接所在的目录并 没有 被添加至模块搜索路径。\n\n|  |  | >>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |\n|  |  | 备注: 为了保证运行效率，每次解释器会话只导入一次模块。如果更改了模块内容，必须重启解\n释器；仅交互测试一个模块时，也可以使用 importlib.reload()，例如 import importlib;\nimportlib.reload(modulename)。 |  |  |  |\n|  |  |  | import importlib; |  |  |\n|  |  |  |  |  |  |\n|  |  | importlib.reload(modulename) |  |  |  |\n|  |  |  |  |  |  |\n|  |  | 6.1.1. 以脚本方式执行模块\n可以用以下方式运行 Python 模块： |  |  |  |\n|  |  | python fibo.py <arguments> |  |  |  |\n|  |  | 这项操作将执行模块里的代码，和导入模块一样，但会把 __name__ 赋值为 \"__main__\"。 也就是\n把下列代码添加到模块末尾： |  |  |  |\n|  |  | if __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1])) |  |  |  |\n|  |  | 这个文件既能被用作脚本，又能被用作一个可供导入的模块，因为解析命令行参数的那两行代码只\n有在模块作为“main”文件执行时才会运行： |  |  |  |\n|  |  | $ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34 |  |  |  |\n|  |  | 当这个模块被导入到其它模块时，那两行代码不运行： |  |  |  |\n|  |  | >>> import fibo\n>>> |  |  |  |\n|  |  | 这常用于为模块提供一个便捷的用户接口，或用于测试（把模块作为执行测试套件的脚本运行）。\n6.1.2. 模块搜索路径\n当导入一个名为 spam 的模块时，解释器首先会搜索具有该名称的内置模块。 这些模块的名称在\nsys.builtin_module_names 中列出。 如果未找到，它将在变量 sys.path 所给出的目录列表中搜\n索名为 spam.py 的文件。 sys.path 是从这些位置初始化的:\n被命令行直接运行的脚本所在的目录（或未指定文件时的当前目录）。\nPYTHONPATH （目录列表，与 shell 变量 PATH 的语法一样）。\n依赖于安装的默认值（按照惯例包括一个 site-packages 目录，由 site 模块处理）。\n更多细节请参阅 sys.path 模块搜索路径的初始化。 |  |  |  |\n|  |  | 备注: 在支持符号链接的文件系统中，“被命令行直接运行的脚本所在的目录”是符号链接最终指\n向的目录。换句话说，符号链接所在的目录并 没有 被添加至模块搜索路径。 |  |  |  |\n\n初始化后，Python 程序可以更改 sys.path。脚本所在的目录先于标准库所在的路径被搜索。这意\n味着，脚本所在的目录如果有和标准库同名的文件，那么加载的是该目录里的，而不是标准库的。\n这一般是一个错误，除非这样的替换是你有意为之。详见 标准模块。\n6.1.3. “已编译的” Python 文件\n为了快速加载模块，Python 把模块的编译版本缓存在 __pycache__ 目录中，文件名为\nmodule.version.pyc，version 对编译文件格式进行编码，一般是 Python 的版本号。例如，\nCPython 的 3.3 发行版中，spam.py 的编译版本缓存为 __pycache__/spam.cpython-33.pyc。这种\n命名惯例让不同 Python 版本编译的模块可以共存。\nPython 对比编译版与源码的修改日期，查看编译版是否已过期，是否要重新编译。此进程完全是自\n动的。此外，编译模块与平台无关，因此，可在不同架构的系统之间共享相同的库。\nPython 在两种情况下不检查缓存。一，从命令行直接载入的模块，每次都会重新编译，且不储存编\n译结果；二，没有源模块，就不会检查缓存。为了让一个库能以隐藏源代码的形式分发（通过将所\n有源代码变为编译后的版本），编译后的模块必须放在源目录而非缓存目录中，并且源目录绝不能\n包含同名的未编译的源模块。\n给专业人士的一些小建议：\n在 Python 命令中使用 -O 或 -OO 开关，可以减小编译模块的大小。-O 去除断言语句，-OO 去除\n断言语句和 __doc__ 字符串。有些程序可能依赖于这些内容，因此，没有十足的把握，不要使用\n这两个选项。“优化过的”模块带有 opt- 标签，并且文件通常会一小些。将来的发行版或许会改进\n优化的效果。\n从 .pyc 文件读取的程序不比从 .py 读取的执行速度快，.pyc 文件只是加载速度更快。\ncompileall 模块可以为一个目录下的所有模块创建 .pyc 文件。\n本过程的细节及决策流程图，详见 PEP 3147。\n6.2. 标准模块\nPython 自带一个标准模块的库，它在 Python 库参考（此处以下称为\"库参考\" ）里另外描述。 一些\n模块是内嵌到解释器里面的， 它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效\n率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖\n于底层的操作系统。 例如，winreg 模块只在 Windows 系统上提供。一个特别值得注意的模块\nsys，它被内嵌到每一个 Python 解释器中。sys.ps1 和 sys.ps2 变量定义了一些字符，它们可以\n用作主提示符和辅助提示符:\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\n\n|  |  |  |\n| --- | --- | --- |\n|  | 初始化后，Python 程序可以更改 sys.path。脚本所在的目录先于标准库所在的路径被搜索。这意\n味着，脚本所在的目录如果有和标准库同名的文件，那么加载的是该目录里的，而不是标准库的。\n这一般是一个错误，除非这样的替换是你有意为之。详见 标准模块。\n6.1.3. “已编译的” Python 文件\n为了快速加载模块，Python 把模块的编译版本缓存在 __pycache__ 目录中，文件名为\nmodule.version.pyc，version 对编译文件格式进行编码，一般是 Python 的版本号。例如，\nCPython 的 3.3 发行版中，spam.py 的编译版本缓存为 __pycache__/spam.cpython-33.pyc。这种\n命名惯例让不同 Python 版本编译的模块可以共存。\nPython 对比编译版与源码的修改日期，查看编译版是否已过期，是否要重新编译。此进程完全是自\n动的。此外，编译模块与平台无关，因此，可在不同架构的系统之间共享相同的库。\nPython 在两种情况下不检查缓存。一，从命令行直接载入的模块，每次都会重新编译，且不储存编\n译结果；二，没有源模块，就不会检查缓存。为了让一个库能以隐藏源代码的形式分发（通过将所\n有源代码变为编译后的版本），编译后的模块必须放在源目录而非缓存目录中，并且源目录绝不能\n包含同名的未编译的源模块。\n给专业人士的一些小建议：\n在 Python 命令中使用 -O 或 -OO 开关，可以减小编译模块的大小。-O 去除断言语句，-OO 去除\n断言语句和 __doc__ 字符串。有些程序可能依赖于这些内容，因此，没有十足的把握，不要使用\n这两个选项。“优化过的”模块带有 opt- 标签，并且文件通常会一小些。将来的发行版或许会改进\n优化的效果。\n从 .pyc 文件读取的程序不比从 .py 读取的执行速度快，.pyc 文件只是加载速度更快。\ncompileall 模块可以为一个目录下的所有模块创建 .pyc 文件。\n本过程的细节及决策流程图，详见 PEP 3147。\n6.2. 标准模块\nPython 自带一个标准模块的库，它在 Python 库参考（此处以下称为\"库参考\" ）里另外描述。 一些\n模块是内嵌到解释器里面的， 它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效\n率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖\n于底层的操作系统。 例如，winreg 模块只在 Windows 系统上提供。一个特别值得注意的模块\nsys，它被内嵌到每一个 Python 解释器中。sys.ps1 和 sys.ps2 变量定义了一些字符，它们可以\n用作主提示符和辅助提示符: |  |\n|  | >>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC> |  |\n|  |  |  |\n\n只有解释器用于交互模式时，才定义这两个变量。\n变量 sys.path 是字符串列表，用于确定解释器的模块搜索路径。该变量以环境变量 PYTHONPATH\n提取的默认路径进行初始化，如未设置 PYTHONPATH，则使用内置的默认路径。可以用标准列表操作\n修改该变量：\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n6.3. dir() 函数\n内置函数 dir() 用于查找模块定义的名称。返回结果是经过排序的字符串列表：\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions']\n没有参数时，dir() 列出当前已定义的名称：\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\n注意它列出所有类型的名称：变量，模块，函数，……。\ndir() 不会列出内置函数和变量的名称。这些内容的定义在标准模块 builtins 中：\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n\n|  | 只有解释器用于交互模式时，才定义这两个变量。\n变量 sys.path 是字符串列表，用于确定解释器的模块搜索路径。该变量以环境变量 PYTHONPATH\n提取的默认路径进行初始化，如未设置 PYTHONPATH，则使用内置的默认路径。可以用标准列表操作\n修改该变量： |  |\n| --- | --- | --- |\n|  | >>> import sys\n>>> sys.path.append('/ufs/guido/lib/python') |  |\n|  | 6.3. dir() 函数\n内置函数 dir() 用于查找模块定义的名称。返回结果是经过排序的字符串列表： |  |\n|  | >>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions'] |  |\n|  | 没有参数时，dir() 列出当前已定义的名称： |  |\n|  | >>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys'] |  |\n|  | 注意它列出所有类型的名称：变量，模块，函数，……。\ndir() 不会列出内置函数和变量的名称。这些内容的定义在标准模块 builtins 中： |  |\n|  | >>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', |  |\n\n'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip']\n6.4. 包\n包是通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式。 例如，模块名 A.B 表示名\n为 A 的包中名为 B 的子模块。 就像使用模块可以让不同模块的作者不必担心彼此的全局变量名一\n样，使用带点号模块名也可以让 NumPy 或 Pillow 等多模块包的作者也不必担心彼此的模块名冲\n突。\n假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展\n名来识别，例如：.wav，.aiff，.au），因此，为了不同文件格式之间的转换，需要创建和维护一\n个不断增长的模块集合。为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、\n创造人工立体声效果），还要编写无穷无尽的模块流。下面这个分级文件树展示了这个包的架构：\nsound/ 最高层级的包\n__init__.py 初始化 sound 包\nformats/ 用于文件格式转换的子包\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/ 用于音效的子包\n__init__.py\necho.py\nsurround.py\nreverse.py\n\n|  | 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip'] |  |\n| --- | --- | --- |\n|  | 6.4. 包\n包是通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式。 例如，模块名 A.B 表示名\n为 A 的包中名为 B 的子模块。 就像使用模块可以让不同模块的作者不必担心彼此的全局变量名一\n样，使用带点号模块名也可以让 NumPy 或 Pillow 等多模块包的作者也不必担心彼此的模块名冲\n突。\n假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展\n名来识别，例如：.wav，.aiff，.au），因此，为了不同文件格式之间的转换，需要创建和维护一\n个不断增长的模块集合。为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、\n创造人工立体声效果），还要编写无穷无尽的模块流。下面这个分级文件树展示了这个包的架构： |  |\n|  | sound/ 最高层级的包\n__init__.py 初始化 sound 包\nformats/ 用于文件格式转换的子包\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/ 用于音效的子包\n__init__.py\necho.py\nsurround.py\nreverse.py |  |\n\n...\nfilters/ 用于过滤器的子包\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n...\n导入包时，Python 搜索 sys.path 里的目录，查找包的子目录。\n需要有 __init__.py 文件才能让 Python 将包含该文件的目录当作包来处理（除非使用 namespace\npackage，这是一个相对高级的特性）。 这可以防止重名的目录如 string 在无意中屏蔽后继出现在\n模块搜索路径中的有效模块。 在最简单的情况下，__init__.py 可以只是一个空文件，但它也可以\n执行包的初始化代码或设置 __all__ 变量，这将在稍后详细描述。\n还可以从包中导入单个模块，例如：\nimport sound.effects.echo\n这将加载子模块 sound.effects.echo。 它必须通过其全名来引用。\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\n另一种导入子模块的方法是 ：\nfrom sound.effects import echo\n这也会加载子模块 echo，并使其不必加包前缀，因此可按如下方式使用:\necho.echofilter(input, output, delay=0.7, atten=4)\nImport 语句的另一种变体是直接导入所需的函数或变量：\nfrom sound.effects.echo import echofilter\n同样，这将加载子模块 echo，但这使其函数 echofilter() 直接可用:\nechofilter(input, output, delay=0.7, atten=4)\n注意，使用 from package import item 时，item 可以是包的子模块（或子包），也可以是包中定\n义的函数、类或变量等其他名称。import 语句首先测试包中是否定义了 item；如果未在包中定义，\n则假定 item 是模块，并尝试加载。如果找不到 item，则触发 ImportError 异常。\n相反，使用 import item.subitem.subsubitem 句法时，除最后一项外，每个 item 都必须是包；\n最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。\n6.4.1. 从包中导入 *\n\n|  | ...\nfilters/ 用于过滤器的子包\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n... |  |\n| --- | --- | --- |\n|  | 导入包时，Python 搜索 sys.path 里的目录，查找包的子目录。\n需要有 __init__.py 文件才能让 Python 将包含该文件的目录当作包来处理（除非使用 namespace\npackage，这是一个相对高级的特性）。 这可以防止重名的目录如 string 在无意中屏蔽后继出现在\n模块搜索路径中的有效模块。 在最简单的情况下，__init__.py 可以只是一个空文件，但它也可以\n执行包的初始化代码或设置 __all__ 变量，这将在稍后详细描述。\n还可以从包中导入单个模块，例如： |  |\n|  | import sound.effects.echo |  |\n|  | 这将加载子模块 sound.effects.echo。 它必须通过其全名来引用。 |  |\n|  | sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) |  |\n|  | 另一种导入子模块的方法是 ： |  |\n|  | from sound.effects import echo |  |\n|  | 这也会加载子模块 echo，并使其不必加包前缀，因此可按如下方式使用: |  |\n|  | echo.echofilter(input, output, delay=0.7, atten=4) |  |\n|  | Import 语句的另一种变体是直接导入所需的函数或变量： |  |\n|  | from sound.effects.echo import echofilter |  |\n|  | 同样，这将加载子模块 echo，但这使其函数 echofilter() 直接可用: |  |\n|  | echofilter(input, output, delay=0.7, atten=4) |  |\n|  | 注意，使用 from package import item 时，item 可以是包的子模块（或子包），也可以是包中定\n义的函数、类或变量等其他名称。import 语句首先测试包中是否定义了 item；如果未在包中定义，\n则假定 item 是模块，并尝试加载。如果找不到 item，则触发 ImportError 异常。\n相反，使用 import item.subitem.subsubitem 句法时，除最后一项外，每个 item 都必须是包；\n最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。\n6.4.1. 从包中导入 * |  |\n\n使用 from sound.effects import * 时会发生什么？你可能希望它会查找并导入包的所有子模\n块，但事实并非如此。因为这将花费很长的时间，并且可能会产生你不想要的副作用，如果这种副\n作用被你设计为只有在导入某个特定的子模块时才应该发生。\n唯一的解决办法是提供包的显式索引。import 语句使用如下惯例：如果包的 __init__.py 代码定\n义了列表 __all__，运行 from package import * 时，它就是被导入的模块名列表。发布包的新\n版本时，包的作者应更新此列表。如果包的作者认为没有必要在包中执行导入 * 操作，也可以不提\n供此列表。例如，sound/effects/__init__.py 文件可以包含以下代码：\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n这意味着 from sound.effects import * 将导入 sound.effects 包的三个命名子模块。\n请注意子模块可能会受到本地定义名称的影响。 例如，如果你在 sound/effects/__init__.py 文\n件中添加了一个 reverse 函数，from sound.effects import * 将只导入 echo 和 surround 这\n两个子模块，但 不会 导入 reverse 子模块，因为它被本地定义的 reverse 函数所遮挡:\n__all__ = [\n\"echo\", # 指向 'echo.py' 文件\n\"surround\", # 指向 'surround.py' 文件\n\"reverse\", # !!! 现在指向 'reverse' 函数 !!!\n]\ndef reverse(msg: str): # <-- 此名称将覆盖 'reverse.py' 子模块\nreturn msg[::-1] # 针对 'from sound.effects import *' 的情况\n如果没有定义 __all__，from sound.effects import * 语句 不会 把包 sound.effects 中的所\n有子模块都导入到当前命名空间；它只是确保包 sound.effects 已被导入（可能还会运行\n__init__.py 中的任何初始化代码），然后再导入包中定义的任何名称。 这包括由 __init__.py\n定义的任何名称（以及显式加载的子模块）。 它还包括先前 import 语句显式加载的包里的任何子\n模块。 请看以下代码:\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\n在本例中，echo 和 surround 模块被导入到当前命名空间，因为在执行 from...import 语句时它\n们已在 sound.effects 包中定义了。 （当定义了 __all__ 时也是如此）。\n虽然，可以把模块设计为用 import * 时只导出遵循指定模式的名称，但仍不提倡在生产代码中使\n用这种做法。\n记住，使用 from package import specific_submodule 没有任何问题！ 实际上，除了导入模块\n使用不同包的同名子模块之外，这种方式是推荐用法。\n6.4.2. 相对导入\n当包由多个子包构成（如示例中的 sound 包）时，可以使用绝对导入来引用同级包的子模块。 例\n如，如果 sound.filters.vocoder 模块需要使用 sound.effects 包中的 echo 模块，它可以使用\n\n|  | 使用 from sound.effects import * 时会发生什么？你可能希望它会查找并导入包的所有子模\n块，但事实并非如此。因为这将花费很长的时间，并且可能会产生你不想要的副作用，如果这种副\n作用被你设计为只有在导入某个特定的子模块时才应该发生。\n唯一的解决办法是提供包的显式索引。import 语句使用如下惯例：如果包的 __init__.py 代码定\n义了列表 __all__，运行 from package import * 时，它就是被导入的模块名列表。发布包的新\n版本时，包的作者应更新此列表。如果包的作者认为没有必要在包中执行导入 * 操作，也可以不提\n供此列表。例如，sound/effects/__init__.py 文件可以包含以下代码： |  |\n| --- | --- | --- |\n|  | __all__ = [\"echo\", \"surround\", \"reverse\"] |  |\n|  | 这意味着 from sound.effects import * 将导入 sound.effects 包的三个命名子模块。\n请注意子模块可能会受到本地定义名称的影响。 例如，如果你在 sound/effects/__init__.py 文\n件中添加了一个 reverse 函数，from sound.effects import * 将只导入 echo 和 surround 这\n两个子模块，但 不会 导入 reverse 子模块，因为它被本地定义的 reverse 函数所遮挡: |  |\n|  | __all__ = [\n\"echo\", # 指向 'echo.py' 文件\n\"surround\", # 指向 'surround.py' 文件\n\"reverse\", # !!! 现在指向 'reverse' 函数 !!!\n]\ndef reverse(msg: str): # <-- 此名称将覆盖 'reverse.py' 子模块\nreturn msg[::-1] # 针对 'from sound.effects import *' 的情况 |  |\n|  | 如果没有定义 __all__，from sound.effects import * 语句 不会 把包 sound.effects 中的所\n有子模块都导入到当前命名空间；它只是确保包 sound.effects 已被导入（可能还会运行\n__init__.py 中的任何初始化代码），然后再导入包中定义的任何名称。 这包括由 __init__.py\n定义的任何名称（以及显式加载的子模块）。 它还包括先前 import 语句显式加载的包里的任何子\n模块。 请看以下代码: |  |\n|  | import sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import * |  |\n|  | 在本例中，echo 和 surround 模块被导入到当前命名空间，因为在执行 from...import 语句时它\n们已在 sound.effects 包中定义了。 （当定义了 __all__ 时也是如此）。\n虽然，可以把模块设计为用 import * 时只导出遵循指定模式的名称，但仍不提倡在生产代码中使\n用这种做法。\n记住，使用 from package import specific_submodule 没有任何问题！ 实际上，除了导入模块\n使用不同包的同名子模块之外，这种方式是推荐用法。\n6.4.2. 相对导入\n当包由多个子包构成（如示例中的 sound 包）时，可以使用绝对导入来引用同级包的子模块。 例\n如，如果 sound.filters.vocoder 模块需要使用 sound.effects 包中的 echo 模块，它可以使用 |  |\n\nfrom sound.effects import echo。\n你还可以编写相对导入代码，即使用 from module import name 形式的 import 语句。 这些导入使\n用前导点号来表示相对导入所涉及的当前包和上级包。 例如对于 surround 模块，可以使用:\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n需要注意的是，相对导入是基于当前模块所属包的名称进行的。由于主模块（即直接运行的脚本）\n没有所属包，因此那些打算作为 Python 应用程序主模块使用的模块，必须始终使用绝对导入。\n6.4.3. 多目录中的包\n包还支持一个特殊的属性， __path__ 。 在执行该文件中的代码之前，它被初始化为字符串的\nsequence，其中包含包的 __init__.py 的目录名称。这个变量可以修改；修改后会影响今后对模块\n和包中包含的子包的搜索。\n这个功能虽然不常用，但可用于扩展包中的模块集。\n备注\n[1] 实际上函数定义也是被执行的语句；模块级函数定义的执行会将函数名称添加到模块的全局命\n名空间。\n\n| from sound.effects import echo。\n你还可以编写相对导入代码，即使用 from module import name 形式的 import 语句。 这些导入使\n用前导点号来表示相对导入所涉及的当前包和上级包。 例如对于 surround 模块，可以使用: |\n| --- |\n| from . import echo\nfrom .. import formats\nfrom ..filters import equalizer |\n| 需要注意的是，相对导入是基于当前模块所属包的名称进行的。由于主模块（即直接运行的脚本）\n没有所属包，因此那些打算作为 Python 应用程序主模块使用的模块，必须始终使用绝对导入。\n6.4.3. 多目录中的包\n包还支持一个特殊的属性， __path__ 。 在执行该文件中的代码之前，它被初始化为字符串的\nsequence，其中包含包的 __init__.py 的目录名称。这个变量可以修改；修改后会影响今后对模块\n和包中包含的子包的搜索。\n这个功能虽然不常用，但可用于扩展包中的模块集。\n备注\n[1] 实际上函数定义也是被执行的语句；模块级函数定义的执行会将函数名称添加到模块的全局命\n名空间。 |", "metadata": {"title": "06_模块", "source": "md_docs\\python_docs_md\\06_模块.md", "doc_type": "教程", "language": "中文", "doc_id": "7d6d0559"}}
{"doc_id": "fa99423c", "content": "7. 输入与输出\n程序输出有几种显示方式；数据既可以输出供人阅读的形式，也可以写入文件备用。本章探讨一些\n可用的方式。\n7.1. 更复杂的输出格式\n到目前为止我们已遇到过两种写入值的方式: 表达式语句 和 print() 函数。 （第三种方式是使用文\n件对象的 write() 方法；标准输出文件可以被引用为 sys.stdout。 更多相关信息请参阅标准库参\n考）。\n对输出格式的控制不只是打印空格分隔的值，还需要更多方式。格式化输出包括以下几种方法。\n使用 格式化字符串字面值 ，要在字符串开头的引号/三引号前添加 f 或 F 。在这种字符串中，可\n以在 { 和 } 字符之间输入引用的变量，或字面值的 Python 表达式。\n>>> year = 2016\n>>> event = 'Referendum'\n>>> f'Results of the {year} {event}'\n'Results of the 2016 Referendum'\n字符串的 str.format() 方法需要更多手动操作。 你仍将使用 { 和 } 来标记变量将被替换的位\n置并且可以提供详细的格式化指令，但你还需要提供待格式化的信息。 下面的代码块中有两个格\n式化变量的例子：\n>>> yes_votes = 42_572_654\n>>> total_votes = 85_705_149\n>>> percentage = yes_votes / total_votes\n>>> '{:-9} YES votes {:2.2%}'.format(yes_votes, percentage)\n' 42572654 YES votes 49.67%'\n请注意Notice how the yes_votes 填充了空格并且只为负数添加了负号。 这个例子还打印了\npercentage 乘以 100 的结果，保留 2 个数位并带有一个百分号 (请参阅 格式规格迷你语言 了解\n详情)。\n最后，还可以用字符串切片和合并操作完成字符串处理操作，创建任何排版布局。字符串类型还\n支持将字符串按给定列宽进行填充，这些方法也很有用。\n如果不需要花哨的输出，只想快速显示变量进行调试，可以用 repr() 或 str() 函数把值转化为字\n符串。\nstr() 函数返回供人阅读的值，repr() 则生成适于解释器读取的值（如果没有等效的语法，则强制\n执行 SyntaxError）。对于没有支持供人阅读展示结果的对象， str() 返回与 repr() 相同的值。\n一般情况下，数字、列表或字典等结构的值，使用这两个函数输出的表现形式是一样的。字符串有\n两种不同的表现形式。\n\n示例如下：\n>>> s = 'Hello, world.'\n>>> str(s)\n'Hello, world.'\n>>> repr(s)\n\"'Hello, world.'\"\n>>> str(1/7)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n>>> print(s)\nThe value of x is 32.5, and y is 40000...\n>>> # The repr() of a string adds string quotes and backslashes:\n>>> hello = 'hello, world\\n'\n>>> hellos = repr(hello)\n>>> print(hellos)\n'hello, world\\n'\n>>> # The argument to repr() may be any Python object:\n>>> repr((x, y, ('spam', 'eggs')))\n\"(32.5, 40000, ('spam', 'eggs'))\"\nstring 模块通过 string.Template 提供了一种基于正则表达式的简单模板方法支持。这种方式为\n字符串中的值替换提供了另一种途径：使用类似 $x 的占位符，并将其替换为字典中的对应值。该语\n法使用简便，但在格式控制方面提供的功能较为有限。\n7.1.1. 格式化字符串字面值\n格式化字符串字面值 （简称为 f-字符串）在字符串前加前缀 f 或 F，通过 {expression} 表达式，\n把 Python 表达式的值添加到字符串内。\n格式说明符是可选的，写在表达式后面，可以更好地控制格式化值的方式。下例将 pi 舍入到小数点\n后三位：\n>>> import math\n>>> print(f'The value of pi is approximately {math.pi:.3f}.')\nThe value of pi is approximately 3.142.\n在 ':' 后传递整数，为该字段设置最小字符宽度，常用于列对齐：\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n>>> for name, phone in table.items():\n... print(f'{name:10} ==> {phone:10d}')\n...\nSjoerd ==> 4127\nJack ==> 4098\nDcab ==> 7678\n还有一些修饰符可以在格式化前转换值。 '!a' 应用 ascii() ，'!s' 应用 str()，'!r' 应用\nrepr()：\n\n|  | 示例如下： |  |\n| --- | --- | --- |\n|  | >>> s = 'Hello, world.'\n>>> str(s)\n'Hello, world.'\n>>> repr(s)\n\"'Hello, world.'\"\n>>> str(1/7)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n>>> print(s)\nThe value of x is 32.5, and y is 40000...\n>>> # The repr() of a string adds string quotes and backslashes:\n>>> hello = 'hello, world\\n'\n>>> hellos = repr(hello)\n>>> print(hellos)\n'hello, world\\n'\n>>> # The argument to repr() may be any Python object:\n>>> repr((x, y, ('spam', 'eggs')))\n\"(32.5, 40000, ('spam', 'eggs'))\" |  |\n|  | string 模块通过 string.Template 提供了一种基于正则表达式的简单模板方法支持。这种方式为\n字符串中的值替换提供了另一种途径：使用类似 $x 的占位符，并将其替换为字典中的对应值。该语\n法使用简便，但在格式控制方面提供的功能较为有限。\n7.1.1. 格式化字符串字面值\n格式化字符串字面值 （简称为 f-字符串）在字符串前加前缀 f 或 F，通过 {expression} 表达式，\n把 Python 表达式的值添加到字符串内。\n格式说明符是可选的，写在表达式后面，可以更好地控制格式化值的方式。下例将 pi 舍入到小数点\n后三位： |  |\n|  | >>> import math\n>>> print(f'The value of pi is approximately {math.pi:.3f}.')\nThe value of pi is approximately 3.142. |  |\n|  | 在 ':' 后传递整数，为该字段设置最小字符宽度，常用于列对齐： |  |\n|  | >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n>>> for name, phone in table.items():\n... print(f'{name:10} ==> {phone:10d}')\n...\nSjoerd ==> 4127\nJack ==> 4098\nDcab ==> 7678 |  |\n|  | 还有一些修饰符可以在格式化前转换值。 '!a' 应用 ascii() ，'!s' 应用 str()，'!r' 应用\nrepr()： |  |\n\n>>> animals = 'eels'\n>>> print(f'My hovercraft is full of {animals}.')\nMy hovercraft is full of eels.\n>>> print(f'My hovercraft is full of {animals!r}.')\nMy hovercraft is full of 'eels'.\n= 说明符可被用于将一个表达式扩展为表达式文本、等号再加表达式求值结果的形式。\n>>> bugs = 'roaches'\n>>> count = 13\n>>> area = 'living room'\n>>> print(f'Debugging {bugs=} {count=} {area=}')\nDebugging bugs='roaches' count=13 area='living room'\n请参阅 自说明型表达式 以了解 = 说明符的更多信息。 有关这些格式说明的详情，请查看针对 格式\n规格迷你语言 的参考指南。\n7.1.2. 字符串 format() 方法\nstr.format() 方法的基本用法如下所示：\n>>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\nWe are the knights who say \"Ni!\"\n花括号及之内的字符（称为格式字段）被替换为传递给 str.format() 方法的对象。花括号中的数\n字表示传递给 str.format() 方法的对象所在的位置。\n>>> print('{0} and {1}'.format('spam', 'eggs'))\nspam and eggs\n>>> print('{1} and {0}'.format('spam', 'eggs'))\neggs and spam\nstr.format() 方法中使用关键字参数名引用值。\n>>> print('This {food} is {adjective}.'.format(\n... food='spam', adjective='absolutely horrible'))\nThis spam is absolutely horrible.\n位置参数和关键字参数可以任意组合：\n>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n... other='Georg'))\nThe story of Bill, Manfred, and Georg.\n如果不想分拆较长的格式字符串，最好按名称引用变量进行格式化，不要按位置。这项操作可以通\n过传递字典，并用方括号 '[]' 访问键来完成。\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n... 'Dcab: {0[Dcab]:d}'.format(table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n\n|  | >>> animals = 'eels'\n>>> print(f'My hovercraft is full of {animals}.')\nMy hovercraft is full of eels.\n>>> print(f'My hovercraft is full of {animals!r}.')\nMy hovercraft is full of 'eels'. |  |\n| --- | --- | --- |\n|  | = 说明符可被用于将一个表达式扩展为表达式文本、等号再加表达式求值结果的形式。 |  |\n|  | >>> bugs = 'roaches'\n>>> count = 13\n>>> area = 'living room'\n>>> print(f'Debugging {bugs=} {count=} {area=}')\nDebugging bugs='roaches' count=13 area='living room' |  |\n|  | 请参阅 自说明型表达式 以了解 = 说明符的更多信息。 有关这些格式说明的详情，请查看针对 格式\n规格迷你语言 的参考指南。\n7.1.2. 字符串 format() 方法\nstr.format() 方法的基本用法如下所示： |  |\n|  | >>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\nWe are the knights who say \"Ni!\" |  |\n|  | 花括号及之内的字符（称为格式字段）被替换为传递给 str.format() 方法的对象。花括号中的数\n字表示传递给 str.format() 方法的对象所在的位置。 |  |\n|  | >>> print('{0} and {1}'.format('spam', 'eggs'))\nspam and eggs\n>>> print('{1} and {0}'.format('spam', 'eggs'))\neggs and spam |  |\n|  | str.format() 方法中使用关键字参数名引用值。 |  |\n|  | >>> print('This {food} is {adjective}.'.format(\n... food='spam', adjective='absolutely horrible'))\nThis spam is absolutely horrible. |  |\n|  | 位置参数和关键字参数可以任意组合： |  |\n|  | >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n... other='Georg'))\nThe story of Bill, Manfred, and Georg. |  |\n|  | 如果不想分拆较长的格式字符串，最好按名称引用变量进行格式化，不要按位置。这项操作可以通\n过传递字典，并用方括号 '[]' 访问键来完成。 |  |\n|  | >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n... 'Dcab: {0[Dcab]:d}'.format(table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678 |  |\n|  |  |  |\n\n这也可以通过将 table 字典作为采用 ** 标记的关键字参数传入来实现。\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n与内置函数 vars() 一同使用时这种方式非常实用，它将返回一个包含所有局部变量的字典:\n>>> table = {k: str(v) for k, v in vars().items()}\n>>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n>>> print(message.format(**table))\n__name__: __main__; __doc__: None; __package__: None; __loader__: ...\n举个例子，以下几行代码将产生一组整齐的数据列，包含给定的整数及其平方与立方:\n>>> for x in range(1, 11):\n... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n1 1 1\n2 4 8\n3 9 27\n4 16 64\n5 25 125\n6 36 216\n7 49 343\n8 64 512\n9 81 729\n10 100 1000\nstr.format() 进行字符串格式化的完整概述详见 格式字符串语法 。\n7.1.3. 手动格式化字符串\n下面是使用手动格式化方式实现的同一个平方和立方的表：\n>>> for x in range(1, 11):\n... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n... # 请注意上一行中 'end' 的使用\n... print(repr(x*x*x).rjust(4))\n...\n1 1 1\n2 4 8\n3 9 27\n4 16 64\n5 25 125\n6 36 216\n7 49 343\n8 64 512\n9 81 729\n10 100 1000\n（注意，每列之间的空格是通过使用 print() 添加的：它总在其参数间添加空格。）\n字符串对象的 str.rjust() 方法通过在左侧填充空格，对给定宽度字段中的字符串进行右对齐。同\n类方法还有 str.ljust() 和 str.center() 。这些方法不写入任何内容，只返回一个新字符串，如\n\n|  | 这也可以通过将 table 字典作为采用 ** 标记的关键字参数传入来实现。 |  |\n| --- | --- | --- |\n|  | >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678 |  |\n|  | 与内置函数 vars() 一同使用时这种方式非常实用，它将返回一个包含所有局部变量的字典: |  |\n|  | >>> table = {k: str(v) for k, v in vars().items()}\n>>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n>>> print(message.format(**table))\n__name__: __main__; __doc__: None; __package__: None; __loader__: ... |  |\n|  | 举个例子，以下几行代码将产生一组整齐的数据列，包含给定的整数及其平方与立方: |  |\n|  | >>> for x in range(1, 11):\n... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n1 1 1\n2 4 8\n3 9 27\n4 16 64\n5 25 125\n6 36 216\n7 49 343\n8 64 512\n9 81 729\n10 100 1000 |  |\n|  | str.format() 进行字符串格式化的完整概述详见 格式字符串语法 。\n7.1.3. 手动格式化字符串\n下面是使用手动格式化方式实现的同一个平方和立方的表： |  |\n|  | >>> for x in range(1, 11):\n... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n... # 请注意上一行中 'end' 的使用\n... print(repr(x*x*x).rjust(4))\n...\n1 1 1\n2 4 8\n3 9 27\n4 16 64\n5 25 125\n6 36 216\n7 49 343\n8 64 512\n9 81 729\n10 100 1000 |  |\n|  | （注意，每列之间的空格是通过使用 print() 添加的：它总在其参数间添加空格。）\n字符串对象的 str.rjust() 方法通过在左侧填充空格，对给定宽度字段中的字符串进行右对齐。同\n类方法还有 str.ljust() 和 str.center() 。这些方法不写入任何内容，只返回一个新字符串，如 |  |\n\n果输入的字符串太长，它们不会截断字符串，而是原样返回；虽然这种方式会弄乱列布局，但也比\n另一种方法好，后者在显示值时可能不准确（如果真的想截断字符串，可以使用 x.ljust(n)[:n]\n这样的切片操作 。）\n另一种方法是 str.zfill() ，该方法在数字字符串左边填充零，且能识别正负号：\n>>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359'\n7.1.4. 旧式字符串格式化方法\n% 运算符 (求余) 也可被用于字符串格式化。 给定 format % values (其中 format 是一个字符串)，\n则 format 中的 % 转换占位符将以 values 中的零个或多个元素来替换。 此操作通常称为字符串插\n值。 例如:\n>>> import math\n>>> print('The value of pi is approximately %5.3f.' % math.pi)\nThe value of pi is approximately 3.142.\nprintf 风格的字符串格式化 小节介绍更多相关内容。\n7.2. 读写文件\nopen() 返回一个 file object ，最常使用的是两个位置参数和一个关键字参数：open(filename,\nmode, encoding=None)\n>>> f = open('workfile', 'w', encoding=\"utf-8\")\n第一个实参是文件名字符串。第二个实参是包含描述文件使用方式字符的字符串。mode 的值包括\n'r' ，表示文件只能读取；'w' 表示只能写入（现有同名文件会被覆盖）；'a' 表示打开文件并追\n加内容，任何写入的数据会自动添加到文件末尾。'r+' 表示打开文件进行读写。mode 实参是可选\n的，省略时的默认值为 'r'。\n通常情况下，文件是以 text mode 打开的，也就是说，你从文件中读写字符串，这些字符串是以特定\n的 encoding 编码的。如果没有指定 encoding ，默认的是与平台有关的（见 open() ）。因为 UTF-8\n是现代事实上的标准，除非你知道你需要使用一个不同的编码，否则建议使用 encoding=\"utf-8\"\n。在模式后面加上一个 'b' ，可以用 binary mode 打开文件。二进制模式的数据是以 bytes 对象的\n形式读写的。在二进制模式下打开文件时，你不能指定 encoding 。\n在文本模式下读取文件时，默认把平台特定的行结束符（Unix 上为 \\n, Windows 上为 \\r\\n）转换\n为 \\n。在文本模式下写入数据时，默认把 \\n 转换回平台特定结束符。这种操作方式在后台修改文\n件数据对文本文件来说没有问题，但会破坏 JPEG 或 EXE 等二进制文件中的数据。注意，在读写此\n类文件时，一定要使用二进制模式。\n\n|  |  | 果输入的字符串太长，它们不会截断字符串，而是原样返回；虽然这种方式会弄乱列布局，但也比\n另一种方法好，后者在显示值时可能不准确（如果真的想截断字符串，可以使用 x.ljust(n)[:n]\n这样的切片操作 。）\n另一种方法是 str.zfill() ，该方法在数字字符串左边填充零，且能识别正负号： |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  | >>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359' |  |  |  |\n|  |  | 7.1.4. 旧式字符串格式化方法\n% 运算符 (求余) 也可被用于字符串格式化。 给定 format % values (其中 format 是一个字符串)，\n则 format 中的 % 转换占位符将以 values 中的零个或多个元素来替换。 此操作通常称为字符串插\n值。 例如: |  |  |  |\n|  |  | >>> import math\n>>> print('The value of pi is approximately %5.3f.' % math.pi)\nThe value of pi is approximately 3.142. |  |  |  |\n|  |  | printf 风格的字符串格式化 小节介绍更多相关内容。\n7.2. 读写文件\nopen() 返回一个 file object ，最常使用的是两个位置参数和一个关键字参数：open(filename,\nmode, encoding=None) |  |  |  |\n|  |  |  | open(filename, |  |  |\n|  |  |  |  |  |  |\n|  |  | mode, encoding=None) |  |  |  |\n|  |  |  |  |  |  |\n|  |  | >>> f = open('workfile', 'w', encoding=\"utf-8\") |  |  |  |\n|  |  | 第一个实参是文件名字符串。第二个实参是包含描述文件使用方式字符的字符串。mode 的值包括\n'r' ，表示文件只能读取；'w' 表示只能写入（现有同名文件会被覆盖）；'a' 表示打开文件并追\n加内容，任何写入的数据会自动添加到文件末尾。'r+' 表示打开文件进行读写。mode 实参是可选\n的，省略时的默认值为 'r'。\n通常情况下，文件是以 text mode 打开的，也就是说，你从文件中读写字符串，这些字符串是以特定\n的 encoding 编码的。如果没有指定 encoding ，默认的是与平台有关的（见 open() ）。因为 UTF-8\n是现代事实上的标准，除非你知道你需要使用一个不同的编码，否则建议使用 encoding=\"utf-8\"\n。在模式后面加上一个 'b' ，可以用 binary mode 打开文件。二进制模式的数据是以 bytes 对象的\n形式读写的。在二进制模式下打开文件时，你不能指定 encoding 。\n在文本模式下读取文件时，默认把平台特定的行结束符（Unix 上为 \\n, Windows 上为 \\r\\n）转换\n为 \\n。在文本模式下写入数据时，默认把 \\n 转换回平台特定结束符。这种操作方式在后台修改文\n件数据对文本文件来说没有问题，但会破坏 JPEG 或 EXE 等二进制文件中的数据。注意，在读写此\n类文件时，一定要使用二进制模式。 |  |  |  |\n\n在处理文件对象时，最好使用 with 关键字。优点是，子句体结束后，文件会正确关闭，即便触发异\n常也可以。而且，使用 with 相比等效的 try-finally 代码块要简短得多：\n>>> with open('workfile', encoding=\"utf-8\") as f:\n... read_data = f.read()\n>>> # 我们可以检测文件是否已被自动关闭。\n>>> f.closed\nTrue\n如果没有使用 with 关键字，则应调用 f.close() 关闭文件，即可释放文件占用的系统资源。\n警告: 调用 f.write() 时，未使用 with 关键字，或未调用 f.close()，即使程序正常退出，\n也**可能** 导致 f.write() 的参数没有完全写入磁盘。\n通过 with 语句，或调用 f.close() 关闭文件对象后，再次使用该文件对象将会失败。\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file.\n7.2.1. 文件对象的方法\n本节下文中的例子假定已创建 f 文件对象。\nf.read(size) 可用于读取文件内容，它会读取一些数据，并返回字符串（文本模式），或字节串对\n象（在二进制模式下）。 size 是可选的数值参数。省略 size 或 size 为负数时，读取并返回整个文件\n的内容；文件大小是内存的两倍时，会出现问题。size 取其他值时，读取并返回最多 size 个字符\n（文本模式）或 size 个字节（二进制模式）。如已到达文件末尾，f.read() 返回空字符串\n（''）。\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\nf.readline() 从文件中读取单行数据；字符串末尾保留换行符（\\n），只有在文件不以换行符结\n尾时，文件的最后一行才会省略换行符。这种方式让返回值清晰明确；只要 f.readline() 返回空\n字符串，就表示已经到达了文件末尾，空行使用 '\\n' 表示，该字符串只包含一个换行符。\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n\n|  | 在处理文件对象时，最好使用 with 关键字。优点是，子句体结束后，文件会正确关闭，即便触发异\n常也可以。而且，使用 with 相比等效的 try-finally 代码块要简短得多： |  |\n| --- | --- | --- |\n|  | >>> with open('workfile', encoding=\"utf-8\") as f:\n... read_data = f.read()\n>>> # 我们可以检测文件是否已被自动关闭。\n>>> f.closed\nTrue |  |\n|  | 如果没有使用 with 关键字，则应调用 f.close() 关闭文件，即可释放文件占用的系统资源。 |  |\n|  | 警告: 调用 f.write() 时，未使用 with 关键字，或未调用 f.close()，即使程序正常退出，\n也**可能** 导致 f.write() 的参数没有完全写入磁盘。 |  |\n|  | 通过 with 语句，或调用 f.close() 关闭文件对象后，再次使用该文件对象将会失败。 |  |\n|  | >>> f.close()\n>>> f.read()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file. |  |\n|  | 7.2.1. 文件对象的方法\n本节下文中的例子假定已创建 f 文件对象。\nf.read(size) 可用于读取文件内容，它会读取一些数据，并返回字符串（文本模式），或字节串对\n象（在二进制模式下）。 size 是可选的数值参数。省略 size 或 size 为负数时，读取并返回整个文件\n的内容；文件大小是内存的两倍时，会出现问题。size 取其他值时，读取并返回最多 size 个字符\n（文本模式）或 size 个字节（二进制模式）。如已到达文件末尾，f.read() 返回空字符串\n（''）。 |  |\n|  | >>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n'' |  |\n|  | f.readline() 从文件中读取单行数据；字符串末尾保留换行符（\\n），只有在文件不以换行符结\n尾时，文件的最后一行才会省略换行符。这种方式让返回值清晰明确；只要 f.readline() 返回空\n字符串，就表示已经到达了文件末尾，空行使用 '\\n' 表示，该字符串只包含一个换行符。 |  |\n|  | >>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n'' |  |\n|  |  |  |\n\n从文件中读取多行时，可以用循环遍历整个文件对象。这种操作能高效利用内存，快速，且代码简\n单：\n>>> for line in f:\n... print(line, end='')\n...\nThis is the first line of the file.\nSecond line of the file\n如需以列表形式读取文件中的所有行，可以用 list(f) 或 f.readlines()。\nf.write(string) 把 string 的内容写入文件，并返回写入的字符数。\n>>> f.write('This is a test\\n')\n15\n写入其他类型的对象前，要先把它们转化为字符串（文本模式）或字节对象（二进制模式）：\n>>> value = ('the answer', 42)\n>>> s = str(value) # 将元组转换为字符串\n>>> f.write(s)\n18\nf.tell() 返回整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节\n数，以及文本模式下的意义不明的数字。\nf.seek(offset, whence) 可以改变文件对象的位置。通过向参考点添加 offset 计算位置；参考点\n由 whence 参数指定。 whence 值为 0 时，表示从文件开头计算，1 表示使用当前文件位置，2 表示\n使用文件末尾作为参考点。省略 whence 时，其默认值为 0，即使用文件开头作为参考点。\n>>> f = open('workfile', 'rb+')\n>>> f.write(b'0123456789abcdef')\n16\n>>> f.seek(5) # 定位到文件中的第 6 个字节\n5\n>>> f.read(1)\nb'5'\n>>> f.seek(-3, 2) # 定位到倒数第 3 个字节\n13\n>>> f.read(1)\nb'd'\n在文本文件（模式字符串未使用 b 时打开的文件）中，只允许相对于文件开头搜索（使用 seek(0,\n2) 搜索到文件末尾是个例外），唯一有效的 offset 值是能从 f.tell() 中返回的，或 0。其他 offset\n值都会产生未定义的行为。\n文件对象还有一些额外的方法，如使用频率较低的 isatty() 和 truncate() 等；有关文件对象的\n完整指南请查阅标准库参考。\n7.2.2. 使用 json 保存结构化数据\n\n|  |  | 从文件中读取多行时，可以用循环遍历整个文件对象。这种操作能高效利用内存，快速，且代码简\n单： |  |\n| --- | --- | --- | --- |\n|  |  | >>> for line in f:\n... print(line, end='')\n...\nThis is the first line of the file.\nSecond line of the file |  |\n|  |  | 如需以列表形式读取文件中的所有行，可以用 list(f) 或 f.readlines()。\nf.write(string) 把 string 的内容写入文件，并返回写入的字符数。 |  |\n|  |  | >>> f.write('This is a test\\n')\n15 |  |\n|  |  | 写入其他类型的对象前，要先把它们转化为字符串（文本模式）或字节对象（二进制模式）： |  |\n|  |  | >>> value = ('the answer', 42)\n>>> s = str(value) # 将元组转换为字符串\n>>> f.write(s)\n18 |  |\n|  |  | f.tell() 返回整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节\n数，以及文本模式下的意义不明的数字。\nf.seek(offset, whence) 可以改变文件对象的位置。通过向参考点添加 offset 计算位置；参考点\n由 whence 参数指定。 whence 值为 0 时，表示从文件开头计算，1 表示使用当前文件位置，2 表示\n使用文件末尾作为参考点。省略 whence 时，其默认值为 0，即使用文件开头作为参考点。 |  |\n|  |  | >>> f = open('workfile', 'rb+')\n>>> f.write(b'0123456789abcdef')\n16\n>>> f.seek(5) # 定位到文件中的第 6 个字节\n5\n>>> f.read(1)\nb'5'\n>>> f.seek(-3, 2) # 定位到倒数第 3 个字节\n13\n>>> f.read(1)\nb'd' |  |\n|  |  | 在文本文件（模式字符串未使用 b 时打开的文件）中，只允许相对于文件开头搜索（使用 seek(0,\n2) 搜索到文件末尾是个例外），唯一有效的 offset 值是能从 f.tell() 中返回的，或 0。其他 offset\n值都会产生未定义的行为。\n文件对象还有一些额外的方法，如使用频率较低的 isatty() 和 truncate() 等；有关文件对象的\n完整指南请查阅标准库参考。\n7.2.2. 使用 json 保存结构化数据 |  |\n|  |  | 2) |  |\n|  |  |  |  |\n\n| seek(0, |  |\n| --- | --- |\n\n字符串可以很容易地写入文件或从文件中读取。 数字则更麻烦一些，因为 read() 方法只返回字符\n串，而字符串必须传给 int() 这样的函数，它接受 '123' 这样的字符串并返回其数值 123。 当你想\n要保存嵌套列表和字典等更复杂的数据类型时，手动执行解析和序列化操作将会变得非常复杂。\nPython 允许你使用流行的数据交换格式 JSON (JavaScript Object Notation)，而不是让用户持续编写\n和调试代码来将复杂的数据类型存入文件中。 标准库模块 json 可以接受带有层级结构的 Python 数\n据，并将其转换为字符串表示形式；这个过程称为 serializing。 根据字符串表示形式重建数据则称\n为 deserializing。 在序列化和反序列化之间，用于代表对象的字符串可以存储在文件或数据库中，\n或者通过网络连接发送到远端主机。\n备注: JSON 格式通常用于现代应用程序的数据交换。程序员早已对它耳熟能详，可谓是交互操\n作的不二之选。\n只需一行简单的代码即可查看某个对象的 JSON 字符串表现形式：\n>>> import json\n>>> x = [1, 'simple', 'list']\n>>> json.dumps(x)\n'[1, \"simple\", \"list\"]'\ndumps() 函数还有一个变体， dump() ，它只将对象序列化为 text file 。因此，如果 f 是 text file 对\n象，可以这样做：\njson.dump(x, f)\n要再次解码对象，如果 f 是已打开、供读取的 binary file 或 text file 对象：\nx = json.load(f)\n备注: JSON文件必须以UTF-8编码。当打开JSON文件作为一个 text file 用于读写时，使用\nencoding=\"utf-8\" 。\n这种简单的序列化技术可以处理列表和字典，但在 JSON 中序列化任意类的实例，则需要付出额外\n努力。json 模块的参考包含对此的解释。\n参见: pickle - 封存模块\n与 JSON 不同，pickle 是一种允许对复杂 Python 对象进行序列化的协议。因此，它为 Python 所\n特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果解序化的数\n据是由手段高明的攻击者精心设计的，这种不受信任来源的 pickle 数据可以执行任意代码。\n\n| 字符串可以很容易地写入文件或从文件中读取。 数字则更麻烦一些，因为 read() 方法只返回字符\n串，而字符串必须传给 int() 这样的函数，它接受 '123' 这样的字符串并返回其数值 123。 当你想\n要保存嵌套列表和字典等更复杂的数据类型时，手动执行解析和序列化操作将会变得非常复杂。\nPython 允许你使用流行的数据交换格式 JSON (JavaScript Object Notation)，而不是让用户持续编写\n和调试代码来将复杂的数据类型存入文件中。 标准库模块 json 可以接受带有层级结构的 Python 数\n据，并将其转换为字符串表示形式；这个过程称为 serializing。 根据字符串表示形式重建数据则称\n为 deserializing。 在序列化和反序列化之间，用于代表对象的字符串可以存储在文件或数据库中，\n或者通过网络连接发送到远端主机。 |\n| --- |\n| 备注: JSON 格式通常用于现代应用程序的数据交换。程序员早已对它耳熟能详，可谓是交互操\n作的不二之选。 |\n| 只需一行简单的代码即可查看某个对象的 JSON 字符串表现形式： |\n| >>> import json\n>>> x = [1, 'simple', 'list']\n>>> json.dumps(x)\n'[1, \"simple\", \"list\"]' |\n| dumps() 函数还有一个变体， dump() ，它只将对象序列化为 text file 。因此，如果 f 是 text file 对\n象，可以这样做： |\n| json.dump(x, f) |\n| 要再次解码对象，如果 f 是已打开、供读取的 binary file 或 text file 对象： |\n| x = json.load(f) |\n|  |\n| 备注: JSON文件必须以UTF-8编码。当打开JSON文件作为一个 text file 用于读写时，使用\nencoding=\"utf-8\" 。 |\n| 这种简单的序列化技术可以处理列表和字典，但在 JSON 中序列化任意类的实例，则需要付出额外\n努力。json 模块的参考包含对此的解释。 |\n| 参见: pickle - 封存模块\n与 JSON 不同，pickle 是一种允许对复杂 Python 对象进行序列化的协议。因此，它为 Python 所\n特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果解序化的数\n据是由手段高明的攻击者精心设计的，这种不受信任来源的 pickle 数据可以执行任意代码。 |", "metadata": {"title": "07_输入与输出", "source": "md_docs\\python_docs_md\\07_输入与输出.md", "doc_type": "教程", "language": "中文", "doc_id": "fa99423c"}}
{"doc_id": "2fab4292", "content": "8. 错误和异常\n至此，本教程还未深入介绍错误信息，但如果您尝试过本教程前文中的例子，应该已经看到过一些\n错误信息。错误可（至少）被分为两种：语法错误 和 异常。\n8.1. 语法错误\n语法错误又称解析错误，是学习 Python 时最常见的错误：\n>>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax\n解析器会重复出错的行并显示指向检测到错误的位置的小箭头。 请注意这并不一定是需要被修复的\n位置。 在这个例子中，错误在 print() 上被检测到，原因则是在它之前缺少一个冒号 (':')。\n将会打印文件名 (在我们的例子中为 <stdin>) 和行号以便你在输入是来自文件时能知道要去哪里查\n看。\n8.2. 异常\n即使语句或表达式使用了正确的语法，执行时仍可能触发错误。执行时检测到的错误称为 异常，异\n常不一定导致严重的后果：很快我们就能学会如何处理 Python 的异常。大多数异常不会被程序处\n理，而是显示下列错误信息：\n>>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n10 * (1/0)\n~^~\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n4 + spam*3\n^^^^\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n'2' + 2\n~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str\n\n| 8. 错误和异常\n至此，本教程还未深入介绍错误信息，但如果您尝试过本教程前文中的例子，应该已经看到过一些\n错误信息。错误可（至少）被分为两种：语法错误 和 异常。\n8.1. 语法错误\n语法错误又称解析错误，是学习 Python 时最常见的错误： |\n| --- |\n| >>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax |\n| 解析器会重复出错的行并显示指向检测到错误的位置的小箭头。 请注意这并不一定是需要被修复的\n位置。 在这个例子中，错误在 print() 上被检测到，原因则是在它之前缺少一个冒号 (':')。\n将会打印文件名 (在我们的例子中为 <stdin>) 和行号以便你在输入是来自文件时能知道要去哪里查\n看。\n8.2. 异常\n即使语句或表达式使用了正确的语法，执行时仍可能触发错误。执行时检测到的错误称为 异常，异\n常不一定导致严重的后果：很快我们就能学会如何处理 Python 的异常。大多数异常不会被程序处\n理，而是显示下列错误信息： |\n| >>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n10 * (1/0)\n~^~\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n4 + spam*3\n^^^^\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n'2' + 2\n~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str |\n|  |\n\n错误信息的最后一行说明程序遇到了什么类型的错误。异常有不同的类型，而类型名称会作为错误\n信息的一部分中打印出来：上述示例中的异常类型依次是：ZeroDivisionError， NameError 和\nTypeError。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，\n但对于用户定义的异常则不一定如此（虽然这种规范很有用）。标准的异常类型是内置的标识符\n（不是保留关键字）。\n此行其余部分根据异常类型，结合出错原因，说明错误细节。\n错误信息开头用堆栈回溯形式展示发生异常的语境。一般会列出源代码行的堆栈回溯；但不会显示\n从标准输入读取的行。\n内置异常 列出了内置异常及其含义。\n8.3. 异常的处理\n可以编写程序处理选定的异常。下例会要求用户一直输入内容，直到输入有效的整数，但允许用户\n中断程序（使用 Control-C 或操作系统支持的其他操作）；注意，用户中断程序会触发\nKeyboardInterrupt 异常。\n>>> while True:\n... try:\n... x = int(input(\"Please enter a number: \"))\n... break\n... except ValueError:\n... print(\"Oops! That was no valid number. Try again...\")\n...\ntry 语句的工作原理如下：\n首先，执行 try 子句 （try 和 except 关键字之间的（多行）语句）。\n如果没有触发异常，则跳过 except 子句，try 语句执行完毕。\n如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 如果异常的类型与 except 关\n键字后指定的异常相匹配，则会执行 except 子句，然后跳到 try/except 代码块之后继续执行。\n如果发生的异常与 except 子句 中指定的异常不匹配，则它会被传递到外层的 try 语句中；如果\n没有找到处理器，则它是一个 未处理异常 且执行将停止并输出一条错误消息。\ntry 语句可以有多个 except 子句 来为不同的异常指定处理程序。 但最多只有一个处理程序会被执\n行。 处理程序只处理对应的 try 子句 中发生的异常，而不处理同一 try 语句内其他处理程序中的异\n常。 except 子句 可以用带圆括号的元组来指定多个异常，例如:\n... except (RuntimeError, TypeError, NameError):\n... pass\n一个 except 子句中的类匹配的异常将是该类本身的实例或其所派生的类的实例（但反过来则不可\n以 --- 列出派生类的 except 子句 不会匹配其基类的实例）。 例如，下面的代码将依次打印 B, C, D:\nclass B(Exception):\npass\nclass C(B):\n\n|  | 错误信息的最后一行说明程序遇到了什么类型的错误。异常有不同的类型，而类型名称会作为错误\n信息的一部分中打印出来：上述示例中的异常类型依次是：ZeroDivisionError， NameError 和\nTypeError。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，\n但对于用户定义的异常则不一定如此（虽然这种规范很有用）。标准的异常类型是内置的标识符\n（不是保留关键字）。\n此行其余部分根据异常类型，结合出错原因，说明错误细节。\n错误信息开头用堆栈回溯形式展示发生异常的语境。一般会列出源代码行的堆栈回溯；但不会显示\n从标准输入读取的行。\n内置异常 列出了内置异常及其含义。\n8.3. 异常的处理\n可以编写程序处理选定的异常。下例会要求用户一直输入内容，直到输入有效的整数，但允许用户\n中断程序（使用 Control-C 或操作系统支持的其他操作）；注意，用户中断程序会触发\nKeyboardInterrupt 异常。 |  |\n| --- | --- | --- |\n|  | >>> while True:\n... try:\n... x = int(input(\"Please enter a number: \"))\n... break\n... except ValueError:\n... print(\"Oops! That was no valid number. Try again...\")\n... |  |\n|  | try 语句的工作原理如下：\n首先，执行 try 子句 （try 和 except 关键字之间的（多行）语句）。\n如果没有触发异常，则跳过 except 子句，try 语句执行完毕。\n如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 如果异常的类型与 except 关\n键字后指定的异常相匹配，则会执行 except 子句，然后跳到 try/except 代码块之后继续执行。\n如果发生的异常与 except 子句 中指定的异常不匹配，则它会被传递到外层的 try 语句中；如果\n没有找到处理器，则它是一个 未处理异常 且执行将停止并输出一条错误消息。\ntry 语句可以有多个 except 子句 来为不同的异常指定处理程序。 但最多只有一个处理程序会被执\n行。 处理程序只处理对应的 try 子句 中发生的异常，而不处理同一 try 语句内其他处理程序中的异\n常。 except 子句 可以用带圆括号的元组来指定多个异常，例如: |  |\n|  | ... except (RuntimeError, TypeError, NameError):\n... pass |  |\n|  | 一个 except 子句中的类匹配的异常将是该类本身的实例或其所派生的类的实例（但反过来则不可\n以 --- 列出派生类的 except 子句 不会匹配其基类的实例）。 例如，下面的代码将依次打印 B, C, D: |  |\n|  | class B(Exception):\npass\nclass C(B): |  |\n\npass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\")\n请注意如果颠倒 except 子句 的顺序（把 except B 放在最前），则会输出 B, B, B --- 即触发了第一\n个匹配的 except 子句。\n发生异常时，它可能具有关联值，即异常 参数 。是否需要参数，以及参数的类型取决于异常的类\n型。\nexcept 子句 可能会在异常名称后面指定一个变量。 这个变量将被绑定到异常实例，该实例通常会有\n一个存储参数的 args 属性。 为了方便起见，内置异常类型定义了 __str__() 来打印所有参数而不\n必显式地访问 .args。\n>>> try:\n... raise Exception('spam', 'eggs')\n... except Exception as inst:\n... print(type(inst)) # 异常的类型\n... print(inst.args) # 参数保存在 .args 中\n... print(inst) # __str__ 允许 args 被直接打印，\n... # 但可能在异常子类中被覆盖\n... x, y = inst.args # 解包 args\n... print('x =', x)\n... print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\n未处理异常的 __str__() 输出会被打印为该异常消息的最后部分 ('detail')。\nBaseException 是所有异常的共同基类。它的一个子类， Exception ，是所有非致命异常的基类。\n不是 Exception 的子类的异常通常不被处理，因为它们被用来指示程序应该终止。它们包括由\nsys.exit() 引发的 SystemExit ，以及当用户希望中断程序时引发的 KeyboardInterrupt 。\nException 可以被用作通配符，捕获（几乎）一切。然而，好的做法是，尽可能具体地说明我们打\n算处理的异常类型，并允许任何意外的异常传播下去。\n处理 Exception 最常见的模式是打印或记录异常，然后重新提出（允许调用者也处理异常）:\n\n|  | pass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\") |  |\n| --- | --- | --- |\n|  | 请注意如果颠倒 except 子句 的顺序（把 except B 放在最前），则会输出 B, B, B --- 即触发了第一\n个匹配的 except 子句。\n发生异常时，它可能具有关联值，即异常 参数 。是否需要参数，以及参数的类型取决于异常的类\n型。\nexcept 子句 可能会在异常名称后面指定一个变量。 这个变量将被绑定到异常实例，该实例通常会有\n一个存储参数的 args 属性。 为了方便起见，内置异常类型定义了 __str__() 来打印所有参数而不\n必显式地访问 .args。 |  |\n|  | >>> try:\n... raise Exception('spam', 'eggs')\n... except Exception as inst:\n... print(type(inst)) # 异常的类型\n... print(inst.args) # 参数保存在 .args 中\n... print(inst) # __str__ 允许 args 被直接打印，\n... # 但可能在异常子类中被覆盖\n... x, y = inst.args # 解包 args\n... print('x =', x)\n... print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs |  |\n|  | 未处理异常的 __str__() 输出会被打印为该异常消息的最后部分 ('detail')。\nBaseException 是所有异常的共同基类。它的一个子类， Exception ，是所有非致命异常的基类。\n不是 Exception 的子类的异常通常不被处理，因为它们被用来指示程序应该终止。它们包括由\nsys.exit() 引发的 SystemExit ，以及当用户希望中断程序时引发的 KeyboardInterrupt 。\nException 可以被用作通配符，捕获（几乎）一切。然而，好的做法是，尽可能具体地说明我们打\n算处理的异常类型，并允许任何意外的异常传播下去。\n处理 Exception 最常见的模式是打印或记录异常，然后重新提出（允许调用者也处理异常）: |  |\n\nimport sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise\ntry ... except 语句具有可选的 else 子句，该子句如果存在，它必须放在所有 except 子句 之后。 它\n适用于 try 子句 没有引发异常但又必须要执行的代码。 例如:\nfor arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close()\n使用 else 子句比向 try 子句添加额外的代码要好，可以避免意外捕获非 try ... except 语句保护\n的代码触发的异常。\n异常处理程序不仅会处理在 try 子句 中立刻发生的异常，还会处理在 try 子句 中调用（包括间接调\n用）的函数。 例如:\n>>> def this_fails():\n... x = 1/0\n...\n>>> try:\n... this_fails()\n... except ZeroDivisionError as err:\n... print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n8.4. 触发异常\nraise 语句支持强制触发指定的异常。例如：\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nraise NameError('HiThere')\nNameError: HiThere\nraise 唯一的参数就是要触发的异常。这个参数必须是异常实例或异常类（派生自 BaseException\n类，例如 Exception 或其子类）。如果传递的是异常类，将通过调用没有参数的构造函数来隐式实\n\n|  | import sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise |  |\n| --- | --- | --- |\n|  | try ... except 语句具有可选的 else 子句，该子句如果存在，它必须放在所有 except 子句 之后。 它\n适用于 try 子句 没有引发异常但又必须要执行的代码。 例如: |  |\n|  | for arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close() |  |\n|  | 使用 else 子句比向 try 子句添加额外的代码要好，可以避免意外捕获非 try ... except 语句保护\n的代码触发的异常。\n异常处理程序不仅会处理在 try 子句 中立刻发生的异常，还会处理在 try 子句 中调用（包括间接调\n用）的函数。 例如: |  |\n|  | >>> def this_fails():\n... x = 1/0\n...\n>>> try:\n... this_fails()\n... except ZeroDivisionError as err:\n... print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero |  |\n|  | 8.4. 触发异常\nraise 语句支持强制触发指定的异常。例如： |  |\n|  | >>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nraise NameError('HiThere')\nNameError: HiThere |  |\n|  | raise 唯一的参数就是要触发的异常。这个参数必须是异常实例或异常类（派生自 BaseException\n类，例如 Exception 或其子类）。如果传递的是异常类，将通过调用没有参数的构造函数来隐式实 |  |\n\n例化：\nraise ValueError # 'raise ValueError()' 的简化\n如果只想判断是否触发了异常，但并不打算处理该异常，则可以使用更简单的 raise 语句重新触发\n异常：\n>>> try:\n... raise NameError('HiThere')\n... except NameError:\n... print('An exception flew by!')\n... raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nraise NameError('HiThere')\nNameError: HiThere\n8.5. 异常链\n如果一个未处理的异常发生在 except 部分内，它将会有被处理的异常附加到它上面，并包括在错\n误信息中:\n>>> try:\n... open(\"database.sqlite\")\n... except OSError:\n... raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nopen(\"database.sqlite\")\n~~~~^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"unable to handle error\")\nRuntimeError: unable to handle error\n为了表明一个异常是另一个异常的直接后果， raise 语句允许一个可选的 from 子句:\n# exc 必须为异常实例或为 None。\nraise RuntimeError from exc\n转换异常时，这种方式很有用。例如：\n>>> def func():\n... raise ConnectionError\n...\n>>> try:\n... func()\n\n|  | 例化： |  |\n| --- | --- | --- |\n|  | raise ValueError # 'raise ValueError()' 的简化 |  |\n|  | 如果只想判断是否触发了异常，但并不打算处理该异常，则可以使用更简单的 raise 语句重新触发\n异常： |  |\n|  | >>> try:\n... raise NameError('HiThere')\n... except NameError:\n... print('An exception flew by!')\n... raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nraise NameError('HiThere')\nNameError: HiThere |  |\n|  | 8.5. 异常链\n如果一个未处理的异常发生在 except 部分内，它将会有被处理的异常附加到它上面，并包括在错\n误信息中: |  |\n|  | >>> try:\n... open(\"database.sqlite\")\n... except OSError:\n... raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nopen(\"database.sqlite\")\n~~~~^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError(\"unable to handle error\")\nRuntimeError: unable to handle error |  |\n|  | 为了表明一个异常是另一个异常的直接后果， raise 语句允许一个可选的 from 子句: |  |\n|  | # exc 必须为异常实例或为 None。\nraise RuntimeError from exc |  |\n|  | 转换异常时，这种方式很有用。例如： |  |\n|  | >>> def func():\n... raise ConnectionError\n...\n>>> try:\n... func() |  |\n\n... except ConnectionError as exc:\n... raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nfunc()\n~~~~^^\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n它还允许使用 from None 表达禁用自动异常链:\n>>> try:\n... open('database.sqlite')\n... except OSError:\n... raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError from None\nRuntimeError\n异常链机制详见 内置异常。\n8.6. 用户自定义异常\n程序可以通过创建新的异常类命名自己的异常（Python 类的内容详见 类）。不论是以直接还是间接\n的方式，异常都应从 Exception 类派生。\n异常类可以被定义成能做其他类所能做的任何事，但通常应当保持简单，它往往只提供一些属性，\n允许相应的异常处理程序提取有关错误的信息。\n大多数异常命名都以 “Error” 结尾，类似标准异常的命名。\n许多标准模块定义了自己的异常，以报告他们定义的函数中可能出现的错误。\n8.7. 定义清理操作\ntry 语句还有一个可选子句，用于定义在所有情况下都必须要执行的清理操作。例如：\n>>> try:\n... raise KeyboardInterrupt\n... finally:\n... print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\n\n|  | ... except ConnectionError as exc:\n... raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nfunc()\n~~~~^^\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database |  |\n| --- | --- | --- |\n|  | 它还允许使用 from None 表达禁用自动异常链: |  |\n|  | >>> try:\n... open('database.sqlite')\n... except OSError:\n... raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nraise RuntimeError from None\nRuntimeError |  |\n|  | 异常链机制详见 内置异常。\n8.6. 用户自定义异常\n程序可以通过创建新的异常类命名自己的异常（Python 类的内容详见 类）。不论是以直接还是间接\n的方式，异常都应从 Exception 类派生。\n异常类可以被定义成能做其他类所能做的任何事，但通常应当保持简单，它往往只提供一些属性，\n允许相应的异常处理程序提取有关错误的信息。\n大多数异常命名都以 “Error” 结尾，类似标准异常的命名。\n许多标准模块定义了自己的异常，以报告他们定义的函数中可能出现的错误。\n8.7. 定义清理操作\ntry 语句还有一个可选子句，用于定义在所有情况下都必须要执行的清理操作。例如： |  |\n|  | >>> try:\n... raise KeyboardInterrupt\n... finally:\n... print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last): |  |\n\nFile \"<stdin>\", line 2, in <module>\nraise KeyboardInterrupt\nKeyboardInterrupt\n如果存在 finally 子句，则 finally 子句是 try 语句结束前执行的最后一项任务。不论 try 语句\n是否触发异常，都会执行 finally 子句。以下内容介绍了几种比较复杂的触发异常情景：\n如果执行 try 子句期间触发了某个异常，则某个 except 子句应处理该异常。如果该异常没有\nexcept 子句处理，在 finally 子句执行后会被重新触发。\nexcept 或 else 子句执行期间也会触发异常。 同样，该异常会在 finally 子句执行之后被重新\n触发。\n如果 finally 子句执行 break、 continue 或 return 语句，异常不重新引发。 这可能会引起混\n淆，因此不鼓励使用。 从 3.14 版开始，编译器会为它发出一个 SyntaxWarning (参见 PEP\n765)。\n如果执行 try 语句时遇到 break,、continue 或 return 语句，则 finally 子句在执行 break、\ncontinue 或 return 语句之前执行。\n如果一个 finally 子句包含一个 return 语句 ，返回的值将是来自 finally 子句的 return 语\n句 ，而不是来自 try 子句的 return 语句 。这可能会引起混淆，因此不提倡使用。从版 3.14 开\n始，编译器会为它发出一个 SyntaxWarning （参见 PEP 765 ）。\n例如：\n>>> def bool_return():\n... try:\n... return True\n... finally:\n... return False\n...\n>>> bool_return()\nFalse\n这是一个比较复杂的例子：\n>>> def divide(x, y):\n... try:\n... result = x / y\n... except ZeroDivisionError:\n... print(\"division by zero!\")\n... else:\n... print(\"result is\", result)\n... finally:\n... print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n\n|  | File \"<stdin>\", line 2, in <module>\nraise KeyboardInterrupt\nKeyboardInterrupt |  |\n| --- | --- | --- |\n|  | 如果存在 finally 子句，则 finally 子句是 try 语句结束前执行的最后一项任务。不论 try 语句\n是否触发异常，都会执行 finally 子句。以下内容介绍了几种比较复杂的触发异常情景：\n如果执行 try 子句期间触发了某个异常，则某个 except 子句应处理该异常。如果该异常没有\nexcept 子句处理，在 finally 子句执行后会被重新触发。\nexcept 或 else 子句执行期间也会触发异常。 同样，该异常会在 finally 子句执行之后被重新\n触发。\n如果 finally 子句执行 break、 continue 或 return 语句，异常不重新引发。 这可能会引起混\n淆，因此不鼓励使用。 从 3.14 版开始，编译器会为它发出一个 SyntaxWarning (参见 PEP\n765)。\n如果执行 try 语句时遇到 break,、continue 或 return 语句，则 finally 子句在执行 break、\ncontinue 或 return 语句之前执行。\n如果一个 finally 子句包含一个 return 语句 ，返回的值将是来自 finally 子句的 return 语\n句 ，而不是来自 try 子句的 return 语句 。这可能会引起混淆，因此不提倡使用。从版 3.14 开\n始，编译器会为它发出一个 SyntaxWarning （参见 PEP 765 ）。\n例如： |  |\n|  | >>> def bool_return():\n... try:\n... return True\n... finally:\n... return False\n...\n>>> bool_return()\nFalse |  |\n|  | 这是一个比较复杂的例子： |  |\n|  | >>> def divide(x, y):\n... try:\n... result = x / y\n... except ZeroDivisionError:\n... print(\"division by zero!\")\n... else:\n... print(\"result is\", result)\n... finally:\n... print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module> |  |\n\ndivide(\"2\", \"1\")\n~~~~~~^^^^^^^^^^\nFile \"<stdin>\", line 3, in divide\nresult = x / y\n~~^~~\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n如上所示，任何情况下都会执行 finally 子句。except 子句不处理两个字符串相除触发的\nTypeError，因此会在 finally 子句执行后被重新触发。\n在实际应用程序中，finally 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是\n否成功使用资源。\n8.8. 预定义的清理操作\n某些对象定义了不需要该对象时要执行的标准清理操作。无论使用该对象的操作是否成功，都会执\n行清理操作。比如，下例要打开一个文件，并输出文件内容：\nfor line in open(\"myfile.txt\"):\nprint(line, end=\"\")\n这个代码的问题在于，执行完代码后，文件在一段不确定的时间内处于打开状态。在简单脚本中这\n没有问题，但对于较大的应用程序来说可能会出问题。with 语句支持以及时、正确的清理的方式使\n用文件对象：\nwith open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\")\n语句执行完毕后，即使在处理行时遇到问题，都会关闭文件 f。和文件一样，支持预定义清理操作的\n对象会在文档中指出这一点。\n8.9. 引发和处理多个不相关的异常\n在有些情况下，有必要报告几个已经发生的异常。这通常是在并发框架中当几个任务并行失败时的\n情况，但也有其他的用例，有时需要是继续执行并收集多个错误而不是引发第一个异常。\n内置的 ExceptionGroup 打包了一个异常实例的列表，这样它们就可以一起被引发。它本身就是一\n个异常，所以它可以像其他异常一样被捕获。\n>>> def f():\n... excs = [OSError('error 1'), SystemError('error 2')]\n... raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 1, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 3, in f\n| raise ExceptionGroup('there were problems', excs)\n\n|  | divide(\"2\", \"1\")\n~~~~~~^^^^^^^^^^\nFile \"<stdin>\", line 3, in divide\nresult = x / y\n~~^~~\nTypeError: unsupported operand type(s) for /: 'str' and 'str' |  |\n| --- | --- | --- |\n|  | 如上所示，任何情况下都会执行 finally 子句。except 子句不处理两个字符串相除触发的\nTypeError，因此会在 finally 子句执行后被重新触发。\n在实际应用程序中，finally 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是\n否成功使用资源。\n8.8. 预定义的清理操作\n某些对象定义了不需要该对象时要执行的标准清理操作。无论使用该对象的操作是否成功，都会执\n行清理操作。比如，下例要打开一个文件，并输出文件内容： |  |\n|  | for line in open(\"myfile.txt\"):\nprint(line, end=\"\") |  |\n|  | 这个代码的问题在于，执行完代码后，文件在一段不确定的时间内处于打开状态。在简单脚本中这\n没有问题，但对于较大的应用程序来说可能会出问题。with 语句支持以及时、正确的清理的方式使\n用文件对象： |  |\n|  | with open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\") |  |\n|  | 语句执行完毕后，即使在处理行时遇到问题，都会关闭文件 f。和文件一样，支持预定义清理操作的\n对象会在文档中指出这一点。\n8.9. 引发和处理多个不相关的异常\n在有些情况下，有必要报告几个已经发生的异常。这通常是在并发框架中当几个任务并行失败时的\n情况，但也有其他的用例，有时需要是继续执行并收集多个错误而不是引发第一个异常。\n内置的 ExceptionGroup 打包了一个异常实例的列表，这样它们就可以一起被引发。它本身就是一\n个异常，所以它可以像其他异常一样被捕获。 |  |\n|  | >>> def f():\n... excs = [OSError('error 1'), SystemError('error 2')]\n... raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 1, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 3, in f\n| raise ExceptionGroup('there were problems', excs) |  |\n\n| ExceptionGroup: there were problems (2 sub-exceptions)\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n... f()\n... except Exception as e:\n... print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\n通过使用 except* 代替 except ，我们可以有选择地只处理组中符合某种类型的异常。在下面的例\n子中，显示了一个嵌套的异常组，每个 except* 子句都从组中提取了某种类型的异常，而让所有其\n他的异常传播到其他子句，并最终被重新引发。\n>>> def f():\n... raise ExceptionGroup(\n... \"group1\",\n... [\n... OSError(1),\n... SystemError(2),\n... ExceptionGroup(\n... \"group2\",\n... [\n... OSError(3),\n... RecursionError(4)\n... ]\n... )\n... ]\n... )\n...\n>>> try:\n... f()\n... except* OSError as e:\n... print(\"There were OSErrors\")\n... except* SystemError as e:\n... print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 2, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 2, in f\n| raise ExceptionGroup(\n| ...<12 lines>...\n| )\n| ExceptionGroup: group1 (1 sub-exception)\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2 (1 sub-exception)\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>>\n\n|  | | ExceptionGroup: there were problems (2 sub-exceptions)\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n... f()\n... except Exception as e:\n... print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>> |  |\n| --- | --- | --- |\n|  | 通过使用 except* 代替 except ，我们可以有选择地只处理组中符合某种类型的异常。在下面的例\n子中，显示了一个嵌套的异常组，每个 except* 子句都从组中提取了某种类型的异常，而让所有其\n他的异常传播到其他子句，并最终被重新引发。 |  |\n|  | >>> def f():\n... raise ExceptionGroup(\n... \"group1\",\n... [\n... OSError(1),\n... SystemError(2),\n... ExceptionGroup(\n... \"group2\",\n... [\n... OSError(3),\n... RecursionError(4)\n... ]\n... )\n... ]\n... )\n...\n>>> try:\n... f()\n... except* OSError as e:\n... print(\"There were OSErrors\")\n... except* SystemError as e:\n... print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 2, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 2, in f\n| raise ExceptionGroup(\n| ...<12 lines>...\n| )\n| ExceptionGroup: group1 (1 sub-exception)\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2 (1 sub-exception)\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>> |  |\n\n注意，嵌套在一个异常组中的异常必须是实例，而不是类型。这是因为在实践中，这些异常通常是\n那些已经被程序提出并捕获的异常，其模式如下:\n>>> excs = []\n... for test in tests:\n... try:\n... test.run()\n... except Exception as e:\n... excs.append(e)\n...\n>>> if excs:\n... raise ExceptionGroup(\"Test Failures\", excs)\n...\n8.10. 用注释细化异常情况\n当一个异常被创建以引发时，它通常被初始化为描述所发生错误的信息。在有些情况下，在异常被\n捕获后添加信息是很有用的。为了这个目的，异常有一个 add_note(note) 方法接受一个字符串，\n并将其添加到异常的注释列表。标准的回溯在异常之后按照它们被添加的顺序呈现包括所有的注\n释。\n>>> try:\n... raise TypeError('bad type')\n... except Exception as e:\n... e.add_note('Add some information')\n... e.add_note('Add some more information')\n... raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nraise TypeError('bad type')\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\n例如，当把异常收集到一个异常组时，我们可能想为各个错误添加上下文信息。在下文中，组中的\n每个异常都有一个说明，指出这个错误是什么时候发生的。\n>>> def f():\n... raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n... try:\n... f()\n... except Exception as e:\n... e.add_note(f'Happened in Iteration {i+1}')\n... excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 1, in <module>\n| raise ExceptionGroup('We have some problems', excs)\n| ExceptionGroup: We have some problems (3 sub-exceptions)\n\n|  | 注意，嵌套在一个异常组中的异常必须是实例，而不是类型。这是因为在实践中，这些异常通常是\n那些已经被程序提出并捕获的异常，其模式如下: |  |\n| --- | --- | --- |\n|  | >>> excs = []\n... for test in tests:\n... try:\n... test.run()\n... except Exception as e:\n... excs.append(e)\n...\n>>> if excs:\n... raise ExceptionGroup(\"Test Failures\", excs)\n... |  |\n|  | 8.10. 用注释细化异常情况\n当一个异常被创建以引发时，它通常被初始化为描述所发生错误的信息。在有些情况下，在异常被\n捕获后添加信息是很有用的。为了这个目的，异常有一个 add_note(note) 方法接受一个字符串，\n并将其添加到异常的注释列表。标准的回溯在异常之后按照它们被添加的顺序呈现包括所有的注\n释。 |  |\n|  | >>> try:\n... raise TypeError('bad type')\n... except Exception as e:\n... e.add_note('Add some information')\n... e.add_note('Add some more information')\n... raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nraise TypeError('bad type')\nTypeError: bad type\nAdd some information\nAdd some more information\n>>> |  |\n|  | 例如，当把异常收集到一个异常组时，我们可能想为各个错误添加上下文信息。在下文中，组中的\n每个异常都有一个说明，指出这个错误是什么时候发生的。 |  |\n|  | >>> def f():\n... raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n... try:\n... f()\n... except Exception as e:\n... e.add_note(f'Happened in Iteration {i+1}')\n... excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n| File \"<stdin>\", line 1, in <module>\n| raise ExceptionGroup('We have some problems', excs)\n| ExceptionGroup: We have some problems (3 sub-exceptions) |  |\n\n+-+---------------- 1 ----------------\n| Traceback (most recent call last):\n| File \"<stdin>\", line 3, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 2, in f\n| raise OSError('operation failed')\n| OSError: operation failed\n| Happened in Iteration 1\n+---------------- 2 ----------------\n| Traceback (most recent call last):\n| File \"<stdin>\", line 3, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 2, in f\n| raise OSError('operation failed')\n| OSError: operation failed\n| Happened in Iteration 2\n+---------------- 3 ----------------\n| Traceback (most recent call last):\n| File \"<stdin>\", line 3, in <module>\n| f()\n| ~^^\n| File \"<stdin>\", line 2, in f\n| raise OSError('operation failed')\n| OSError: operation failed\n| Happened in Iteration 3\n+------------------------------------\n>>>", "metadata": {"title": "08_错误和异常", "source": "md_docs\\python_docs_md\\08_错误和异常.md", "doc_type": "教程", "language": "中文", "doc_id": "2fab4292"}}
{"doc_id": "e427f828", "content": "9. 类\n类提供了把数据和功能绑定在一起的方法。创建新类时创建了新的对象 类型，从而能够创建该类型\n的新 实例。实例具有能维持自身状态的属性，还具有能修改自身状态的方法（由其所属的类来定\n义）。\n和其他编程语言相比，Python 的类只使用了很少的新语法和语义。Python 的类有点类似于 C++ 和\nModula-3 中类的结合体，而且支持面向对象编程（OOP）的所有标准特性：类的继承机制支持多个\n基类、派生的类能覆盖基类的方法、类的方法能调用基类中的同名方法。对象可包含任意数量和类\n型的数据。和模块一样，类也支持 Python 动态特性：在运行时创建，创建后还可以修改。\n如果用 C++ 术语来描述的话，类成员（包括数据成员）通常为 public （例外的情况见下文 私有变\n量），所有成员函数都为 virtual 。与 Modula-3 中一样，没有用于从对象的方法中引用本对象成员\n的简写形式：方法函数在声明时，有一个显式的第一个参数代表本对象，该参数由方法调用隐式提\n供。与在 Smalltalk 中一样，Python 的类也是对象，这为导入和重命名提供了语义支持。与 C++ 和\nModula-3 不同，Python 的内置类型可以用作基类，供用户扩展。此外，与 C++ 一样，具有特殊语\n法的内置运算符（算术运算符、下标等）都可以为类实例重新定义。\n由于缺乏关于类的公认术语，本章中偶尔会使用 Smalltalk 和 C++ 的术语。本章还会使用 Modula-3\n的术语，Modula-3 的面向对象语义比 C++ 更接近 Python，但估计听说过这门语言的读者很少。\n9.1. 名称和对象\n对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他\n语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可\n变基本类型时，可以不必理会。但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）\n的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别\n名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了\n作为参数传递的对象，调用者就可以看到更改——无需像 Pascal 那样用两个不同的机制来传参。\n9.2. Python 作用域和命名空间\n在介绍类前，首先要介绍 Python 的作用域规则。类定义对命名空间有一些巧妙的技巧，了解作用域\n和命名空间的工作机制有利于加强对类的理解。并且，即便对于高级 Python 程序员，这方面的知识\n也很有用。\n接下来，我们先了解一些定义。\nnamespace （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，\n但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名\n空间的例子有：内置名称集合（包括 abs() 函数以及内置异常的名称等）；一个模块的全局名称；\n一个函数调用中的局部名称。对象的属性集合也是命名空间的一种形式。关于命名空间的一个重要\n\n知识点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义 maximize\n函数，且不会造成混淆。用户使用函数时必须要在函数名前面加上模块名。\n点号之后的名称是 属性。例如，表达式 z.real 中，real 是对象 z 的属性。严格来说，对模块中\n名称的引用是属性引用：表达式 modname.funcname 中，modname 是模块对象，funcname 是模块\n的属性。模块属性和模块中定义的全局名称之间存在直接的映射：它们共享相同的命名空间！ [1]\n属性可以是只读的或者可写的。 在后一种情况下，可以对属性进行赋值。 模块属性是可写的：你可\n以写入 modname.the_answer = 42 。 也可以使用 del 语句删除可写属性。 例如，del\nmodname.the_answer 将从名为 modname 对象中移除属性 the_answer。\n命名空间是在不同时刻创建的，且拥有不同的生命周期。内置名称的命名空间是在 Python 解释器启\n动时创建的，永远不会被删除。模块的全局命名空间在读取模块定义时创建；通常，模块的命名空\n间也会持续到解释器退出。从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是\n__main__ 模块调用的一部分，也拥有自己的全局命名空间。内置名称实际上也在模块里，即\nbuiltins 。\n函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被\n删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局\n部命名空间。\n一个命名空间的 作用域 是 Python 代码中的一段文本区域，从这个区域可直接访问该命名空间。“可\n直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间\n在内的。\n作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可\n直接访问”的嵌套作用域：\n最内层作用域，包含局部名称，并首先在其中进行搜索\n那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐\n层向外搜索。\n倒数第二层作用域，包含当前模块的全局名称\n最外层（最后搜索）的作用域，是内置名称的命名空间\n如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全\n局名称的作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 nonlocal 语句；如果未\n使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 新的 局\n部变量，而使得同名的外部变量保持不变）。\n通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。在函数之外，局部作用域引用\n与全局作用域一致的命名空间：模块的命名空间。 类定义在局部命名空间内再放置另一个命名空\n间。\n划重点，作用域是按字面文本确定的：模块内定义的函数的全局作用域就是该模块的命名空间，无\n论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但\n是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部\n变量已经是被静态确定了。）\n\n|  |  | 知识点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义 maximize\n函数，且不会造成混淆。用户使用函数时必须要在函数名前面加上模块名。\n点号之后的名称是 属性。例如，表达式 z.real 中，real 是对象 z 的属性。严格来说，对模块中\n名称的引用是属性引用：表达式 modname.funcname 中，modname 是模块对象，funcname 是模块\n的属性。模块属性和模块中定义的全局名称之间存在直接的映射：它们共享相同的命名空间！ [1]\n属性可以是只读的或者可写的。 在后一种情况下，可以对属性进行赋值。 模块属性是可写的：你可\n以写入 modname.the_answer = 42 。 也可以使用 del 语句删除可写属性。 例如，del\nmodname.the_answer 将从名为 modname 对象中移除属性 the_answer。\n命名空间是在不同时刻创建的，且拥有不同的生命周期。内置名称的命名空间是在 Python 解释器启\n动时创建的，永远不会被删除。模块的全局命名空间在读取模块定义时创建；通常，模块的命名空\n间也会持续到解释器退出。从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是\n__main__ 模块调用的一部分，也拥有自己的全局命名空间。内置名称实际上也在模块里，即\nbuiltins 。\n函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被\n删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局\n部命名空间。\n一个命名空间的 作用域 是 Python 代码中的一段文本区域，从这个区域可直接访问该命名空间。“可\n直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间\n在内的。\n作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可\n直接访问”的嵌套作用域：\n最内层作用域，包含局部名称，并首先在其中进行搜索\n那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐\n层向外搜索。\n倒数第二层作用域，包含当前模块的全局名称\n最外层（最后搜索）的作用域，是内置名称的命名空间\n如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全\n局名称的作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 nonlocal 语句；如果未\n使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 新的 局\n部变量，而使得同名的外部变量保持不变）。\n通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。在函数之外，局部作用域引用\n与全局作用域一致的命名空间：模块的命名空间。 类定义在局部命名空间内再放置另一个命名空\n间。\n划重点，作用域是按字面文本确定的：模块内定义的函数的全局作用域就是该模块的命名空间，无\n论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但\n是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部\n变量已经是被静态确定了。） |  |  |  |\n| --- | --- | --- | --- | --- | --- |\n|  |  |  | del |  |  |\n|  |  |  |  |  |  |\n|  |  | modname.the_answer |  |  |  |\n|  |  |  |  |  |  |\n\nPython 有一个特殊规定。如果不存在生效的 global 或 nonlocal 语句，则对名称的赋值总是会进\n入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 del x 从局部\n作用域引用的命名空间中移除对 x 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是\nimport 语句和函数定义会在局部作用域中绑定模块或函数名称。\nglobal 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；nonlocal 语句表\n明特定变量在外层作用域中，并应在外层作用域中重新绑定。\n9.2.1. 作用域和命名空间示例\n下例演示了如何引用不同作用域和名称空间，以及 global 和 nonlocal 对变量绑定的影响：\ndef scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam)\n示例代码的输出是：\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n注意，局部 赋值（这是默认状态）不会改变 scope_test 对 spam 的绑定。 nonlocal 赋值会改变\nscope_test 对 spam 的绑定，而 global 赋值会改变模块层级的绑定。\n而且，global 赋值前没有 spam 的绑定。\n9.3. 初探类\n类引入了一点新语法，三种新的对象类型和一些新语义。\n9.3.1. 类定义语法\n\n|  | Python 有一个特殊规定。如果不存在生效的 global 或 nonlocal 语句，则对名称的赋值总是会进\n入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 del x 从局部\n作用域引用的命名空间中移除对 x 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是\nimport 语句和函数定义会在局部作用域中绑定模块或函数名称。\nglobal 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；nonlocal 语句表\n明特定变量在外层作用域中，并应在外层作用域中重新绑定。\n9.2.1. 作用域和命名空间示例\n下例演示了如何引用不同作用域和名称空间，以及 global 和 nonlocal 对变量绑定的影响： |  |\n| --- | --- | --- |\n|  | def scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam) |  |\n|  | 示例代码的输出是： |  |\n|  | After local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam |  |\n|  | 注意，局部 赋值（这是默认状态）不会改变 scope_test 对 spam 的绑定。 nonlocal 赋值会改变\nscope_test 对 spam 的绑定，而 global 赋值会改变模块层级的绑定。\n而且，global 赋值前没有 spam 的绑定。\n9.3. 初探类\n类引入了一点新语法，三种新的对象类型和一些新语义。\n9.3.1. 类定义语法 |  |\n\n最简单的类定义形式如下：\nclass ClassName:\n<语句-1>\n.\n.\n.\n<语句-N>\n与函数定义 (def 语句) 一样，类定义必须先执行才能生效。把类定义放在 if 语句的分支里或函数\n内部试试。\n在实践中，类定义内的语句通常都是函数定义，但也可以是其他语句。这部分内容稍后再讨论。类\n里的函数定义一般是特殊的参数列表，这是由方法调用的约定规范所指明的 --- 同样，稍后再解释。\n当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 --- 因此，所有对局部变量的赋\n值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。\n当 (从结尾处) 正常离开类定义时，将创建一个 类对象。 这基本上是一个围绕类定义所创建的命名空\n间的包装器；我们将在下一节中了解有关类对象的更多信息。 原始的 (在进入类定义之前有效的) 作\n用域将重新生效，类对象将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为\nClassName)。\n9.3.2. Class 对象\n类对象支持两种操作：属性引用和实例化。\n属性引用 使用 Python 中所有属性引用所使用的标准语法: obj.name。 有效的属性名称是类对象被\n创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:\nclass MyClass:\n\"\"\"一个简单的示例类\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world'\n那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属\n性也可以被赋值，因此可以通过赋值来改变 MyClass.i 的值。 __doc__ 也是一个有效的属性，将\n返回所属类的文档字符串: \"A simple example class\"。\n类的 实例化 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举\n例来说（假设使用上述的类）:\nx = MyClass()\n创建类的新 实例 并将此对象分配给局部变量 x。\n实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态\n定制的。 因此一个类可能会定义名为 __init__() 的特殊方法，就像这样:\n\n|  | 最简单的类定义形式如下： |  |\n| --- | --- | --- |\n|  | class ClassName:\n<语句-1>\n.\n.\n.\n<语句-N> |  |\n|  | 与函数定义 (def 语句) 一样，类定义必须先执行才能生效。把类定义放在 if 语句的分支里或函数\n内部试试。\n在实践中，类定义内的语句通常都是函数定义，但也可以是其他语句。这部分内容稍后再讨论。类\n里的函数定义一般是特殊的参数列表，这是由方法调用的约定规范所指明的 --- 同样，稍后再解释。\n当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 --- 因此，所有对局部变量的赋\n值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。\n当 (从结尾处) 正常离开类定义时，将创建一个 类对象。 这基本上是一个围绕类定义所创建的命名空\n间的包装器；我们将在下一节中了解有关类对象的更多信息。 原始的 (在进入类定义之前有效的) 作\n用域将重新生效，类对象将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为\nClassName)。\n9.3.2. Class 对象\n类对象支持两种操作：属性引用和实例化。\n属性引用 使用 Python 中所有属性引用所使用的标准语法: obj.name。 有效的属性名称是类对象被\n创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的: |  |\n|  | class MyClass:\n\"\"\"一个简单的示例类\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world' |  |\n|  | 那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属\n性也可以被赋值，因此可以通过赋值来改变 MyClass.i 的值。 __doc__ 也是一个有效的属性，将\n返回所属类的文档字符串: \"A simple example class\"。\n类的 实例化 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举\n例来说（假设使用上述的类）: |  |\n|  | x = MyClass() |  |\n|  | 创建类的新 实例 并将此对象分配给局部变量 x。\n实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态\n定制的。 因此一个类可能会定义名为 __init__() 的特殊方法，就像这样: |  |\n\ndef __init__(self):\nself.data = []\n当一个类定义了 __init__() 方法时，类的实例化会自动为新创建的类实例唤起 __init__()。 因\n此在这个例子中，可以通过以下语句获得一个已初始化的新实例:\nx = MyClass()\n当然，__init__() 方法还有一些参数用于实现更高的灵活性。 在这种情况下，提供给类实例化运\n算符的参数将被传递给 __init__()。 例如，\n>>> class Complex:\n... def __init__(self, realpart, imagpart):\n... self.r = realpart\n... self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n9.3.3. 实例对象\n现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名\n称：数据属性和方法。\n数据属性 相当于 Smalltalk 中的 \"实例变量\" 和 C++ 中的 \"数据成员\"。数据属性无需声明；与局部变\n量 一样，它们在首次赋值时就会出现。 例如，如果 x 是上面创建的 MyClass 的实例 ，那么下面的\n代码将打印值 16 ，而不会留下任何痕迹:\nx.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\n另一种实例属性引用称为 方法。 方法是“从属于”对象的函数。\n实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义\n了其实例的相应方法。 因此在我们的示例中，x.f 是有效的方法引用，因为 MyClass.f 是一个函\n数，而 x.i 不是方法，因为 MyClass.i 不是函数。 但是 x.f 与 MyClass.f 并不是一回事 --- 它是\n一个 方法对象，不是函数对象。\n9.3.4. 方法对象\n通常，方法在绑定后立即被调用:\nx.f()\n如果 x = MyClass()，就像上面这样，则将返回字符串 'hello world'。 不过，方法并非必须立\n即被调用: x.f 是一个方法对象，并可被存储起来并在以后再调用。 例如:\n\n|  | def __init__(self):\nself.data = [] |  |\n| --- | --- | --- |\n|  | 当一个类定义了 __init__() 方法时，类的实例化会自动为新创建的类实例唤起 __init__()。 因\n此在这个例子中，可以通过以下语句获得一个已初始化的新实例: |  |\n|  | x = MyClass() |  |\n|  | 当然，__init__() 方法还有一些参数用于实现更高的灵活性。 在这种情况下，提供给类实例化运\n算符的参数将被传递给 __init__()。 例如， |  |\n|  | >>> class Complex:\n... def __init__(self, realpart, imagpart):\n... self.r = realpart\n... self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5) |  |\n|  | 9.3.3. 实例对象\n现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名\n称：数据属性和方法。\n数据属性 相当于 Smalltalk 中的 \"实例变量\" 和 C++ 中的 \"数据成员\"。数据属性无需声明；与局部变\n量 一样，它们在首次赋值时就会出现。 例如，如果 x 是上面创建的 MyClass 的实例 ，那么下面的\n代码将打印值 16 ，而不会留下任何痕迹: |  |\n|  | x.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter |  |\n|  | 另一种实例属性引用称为 方法。 方法是“从属于”对象的函数。\n实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义\n了其实例的相应方法。 因此在我们的示例中，x.f 是有效的方法引用，因为 MyClass.f 是一个函\n数，而 x.i 不是方法，因为 MyClass.i 不是函数。 但是 x.f 与 MyClass.f 并不是一回事 --- 它是\n一个 方法对象，不是函数对象。\n9.3.4. 方法对象\n通常，方法在绑定后立即被调用: |  |\n|  | x.f() |  |\n|  | 如果 x = MyClass()，就像上面这样，则将返回字符串 'hello world'。 不过，方法并非必须立\n即被调用: x.f 是一个方法对象，并可被存储起来并在以后再调用。 例如: |  |\n\nxf = x.f\nwhile True:\nprint(xf())\n将持续打印 hello world，直到结束。\n当一个方法被调用时究竟会发生什么？ 你可能已经注意到尽管 f() 的函数定义指定了一个参数，但\n上面调用 x.f() 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何\n参数的情况下被调用时 Python 肯定会引发异常 --- 即使参数实际上没有被使用...\n实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传\n入。 在我们的示例中，调用 x.f() 其实就相当于 MyClass.f(x)。 总之，调用一个具有 n 个参数的\n方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之\n前。\n总而言之，方法的运作方式如下。 当一个实例的非数据属性被引用时，将搜索该实例所属的类。 如\n果名称表示一个属于函数对象的有效类属性，则指向实例对象和函数对象的引用将被打包为一个方\n法对象。 当传入一个参数列表调用该方法对象时，将基于实例对象和参数列表构造一个新的参数列\n表，并传入这个新参数列表调用相应的函数对象。\n9.3.5. 类和实例变量\n一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:\nclass Dog:\nkind = 'canine' # 类变量被所有实例所共享\ndef __init__(self, name):\nself.name = name # 实例变量为每个实例所独有\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind # 被所有的 Dog 实例所共享\n'canine'\n>>> e.kind # 被所有的 Dog 实例所共享\n'canine'\n>>> d.name # 为 d 所独有\n'Fido'\n>>> e.name # 为 e 所独有\n'Buddy'\n正如 名称和对象 中已讨论过的，共享数据可能在涉及 mutable 对象例如列表和字典的时候导致令人\n惊讶的结果。 例如以下代码中的 tricks 列表不应该被用作类变量，因为所有的 Dog 实例将只共享一\n个单独的列表:\nclass Dog:\ntricks = [] # 类变量的错误用法\ndef __init__(self, name):\nself.name = name\n\n|  | xf = x.f\nwhile True:\nprint(xf()) |  |\n| --- | --- | --- |\n|  | 将持续打印 hello world，直到结束。\n当一个方法被调用时究竟会发生什么？ 你可能已经注意到尽管 f() 的函数定义指定了一个参数，但\n上面调用 x.f() 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何\n参数的情况下被调用时 Python 肯定会引发异常 --- 即使参数实际上没有被使用...\n实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传\n入。 在我们的示例中，调用 x.f() 其实就相当于 MyClass.f(x)。 总之，调用一个具有 n 个参数的\n方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之\n前。\n总而言之，方法的运作方式如下。 当一个实例的非数据属性被引用时，将搜索该实例所属的类。 如\n果名称表示一个属于函数对象的有效类属性，则指向实例对象和函数对象的引用将被打包为一个方\n法对象。 当传入一个参数列表调用该方法对象时，将基于实例对象和参数列表构造一个新的参数列\n表，并传入这个新参数列表调用相应的函数对象。\n9.3.5. 类和实例变量\n一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法: |  |\n|  | class Dog:\nkind = 'canine' # 类变量被所有实例所共享\ndef __init__(self, name):\nself.name = name # 实例变量为每个实例所独有\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind # 被所有的 Dog 实例所共享\n'canine'\n>>> e.kind # 被所有的 Dog 实例所共享\n'canine'\n>>> d.name # 为 d 所独有\n'Fido'\n>>> e.name # 为 e 所独有\n'Buddy' |  |\n|  | 正如 名称和对象 中已讨论过的，共享数据可能在涉及 mutable 对象例如列表和字典的时候导致令人\n惊讶的结果。 例如以下代码中的 tricks 列表不应该被用作类变量，因为所有的 Dog 实例将只共享一\n个单独的列表: |  |\n|  | class Dog:\ntricks = [] # 类变量的错误用法\ndef __init__(self, name):\nself.name = name |  |\n\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks # 非预期地被所有的 Dog 实例所共享\n['roll over', 'play dead']\n正确的类设计应该使用实例变量:\nclass Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = [] # 为每个 Dog 实例新建一个空列表\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n9.4. 补充说明\n如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:\n>>> class Warehouse:\n... purpose = 'storage'\n... region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\n数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯\n抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 --- 它是完全基于约定的。\n（而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访\n问；此特性可以通过用 C 编写 Python 扩展来使用。）\n客户端应当谨慎地使用数据属性 --- 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固\n定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只\n要保证避免名称冲突 --- 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。\n\n|  | def add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks # 非预期地被所有的 Dog 实例所共享\n['roll over', 'play dead'] |  |\n| --- | --- | --- |\n|  | 正确的类设计应该使用实例变量: |  |\n|  | class Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = [] # 为每个 Dog 实例新建一个空列表\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead'] |  |\n|  | 9.4. 补充说明\n如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例: |  |\n|  | >>> class Warehouse:\n... purpose = 'storage'\n... region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east |  |\n|  | 数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯\n抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 --- 它是完全基于约定的。\n（而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访\n问；此特性可以通过用 C 编写 Python 扩展来使用。）\n客户端应当谨慎地使用数据属性 --- 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固\n定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只\n要保证避免名称冲突 --- 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。 |  |\n\n在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读\n性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。\n方法的第一个参数常常被命名为 self。 这也不过就是一个约定: self 这一名称在 Python 中绝对没\n有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，\n而且也可以想像一个 类浏览器 程序的编写可能会依赖于这样的约定。\n任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于\n类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:\n# 在类之外定义的函数\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g\n现在 f、g 和 h 都 C 类的指向函数对象的属性，因此它们都是 C 实例的方法 --- 其中 h 与 g 完全等\n价。 但请注意这种做法通常只会使程序的阅读者感到迷惑。\n方法可以通过使用 self 参数的方法属性调用其他方法:\nclass Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x)\n方法可以通过与普通函数相同的方式引用全局名称。与方法相关联的全局作用域就是包含该方法的\n定义语句的模块。（类永远不会被用作全局作用域。）尽管一个人很少会有好的理由在方法中使用\n全局作用域中的数据，全局作用域依然存在许多合理的使用场景：举个例子，导入到全局作用域的\n函数和模块可以被方法所使用，定义在全局作用域中的函数和类也一样。通常，包含该方法的类本\n身就定义在全局作用域中，而在下一节中我们将会发现，为何有些时候方法需要引用其所属类。\n每个值都是一个对象，因此具有 类 （也称为 类型），并存储为 object.__class__ 。\n9.5. 继承\n当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:\nclass DerivedClassName(BaseClassName):\n<语句-1>\n\n|  | 在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读\n性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。\n方法的第一个参数常常被命名为 self。 这也不过就是一个约定: self 这一名称在 Python 中绝对没\n有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，\n而且也可以想像一个 类浏览器 程序的编写可能会依赖于这样的约定。\n任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于\n类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如: |  |\n| --- | --- | --- |\n|  | # 在类之外定义的函数\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g |  |\n|  | 现在 f、g 和 h 都 C 类的指向函数对象的属性，因此它们都是 C 实例的方法 --- 其中 h 与 g 完全等\n价。 但请注意这种做法通常只会使程序的阅读者感到迷惑。\n方法可以通过使用 self 参数的方法属性调用其他方法: |  |\n|  | class Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x) |  |\n|  | 方法可以通过与普通函数相同的方式引用全局名称。与方法相关联的全局作用域就是包含该方法的\n定义语句的模块。（类永远不会被用作全局作用域。）尽管一个人很少会有好的理由在方法中使用\n全局作用域中的数据，全局作用域依然存在许多合理的使用场景：举个例子，导入到全局作用域的\n函数和模块可以被方法所使用，定义在全局作用域中的函数和类也一样。通常，包含该方法的类本\n身就定义在全局作用域中，而在下一节中我们将会发现，为何有些时候方法需要引用其所属类。\n每个值都是一个对象，因此具有 类 （也称为 类型），并存储为 object.__class__ 。\n9.5. 继承\n当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示: |  |\n|  | class DerivedClassName(BaseClassName):\n<语句-1> |  |\n\n.\n.\n.\n<语句-N>\n名称 BaseClassName 必须定义于可从包含所派生的类的定义的作用域访问的命名空间中。 作为基\n类名称的替代，也允许使用其他任意表达式。 例如，当基类定义在另一个模块中时，这就会很有用\n处:\nclass DerivedClassName(modname.BaseClassName):\n派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引\n用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个\n类，则此规则将被递归地应用。\n派生类的实例化没有任何特殊之处: DerivedClassName() 会创建该类的一个新实例。 方法引用将按\n以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数\n对象则方法引用就生效。\n派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以基类\n方法在尝试调用调用同一基类中定义的另一方法时，可能实际上调用是该基类的派生类中定义的方\n法。（对 C++ 程序员的提示：Python 中所有的方法实际上都是 virtual 方法。）\n在派生类中的重写方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单\n地直接调用基类方法：即调用 BaseClassName.methodname(self, arguments)。 有时这对客户端\n来说也是有用的。 （请注意仅当此基类可在全局作用域中以 BaseClassName 的名称被访问时方可\n使用此方式。）\nPython有两个内置函数可被用于继承机制：\n使用 isinstance() 来检查一个实例的类型: isinstance(obj, int) 仅会在 obj.__class__ 为\nint 或某个派生自 int 的类时为 True。\n使用 issubclass() 来检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int\n的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类。\n9.5.1. 多重继承\nPython 也支持一种多重继承。 带有多个基类的类定义语句如下所示:\nclass DerivedClassName(Base1, Base2, Base3):\n<语句-1>\n.\n.\n.\n<语句-N>\n对于多数目的来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从\n左到右的，当层次结构存在重叠时不会在同一个类中搜索两次。 因此，如果某个属性在\n\n|  | .\n.\n.\n<语句-N> |  |\n| --- | --- | --- |\n|  | 名称 BaseClassName 必须定义于可从包含所派生的类的定义的作用域访问的命名空间中。 作为基\n类名称的替代，也允许使用其他任意表达式。 例如，当基类定义在另一个模块中时，这就会很有用\n处: |  |\n|  | class DerivedClassName(modname.BaseClassName): |  |\n|  | 派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引\n用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个\n类，则此规则将被递归地应用。\n派生类的实例化没有任何特殊之处: DerivedClassName() 会创建该类的一个新实例。 方法引用将按\n以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数\n对象则方法引用就生效。\n派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以基类\n方法在尝试调用调用同一基类中定义的另一方法时，可能实际上调用是该基类的派生类中定义的方\n法。（对 C++ 程序员的提示：Python 中所有的方法实际上都是 virtual 方法。）\n在派生类中的重写方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单\n地直接调用基类方法：即调用 BaseClassName.methodname(self, arguments)。 有时这对客户端\n来说也是有用的。 （请注意仅当此基类可在全局作用域中以 BaseClassName 的名称被访问时方可\n使用此方式。）\nPython有两个内置函数可被用于继承机制：\n使用 isinstance() 来检查一个实例的类型: isinstance(obj, int) 仅会在 obj.__class__ 为\nint 或某个派生自 int 的类时为 True。\n使用 issubclass() 来检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int\n的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类。\n9.5.1. 多重继承\nPython 也支持一种多重继承。 带有多个基类的类定义语句如下所示: |  |\n|  | class DerivedClassName(Base1, Base2, Base3):\n<语句-1>\n.\n.\n.\n<语句-N> |  |\n|  | 对于多数目的来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从\n左到右的，当层次结构存在重叠时不会在同一个类中搜索两次。 因此，如果某个属性在 |  |\n\nDerivedClassName 中找不到，就会在 Base1 中搜索它，然后（递归地）在 Base1 的基类中搜索，\n如果在那里也找不到，就将在 Base2 中搜索，依此类推。\n真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 super() 的协同调用。 这种方式在\n某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。\n动态调整顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有\n一个上级类可通过多条路径被最底层的类所访问）。 例如，所有类都是继承自 object，因此任何\n多重继承的情况都提供了一条以上的路径可以通向 object。 为了确保基类不会被访问一次以上，\n动态算法会用一种特殊方式将搜索顺序线性化，保留每个类所指定的从左至右的顺序，只调用每个\n上级类一次，并且保持单调性（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，\n这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 Python\n2.3 方法解析顺序。\n9.6. 私有变量\n那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码\n都遵循这样一个约定：带有一个下划线的名称 (例如 _spam) 应该被当作是 API 的非公有部分 (无论它\n是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。\n由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在\n对此种机制的有限支持，称为 名称改写。 任何形式为 __spam 的标识符（至少带有两个前缀下划\n线，至多一个后缀下划线）的文本将被替换为 _classname__spam，其中 classname 为去除了前缀\n下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。\n参见: 私有名称调整规范说明 了解相关详情和特例。\n名称改写有助于让子类重写方法而不破坏类内方法调用。例如:\nclass Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update # 原始 update() 方法的私有副本\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# 为 update() 提供了新的签名\n# 但不会破坏 __init__()\nfor item in zip(keys, values):\nself.items_list.append(item)\n上面的示例即使在 MappingSubclass 引入了一个 __update 标识符的情况下也不会出错，因为它会\n在 Mapping 类中被替换为 _Mapping__update 而在 MappingSubclass 类中被替换为\n\n|  | DerivedClassName 中找不到，就会在 Base1 中搜索它，然后（递归地）在 Base1 的基类中搜索，\n如果在那里也找不到，就将在 Base2 中搜索，依此类推。\n真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 super() 的协同调用。 这种方式在\n某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。\n动态调整顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有\n一个上级类可通过多条路径被最底层的类所访问）。 例如，所有类都是继承自 object，因此任何\n多重继承的情况都提供了一条以上的路径可以通向 object。 为了确保基类不会被访问一次以上，\n动态算法会用一种特殊方式将搜索顺序线性化，保留每个类所指定的从左至右的顺序，只调用每个\n上级类一次，并且保持单调性（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，\n这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 Python\n2.3 方法解析顺序。\n9.6. 私有变量\n那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码\n都遵循这样一个约定：带有一个下划线的名称 (例如 _spam) 应该被当作是 API 的非公有部分 (无论它\n是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。\n由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在\n对此种机制的有限支持，称为 名称改写。 任何形式为 __spam 的标识符（至少带有两个前缀下划\n线，至多一个后缀下划线）的文本将被替换为 _classname__spam，其中 classname 为去除了前缀\n下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。 |  |\n| --- | --- | --- |\n|  | 参见: 私有名称调整规范说明 了解相关详情和特例。 |  |\n|  | 名称改写有助于让子类重写方法而不破坏类内方法调用。例如: |  |\n|  | class Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update # 原始 update() 方法的私有副本\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# 为 update() 提供了新的签名\n# 但不会破坏 __init__()\nfor item in zip(keys, values):\nself.items_list.append(item) |  |\n|  | 上面的示例即使在 MappingSubclass 引入了一个 __update 标识符的情况下也不会出错，因为它会\n在 Mapping 类中被替换为 _Mapping__update 而在 MappingSubclass 类中被替换为 |  |\n\n_MappingSubclass__update。\n请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。\n这在特殊情况下甚至会很有用，例如在调试器中。\n请注意传递给 exec() 或 eval() 的代码不会将唤起类的类名视作当前类；这类似于 global 语句的\n效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 getattr(),\nsetattr() 和 delattr()，以及对于 __dict__ 的直接引用。\n9.7. 杂项说明\n有时具有类似于 Pascal \"record\" 或 C \"struct\" 的数据类型是很有用的，将一些带名称的数据项捆绑在\n一起。 实现这一目标的理想方式是使用 dataclasses:\nfrom dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\n一段期望使用特定抽象数据类型的 Python 代码通常可以通过传入一个模拟了该数据类型的方法的类\n作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有\nread() 和 readline() 方法以便从字典串缓冲区获取数据的类，并将其作为参数传入。\n实例方法对象 也具有属性: m.__self__ 就是带有 m() 方法的实例对象，而 m.__func__ 就是该方法\n所对应的 函数对象。\n9.8. 迭代器\n到目前为止，您可能已经注意到大多数容器对象都可以使用 for 语句:\nfor element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='')\n\n|  | _MappingSubclass__update。\n请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。\n这在特殊情况下甚至会很有用，例如在调试器中。\n请注意传递给 exec() 或 eval() 的代码不会将唤起类的类名视作当前类；这类似于 global 语句的\n效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 getattr(),\nsetattr() 和 delattr()，以及对于 __dict__ 的直接引用。\n9.7. 杂项说明\n有时具有类似于 Pascal \"record\" 或 C \"struct\" 的数据类型是很有用的，将一些带名称的数据项捆绑在\n一起。 实现这一目标的理想方式是使用 dataclasses: |  |\n| --- | --- | --- |\n|  | from dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int |  |\n|  |  |  |\n|  | >>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000 |  |\n|  | 一段期望使用特定抽象数据类型的 Python 代码通常可以通过传入一个模拟了该数据类型的方法的类\n作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有\nread() 和 readline() 方法以便从字典串缓冲区获取数据的类，并将其作为参数传入。\n实例方法对象 也具有属性: m.__self__ 就是带有 m() 方法的实例对象，而 m.__func__ 就是该方法\n所对应的 函数对象。\n9.8. 迭代器\n到目前为止，您可能已经注意到大多数容器对象都可以使用 for 语句: |  |\n|  | for element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='') |  |\n|  |  |  |\n\n这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在\n幕后，for 语句会在容器对象上调用 iter()。 该函数返回一个定义了 __next__() 方法的迭代器\n对象，此方法将逐一访问容器中的元素。 当元素用尽时，__next__() 将引发 StopIteration 异常\n来通知终止 for 循环。 你可以使用 next() 内置函数来调用 __next__() 方法；这个例子显示了它\n的运作方式:\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration\n了解了迭代器协议背后的机制后，就可以轻松地为你的类添加迭代器行为了。 定义 __iter__() 方\n法用于返回一个带有 __next__() 方法的对象。 如果类已定义了 __next__()，那么 __iter__()\n可以简单地返回 self:\nclass Reverse:\n\"\"\"对一个序列执行反向循环的迭代器。\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index]\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n... print(char)\n...\nm\na\np\ns\n9.9. 生成器\n\n|  | 这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在\n幕后，for 语句会在容器对象上调用 iter()。 该函数返回一个定义了 __next__() 方法的迭代器\n对象，此方法将逐一访问容器中的元素。 当元素用尽时，__next__() 将引发 StopIteration 异常\n来通知终止 for 循环。 你可以使用 next() 内置函数来调用 __next__() 方法；这个例子显示了它\n的运作方式: |  |\n| --- | --- | --- |\n|  | >>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration |  |\n|  | 了解了迭代器协议背后的机制后，就可以轻松地为你的类添加迭代器行为了。 定义 __iter__() 方\n法用于返回一个带有 __next__() 方法的对象。 如果类已定义了 __next__()，那么 __iter__()\n可以简单地返回 self: |  |\n|  | class Reverse:\n\"\"\"对一个序列执行反向循环的迭代器。\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index] |  |\n|  |  |  |\n|  | >>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n... print(char)\n...\nm\na\np\ns |  |\n|  | 9.9. 生成器 |  |\n\n生成器 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返\n回数据时会使用 yield 语句。 每次在生成器上调用 next() 时，它会从上次离开的位置恢复执行\n（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下:\ndef reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index]\n>>> for char in reverse('golf'):\n... print(char)\n...\nf\nl\no\ng\n可以用生成器来完成的任何功能同样可以通用前一节所描述的基于类的迭代器来完成。 但生成器的\n写法更为紧凑，因为它会自动创建 __iter__() 和 __next__() 方法。\n另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用\nself.index 和 self.data 这种实例变量的方式更易编写且更为清晰。\n除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 StopIteration。 这些\n特性结合在一起，使得创建迭代器能与编写常规函数一样容易。\n9.10. 生成器表达式\n某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方\n括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生\n成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。\n示例:\n>>> sum(i*i for i in range(10)) # 平方和\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec)) # 点乘\n260\n>>> unique_words = set(word for line in page for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\n备注\n\n|  | 生成器 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返\n回数据时会使用 yield 语句。 每次在生成器上调用 next() 时，它会从上次离开的位置恢复执行\n（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下: |  |\n| --- | --- | --- |\n|  | def reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index] |  |\n|  |  |  |\n|  | >>> for char in reverse('golf'):\n... print(char)\n...\nf\nl\no\ng |  |\n|  | 可以用生成器来完成的任何功能同样可以通用前一节所描述的基于类的迭代器来完成。 但生成器的\n写法更为紧凑，因为它会自动创建 __iter__() 和 __next__() 方法。\n另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用\nself.index 和 self.data 这种实例变量的方式更易编写且更为清晰。\n除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 StopIteration。 这些\n特性结合在一起，使得创建迭代器能与编写常规函数一样容易。\n9.10. 生成器表达式\n某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方\n括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生\n成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。\n示例: |  |\n|  | >>> sum(i*i for i in range(10)) # 平方和\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec)) # 点乘\n260\n>>> unique_words = set(word for line in page for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g'] |  |\n|  | 备注 |  |\n\n[1] 存在一个例外。 模块对象有一个秘密的只读属性名为 __dict__，它返回用于实现模块命名空\n间的字典；名称 __dict__ 是一个属性但不是全局名称。 显然，使用个将违反命名空间实现的\n抽象，应当仅限用于事后调试器之类的情况。", "metadata": {"title": "09_类", "source": "md_docs\\python_docs_md\\09_类.md", "doc_type": "教程", "language": "中文", "doc_id": "e427f828"}}
{"doc_id": "0579c0b8", "content": "10. 标准库简介\n10.1. 操作系统接口\nos 模块提供了许多与操作系统交互的函数:\n>>> import os\n>>> os.getcwd() # 返回当前工作目录\n'C:\\\\Python314'\n>>> os.chdir('/server/accesslogs') # 改变当前工作目录\n>>> os.system('mkdir today') # 在系统shell中执行mkdir命令\n0\n一定要使用 import os 而不是 from os import * 。这将避免内建的 open() 函数被 os.open()\n隐式替换掉，因为它们的使用方式大不相同。\n内置的 dir() 和 help() 函数可用作交互式辅助工具，用于处理大型模块，如 os:\n>>> import os\n>>> dir(os)\n<返回由模块的所有函数组成的列表>\n>>> help(os)\n<返回根据模块文档字符串创建的详细说明页面>\n对于日常文件和目录管理任务， shutil 模块提供了更易于使用的更高级别的接口:\n>>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n'archive.db'\n>>> shutil.move('/build/executables', 'installdir')\n'installdir'\n10.2. 文件通配符\nglob 模块提供了一个在目录中使用通配符搜索创建文件列表的函数:\n>>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py']\n10.3. 命令行参数\n一般的工具脚本常常需要处理命令行参数。 这些参数以列表形式存储在 sys 模块的 argv 属性中。\n举例来说，让我们查看下面的 demo.py 文件:\n# 文件 demo.py\nimport sys\n\n| 10. 标准库简介\n10.1. 操作系统接口\nos 模块提供了许多与操作系统交互的函数: |\n| --- |\n| >>> import os\n>>> os.getcwd() # 返回当前工作目录\n'C:\\\\Python314'\n>>> os.chdir('/server/accesslogs') # 改变当前工作目录\n>>> os.system('mkdir today') # 在系统shell中执行mkdir命令\n0 |\n| 一定要使用 import os 而不是 from os import * 。这将避免内建的 open() 函数被 os.open()\n隐式替换掉，因为它们的使用方式大不相同。\n内置的 dir() 和 help() 函数可用作交互式辅助工具，用于处理大型模块，如 os: |\n| >>> import os\n>>> dir(os)\n<返回由模块的所有函数组成的列表>\n>>> help(os)\n<返回根据模块文档字符串创建的详细说明页面> |\n| 对于日常文件和目录管理任务， shutil 模块提供了更易于使用的更高级别的接口: |\n| >>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n'archive.db'\n>>> shutil.move('/build/executables', 'installdir')\n'installdir' |\n| 10.2. 文件通配符\nglob 模块提供了一个在目录中使用通配符搜索创建文件列表的函数: |\n| >>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py'] |\n| 10.3. 命令行参数\n一般的工具脚本常常需要处理命令行参数。 这些参数以列表形式存储在 sys 模块的 argv 属性中。\n举例来说，让我们查看下面的 demo.py 文件: |\n| # 文件 demo.py\nimport sys |\n\nprint(sys.argv)\n以下是在命令行中运行 python demo.py one two three 输出的结果:\n['demo.py', 'one', 'two', 'three']\nargparse 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，\n并可选择要显示的行数:\nimport argparse\nparser = argparse.ArgumentParser(\nprog='top',\ndescription='Show top lines from each file')\nparser.add_argument('filenames', nargs='+')\nparser.add_argument('-l', '--lines', type=int, default=10)\nargs = parser.parse_args()\nprint(args)\n当在通过 python top.py --lines=5 alpha.txt beta.txt 在命令行运行时，该脚本会将\nargs.lines 设为 5 并将 args.filenames 设为 ['alpha.txt', 'beta.txt']。\n10.4. 错误输出重定向和程序终止\nsys 模块还具有 stdin ， stdout 和 stderr 的属性。后者对于发出警告和错误消息非常有用，即使在\nstdout 被重定向后也可以看到它们:\n>>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one\n终止脚本的最直接方法是使用 sys.exit() 。\n10.5. 字符串模式匹配\nre 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优\n化的解决方案:\n>>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat'\n当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试:\n>>> 'tea for too'.replace('too', 'two')\n'tea for two'\n10.6. 数学\n\n|  | print(sys.argv) |  |\n| --- | --- | --- |\n|  | 以下是在命令行中运行 python demo.py one two three 输出的结果: |  |\n|  | ['demo.py', 'one', 'two', 'three'] |  |\n|  | argparse 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，\n并可选择要显示的行数: |  |\n|  | import argparse\nparser = argparse.ArgumentParser(\nprog='top',\ndescription='Show top lines from each file')\nparser.add_argument('filenames', nargs='+')\nparser.add_argument('-l', '--lines', type=int, default=10)\nargs = parser.parse_args()\nprint(args) |  |\n|  | 当在通过 python top.py --lines=5 alpha.txt beta.txt 在命令行运行时，该脚本会将\nargs.lines 设为 5 并将 args.filenames 设为 ['alpha.txt', 'beta.txt']。\n10.4. 错误输出重定向和程序终止\nsys 模块还具有 stdin ， stdout 和 stderr 的属性。后者对于发出警告和错误消息非常有用，即使在\nstdout 被重定向后也可以看到它们: |  |\n|  | >>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one |  |\n|  | 终止脚本的最直接方法是使用 sys.exit() 。\n10.5. 字符串模式匹配\nre 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优\n化的解决方案: |  |\n|  | >>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat' |  |\n|  | 当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试: |  |\n|  | >>> 'tea for too'.replace('too', 'two')\n'tea for two' |  |\n|  | 10.6. 数学 |  |\n\nmath 模块提供对用于浮点数学运算的下层 C 库函数的访问:\n>>> import math\n>>> math.cos(math.pi / 4)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0\nrandom 模块提供了进行随机选择的工具:\n>>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(range(100), 10) # 无替代的取样\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random() # [0.0, 1.0) 区间的随机浮点数\n0.17970987693706186\n>>> random.randrange(6) # 从 range(6) 中随机选取的整数\n4\nstatistics 模块计算数值数据的基本统计属性（均值，中位数，方差等）:\n>>> import statistics\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> statistics.mean(data)\n1.6071428571428572\n>>> statistics.median(data)\n1.25\n>>> statistics.variance(data)\n1.3720238095238095\nSciPy项目 <https://scipy.org> 有许多其他模块用于数值计算。\n10.7. 互联网访问\n有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 urllib.request 用于从URL\n检索数据，以及 smtplib 用于发送邮件:\n>>> from urllib.request import urlopen\n>>> with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response:\n... for line in response:\n... line = line.decode() # 将字节串转换为字符串\n... if line.startswith('datetime'):\n... print(line.rstrip()) # 去除末尾换行符\n...\ndatetime: 2022-01-01T01:36:47.689215+00:00\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March.\n\n|  | math 模块提供对用于浮点数学运算的下层 C 库函数的访问: |  |\n| --- | --- | --- |\n|  | >>> import math\n>>> math.cos(math.pi / 4)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0 |  |\n|  | random 模块提供了进行随机选择的工具: |  |\n|  | >>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(range(100), 10) # 无替代的取样\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random() # [0.0, 1.0) 区间的随机浮点数\n0.17970987693706186\n>>> random.randrange(6) # 从 range(6) 中随机选取的整数\n4 |  |\n|  | statistics 模块计算数值数据的基本统计属性（均值，中位数，方差等）: |  |\n|  | >>> import statistics\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> statistics.mean(data)\n1.6071428571428572\n>>> statistics.median(data)\n1.25\n>>> statistics.variance(data)\n1.3720238095238095 |  |\n|  | SciPy项目 <https://scipy.org> 有许多其他模块用于数值计算。\n10.7. 互联网访问\n有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 urllib.request 用于从URL\n检索数据，以及 smtplib 用于发送邮件: |  |\n|  | >>> from urllib.request import urlopen\n>>> with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response:\n... for line in response:\n... line = line.decode() # 将字节串转换为字符串\n... if line.startswith('datetime'):\n... print(line.rstrip()) # 去除末尾换行符\n...\ndatetime: 2022-01-01T01:36:47.689215+00:00\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March. |  |\n\n... \"\"\")\n>>> server.quit()\n（请注意，第二个示例需要在localhost上运行的邮件服务器。）\n10.8. 日期和时间\ndatetime 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现\n的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。\n>>> # 方便地构造和格式化日期值\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n>>> # 日期值支持日历运算\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368\n10.9. 数据压缩\n常见的数据存档和压缩格式由模块直接支持，包括：zlib, gzip, bz2, lzma, zipfile 和\ntarfile。:\n>>> import zlib\n>>> s = b'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\nb'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979\n10.10. 性能测量\n一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以\n立即回答这些问题的测量工具。\n例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。timeit 模块可以快速演示在运行\n效率方面一定的优势:\n>>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577\n\n|  | ... \"\"\")\n>>> server.quit() |  |\n| --- | --- | --- |\n|  | （请注意，第二个示例需要在localhost上运行的邮件服务器。）\n10.8. 日期和时间\ndatetime 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现\n的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。 |  |\n|  | >>> # 方便地构造和格式化日期值\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n>>> # 日期值支持日历运算\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368 |  |\n|  | 10.9. 数据压缩\n常见的数据存档和压缩格式由模块直接支持，包括：zlib, gzip, bz2, lzma, zipfile 和\ntarfile。: |  |\n|  | >>> import zlib\n>>> s = b'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\nb'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979 |  |\n|  | 10.10. 性能测量\n一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以\n立即回答这些问题的测量工具。\n例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。timeit 模块可以快速演示在运行\n效率方面一定的优势: |  |\n|  | >>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577 |  |\n\n>>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791\n与 timeit 的精细粒度级别相反， profile 和 pstats 模块提供了用于在较大的代码块中识别时间\n关键部分的工具。\n10.11. 质量控制\n开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测\n试。\ndoctest 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像\n将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且\n它允许doctest模块确保代码保持对文档的真实:\ndef average(values):\n\"\"\"计算数字列表的算术平均值\n>>> print(average([20, 30, 70]))\n40.0\n\"\"\"\nreturn sum(values) / len(values)\nimport doctest\ndoctest.testmod() # 自动验证嵌入式测试\nunittest 模块不像 doctest 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试\n集:\nimport unittest\nclass TestStatisticalFunctions(unittest.TestCase):\ndef test_average(self):\nself.assertEqual(average([20, 30, 70]), 40.0)\nself.assertEqual(round(average([1, 5, 7]), 1), 4.3)\nwith self.assertRaises(ZeroDivisionError):\naverage([])\nwith self.assertRaises(TypeError):\naverage(20, 30, 70)\nunittest.main() # 从命令行调用时会执行所有测试\n10.12. 自带电池\nPython有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如:\nxmlrpc.client 和 xmlrpc.server 模块使得实现远程过程调用变成了小菜一碟。 尽管存在于模\n块名称中，但用户不需要直接了解或处理 XML。\nemail 包是一个用于管理电子邮件的库，包括MIME和其他符合 RFC 2822 规范的邮件文档。与\nsmtplib 和 poplib 不同（它们实际上做的是发送和接收消息），电子邮件包提供完整的工具\n\n|  | >>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791 |  |\n| --- | --- | --- |\n|  | 与 timeit 的精细粒度级别相反， profile 和 pstats 模块提供了用于在较大的代码块中识别时间\n关键部分的工具。\n10.11. 质量控制\n开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测\n试。\ndoctest 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像\n将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且\n它允许doctest模块确保代码保持对文档的真实: |  |\n|  | def average(values):\n\"\"\"计算数字列表的算术平均值\n>>> print(average([20, 30, 70]))\n40.0\n\"\"\"\nreturn sum(values) / len(values)\nimport doctest\ndoctest.testmod() # 自动验证嵌入式测试 |  |\n|  | unittest 模块不像 doctest 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试\n集: |  |\n|  | import unittest\nclass TestStatisticalFunctions(unittest.TestCase):\ndef test_average(self):\nself.assertEqual(average([20, 30, 70]), 40.0)\nself.assertEqual(round(average([1, 5, 7]), 1), 4.3)\nwith self.assertRaises(ZeroDivisionError):\naverage([])\nwith self.assertRaises(TypeError):\naverage(20, 30, 70)\nunittest.main() # 从命令行调用时会执行所有测试 |  |\n|  | 10.12. 自带电池\nPython有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如:\nxmlrpc.client 和 xmlrpc.server 模块使得实现远程过程调用变成了小菜一碟。 尽管存在于模\n块名称中，但用户不需要直接了解或处理 XML。\nemail 包是一个用于管理电子邮件的库，包括MIME和其他符合 RFC 2822 规范的邮件文档。与\nsmtplib 和 poplib 不同（它们实际上做的是发送和接收消息），电子邮件包提供完整的工具 |  |\n\n集，用于构建或解码复杂的消息结构（包括附件）以及实现互联网编码和标头协议。\njson 包为解析这种流行的数据交换格式提供了强大的支持。 csv 模块支持以逗号分隔值格式直\n接读取和写入文件，这种格式通常为数据库和电子表格所支持。 XML 处理由\nxml.etree.ElementTree ， xml.dom 和 xml.sax 包支持。这些模块和软件包共同大大简化了\nPython 应用程序和其他工具之间的数据交换。\nsqlite3 模块是 SQLite 数据库库的包装器，提供了一个可以使用稍微非标准的 SQL 语法更新和\n访问的持久数据库。\n国际化由许多模块支持，包括 gettext ， locale ，以及 codecs 包。", "metadata": {"title": "10_标准库简介", "source": "md_docs\\python_docs_md\\10_标准库简介.md", "doc_type": "教程", "language": "中文", "doc_id": "0579c0b8"}}
{"doc_id": "973981aa", "content": "11. 标准库简介 —— 第二部分\n第二部分涵盖了专业编程所需要的更高级的模块。这些模块很少用在小脚本中。\n11.1. 格式化输出\nreprlib 模块提供了一个定制化版本的 repr() 函数，用于缩略显示大型或深层嵌套的容器对象:\n>>> import reprlib\n>>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\"\npprint 模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读\n取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结\n构:\n>>> import pprint\n>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n... 'yellow'], 'blue']]]\n...\n>>> pprint.pprint(t, width=30)\n[[[['black', 'cyan'],\n'white',\n['green', 'red']],\n[['magenta', 'yellow'],\n'blue']]]\ntextwrap 模块能够格式化文本段落，以适应给定的屏幕宽度:\n>>> import textwrap\n>>> doc = \"\"\"The wrap() method is just like fill() except that it returns\n... a list of strings instead of one big string with newlines to separate\n... the wrapped lines.\"\"\"\n...\n>>> print(textwrap.fill(doc, width=40))\nThe wrap() method is just like fill()\nexcept that it returns a list of strings\ninstead of one big string with newlines\nto separate the wrapped lines.\nlocale 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping 属\n性，可直接将数字格式化为带有组分隔符的样式:\n>>> import locale\n>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n'English_United States.1252'\n>>> conv = locale.localeconv() # 获取语言区域设置的映射\n>>> x = 1234567.8\n>>> locale.format_string(\"%d\", x, grouping=True)\n\n| 11. 标准库简介 —— 第二部分\n第二部分涵盖了专业编程所需要的更高级的模块。这些模块很少用在小脚本中。\n11.1. 格式化输出\nreprlib 模块提供了一个定制化版本的 repr() 函数，用于缩略显示大型或深层嵌套的容器对象: |\n| --- |\n| >>> import reprlib\n>>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\" |\n| pprint 模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读\n取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结\n构: |\n| >>> import pprint\n>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n... 'yellow'], 'blue']]]\n...\n>>> pprint.pprint(t, width=30)\n[[[['black', 'cyan'],\n'white',\n['green', 'red']],\n[['magenta', 'yellow'],\n'blue']]] |\n| textwrap 模块能够格式化文本段落，以适应给定的屏幕宽度: |\n| >>> import textwrap\n>>> doc = \"\"\"The wrap() method is just like fill() except that it returns\n... a list of strings instead of one big string with newlines to separate\n... the wrapped lines.\"\"\"\n...\n>>> print(textwrap.fill(doc, width=40))\nThe wrap() method is just like fill()\nexcept that it returns a list of strings\ninstead of one big string with newlines\nto separate the wrapped lines. |\n| locale 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping 属\n性，可直接将数字格式化为带有组分隔符的样式: |\n| >>> import locale\n>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n'English_United States.1252'\n>>> conv = locale.localeconv() # 获取语言区域设置的映射\n>>> x = 1234567.8\n>>> locale.format_string(\"%d\", x, grouping=True) |\n\n'1,234,567'\n>>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n... conv['frac_digits'], x), grouping=True)\n'$1,234,567.80'\n11.2. 模板\nstring 模块包含一个通用的 Template 类，具有适用于最终用户的简化语法。它允许用户在不更改\n应用逻辑的情况下定制自己的应用。\n上述格式化操作是通过占位符实现的，占位符由 $ 加上合法的 Python 标识符（只能包含字母、数\n字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而\n无需空格分割。$$ 将被转义成单个字符 $:\n>>> from string import Template\n>>> t = Template('${village}folk send $$10 to $cause.')\n>>> t.substitute(village='Nottingham', cause='the ditch fund')\n'Nottinghamfolk send $10 to the ditch fund.'\n如果在字典或关键字参数中未提供某个占位符的值，那么 substitute() 方法将抛出 KeyError。对\n于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 safe_substitute() 方法更\n加合适 —— 如果数据缺失，它会直接将占位符原样保留。\n>>> t = Template('Return the $item to $owner.')\n>>> d = dict(item='unladen swallow')\n>>> t.substitute(d)\nTraceback (most recent call last):\n...\nKeyError: 'owner'\n>>> t.safe_substitute(d)\n'Return the unladen swallow to $owner.'\nTemplate 的子类可以自定义分隔符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分\n号作为日期、照片序号和照片格式的占位符:\n>>> import time, os.path\n>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n>>> class BatchRename(Template):\n... delimiter = '%'\n...\n>>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format): ')\nEnter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f\n>>> t = BatchRename(fmt)\n>>> date = time.strftime('%d%b%y')\n>>> for i, filename in enumerate(photofiles):\n... base, ext = os.path.splitext(filename)\n... newname = t.substitute(d=date, n=i, f=ext)\n... print('{0} --> {1}'.format(filename, newname))\nimg_1074.jpg --> Ashley_0.jpg\nimg_1076.jpg --> Ashley_1.jpg\nimg_1077.jpg --> Ashley_2.jpg\n\n|  | '1,234,567'\n>>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n... conv['frac_digits'], x), grouping=True)\n'$1,234,567.80' |  |\n| --- | --- | --- |\n|  | 11.2. 模板\nstring 模块包含一个通用的 Template 类，具有适用于最终用户的简化语法。它允许用户在不更改\n应用逻辑的情况下定制自己的应用。\n上述格式化操作是通过占位符实现的，占位符由 $ 加上合法的 Python 标识符（只能包含字母、数\n字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而\n无需空格分割。$$ 将被转义成单个字符 $: |  |\n|  | >>> from string import Template\n>>> t = Template('${village}folk send $$10 to $cause.')\n>>> t.substitute(village='Nottingham', cause='the ditch fund')\n'Nottinghamfolk send $10 to the ditch fund.' |  |\n|  | 如果在字典或关键字参数中未提供某个占位符的值，那么 substitute() 方法将抛出 KeyError。对\n于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 safe_substitute() 方法更\n加合适 —— 如果数据缺失，它会直接将占位符原样保留。 |  |\n|  | >>> t = Template('Return the $item to $owner.')\n>>> d = dict(item='unladen swallow')\n>>> t.substitute(d)\nTraceback (most recent call last):\n...\nKeyError: 'owner'\n>>> t.safe_substitute(d)\n'Return the unladen swallow to $owner.' |  |\n|  | Template 的子类可以自定义分隔符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分\n号作为日期、照片序号和照片格式的占位符: |  |\n|  | >>> import time, os.path\n>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n>>> class BatchRename(Template):\n... delimiter = '%'\n...\n>>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format): ')\nEnter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f\n>>> t = BatchRename(fmt)\n>>> date = time.strftime('%d%b%y')\n>>> for i, filename in enumerate(photofiles):\n... base, ext = os.path.splitext(filename)\n... newname = t.substitute(d=date, n=i, f=ext)\n... print('{0} --> {1}'.format(filename, newname))\nimg_1074.jpg --> Ashley_0.jpg\nimg_1076.jpg --> Ashley_1.jpg\nimg_1077.jpg --> Ashley_2.jpg |  |\n|  |  |  |\n\n模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报\n表和 HTML 网络报表使用自定义模板成为可能。\n11.3. 使用二进制数据记录格式\nstruct 模块提供了 pack() 和 unpack() 函数，用于处理不定长度的二进制记录格式。下面的例子\n展示了在不使用 zipfile 模块的情况下，如何循环遍历一个 ZIP 文件的所有头信息。Pack 代码 \"H\"\n和 \"I\" 分别代表两字节和四字节无符号整数。\"<\" 代表它们是标准尺寸的小端字节序:\nimport struct\nwith open('myfile.zip', 'rb') as f:\ndata = f.read()\nstart = 0\nfor i in range(3): # 显示前 3 个文件标头\nstart += 14\nfields = struct.unpack('<IIIHH', data[start:start+16])\ncrc32, comp_size, uncomp_size, filenamesize, extra_size = fields\nstart += 16\nfilename = data[start:start+filenamesize]\nstart += filenamesize\nextra = data[start:start+extra_size]\nprint(filename, hex(crc32), comp_size, uncomp_size)\nstart += extra_size + comp_size # 跳过下一个标头\n11.4. 多线程\n线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收\n用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并\n行的线程中。\n以下代码展示了高阶的 threading 模块如何在后台运行任务，且不影响主程序的继续运行:\nimport threading, zipfile\nclass AsyncZip(threading.Thread):\ndef __init__(self, infile, outfile):\nthreading.Thread.__init__(self)\nself.infile = infile\nself.outfile = outfile\ndef run(self):\nf = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\nf.write(self.infile)\nf.close()\nprint('Finished background zip of:', self.infile)\nbackground = AsyncZip('mydata.txt', 'myarchive.zip')\nbackground.start()\nprint('The main program continues to run in foreground.')\n\n|  | 模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报\n表和 HTML 网络报表使用自定义模板成为可能。\n11.3. 使用二进制数据记录格式\nstruct 模块提供了 pack() 和 unpack() 函数，用于处理不定长度的二进制记录格式。下面的例子\n展示了在不使用 zipfile 模块的情况下，如何循环遍历一个 ZIP 文件的所有头信息。Pack 代码 \"H\"\n和 \"I\" 分别代表两字节和四字节无符号整数。\"<\" 代表它们是标准尺寸的小端字节序: |  |\n| --- | --- | --- |\n|  | import struct\nwith open('myfile.zip', 'rb') as f:\ndata = f.read()\nstart = 0\nfor i in range(3): # 显示前 3 个文件标头\nstart += 14\nfields = struct.unpack('<IIIHH', data[start:start+16])\ncrc32, comp_size, uncomp_size, filenamesize, extra_size = fields\nstart += 16\nfilename = data[start:start+filenamesize]\nstart += filenamesize\nextra = data[start:start+extra_size]\nprint(filename, hex(crc32), comp_size, uncomp_size)\nstart += extra_size + comp_size # 跳过下一个标头 |  |\n|  | 11.4. 多线程\n线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收\n用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并\n行的线程中。\n以下代码展示了高阶的 threading 模块如何在后台运行任务，且不影响主程序的继续运行: |  |\n|  | import threading, zipfile\nclass AsyncZip(threading.Thread):\ndef __init__(self, infile, outfile):\nthreading.Thread.__init__(self)\nself.infile = infile\nself.outfile = outfile\ndef run(self):\nf = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\nf.write(self.infile)\nf.close()\nprint('Finished background zip of:', self.infile)\nbackground = AsyncZip('mydata.txt', 'myarchive.zip')\nbackground.start()\nprint('The main program continues to run in foreground.') |  |\n\nbackground.join() # 等待背景任务结束\nprint('Main program waited until background was done.')\n多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，\nthreading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。\n尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协\n作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 queue 模块向该线程供应来自其\n他线程的请求。 应用程序使用 Queue 对象进行线程间通信和协调，更易于设计，更易读，更可靠。\n11.5. 日志记录\nlogging 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或\nsys.stderr\nimport logging\nlogging.debug('Debugging information')\nlogging.info('Informational message')\nlogging.warning('Warning:config file %s not found', 'server.conf')\nlogging.error('Error occurred')\nlogging.critical('Critical error -- shutting down')\n这会产生以下输出:\nWARNING:root:Warning:config file server.conf not found\nERROR:root:Error occurred\nCRITICAL:root:Critical error -- shutting down\n默认情况下，informational 和 debugging 消息被压制，输出会发送到标准错误流。其他输出选项包\n括将消息转发到电子邮件，数据报，套接字或 HTTP 服务器。新的过滤器可以根据消息优先级选择\n不同的路由方式：DEBUG，INFO，WARNING，ERROR，和 CRITICAL。\n日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应\n用程序。\n11.6. 弱引用\nPython 会自动进行内存管理（对大多数对象进行引用计数并使用 garbage collection 来清除循环引\n用）。 当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。\n此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的\n是，跟踪它们将创建一个会令其永久化的引用。 weakref 模块提供的工具可以不必创建引用就能跟\n踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。\n典型应用包括对创建开销较大的对象进行缓存:\n>>> import weakref, gc\n>>> class A:\n... def __init__(self, value):\n... self.value = value\n... def __repr__(self):\n\n|  | background.join() # 等待背景任务结束\nprint('Main program waited until background was done.') |  |\n| --- | --- | --- |\n|  | 多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，\nthreading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。\n尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协\n作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 queue 模块向该线程供应来自其\n他线程的请求。 应用程序使用 Queue 对象进行线程间通信和协调，更易于设计，更易读，更可靠。\n11.5. 日志记录\nlogging 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或\nsys.stderr |  |\n|  | import logging\nlogging.debug('Debugging information')\nlogging.info('Informational message')\nlogging.warning('Warning:config file %s not found', 'server.conf')\nlogging.error('Error occurred')\nlogging.critical('Critical error -- shutting down') |  |\n|  | 这会产生以下输出: |  |\n|  | WARNING:root:Warning:config file server.conf not found\nERROR:root:Error occurred\nCRITICAL:root:Critical error -- shutting down |  |\n|  | 默认情况下，informational 和 debugging 消息被压制，输出会发送到标准错误流。其他输出选项包\n括将消息转发到电子邮件，数据报，套接字或 HTTP 服务器。新的过滤器可以根据消息优先级选择\n不同的路由方式：DEBUG，INFO，WARNING，ERROR，和 CRITICAL。\n日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应\n用程序。\n11.6. 弱引用\nPython 会自动进行内存管理（对大多数对象进行引用计数并使用 garbage collection 来清除循环引\n用）。 当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。\n此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的\n是，跟踪它们将创建一个会令其永久化的引用。 weakref 模块提供的工具可以不必创建引用就能跟\n踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。\n典型应用包括对创建开销较大的对象进行缓存: |  |\n|  | >>> import weakref, gc\n>>> class A:\n... def __init__(self, value):\n... self.value = value\n... def __repr__(self): |  |\n\n... return str(self.value)\n...\n>>> a = A(10) # create a reference\n>>> d = weakref.WeakValueDictionary()\n>>> d['primary'] = a # does not create a reference\n>>> d['primary'] # fetch the object if it is still alive\n10\n>>> del a # remove the one reference\n>>> gc.collect() # run garbage collection right away\n0\n>>> d['primary'] # entry was automatically removed\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nd['primary'] # entry was automatically removed\nFile \"C:/python314/lib/weakref.py\", line 46, in __getitem__\no = self.data[key]()\nKeyError: 'primary'\n11.7. 用于操作列表的工具\n许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替\n代实现。\narray 模块提供了一种 array 对象，它类似于列表，但只能存储类型一致的数据且存储密度更高。\n下面的例子显示了一个由存储为双字节无符号整数的数字 (类型码 \"H\") 组成的元组，而不是常规\nPython int 对象列表所采用的每个条目 16 字节:\n>>> from array import array\n>>> a = array('H', [4000, 10, 700, 22222])\n>>> sum(a)\n26932\n>>> a[1:3]\narray('H', [10, 700])\ncollections 模块提供了一种 deque 对象，它类似于列表，但从左端添加和弹出的速度较快而在中\n间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索:\n>>> from collections import deque\n>>> d = deque([\"task1\", \"task2\", \"task3\"])\n>>> d.append(\"task4\")\n>>> print(\"Handling\", d.popleft())\nHandling task1\nunsearched = deque([starting_node])\ndef breadth_first_search(unsearched):\nnode = unsearched.popleft()\nfor m in gen_moves(node):\nif is_goal(m):\nreturn m\nunsearched.append(m)\n在替代的列表实现以外，标准库也提供了其他工具，例如 bisect 模块具有用于操作有序列表的函\n数:\n\n|  | ... return str(self.value)\n...\n>>> a = A(10) # create a reference\n>>> d = weakref.WeakValueDictionary()\n>>> d['primary'] = a # does not create a reference\n>>> d['primary'] # fetch the object if it is still alive\n10\n>>> del a # remove the one reference\n>>> gc.collect() # run garbage collection right away\n0\n>>> d['primary'] # entry was automatically removed\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nd['primary'] # entry was automatically removed\nFile \"C:/python314/lib/weakref.py\", line 46, in __getitem__\no = self.data[key]()\nKeyError: 'primary' |  |\n| --- | --- | --- |\n|  | 11.7. 用于操作列表的工具\n许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替\n代实现。\narray 模块提供了一种 array 对象，它类似于列表，但只能存储类型一致的数据且存储密度更高。\n下面的例子显示了一个由存储为双字节无符号整数的数字 (类型码 \"H\") 组成的元组，而不是常规\nPython int 对象列表所采用的每个条目 16 字节: |  |\n|  | >>> from array import array\n>>> a = array('H', [4000, 10, 700, 22222])\n>>> sum(a)\n26932\n>>> a[1:3]\narray('H', [10, 700]) |  |\n|  | collections 模块提供了一种 deque 对象，它类似于列表，但从左端添加和弹出的速度较快而在中\n间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索: |  |\n|  | >>> from collections import deque\n>>> d = deque([\"task1\", \"task2\", \"task3\"])\n>>> d.append(\"task4\")\n>>> print(\"Handling\", d.popleft())\nHandling task1 |  |\n|  |  |  |\n|  | unsearched = deque([starting_node])\ndef breadth_first_search(unsearched):\nnode = unsearched.popleft()\nfor m in gen_moves(node):\nif is_goal(m):\nreturn m\nunsearched.append(m) |  |\n|  | 在替代的列表实现以外，标准库也提供了其他工具，例如 bisect 模块具有用于操作有序列表的函\n数: |  |\n\n>>> import bisect\n>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n>>> bisect.insort(scores, (300, 'ruby'))\n>>> scores\n[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]\nheapq 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重\n复访问最小元素而不希望运行完整列表排序的应用来说非常有用:\n>>> from heapq import heapify, heappop, heappush\n>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n>>> heapify(data) # 将列表重新调整为堆顺序\n>>> heappush(data, -5) # 添加一个新条目\n>>> [heappop(data) for i in range(3)] # 获取三个最小的条目\n[-5, 0, 1]\n11.8. 十进制浮点运算\ndecimal 模块提供了一种 Decimal 数据类型用于十进制浮点运算。 相比内置的 float 二进制浮点\n实现，该类特别适用于\n财务应用和其他需要精确十进制表示的用途，\n控制精度，\n控制四舍五入以满足法律或监管要求，\n跟踪有效小数位，或\n用户期望结果与手工完成的计算相匹配的应用程序。\n例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果\n结果四舍五入到最接近的分数差异会更大:\n>>> from decimal import *\n>>> round(Decimal('0.70') * Decimal('1.05'), 2)\nDecimal('0.74')\n>>> round(.70 * 1.05, 2)\n0.73\nDecimal 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。\nDecimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。\n精确表示特性使得 Decimal 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测:\n>>> Decimal('1.00') % Decimal('.10')\nDecimal('0.00')\n>>> 1.00 % 0.10\n0.09999999999999995\n>>> sum([Decimal('0.1')]*10) == Decimal('1.0')\nTrue\n>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\nFalse\ndecimal 模块提供了运算所需要的足够精度:\n\n|  | >>> import bisect\n>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n>>> bisect.insort(scores, (300, 'ruby'))\n>>> scores\n[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')] |  |\n| --- | --- | --- |\n|  | heapq 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重\n复访问最小元素而不希望运行完整列表排序的应用来说非常有用: |  |\n|  | >>> from heapq import heapify, heappop, heappush\n>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n>>> heapify(data) # 将列表重新调整为堆顺序\n>>> heappush(data, -5) # 添加一个新条目\n>>> [heappop(data) for i in range(3)] # 获取三个最小的条目\n[-5, 0, 1] |  |\n|  | 11.8. 十进制浮点运算\ndecimal 模块提供了一种 Decimal 数据类型用于十进制浮点运算。 相比内置的 float 二进制浮点\n实现，该类特别适用于\n财务应用和其他需要精确十进制表示的用途，\n控制精度，\n控制四舍五入以满足法律或监管要求，\n跟踪有效小数位，或\n用户期望结果与手工完成的计算相匹配的应用程序。\n例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果\n结果四舍五入到最接近的分数差异会更大: |  |\n|  | >>> from decimal import *\n>>> round(Decimal('0.70') * Decimal('1.05'), 2)\nDecimal('0.74')\n>>> round(.70 * 1.05, 2)\n0.73 |  |\n|  | Decimal 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。\nDecimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。\n精确表示特性使得 Decimal 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测: |  |\n|  | >>> Decimal('1.00') % Decimal('.10')\nDecimal('0.00')\n>>> 1.00 % 0.10\n0.09999999999999995\n>>> sum([Decimal('0.1')]*10) == Decimal('1.0')\nTrue\n>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\nFalse |  |\n|  | decimal 模块提供了运算所需要的足够精度: |  |\n\n>>> getcontext().prec = 36\n>>> Decimal(1) / Decimal(7)\nDecimal('0.142857142857142857142857142857142857')\n\n| >>> getcontext().prec = 36\n>>> Decimal(1) / Decimal(7)\nDecimal('0.142857142857142857142857142857142857') |\n| --- |\n|  |", "metadata": {"title": "11_标准库简介_——_第二部分", "source": "md_docs\\python_docs_md\\11_标准库简介_——_第二部分.md", "doc_type": "教程", "language": "中文", "doc_id": "973981aa"}}
{"doc_id": "216fa4a6", "content": "12. 虚拟环境和包\n12.1. 概述\nPython应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为\n应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。\n这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版\n本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。\n这个问题的解决方案是创建一个 virtual environment，一个目录树，其中安装有特定Python版本，\n以及许多其他包。\n然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥\n有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如\n果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。\n12.2. 创建虚拟环境\n用于创建和管理虚拟环境的模块是 venv。 venv 将安装运行命令所使用的 Python 版本（即 --\nversion 选项所报告的版本）。 例如，使用 python3.12 执行命令将会安装 3.12 版。\n要创建虚拟环境，请确定要放置它的目录，并将 venv 模块作为脚本运行目录路径:\npython -m venv tutorial-env\n这将创建 tutorial-env 目录，如果它不存在的话，并在其中创建包含 Python 解释器副本和各种支\n持文件的目录。\n虚拟环境的常用目录位置是 .venv。 这个名称通常会令该目录在你的终端中保持隐藏，从而避免需\n要对所在目录进行额外解释的一般名称。 它还能防止与某些工具所支持的 .env 环境变量定义文件\n发生冲突。\n创建虚拟环境后，您可以激活它。\n在Windows上，运行:\ntutorial-env\\Scripts\\activate\n在Unix或MacOS上，运行:\nsource tutorial-env/bin/activate\n（这个脚本是为bash shell编写的。如果你使用 csh 或 fish shell，你应该改用 activate.csh 或\nactivate.fish 脚本。）\n\n| 12. 虚拟环境和包\n12.1. 概述\nPython应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为\n应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。\n这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版\n本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。\n这个问题的解决方案是创建一个 virtual environment，一个目录树，其中安装有特定Python版本，\n以及许多其他包。\n然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥\n有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如\n果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。\n12.2. 创建虚拟环境\n用于创建和管理虚拟环境的模块是 venv。 venv 将安装运行命令所使用的 Python 版本（即 --\nversion 选项所报告的版本）。 例如，使用 python3.12 执行命令将会安装 3.12 版。\n要创建虚拟环境，请确定要放置它的目录，并将 venv 模块作为脚本运行目录路径: |\n| --- |\n| python -m venv tutorial-env |\n| 这将创建 tutorial-env 目录，如果它不存在的话，并在其中创建包含 Python 解释器副本和各种支\n持文件的目录。\n虚拟环境的常用目录位置是 .venv。 这个名称通常会令该目录在你的终端中保持隐藏，从而避免需\n要对所在目录进行额外解释的一般名称。 它还能防止与某些工具所支持的 .env 环境变量定义文件\n发生冲突。\n创建虚拟环境后，您可以激活它。\n在Windows上，运行: |\n| tutorial-env\\Scripts\\activate |\n| 在Unix或MacOS上，运行: |\n| source tutorial-env/bin/activate |\n| （这个脚本是为bash shell编写的。如果你使用 csh 或 fish shell，你应该改用 activate.csh 或\nactivate.fish 脚本。） |\n\n激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 python\n命令所运行的将是已安装的特定 Python 版本。 例如：\n$ source ~/envs/tutorial-env/bin/activate\n(tutorial-env) $ python\nPython 3.5.1 (default, May 6 2016, 10:59:36)\n...\n>>> import sys\n>>> sys.path\n['', '/usr/local/lib/python35.zip', ...,\n'~/envs/tutorial-env/lib/python3.5/site-packages']\n>>>\n要撤销激活一个虚拟环境，请输入:\ndeactivate\n到终端。\n12.3. 使用pip管理包\n你可以使用一个名为 pip 的程序来安装、升级和移除软件包。 默认情况下 pip 将从 Python\nPackage Index 安装软件包。 你可以在你的 web 浏览器中查看 Python Package Index。\npip 有许多子命令: \"install\", \"uninstall\", \"freeze\" 等等。 （请在 安装 Python 模块 指南页查看完整的\npip 文档。）\n您可以通过指定包的名称来安装最新版本的包：\n(tutorial-env) $ python -m pip install novas\nCollecting novas\nDownloading novas-3.1.1.3.tar.gz (136kB)\nInstalling collected packages: novas\nRunning setup.py install for novas\nSuccessfully installed novas-3.1.1.3\n您还可以通过提供包名称后跟 == 和版本号来安装特定版本的包：\n(tutorial-env) $ python -m pip install requests==2.6.0\nCollecting requests==2.6.0\nUsing cached requests-2.6.0-py2.py3-none-any.whl\nInstalling collected packages: requests\nSuccessfully installed requests-2.6.0\n如果你重新运行这个命令，pip 会注意到已经安装了所请求的版本因而不做任何事。 你可以提供不\n同的版本号来获取相应版本，或者你可以运行 python -m pip install --upgrade 以将软件包升\n级到最新版本:\n(tutorial-env) $ python -m pip install --upgrade requests\nCollecting requests\nInstalling collected packages: requests\nFound existing installation: requests 2.6.0\n\n|  | 激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 python\n命令所运行的将是已安装的特定 Python 版本。 例如： |  |\n| --- | --- | --- |\n|  | $ source ~/envs/tutorial-env/bin/activate\n(tutorial-env) $ python\nPython 3.5.1 (default, May 6 2016, 10:59:36)\n...\n>>> import sys\n>>> sys.path\n['', '/usr/local/lib/python35.zip', ...,\n'~/envs/tutorial-env/lib/python3.5/site-packages']\n>>> |  |\n|  | 要撤销激活一个虚拟环境，请输入: |  |\n|  | deactivate |  |\n|  | 到终端。\n12.3. 使用pip管理包\n你可以使用一个名为 pip 的程序来安装、升级和移除软件包。 默认情况下 pip 将从 Python\nPackage Index 安装软件包。 你可以在你的 web 浏览器中查看 Python Package Index。\npip 有许多子命令: \"install\", \"uninstall\", \"freeze\" 等等。 （请在 安装 Python 模块 指南页查看完整的\npip 文档。）\n您可以通过指定包的名称来安装最新版本的包： |  |\n|  | (tutorial-env) $ python -m pip install novas\nCollecting novas\nDownloading novas-3.1.1.3.tar.gz (136kB)\nInstalling collected packages: novas\nRunning setup.py install for novas\nSuccessfully installed novas-3.1.1.3 |  |\n|  | 您还可以通过提供包名称后跟 == 和版本号来安装特定版本的包： |  |\n|  | (tutorial-env) $ python -m pip install requests==2.6.0\nCollecting requests==2.6.0\nUsing cached requests-2.6.0-py2.py3-none-any.whl\nInstalling collected packages: requests\nSuccessfully installed requests-2.6.0 |  |\n|  | 如果你重新运行这个命令，pip 会注意到已经安装了所请求的版本因而不做任何事。 你可以提供不\n同的版本号来获取相应版本，或者你可以运行 python -m pip install --upgrade 以将软件包升\n级到最新版本: |  |\n|  | (tutorial-env) $ python -m pip install --upgrade requests\nCollecting requests\nInstalling collected packages: requests\nFound existing installation: requests 2.6.0 |  |\n\nUninstalling requests-2.6.0:\nSuccessfully uninstalled requests-2.6.0\nSuccessfully installed requests-2.7.0\npython -m pip uninstall 后跟一个或多个要从虚拟环境中删除的包所对应的名称。\npython -m pip show 将显示有关某个特定包的信息:\n(tutorial-env) $ python -m pip show requests\n---\nMetadata-Version: 2.0\nName: requests\nVersion: 2.7.0\nSummary: Python HTTP for Humans.\nHome-page: http://python-requests.org\nAuthor: Kenneth Reitz\nAuthor-email: me@kennethreitz.com\nLicense: Apache 2.0\nLocation: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages\nRequires:\npython -m pip list 将显示所有在虚拟环境中安装的包:\n(tutorial-env) $ python -m pip list\nnovas (3.1.1.3)\nnumpy (1.9.2)\npip (7.0.3)\nrequests (2.7.0)\nsetuptools (16.0)\npython -m pip freeze 将产生一个类似的已安装包列表，但其输出会使用 python -m pip\ninstall 所期望的格式。 一个常见的约定是将此列表放在 requirements.txt 文件中:\n(tutorial-env) $ python -m pip freeze > requirements.txt\n(tutorial-env) $ cat requirements.txt\nnovas==3.1.1.3\nnumpy==1.9.2\nrequests==2.7.0\n然后可以将 requirements.txt 提交给版本控制并作为应用程序的一部分提供。然后用户可以使用\ninstall -r 安装所有必需的包：\n(tutorial-env) $ python -m pip install -r requirements.txt\nCollecting novas==3.1.1.3 (from -r requirements.txt (line 1))\n...\nCollecting numpy==1.9.2 (from -r requirements.txt (line 2))\n...\nCollecting requests==2.7.0 (from -r requirements.txt (line 3))\n...\nInstalling collected packages: novas, numpy, requests\nRunning setup.py install for novas\nSuccessfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0\n\n|  |  | Uninstalling requests-2.6.0:\nSuccessfully uninstalled requests-2.6.0\nSuccessfully installed requests-2.7.0 |  |\n| --- | --- | --- | --- |\n|  |  | python -m pip uninstall 后跟一个或多个要从虚拟环境中删除的包所对应的名称。\npython -m pip show 将显示有关某个特定包的信息: |  |\n|  |  | (tutorial-env) $ python -m pip show requests\n---\nMetadata-Version: 2.0\nName: requests\nVersion: 2.7.0\nSummary: Python HTTP for Humans.\nHome-page: http://python-requests.org\nAuthor: Kenneth Reitz\nAuthor-email: me@kennethreitz.com\nLicense: Apache 2.0\nLocation: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages\nRequires: |  |\n|  |  | python -m pip list 将显示所有在虚拟环境中安装的包: |  |\n|  |  | (tutorial-env) $ python -m pip list\nnovas (3.1.1.3)\nnumpy (1.9.2)\npip (7.0.3)\nrequests (2.7.0)\nsetuptools (16.0) |  |\n|  |  | python -m pip freeze 将产生一个类似的已安装包列表，但其输出会使用 python -m pip\ninstall 所期望的格式。 一个常见的约定是将此列表放在 requirements.txt 文件中: |  |\n|  |  | install |  |\n|  |  |  |  |\n|  |  | (tutorial-env) $ python -m pip freeze > requirements.txt\n(tutorial-env) $ cat requirements.txt\nnovas==3.1.1.3\nnumpy==1.9.2\nrequests==2.7.0 |  |\n|  |  | 然后可以将 requirements.txt 提交给版本控制并作为应用程序的一部分提供。然后用户可以使用\ninstall -r 安装所有必需的包： |  |\n|  |  | (tutorial-env) $ python -m pip install -r requirements.txt\nCollecting novas==3.1.1.3 (from -r requirements.txt (line 1))\n...\nCollecting numpy==1.9.2 (from -r requirements.txt (line 2))\n...\nCollecting requests==2.7.0 (from -r requirements.txt (line 3))\n...\nInstalling collected packages: novas, numpy, requests\nRunning setup.py install for novas\nSuccessfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0 |  |\n|  |  |  |  |\n\npip 有更多的选项。 有关 pip 的完整文档请查阅 安装 Python 模块 指南。 当你编写了一个软件包\n并希望将其放在 Python Package Index 中时，请查阅 Python packaging user guide。", "metadata": {"title": "12_虚拟环境和包", "source": "md_docs\\python_docs_md\\12_虚拟环境和包.md", "doc_type": "教程", "language": "中文", "doc_id": "216fa4a6"}}
{"doc_id": "b408e4a5", "content": "13. 接下来？\n阅读本教程可能会增强您对使用Python的兴趣 - 您应该热衷于应用Python来解决您的实际问题。你\n应该去哪里了解更多？\n本教程是Python文档集的一部分。其他文档：\nPython 标准库:\n你应当浏览一下本手册，其中提供了有关标准库中的类型、函数和模块的完整（但简洁）的参考\n资料。 标准 Python 分发版包括 许多 附加代码。 这些模块可以完成读取 Unix 邮箱，通过 HTTP\n获取文档，生成随机数，解析命令行选项，压缩数据以及许多其他任务。 浏览标准库参考将使你\n了解有哪些可用的功能。\n安装 Python 模块 解释了怎么安装由其他Python开发者编写的模块。\nPython 语言参考手册: Python的语法和语义的详细解释。尽管阅读完非常繁重，但作为语言本身\n的完整指南是有用的。\n更多Python资源：\nhttps://www.python.org: Python 主网站。 它包含代码、文档和指向全网 Python 相关网页的链\n接。\nhttps://docs.python.org ：快速访问Python的文档。\nhttps://pypi.org: The Python Package Index，以前也被昵称为 Cheese Shop [1]，是可下载用户自\n制 Python 模块的索引。 当你要开始发布代码时，你可以在此处进行注册以便其他人能找到它。\nhttps://code.activestate.com/recipes/langs/python/ ：Python Cookbook是一个相当大的代码示\n例集，更多的模块和有用的脚本。特别值得一看的贡献收集在一本名为Python Cookbook\n（O'Reilly＆Associates，ISBN 0-596-00797-3）的书中。\nhttps://pyvideo.org 收集了来自研讨会和用户组会议的 Python 相关视频的链接。\nhttps://scipy.org ：Scientific Python 项目包含用于快速矩阵计算和操作的模块，以及用于诸如线\n性代数，傅里叶变换，非线性求解器，随机数分布，统计分析等的一系列包。\n对于与Python相关的问题和问题报告，您可以发布到新闻组 comp.lang.python ，或者将它们发送到\n邮件列表python-list@python.org。新闻组和邮件列表是互通的，因此发布到一个地方将自动转发给\n另一个。每天有数百个帖子，询问（和回答）问题，建议新功能，以及宣布新模块。邮件列表档案\n可在 https://mail.python.org/pipermail/ 上找到。\n在发问之前，请务必查看以下列表 常见问题 （或简写为 FAQ）。常见问题包含了很多一次又一次被\n提出的问题及其答案，所以可能已经包含了您的问题解决方案。\n备注\n\n[1] “Cheese Shop”是 Monty Python 的一个短剧：一位顾客来到一家奶酪商店，但无论他要哪种奶\n酪，店员都说没有货。", "metadata": {"title": "13_接下来？", "source": "md_docs\\python_docs_md\\13_接下来？.md", "doc_type": "教程", "language": "中文", "doc_id": "b408e4a5"}}
{"doc_id": "0496c0a5", "content": "14. 交互式编辑和编辑历史\n某些版本的 Python 解释器支持编辑当前输入行和编辑历史记录，类似 Korn shell 和 GNU Bash shell\n的功能 。这个功能使用了 GNU Readline 来实现，一个支持多种编辑方式的库。这个库有它自己的\n文档，在这里我们就不重复说明了。\n14.1. Tab 补全和编辑历史\n在解释器启动的时候变量和模块名补全功能将 自动启用 以便在按下 Tab 键时唤起补全函数；它会查\n找 Python 语句名称、当前局部变量和可用的模块名称。 对于带点号的表达式如 string.a，它会对\n该表达式最后一个 '.' 之前的部分求值然后根据结果对象的属性给出补全建议。 请注意如果具有\n__getattr__() 方法的对象是该表达式的一部分这可能会执行应用程序定义的代码。 默认配置还会\n将你的编辑历史保存到你的用户目录下名为 .python_history 的文件。 该历史在下一次交互式解\n释器会话期间将继续可用。\n14.2. 默认交互式解释器的替代品\n此功能相比较早版本的解释器是很大的进步；不过，还有一些需求没有实现：如果能为连续行提示\n正确的缩进就更好了（解析器知道接下来是否需要 INDENT 词元）。 补全机制或许可以使用解释器\n的符号表。 使用一个命令来检查（甚至提示）匹配括号、引号等也会很有帮助。\n一个可选的增强型交互式解释器是 IPython，它已经存在了有一段时间，它具有 tab 补全，探索对象\n和高级历史记录管理功能。它还可以彻底定制并嵌入到其他应用程序中。另一个相似的增强型交互\n式环境是 bpython。", "metadata": {"title": "14_交互式编辑和编辑历史", "source": "md_docs\\python_docs_md\\14_交互式编辑和编辑历史.md", "doc_type": "教程", "language": "中文", "doc_id": "0496c0a5"}}
{"doc_id": "70ca7b55", "content": "15. 浮点算术：争议和限制\n浮点数在计算机硬件中是以基数为 2 (二进制) 的小数来表示的。 例如，十进制 小数 0.625 的值为\n6/10 + 2/100 + 5/1000，而同样的 二进制 小数 0.101 的值为 1/2 + 0/4 + 1/8。 这两个小数具有相\n同的值，唯一的区别在于第一个写成了基数为 10 的小数形式，而第二个则写成的基数为 2 的小数形\n式。\n不幸的是，大多数的十进制小数都不能精确地表示为二进制小数。这导致在大多数情况下，你输入\n的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。\n用十进制来理解这个问题显得更加容易一些。考虑分数 1/3 。我们可以得到它在十进制下的一个近\n似值\n0.3\n或者，更近似的，:\n0.33\n或者，更近似的，:\n0.333\n以此类推。结果是无论你写下多少的数字，它都永远不会等于 1/3 ，只是更加更加地接近 1/3 。\n同样的道理，无论你使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为\n基数的小数。 在以 2 为基数的情况下， 1/10 是一个无限循环小数\n0.0001100110011001100110011001100110011001100110011...\n在任何一个位置停下，你都只能得到一个近似值。因此，在今天的大部分架构上，浮点数都只能近\n似地使用二进制小数表示，对应分数的分子使用每 8 字节的前 53 位表示，分母则表示为 2 的幂次。\n在 1/10 这个例子中，相应的二进制分数是 3602879701896397 / 2 ** 55 ，它很接近 1/10 ，但并\n不是 1/10 。\n由于值的显示方式大多数用户都不会意识到这个差异的存在。 Python 只会打印计算机中存储的二进\n制值的十进制近似值。 在大部分计算机中，如果 Python 要把 0.1 的二进制值对应的准确的十进制值\n打印出来，将会显示成这样:\n>>> 0.1\n0.1000000000000000055511151231257827021181583404541015625\n这比大多数人认为有用的数位更多，因此 Python 通过改为显示舍入值来保留可管理的数位:\n\n| 15. 浮点算术：争议和限制\n浮点数在计算机硬件中是以基数为 2 (二进制) 的小数来表示的。 例如，十进制 小数 0.625 的值为\n6/10 + 2/100 + 5/1000，而同样的 二进制 小数 0.101 的值为 1/2 + 0/4 + 1/8。 这两个小数具有相\n同的值，唯一的区别在于第一个写成了基数为 10 的小数形式，而第二个则写成的基数为 2 的小数形\n式。\n不幸的是，大多数的十进制小数都不能精确地表示为二进制小数。这导致在大多数情况下，你输入\n的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。\n用十进制来理解这个问题显得更加容易一些。考虑分数 1/3 。我们可以得到它在十进制下的一个近\n似值 |\n| --- |\n| 0.3 |\n| 或者，更近似的，: |\n| 0.33 |\n| 或者，更近似的，: |\n| 0.333 |\n| 以此类推。结果是无论你写下多少的数字，它都永远不会等于 1/3 ，只是更加更加地接近 1/3 。\n同样的道理，无论你使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为\n基数的小数。 在以 2 为基数的情况下， 1/10 是一个无限循环小数 |\n| 0.0001100110011001100110011001100110011001100110011... |\n| 在任何一个位置停下，你都只能得到一个近似值。因此，在今天的大部分架构上，浮点数都只能近\n似地使用二进制小数表示，对应分数的分子使用每 8 字节的前 53 位表示，分母则表示为 2 的幂次。\n在 1/10 这个例子中，相应的二进制分数是 3602879701896397 / 2 ** 55 ，它很接近 1/10 ，但并\n不是 1/10 。\n由于值的显示方式大多数用户都不会意识到这个差异的存在。 Python 只会打印计算机中存储的二进\n制值的十进制近似值。 在大部分计算机中，如果 Python 要把 0.1 的二进制值对应的准确的十进制值\n打印出来，将会显示成这样: |\n| >>> 0.1\n0.1000000000000000055511151231257827021181583404541015625 |\n| 这比大多数人认为有用的数位更多，因此 Python 通过改为显示舍入值来保留可管理的数位: |\n\n>>> 1 / 10\n0.1\n牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可\n表示的二进制分数。\n有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如， 0.1 、\n0.10000000000000001 、 0.1000000000000000055511151231257827021181583404541015625 全\n都近似于 3602879701896397 / 2 ** 55 。由于所有这些十进制值都具有相同的近似值，因此可以\n显示其中任何一个，同时仍然保留不变的 eval(repr(x)) == x 。\n在历史上，Python 提示符和内置的 repr() 函数会选择具有 17 位有效数字的来显示，即\n0.10000000000000001。 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中\n最短的并简单地显示 0.1 。\n请注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你\n会在所有支持你的硬件中的浮点运算的语言中发现同样的情况（虽然某些语言在默认状态或所有输\n出模块下都不会 显示 这种差异）。\n想要更美观的输出，你可能会希望使用字符串格式化来产生限定长度的有效位数:\n>>> format(math.pi, '.12g') # 有 12 个有效数位\n'3.14159265359'\n>>> format(math.pi, '.2f') # 小数点后有 2 个数位\n'3.14'\n>>> repr(math.pi)\n'3.141592653589793'\n必须重点了解的是，这在实际上只是一个假象：你只是将真正的机器码值进行了舍入操作再 显示 而\n已。\n一个假象还可能导致另一个假象。 例如，由于这个 0.1 并非真正的 1/10，将三个 0.1 的值相加也无\n法恰好得到 0.3:\n>>> 0.1 + 0.1 + 0.1 == 0.3\nFalse\n而且，由于这个 0.1 无法精确表示 1/10 而这个 0.3 也无法精确表示 3/10 的值，使用 round() 函数\n进行预先舍入也是没用的:\n>>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\nFalse\n虽然这些数字无法精确表示其所要代表的实际值，但是可以使用 math.isclose() 函数来进行不精\n确的值比较:\n>>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\nTrue\n\n|  | >>> 1 / 10\n0.1 |  |\n| --- | --- | --- |\n|  | 牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可\n表示的二进制分数。\n有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如， 0.1 、\n0.10000000000000001 、 0.1000000000000000055511151231257827021181583404541015625 全\n都近似于 3602879701896397 / 2 ** 55 。由于所有这些十进制值都具有相同的近似值，因此可以\n显示其中任何一个，同时仍然保留不变的 eval(repr(x)) == x 。\n在历史上，Python 提示符和内置的 repr() 函数会选择具有 17 位有效数字的来显示，即\n0.10000000000000001。 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中\n最短的并简单地显示 0.1 。\n请注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你\n会在所有支持你的硬件中的浮点运算的语言中发现同样的情况（虽然某些语言在默认状态或所有输\n出模块下都不会 显示 这种差异）。\n想要更美观的输出，你可能会希望使用字符串格式化来产生限定长度的有效位数: |  |\n|  | >>> format(math.pi, '.12g') # 有 12 个有效数位\n'3.14159265359'\n>>> format(math.pi, '.2f') # 小数点后有 2 个数位\n'3.14'\n>>> repr(math.pi)\n'3.141592653589793' |  |\n|  | 必须重点了解的是，这在实际上只是一个假象：你只是将真正的机器码值进行了舍入操作再 显示 而\n已。\n一个假象还可能导致另一个假象。 例如，由于这个 0.1 并非真正的 1/10，将三个 0.1 的值相加也无\n法恰好得到 0.3: |  |\n|  | >>> 0.1 + 0.1 + 0.1 == 0.3\nFalse |  |\n|  | 而且，由于这个 0.1 无法精确表示 1/10 而这个 0.3 也无法精确表示 3/10 的值，使用 round() 函数\n进行预先舍入也是没用的: |  |\n|  | >>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\nFalse |  |\n|  | 虽然这些数字无法精确表示其所要代表的实际值，但是可以使用 math.isclose() 函数来进行不精\n确的值比较: |  |\n|  | >>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\nTrue |  |\n\n或者，也可以使用 round() 函数来大致地比较近似程度：\n>>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\nTrue\n二进制浮点运算会有许多这样令人惊讶的情况。 有关 \"0.1\" 的问题会在下面 \"表示性错误\" 一节中更\n精确详细地描述。 请参阅 Examples of Floating Point Problems 获取针对二进制浮点运算机制及在\n实践中各种常见问题的概要说明。 还可参阅 The Perils of Floating Point 获取其他常见意外现象的更\n完整介绍。\n正如那篇文章的结尾所言，“对此问题并无简单的答案。” 但是也不必过于担心浮点数的问题！\nPython 浮点运算中的错误是从浮点运算硬件继承而来，而在大多数机器上每次浮点运算得到的\n2**53 数码位都会被作为 1 个整体来处理。 这对大多数任务来说都已足够，但你确实需要记住它并\n非十进制算术，且每次浮点运算都可能会导致新的舍入错误。\n虽然病态的情况确实存在，但对于大多数正常的浮点运算使用来说，你只需简单地将最终显示的结\n果舍入为你期望的十进制数值即可得到你期望的结果。 str() 通常已足够，对于更精度的控制可参\n看 格式字符串语法 中 str.format() 方法的格式描述符。\n对于需要精确十进制表示的使用场景，请尝试使用 decimal 模块，该模块实现了适合会计应用和高\n精度应用的十进制运算。\n另一种形式的精确运算由 fractions 模块提供支持，该模块实现了基于有理数的算术运算（因此可\n以精确表示像 1/3 这样的数值）。\n如果你是浮点运算的重度用户那么你应当了解一下 NumPy 包以及由 SciPy 项目所提供的许多其他数\n学和统计运算包。 参见 <https://scipy.org>。\nPython 还提供了一些工具可能在你 确实 想要知道一个浮点数的精确值的少数情况下提供帮助。 例\n如 float.as_integer_ratio() 方法会将浮点数值表示为一个分数:\n>>> x = 3.14159\n>>> x.as_integer_ratio()\n(3537115888337719, 1125899906842624)\n由于这个比值是精确的，它可以被用来无损地重建原始值:\n>>> x == 3537115888337719 / 1125899906842624\nTrue\nfloat.hex() 方法会以十六进制（以 16 为基数）来表示浮点数，同样能给出保存在你的计算机中\n的精确值:\n>>> x.hex()\n'0x1.921f9f01b866ep+1'\n这种精确的十六进制表示形式可被用来精确地重建浮点数值:\n\n|  | 或者，也可以使用 round() 函数来大致地比较近似程度： |  |\n| --- | --- | --- |\n|  | >>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\nTrue |  |\n|  | 二进制浮点运算会有许多这样令人惊讶的情况。 有关 \"0.1\" 的问题会在下面 \"表示性错误\" 一节中更\n精确详细地描述。 请参阅 Examples of Floating Point Problems 获取针对二进制浮点运算机制及在\n实践中各种常见问题的概要说明。 还可参阅 The Perils of Floating Point 获取其他常见意外现象的更\n完整介绍。\n正如那篇文章的结尾所言，“对此问题并无简单的答案。” 但是也不必过于担心浮点数的问题！\nPython 浮点运算中的错误是从浮点运算硬件继承而来，而在大多数机器上每次浮点运算得到的\n2**53 数码位都会被作为 1 个整体来处理。 这对大多数任务来说都已足够，但你确实需要记住它并\n非十进制算术，且每次浮点运算都可能会导致新的舍入错误。\n虽然病态的情况确实存在，但对于大多数正常的浮点运算使用来说，你只需简单地将最终显示的结\n果舍入为你期望的十进制数值即可得到你期望的结果。 str() 通常已足够，对于更精度的控制可参\n看 格式字符串语法 中 str.format() 方法的格式描述符。\n对于需要精确十进制表示的使用场景，请尝试使用 decimal 模块，该模块实现了适合会计应用和高\n精度应用的十进制运算。\n另一种形式的精确运算由 fractions 模块提供支持，该模块实现了基于有理数的算术运算（因此可\n以精确表示像 1/3 这样的数值）。\n如果你是浮点运算的重度用户那么你应当了解一下 NumPy 包以及由 SciPy 项目所提供的许多其他数\n学和统计运算包。 参见 <https://scipy.org>。\nPython 还提供了一些工具可能在你 确实 想要知道一个浮点数的精确值的少数情况下提供帮助。 例\n如 float.as_integer_ratio() 方法会将浮点数值表示为一个分数: |  |\n|  | >>> x = 3.14159\n>>> x.as_integer_ratio()\n(3537115888337719, 1125899906842624) |  |\n|  | 由于这个比值是精确的，它可以被用来无损地重建原始值: |  |\n|  | >>> x == 3537115888337719 / 1125899906842624\nTrue |  |\n|  | float.hex() 方法会以十六进制（以 16 为基数）来表示浮点数，同样能给出保存在你的计算机中\n的精确值: |  |\n|  | >>> x.hex()\n'0x1.921f9f01b866ep+1' |  |\n|  | 这种精确的十六进制表示形式可被用来精确地重建浮点数值: |  |\n\n>>> x == float.fromhex('0x1.921f9f01b866ep+1')\nTrue\n由于这种表示法是精确的，它适用于跨越不同版本（平台无关）的 Python 移植数值，以及与支持相\n同格式的其他语言（例如 Java 和 C99）交换数据.\n另一个有用的工具是 sum() 函数，它能够帮助减少求和过程中的精度损失。 它会在数值被添加到总\n计值的时候为中间舍入步骤使用扩展的精度。 这可以更好地保持总体精确度，使得错误不会积累到\n能够影响最终总计值的程度:\n>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\nFalse\n>>> sum([0.1] * 10) == 1.0\nTrue\nmath.fsum() 函数进一步追踪在累加过程中“丢失的数位”，因此结果只会经过一次舍入。 相比于\nsum() 它的执行速度较慢，但在一些不常见的情况下会更加准确，尤其是当大数值输入彼此几乎相\n互抵消，最终结果接近零时：\n>>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n... -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n>>> float(sum(map(Fraction, arr))) # 精确求和，结果经过一次四舍五入\n8.042173697819788e-13\n>>> math.fsum(arr) # 一次四舍五入\n8.042173697819788e-13\n>>> sum(arr) # 多次四舍五入，扩展精度\n8.042178034628478e-13\n>>> total = 0.0\n>>> for x in arr:\n... total += x # 多次四舍五入，标准精度\n...\n>>> total # 直接加法没有一个正确的数字！\n-0.0051575902860057365\n15.1. 表示性错误\n本小节将详细解释 \"0.1\" 的例子，并说明你可以怎样亲自对此类情况进行精确分析。 假定前提是已\n基本熟悉二进制浮点表示法。\n表示性错误 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示\n这一事实造成的错误。 这就是为什么 Python（或者 Perl、C、C++、Java、Fortran 以及许多其他语\n言）经常不会显示你所期待的精确十进制数值的主要原因。\n为什么会这样？ 1/10 是无法用二进制小数精确表示的。 至少从 2000 年起，几乎所有机器都使用\nIEEE 754 二进制浮点运算标准，而几乎所有系统平台都将 Python 浮点数映射为 IEEE 754 binary64\n\"双精度\" 值。 IEEE 754 binary64 值包含 53 位精度，因此在输入时计算机会尽量将 0.1 转换为以\nJ/2**N 形式所能表示的最接近的小数，其中 J 为恰好包含 53 比特位的整数。 重新将\n1 / 10 ~= J / (2**N)\n\n|  | >>> x == float.fromhex('0x1.921f9f01b866ep+1')\nTrue |  |\n| --- | --- | --- |\n|  | 由于这种表示法是精确的，它适用于跨越不同版本（平台无关）的 Python 移植数值，以及与支持相\n同格式的其他语言（例如 Java 和 C99）交换数据.\n另一个有用的工具是 sum() 函数，它能够帮助减少求和过程中的精度损失。 它会在数值被添加到总\n计值的时候为中间舍入步骤使用扩展的精度。 这可以更好地保持总体精确度，使得错误不会积累到\n能够影响最终总计值的程度: |  |\n|  | >>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\nFalse\n>>> sum([0.1] * 10) == 1.0\nTrue |  |\n|  | math.fsum() 函数进一步追踪在累加过程中“丢失的数位”，因此结果只会经过一次舍入。 相比于\nsum() 它的执行速度较慢，但在一些不常见的情况下会更加准确，尤其是当大数值输入彼此几乎相\n互抵消，最终结果接近零时： |  |\n|  | >>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n... -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n>>> float(sum(map(Fraction, arr))) # 精确求和，结果经过一次四舍五入\n8.042173697819788e-13\n>>> math.fsum(arr) # 一次四舍五入\n8.042173697819788e-13\n>>> sum(arr) # 多次四舍五入，扩展精度\n8.042178034628478e-13\n>>> total = 0.0\n>>> for x in arr:\n... total += x # 多次四舍五入，标准精度\n...\n>>> total # 直接加法没有一个正确的数字！\n-0.0051575902860057365 |  |\n|  | 15.1. 表示性错误\n本小节将详细解释 \"0.1\" 的例子，并说明你可以怎样亲自对此类情况进行精确分析。 假定前提是已\n基本熟悉二进制浮点表示法。\n表示性错误 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示\n这一事实造成的错误。 这就是为什么 Python（或者 Perl、C、C++、Java、Fortran 以及许多其他语\n言）经常不会显示你所期待的精确十进制数值的主要原因。\n为什么会这样？ 1/10 是无法用二进制小数精确表示的。 至少从 2000 年起，几乎所有机器都使用\nIEEE 754 二进制浮点运算标准，而几乎所有系统平台都将 Python 浮点数映射为 IEEE 754 binary64\n\"双精度\" 值。 IEEE 754 binary64 值包含 53 位精度，因此在输入时计算机会尽量将 0.1 转换为以\nJ/2**N 形式所能表示的最接近的小数，其中 J 为恰好包含 53 比特位的整数。 重新将 |  |\n|  | 1 / 10 ~= J / (2**N) |  |\n|  |  |  |\n\n写为\nJ ~= 2**N / 10\n并且由于 J 恰好有 53 位 (即 >= 2**52 但 < 2**53)，N 的最佳值为 56:\n>>> 2**52 <= 2**56 // 10 < 2**53\nTrue\n也就是说，56 是唯一能使 J 恰好有 53 位的 N 值。 这样 J 可能的最佳就是舍入之后的商:\n>>> q, r = divmod(2**56, 10)\n>>> r\n6\n由于余数超于 10 的一半，所以最佳近似值可通过向上舍入获得:\n>>> q+1\n7205759403792794\n因此在 IEEE 754 双精度下可能达到的 1/10 的最佳近似值为:\n7205759403792794 / 2 ** 56\n分子和分母都除以二则结果小数为:\n3602879701896397 / 2 ** 55\n请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略\n小于 1/10。 但无论如何它都不会是 精确的 1/10！\n因此计算机永远不会 \"看到\" 1/10: 它实际看到的就是上面所给出的小数，即它能达到的最佳 IEEE 754\n双精度近似值:\n>>> 0.1 * 2 ** 55\n3602879701896397.0\n如果我们将该小数乘以 10**55，我们可以看到该值输出 55 个十进制数位:\n>>> 3602879701896397 * 10 ** 55 // 2 ** 55\n1000000000000000055511151231257827021181583404541015625\n这意味着存储在计算机中的确切数字等于十进制数值\n0.1000000000000000055511151231257827021181583404541015625。 许多语言（包括较旧版本的\nPython）都不会显示这个完整的十进制数值，而是将结果舍入到 17 位有效数字:\n>>> format(0.1, '.17f')\n'0.10000000000000001'\nfractions 和 decimal 模块使得这样的计算更为容易:\n\n|  | 写为 |  |\n| --- | --- | --- |\n|  | J ~= 2**N / 10 |  |\n|  | 并且由于 J 恰好有 53 位 (即 >= 2**52 但 < 2**53)，N 的最佳值为 56: |  |\n|  | >>> 2**52 <= 2**56 // 10 < 2**53\nTrue |  |\n|  | 也就是说，56 是唯一能使 J 恰好有 53 位的 N 值。 这样 J 可能的最佳就是舍入之后的商: |  |\n|  | >>> q, r = divmod(2**56, 10)\n>>> r\n6 |  |\n|  | 由于余数超于 10 的一半，所以最佳近似值可通过向上舍入获得: |  |\n|  | >>> q+1\n7205759403792794 |  |\n|  | 因此在 IEEE 754 双精度下可能达到的 1/10 的最佳近似值为: |  |\n|  | 7205759403792794 / 2 ** 56 |  |\n|  | 分子和分母都除以二则结果小数为: |  |\n|  | 3602879701896397 / 2 ** 55 |  |\n|  | 请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略\n小于 1/10。 但无论如何它都不会是 精确的 1/10！\n因此计算机永远不会 \"看到\" 1/10: 它实际看到的就是上面所给出的小数，即它能达到的最佳 IEEE 754\n双精度近似值: |  |\n|  | >>> 0.1 * 2 ** 55\n3602879701896397.0 |  |\n|  | 如果我们将该小数乘以 10**55，我们可以看到该值输出 55 个十进制数位: |  |\n|  | >>> 3602879701896397 * 10 ** 55 // 2 ** 55\n1000000000000000055511151231257827021181583404541015625 |  |\n|  | 这意味着存储在计算机中的确切数字等于十进制数值\n0.1000000000000000055511151231257827021181583404541015625。 许多语言（包括较旧版本的\nPython）都不会显示这个完整的十进制数值，而是将结果舍入到 17 位有效数字: |  |\n|  | >>> format(0.1, '.17f')\n'0.10000000000000001' |  |\n|  | fractions 和 decimal 模块使得这样的计算更为容易: |  |\n\n>>> from decimal import Decimal\n>>> from fractions import Fraction\n>>> Fraction.from_float(0.1)\nFraction(3602879701896397, 36028797018963968)\n>>> (0.1).as_integer_ratio()\n(3602879701896397, 36028797018963968)\n>>> Decimal.from_float(0.1)\nDecimal('0.1000000000000000055511151231257827021181583404541015625')\n>>> format(Decimal.from_float(0.1), '.17')\n'0.10000000000000001'", "metadata": {"title": "15_浮点算术：争议和限制", "source": "md_docs\\python_docs_md\\15_浮点算术：争议和限制.md", "doc_type": "教程", "language": "中文", "doc_id": "70ca7b55"}}
{"doc_id": "d8d431a5", "content": "16. 附录\n16.1. 交互模式\n交互式 REPL 有两个变种版本。 经典的基本解释器在所有平台上受到支持，具有最小化的行控制功\n能。\n在 Windows 上，或在具有 curses 支持的类 Unix 系统上，从 Python 3.13 开始默认会使用一个新的\n交互式 shell。 它支持彩色、多行编辑、历史浏览和粘贴模式。 要禁用彩色，请参阅 控制颜色 了解\n详情。 功能键将提供一些附加功能。 F1 是进入交互式帮助浏览器 pydoc。 F2 允许浏览不带输出也\n不带 >>> 和 ... 提示符的命令行历史。 F3 是进入“粘贴模式”，这可以更方便地粘贴大段代码。 按 F3\n将返回常规提示符。\n当使用新的交互式 shell 时，可通过键入 exit 或 quit 退出 shell。 不再需要在这些命令之后添加代\n表调用的圆括号。\n如果不想要新的交互式 shell，可以通过 PYTHON_BASIC_REPL 环境变量禁用它。\n16.1.1. 错误处理\n当发生错误时，解释器会打印错误消息和栈回溯。 在交互模式下，将返回到主提示符；当输入是来\n自文件的时候，它将在打印栈回溯之后退出并附带一个非零的退出状态码。 （由 try 语句中\nexcept 子句所处理的异常在此上下文中不属于错误。） 有些错误属于无条件致命错误，会导致程\n序附带非零状态码退出；这适用于内部一致性丧失以及某些内存耗尽的情况等。 所有错误消息都将\n被写入到标准错误流；来自被执行命令的正常输出测会被写入到标准输出。\n将中断字符（通常为 Control-C 或 Delete ）键入主要或辅助提示符会取消输入并返回主提示符。\n[1] 在执行命令时键入中断引发的 KeyboardInterrupt 异常，可以由 try 语句处理。\n16.1.2. 可执行的Python脚本\n在 BSD 等类Unix系统上，Python 脚本可以像 shell 脚本一样直接执行，通过在第一行添加：\n#!/usr/bin/env python3\n（假设解释器位于用户的 PATH ）脚本的开头，并将文件设置为可执行。 #! 必须是文件的前两个字\n符。在某些平台上，第一行必须以Unix样式的行结尾（'\\n'）结束，而不是以Windows（'\\r\\n'）\n行结尾。注意，“散列字符”，或者说“磅字符”， '#' ，在Python中代表注释开始。\n可以使用 chmod 命令为脚本提供可执行模式或权限。\n$ chmod +x myscript.py\n\n| 16. 附录\n16.1. 交互模式\n交互式 REPL 有两个变种版本。 经典的基本解释器在所有平台上受到支持，具有最小化的行控制功\n能。\n在 Windows 上，或在具有 curses 支持的类 Unix 系统上，从 Python 3.13 开始默认会使用一个新的\n交互式 shell。 它支持彩色、多行编辑、历史浏览和粘贴模式。 要禁用彩色，请参阅 控制颜色 了解\n详情。 功能键将提供一些附加功能。 F1 是进入交互式帮助浏览器 pydoc。 F2 允许浏览不带输出也\n不带 >>> 和 ... 提示符的命令行历史。 F3 是进入“粘贴模式”，这可以更方便地粘贴大段代码。 按 F3\n将返回常规提示符。\n当使用新的交互式 shell 时，可通过键入 exit 或 quit 退出 shell。 不再需要在这些命令之后添加代\n表调用的圆括号。\n如果不想要新的交互式 shell，可以通过 PYTHON_BASIC_REPL 环境变量禁用它。\n16.1.1. 错误处理\n当发生错误时，解释器会打印错误消息和栈回溯。 在交互模式下，将返回到主提示符；当输入是来\n自文件的时候，它将在打印栈回溯之后退出并附带一个非零的退出状态码。 （由 try 语句中\nexcept 子句所处理的异常在此上下文中不属于错误。） 有些错误属于无条件致命错误，会导致程\n序附带非零状态码退出；这适用于内部一致性丧失以及某些内存耗尽的情况等。 所有错误消息都将\n被写入到标准错误流；来自被执行命令的正常输出测会被写入到标准输出。\n将中断字符（通常为 Control-C 或 Delete ）键入主要或辅助提示符会取消输入并返回主提示符。\n[1] 在执行命令时键入中断引发的 KeyboardInterrupt 异常，可以由 try 语句处理。\n16.1.2. 可执行的Python脚本\n在 BSD 等类Unix系统上，Python 脚本可以像 shell 脚本一样直接执行，通过在第一行添加： |\n| --- |\n| #!/usr/bin/env python3 |\n| （假设解释器位于用户的 PATH ）脚本的开头，并将文件设置为可执行。 #! 必须是文件的前两个字\n符。在某些平台上，第一行必须以Unix样式的行结尾（'\\n'）结束，而不是以Windows（'\\r\\n'）\n行结尾。注意，“散列字符”，或者说“磅字符”， '#' ，在Python中代表注释开始。\n可以使用 chmod 命令为脚本提供可执行模式或权限。 |\n| $ chmod +x myscript.py |\n|  |\n\n在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 .py 文件与 python.exe 相\n关联，这样双击Python文件就会将其作为脚本运行。扩展也可以是 .pyw ，在这种情况下，会隐藏\n通常出现的控制台窗口。\n16.1.3. 交互式启动文件\n当您以交互模式使用 Python 时，您可能会希望在每次启动解释器时，解释器先执行几条您预先编写\n的命令，然后您再以交互模式继续使用。您可以通过将名为 PYTHONSTARTUP 的环境变量设置为包含\n启动命令的文件的文件名来实现。这类似于 Unix shell 的 .profile 功能。\nPython 只有在交互模式时，才会读取此文件，而非在从脚本读指令或是将 /dev/tty 显式作为被运\n行的 Python 脚本的文件名时（后者反而表现得像一个交互式会话）。这个文件与交互式指令共享相\n同的命名空间，所以它定义或导入的对象可以在交互式会话中直接使用。您也可以在该文件中更改\n提示符 sys.ps1 和 sys.ps2。\n如果您想 从当前目录中 读取一个额外的启动文件，您可以在上文所说的全局启动文件中编写像 if\nos.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read()) 这样的代码。如果要\n在脚本中使用启动文件，则必须在脚本中显式执行此操作：\nimport os\nfilename = os.environ.get('PYTHONSTARTUP')\nif filename and os.path.isfile(filename):\nwith open(filename) as fobj:\nstartup_file = fobj.read()\nexec(startup_file)\n16.1.4. 定制模块\nPython 提供了两个钩子供你进行自定义: sitecustomize 和 usercustomize。 要了解它是如何工作\n的，首先需要找到用户 site-packages 目录的位置。 启动 Python 并运行以下代码:\n>>> import site\n>>> site.getusersitepackages()\n'/home/user/.local/lib/python3.x/site-packages'\n现在，您可以在该目录中创建一个名为 usercustomize.py 的文件，并将所需内容放入其中。它会\n影响Python的每次启动，除非它以 -s 选项启动，以禁用自动导入。\nsitecustomize 的工作方式相同，但通常由计算机管理员在全局 site-packages 目录中创建，并在\nusercustomize 之前导入。 更多细节请参阅 site 模块的文档。\n备注\n[1] GNU Readline 包的问题可能会阻止这种情况。\n\n|  | 在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 .py 文件与 python.exe 相\n关联，这样双击Python文件就会将其作为脚本运行。扩展也可以是 .pyw ，在这种情况下，会隐藏\n通常出现的控制台窗口。\n16.1.3. 交互式启动文件\n当您以交互模式使用 Python 时，您可能会希望在每次启动解释器时，解释器先执行几条您预先编写\n的命令，然后您再以交互模式继续使用。您可以通过将名为 PYTHONSTARTUP 的环境变量设置为包含\n启动命令的文件的文件名来实现。这类似于 Unix shell 的 .profile 功能。\nPython 只有在交互模式时，才会读取此文件，而非在从脚本读指令或是将 /dev/tty 显式作为被运\n行的 Python 脚本的文件名时（后者反而表现得像一个交互式会话）。这个文件与交互式指令共享相\n同的命名空间，所以它定义或导入的对象可以在交互式会话中直接使用。您也可以在该文件中更改\n提示符 sys.ps1 和 sys.ps2。\n如果您想 从当前目录中 读取一个额外的启动文件，您可以在上文所说的全局启动文件中编写像 if\nos.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read()) 这样的代码。如果要\n在脚本中使用启动文件，则必须在脚本中显式执行此操作： |  |  |  |\n| --- | --- | --- | --- | --- |\n|  |  | if |  |  |\n|  | os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read()) |  |  |  |\n|  | import os\nfilename = os.environ.get('PYTHONSTARTUP')\nif filename and os.path.isfile(filename):\nwith open(filename) as fobj:\nstartup_file = fobj.read()\nexec(startup_file) |  |  |  |\n|  | 16.1.4. 定制模块\nPython 提供了两个钩子供你进行自定义: sitecustomize 和 usercustomize。 要了解它是如何工作\n的，首先需要找到用户 site-packages 目录的位置。 启动 Python 并运行以下代码: |  |  |  |\n|  | >>> import site\n>>> site.getusersitepackages()\n'/home/user/.local/lib/python3.x/site-packages' |  |  |  |\n|  | 现在，您可以在该目录中创建一个名为 usercustomize.py 的文件，并将所需内容放入其中。它会\n影响Python的每次启动，除非它以 -s 选项启动，以禁用自动导入。\nsitecustomize 的工作方式相同，但通常由计算机管理员在全局 site-packages 目录中创建，并在\nusercustomize 之前导入。 更多细节请参阅 site 模块的文档。\n备注\n[1] GNU Readline 包的问题可能会阻止这种情况。 |  |  |  |", "metadata": {"title": "16_附录", "source": "md_docs\\python_docs_md\\16_附录.md", "doc_type": "教程", "language": "中文", "doc_id": "d8d431a5"}}
